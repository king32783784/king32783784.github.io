{"pages":[{"url":"http://king32783784.github.io/pages/opensource.html","text":"linux系统自动回归测试 Lart_i The framework for bridging Linux product development or maintenance of automated regression testing Linux系统性能测试套件 Lpbs-i 性能测试结果可视化处理 Report_generate linux系统测试工具 itest linux系统测试app，包括测试、报告制作、负载显示等功能。其中测试内容包括：linux系统信息侦测、linux功能测试、linux性能测试、linux稳定性测试。 报告制作功能支持单次测试报告制作、多次测试对比报告制作。负责显示功能支持cpu、内存、swap、网络等资源的实时监控。","tags":"pages","title":"开源项目"},{"url":"http://king32783784.github.io/pages/links.html","text":"博客 美团技术团队 陈皓 isoft 普华基础软件 普华开源社区 loongson 龙芯开源社区 CSDN-知识库 MySql Python docker Hadoop 网站架构 C语言 C++ Java 数据结构与算法 PHP javascript android 微信开发 HTML5 测试 TestHome gradle教程 Android 性能测试初探 Android安全测试初探 Robotium appium源码分析一 appium的android平台源码分析 appium文档 Docker Docker社区 OpenStack OpenStack社区 Test test","tags":"pages","title":"常用链接"},{"url":"http://king32783784.github.io/pages/Reference material.html","text":"资料 文章 链接 Requests中文文档 AWK程序设计语言 Python库 书籍 Code Complete (代码大全) The Pragmatic Programmer C Programming Language (2nd Edition)（C编程语言) Refactoring: Improving the Design of Existing Code（重构，改善既有代码的设计) The Mythical Man-Month（人月神话) Code: The Hidden Language of Computer Hardware and Software Head First Design Patterns（深入浅出设计模式) Programming Pearls（编程珠玑） Effective Java (2nd Edition) or Effective C++ Introduction to Algorithms （CLRS，算法导论) Compilers: Principles, Techniques, and Tools （the Dragon Book，编译原理） The Art of Computer Programming（TAOCP，计算机程序设计艺术） Test Driven Development: By Example","tags":"pages","title":"参考资料"},{"url":"http://king32783784.github.io/pages/todo list.html","text":"Python unittest Flask Django Tornado Python HOWTOs The Python Standard Library Autotest Autotest framework Linux Test Project :1.caselist 2.add case selenium loadrunner 书籍 Python高手之路 Effective Python: 59 Specific Ways to Write Better Python 深入理解计算机系统 ... others HBase Hadoop docker Topics logging urllib2 re xml 虚拟化 Priority avocado appium property","tags":"pages","title":"Todo List"},{"url":"http://king32783784.github.io/pages/tools.html","text":"Sublime Text 参考资料： Setting up Sublime Text for Python development Sublime Text 2 Documentation SublimeREPL , Github - SublimeREPL colorsublime Package Control VIM 配置文件： https://github.com/youngsterxyf/mydotfiles 快捷键 跳到行尾： shift + a , 跳到行首： shift + b 删除N行： N + d ，复制N行： N + yy 跳到最后一行： G ，跳到第一行： gg 剪切： dd ，粘贴： p vim + ctags: Ctrl + ] 自动跳转至定义; Ctrl + t 返回上一次查看位置。 块操作: &#94; → 到行头； <C-v> → 开始块操作； <C-d> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)； I-- [ESC] → I是插入，插入\"--\"，按ESC键来为每一行生效。 插件 Vundle (插件管理) vim-javascript (JavaScript语法高亮与自动缩进) The-NERD-Tree (文件系统树状浏览窗口) vim-markdown (Markdown格式高亮) awk.vim (awk代码自动缩进) jedi-vim (Python代码自动完成，对jedi自动完成库的vim绑定) pep8 (检查Python源码是否符合PEP8风格) vim-gitgutter (A Vim plugin which shows a git diff in the 'gutter' (sign column). It shows whether each line has been added, modified, and where lines have been removed.) jshint.vim (jshint的vim前端插件) vim-powerline (实现更美观、功能更多的vim状态栏) molokai (Molokai Color Scheme for Vim) vim-monokai-refined (Port of Monokai Refined for TextMate/Sublime Text) indentLine (缩进线) vim-css-color (css显示颜色值代表的颜色) vim-golang (go代码高亮、自动缩进等) 资料 超级牛逼的VIM配置 spf13-vim - The Ultimate Vim Distribution Learn Vimscript the Hard Way Practical Vim: Edit Text at the Speed of Thought VIM标签页（tab） Vim的分屏功能 100 Vim commands every programmer should know Git 书籍： Pro Git Git Community Book Git Internals Git Reference Latex LaTeX项目主页 CTEX项目主页 LaTeX编辑部 浙江大学理学院数学系-TeX和LaTex论坛 Tex-StackExchange LaTeX - WikiBooks Beamer Beamer theme gallery beamer-theme-matrix 如何准备演讲（beamer版） Beamer演示学习笔记 A Beamer Quickstart moderncv的笔记 The LaTeX Font Catalogue 绘图语言与绘图工具 GnuPlot Asymptote MetaPost 开发工具 VIM / Sublime Text / StackEdit(Markdown文本编辑) InteliJ IDEA（Golang） JetBrains PyCharm（Python） JetBrains PhpStorm Zend Studio （PHP） CodeBlocks（C/C++） Racket（Scheme） Wappalyzer（Chrome、Firefox插件，用于检测网站所使用的技术，非常赞） TeXstudio（Latex）（算开发工具么？） Git/SVN（源码控制），SourceTree（free Git & Mercurial client for Windows or Mac）， ungit jshint（JavaScript代码检查命令行工具） virtualenv（Python虚拟环境） IPython（可在virtualenv虚拟环境中通过pip install ipython安装使用） ack/codequery（代码搜索工具） 命令行工具与解决方案 The Linux Alternative Project Windows命令行列表 （置顶） 命令行乐园 （置顶） 命令行的艺术 递归查询某目录下的最大文件： find -type f -exec stat -c \"%s %n\" {} \\; | sort -nr | head -1 查看所有库/模块的docstring： python -m pydoc -p 8080 Linux中查看当前所有的资源限制： ulimit -a ；设置内核可以同时打开的文件描述符的最大值为2048： ulimit -n 2048 使用HTTP/HTTPS协议push大文件时失败，提示RPC failed; result=22, HTTP code = 411，可能是因为Git默认post数据buffer比较小，需要自己设置下： git config http.postBuffer 524288000 #Set to 500MB 当git不支持https协议时，可以通过禁用SSL认证来继续使用： git config --global http.sslVerify false Git签出某个tag的代码： git checkout -b branch_name tag_name 或 git checkout tag_name 或 git checkout tag/tag_name Ubuntu为Firefox安装Adobe Flash插件： sudo apt-get install flashplugin-installer 从某网卡上删除绑定的ip： ip addr del 192.168.2.201/32 dev eth0 图片缩放、格式转换等： convert Linux上如何删除文本文件中来自Windows的CRLF(&#94;M)的换行符： dos2unix filename Windows命令行下查看本地路由表： route print 系统监控工具： Glances ，可以监控本机也可以通过客户端服务器模式监控其他机器；Glances提供了基于XML/RPC的API便于其他程序调用，可编程；Glances可以将数据输出保存到csv或html格式的文件方便其他程序处理（报告或绘制图形）。Glances是用Python开发的，使用psutil库来采集系统数据，在用户的终端上实时动态的显示重要的系统数据和变化。显示的数据包括：CPU、内存、磁盘、网络等使用情况，内核、运行队列、负载、I/O 状态、消耗资源最多的进程等等。 修改文件编码： iconv -f encoding -t encoding inputfile 查看防火墙设置（包含防火墙规则绑定的网卡）： iptables -nvL 使用一行python命令查看/解压缩/创建zip文件：1.查看 - python -m zipfile -l test.zip , 2.解压缩 - python -m zipfile -e test.zip test , 3.创建 - python -m zipfile -c release.zip *.py 查看所有用户的crontab任务(root权限执行)： for user in $(cut -f1 -d: /etc/passwd); do echo \"### Crontabs for $user ####\"; crontab -u $user -l; done 删除当前目录下大小为0的文件，且不进一步递归查找： find -size 0 -prune -exec rm {} \\; 从命令行使用HTTP协议做测试的强大工具：cURL，参考 9 uses for cURL worth knowing 追踪命令执行过程中的系统调用和信号： strace CPU/磁盘/网络等系统资源统计工具： dstat （很好很强大，可替代vmstat，iostat，ifstat） 查看PHP会动态加载的扩展模块： php -m 递归查找当前目录下所有名为test.txt的文件： find ./ -name test.txt Windows上查看端口占用情况： netstat -ano 查看LINUX发行版的名称及其版本号的命令：1. cat /etc/issue ；2. lsb_release -a ；3. cat /etc/redhat-release (针对redhat，Fedora) ack-grep --- 比grep更好用的搜索工具，专为程序员优化 禁用触摸板： sudo rmmod psmouse ，开启触摸板： sudo modprobe psmouse 将man手册转换为pdf格式打印出来阅读，如直接将man命令的手册页转换为pdf格式: man -t man | ps2pdf - > man.pdf 显示进程树： pstree 更新Python第三方软件包： pip install -U [package_name] 从命令行安装.deb文件： sudo dpkg -i package.deb 打印环境变量： printenv 查看通过USB接口连接的硬件： lsusb 查看已安装的软件包： dpkg --get-selections 由大到小输出home目录下的所有文件（递归的）： du -a ~/ | sort -n -r | less 每隔x秒执行命令command，显示输出： watch -n [number_of_seconds] [command] 监听来自端口的网络输入，存入文件中： netcat -l [recieving_port] > file_copied 将命令的输出通过管道经网络传递给目标ip端口： [command] | netcat -w [number_of_seconds_before_timeout] [target_ip] [target_port] 使用tar压缩文件并将文件作为流输出，通过管道经网络传递给目标ip端口： sudo tar -czf - [filename] | netcat -w [number_of_seconds_before_timeout] [target_ip] [target_port] traceroute ：查看到目标机器/ip的网络路由，如 traceroute www.google.com.hk nmap ：扫描机器检查开放的网络端口，如 nmap 127.0.0.1 ---扫描本地机器的开放端口 tee ：在标准输出显示的同时输出到文件，如 ls | tee ls.txt 显示软件包的详细描述信息： apt-cache show [package_name] ls 按文件名逆序输出结果： ls -r ；递归遍历目录： ls -R ；按时间顺序： ls -t ，按时间逆序： ls -tr ；按文件大小排序： ls -S 。（默认按文件名排序， -r 表示逆序， -t 表示按时间排序， -S 表示按文件大小排序， -h 表示以方便人阅读的形式输出） 系统负载监控：top/htop/nmon 查看所有进程： ps -e 或 ps aux ，另外可通过 ps -e | grep name 来模糊查找是否存在特定进程 根据进程名终止进程： sudo pkill process_name 以树状分支罗列目录内容： tree [dir_name] 大数据传输：1. scp -P remoteport username@remoteip:remotedir localdir 或 scp -P remoteport localfile username@remoteip:remotedir ；2.scp之外可以使用命令组合： gzip -c /home/xiayf/data | ssh username@ip \"gunzip -c - > /home/xiayf/data\" ping ip -f ：持续不断地ping某台服务器(泛洪？)，可能会ping死那台服务器 重装Ubuntu，一个个安装程序太麻烦，可先在原来的Ubuntu上执行 dpkg --get-selections|awk '{print $1}' > o.txt 导出一个所有已安装程序的列表，然后就可以一键安装了： cat o.txt | xargs sudo apt-get install 打包后，以 gzip 压缩： tar -zcvf /tmp/etc.tar.gz /etc ；打包后，以 bzip2 压缩： tar -jcvf /tmp/etc.tar.bz2 /etc 在Linux系统下, 可以用一个命令很容易批量删除.svn的文件夹： find . -name .svn -type d -exec rm -fr {} \\; 查看当前正在监听的网络端口： lsof -i 或者 netstat -tlnp linux下查看某目录占用的空间大小： du -h -s 或 du -h -s /* | sort python内嵌的简单便捷HTTP Server： python -m SimpleHTTPServer Port Python命令行美化输出json数据： python -mjson.tool json_filename 或者通过管道 some_cmd | python -mjson.tool ，也可以直接在命令行使用双引号包围一个json数据字符串来替代json_filename的位置。而且，如果你安装了 Pygments 模块，可以高亮地打印JSON： echo '{\"json\":\"obj\"}' | python -mjson.tool | pygmentize -l json 。 保存某个virtualenv中已安装的package列表，并在另一个virtualenv中原样恢复：1. (some_env)$pip freeze > requirements.txt ; 2. (another_env)$pip install -r requirements.txt Linux性能分析工具 酷毙的Linux单行命令 Gnome/KDE键盘快捷键 日常使用工具 桌面环境：KDE Shell：zsh + oh-my-zsh Bash + powerline-shell 图形化Web浏览器：Google Chrome/Firefox 命令行Web浏览器：lynx 终端：Terminator 截屏：KSnapshot 虚拟机：VirtualBox 屏幕录像：XVidCap 音频播放器：Songbird/深度音乐播放器/Audacious/ cplay 视频播放器：VLC/MPlayer/SMPlayer/深度影音 翻译：Google Translate/有道词典chrome插件 图片浏览：GPicView/Shotwell 数据统计图命令行绘制工具：GnuPlot PDF阅读器：Okular(支持EPUB格式) BT下载器：Transmission FTP客户端：FileZilla RSS阅读：Akregator/Google Reader Email阅读：Thunderbird/Gmail 即时通讯(GTalk/MSN)：Pidgin/KDE IM Contacts/WebQQ 办公套件：WPS office LibreOffice 日程管理：Trello(Chrome插件+Andriod应用) 思维导图：XMind / Docear / www.mindmeister.com / www.wisemapping.com 原型、系统结构图：Lucidchart 数据备份同步：Dropbox(+Andriod应用)(注： linux下安装使用Dropbox ) 文档记录与在线编辑：Evernote(+chrome插件Web Clipper+Andriod应用)/Google Drive/Readability(仅可记录阅读，Chrome插件+Andriod应用) mRemote（支持多种协议-RDP、SSH、VNC、Telnet、HTTP/HTTPS等，但我用来访问Windows服务器远程桌面） Xshell（远程访问Linux服务器） Vim多行缩进技巧 关键字: vim indent 按v进入visual状态，选择多行，用>或<缩进或缩出 通常根据语言特征使用自动缩进排版：在命令状态下对当前行用== （连按=两次）, 或对多行用n==（n是自然数）表示自动缩进从当前行起的下面n行。你可以试试把代码缩进任意打乱再用n==排版，相当于一般IDE里的code format。使用gg=G可对整篇代码进行排版。 vim 多行注释 :20,30 s/&#94;/#/g 第20到30行用 # 注释掉。 :20,30 s/&#94;#//g 取消注释 :4,10 s/&#94;[&#94;I ]+// 去掉行首的空白字符 用 . 表示当前行。 :.,30 s/&#94;/#/g 可以看到 vim 命令针对当前行，在前面加个范围就可以针对多行。 :co 12 把当前行 copy 到行 12 的地方。 简历设计","tags":"pages","title":"工具集"},{"url":"http://king32783784.github.io/pages/aboutme.html","text":"My name is lipeng, currently living in Beijing, China.I am currently working for isoft, a company that makes linux distributions. I like Computers, Food, and Movie, Reading, Travel! Thank you for checking out my Blog! What's on this blog? I like programming (eg C, Python, Linux, etc.), and my job is to test development, so this will be most of the content here but I intend to also make some content about my other hobbies such as reading, movies and music ... The picture in the blog is from https://stocksnap.io. Thanks for https://stocksnap.io. Contact You can contact me either via the social links in the sidebar or use one of these options: Protocol Contact Information GitHub king32783784 Email king32783784@163.com Tencent QQ 243246714 Resume Schooling: Period Occupation 2006-2009 Shandong University of Technology, Computer Science Work Period Occupation 2014-now Test Supervisor, iSoft 2012-2014 Test development, Loonson 2009-2012 System test, Hon Hai Technology Stack Tag Description Programming Language Familiar with Python, shell, C ,etc. Test Framework Autotest、LTP、selenium, etc. Others linux, docker，hardware，Virtualization，database，etc.","tags":"pages","title":"关于我"},{"url":"http://king32783784.github.io/pages/doc.html","text":"一、文档翻译 1.Autotest中文文档 Autotest测试框架的深入介绍, 详细 2.Avocado中文文档 Avocado测试框架的深入介绍, 详细 二、代码分析 1.Ltp-case说明 通过ltp测试用例的分析，从测试角度深入了解linux系统、linux编程, 详细","tags":"pages","title":"专题文档"},{"url":"http://king32783784.github.io/2016/11/15/python/","text":"对话框 PyQT提供基本的消息框和标准对话框。在PyQt也可以根据需要创建自定义的对话框。 使用PyQt提供的类和方法可以创建和使用消息框、标准对话框等。标准对话框包含基本的打开，关闭，字体选择对话框和颜色选择对话框等。 消息框 使用QtGui.QMessageBox类中的方法可以创建简单的消息框，用于向用户传递信息。QtGui.QMessageBox类中包含一下方法： about():创建关于消息框 aboutQt(): 创建关于Qt消息框 critical(): 创建错误处理对话框 infomation(): 创建信息消息框 question(): 创建询问消息框 warning(): 创建警告消息框 以下是示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #!/usr/bin/env python #*-* coding=utf-8 *-* import sys from PyQt4 import QtGui , QtCore class MyWindow ( QtGui . QWidget ): def __init__ ( self ): super ( MyWindow , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 self . label = QtGui . QLabel ( 'MessBox example' ) gridlayout . addWidget ( self . label , 1 , 3 , 1 , 3 ) #添加标签 self . button1 = QtGui . QPushButton ( \"About\" ) # 生成button1 gridlayout . addWidget ( self . button1 , 2 , 1 ) # 添加button到布局组件 self . button2 = QtGui . QPushButton ( \"AboutQt\" ) # 生成button2 gridlayout . addWidget ( self . button2 , 2 , 2 ) self . button3 = QtGui . QPushButton ( \"Critical\" ) gridlayout . addWidget ( self . button3 , 2 , 3 ) self . button4 = QtGui . QPushButton ( \"Info\" ) gridlayout . addWidget ( self . button4 , 2 , 4 ) self . button5 = QtGui . QPushButton ( \"Question\" ) gridlayout . addWidget ( self . button5 , 2 , 5 ) self . button6 = QtGui . QPushButton ( \"warning\" ) gridlayout . addWidget ( self . button6 , 2 , 6 ) spacer = QtGui . QSpacerItem ( 200 , 80 ) gridlayout . addItem ( spacer , 3 , 1 , 1 , 5 ) self . setLayout ( gridlayout ) # 向窗口中添加布局组件 self . connect ( self . button1 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton1 ) # button1事件 self . connect ( self . button2 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton2 ) self . connect ( self . button3 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton3 ) self . connect ( self . button4 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton4 ) self . connect ( self . button5 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton5 ) self . connect ( self . button6 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton6 ) def Onbutton1 ( self ): # button1插槽函数 self . button1 . setText ( 'clicked' ) QtGui . QMessageBox . about ( self , 'pyQt' , 'About' ) # 创建About消息框 def Onbutton2 ( self ): self . button2 . setText ( 'clicked' ) QtGui . QMessageBox . aboutQt ( self , \"PyQt\" ) def Onbutton3 ( self ): self . button3 . setText ( 'clicked' ) r = QtGui . QMessageBox . critical ( self , \"PyQt\" , \"Critical\" , QtGui . QMessageBox . Abort , QtGui . QMessageBox . Retry , QtGui . QMessageBox . Ignore ) if r == QtGui . QMessageBox . Abort : self . setWindowTitle ( \"Abort\" ) elif r == QtGui . QMessageBox . Retry : self . setWindowTitle ( \"Retry\" ) else : self . setWindowTitle ( \"Ignore\" ) def Onbutton4 ( self ): self . button4 . setText ( 'clicked' ) QtGui . QMessageBox . information ( self , \"Pyqt\" , \"information\" ) def Onbutton5 ( self ): self . button5 . setText ( 'clicked' ) r = QtGui . QMessageBox . question ( self , \"PyQt\" , \"Question\" , QtGui . QMessageBox . Yes , QtGui . QMessageBox . No , QtGui . QMessageBox . Cancel ) def Onbutton6 ( self ): self . button6 . setText ( 'clicked' ) r = QtGui . QMessageBox . warning ( self , \"PyQT\" , 'warning' , QtGui . QMessageBox . Yes , QtGui . QMessageBox . No ) app = QtGui . QApplication ( sys . argv ) win = MyWindow () win . show () app . exec_ () 运行效果： 标准对话框 PyQt使用QtGui.QFileDialog提供的方法可以创建文件打开、关闭对话框。使用QtGui.QFontDialog可以创建文章选择对话框，使用QtGui.QColorDialog可以创建颜色选择对话框。 其中QtGui.QFileDialog: getExistingDirectory(): 创建选取路径对话框 getOpenFileName(): 创建打开文件对话框 getOpenFileNames(): 创建打开文件对话框，可以同时打开多个文件 getSaveFileNmae(): 创建保存文件对话框 对于QtGui.QFontDialog,静态方法只有getFont,创建字体选择对话框。QtGui.QColorDialog，可以使用getColor创建颜色选择对话框。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/usr/bin/env python #*-* coding=utf-8 *-* import sys from PyQt4 import QtGui , QtCore class MyWindow ( QtGui . QWidget ): def __init__ ( self ): super ( MyWindow , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () self . label = QtGui . QLabel ( 'StandarDialog example' ) gridlayout . addWidget ( self . label , 1 , 2 ) self . button1 = QtGui . QPushButton ( \"File\" ) # 生成button1 gridlayout . addWidget ( self . button1 , 2 , 1 ) self . button2 = QtGui . QPushButton ( \"Font\" ) # 生成button2 gridlayout . addWidget ( self . button2 , 2 , 2 ) self . button3 = QtGui . QPushButton ( \"Color\" ) gridlayout . addWidget ( self . button3 , 2 , 3 ) spacer = QtGui . QSpacerItem ( 200 , 80 ) gridlayout . addItem ( spacer , 3 , 1 , 1 , 3 ) self . setLayout ( gridlayout ) # 向窗口添加布局组件 self . connect ( self . button1 , QtCore . SIGNAL ( 'clicked()' ), self . OnButton1 ) self . connect ( self . button2 , QtCore . SIGNAL ( 'clicked()' ), self . OnButton2 ) self . connect ( self . button3 , QtCore . SIGNAL ( 'clicked()' ), self . OnButton3 ) def OnButton1 ( self ): self . button1 . setText ( 'clicked' ) filename = QtGui . QFileDialog . getOpenFileName ( self , 'Open' ) # 创建文件打开对话框 if not filename . isEmpty (): self . label . setText ( filename ) def OnButton2 ( self ): self . button2 . setText ( 'clicked' ) font , ok = QtGui . QFontDialog . getFont () # 创建字体选择对话框 if ok : self . label . setText ( font . key ()) def OnButton3 ( self ): self . button3 . setText ( 'clicked' ) color = QtGui . QColorDialog . getColor () # 创建颜色选择对话框 if color . isValid (): self . label . setText ( color . name ()) app = QtGui . QApplication ( sys . argv ) win = MyWindow () win . show () app . exec_ () 运行效果： 自定义对话框 通过继承QtGui.QDialog类可以创建自定义的对话框。所创建的对话框和窗口一样，可以向其添加组件。使用connect方法响应组件时间。 自定义对话框例子： #coding=utf-8 import sys from PyQt4 import QtGui , QtCore class MyDialog ( QtGui . QDialog ): def __init__ ( self ): super ( MyDialog , self ) . __init__ () self . gridlayout = QtGui . QGridLayout () self . label = QtGui . QLabel ( \"Input:\" ) self . gridlayout . addWidget ( self . label , 0 , 0 ) self . textField = QtGui . QLineEdit () # 创建单行文本框 self . gridlayout . addWidget ( self . textField , 0 , 1 ) # 添加文本框到布局组件 self . okButton = QtGui . QPushButton ( \"OK\" ) # 创建OK按钮 self . gridlayout . addWidget ( self . okButton , 1 , 0 ) #添加按钮到布局组件 self . cancelButton = QtGui . QPushButton ( \"Cancel\" ) # 创建cancel按钮 self . gridlayout . addWidget ( self . cancelButton , 1 , 1 ) self . setLayout ( self . gridlayout ) self . connect ( self . okButton , QtCore . SIGNAL ( 'clicked()' ), self . OnOk ) self . connect ( self . cancelButton , QtCore . SIGNAL ( 'clicked()' ), self . OnCancel ) def OnOk ( self ): self . text = self . textField . text () # 获取文本框中的内容 self . done ( 1 ) # 结束对话框返回１ def OnCancel ( self ): self . done ( 0 ) class Window ( QtGui . QWidget ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb-i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () self . creatDialogButton = QtGui . QPushButton ( \"Create a new Dialog\" ) #生成button gridlayout . addWidget ( self . creatDialogButton , 1 , 1 ) self . setLayout ( gridlayout ) self . connect ( self . creatDialogButton , QtCore . SIGNAL ( 'clicked()' ), self . OnButton ) def OnButton ( self ): dialog = MyDialog () r = dialog . exec_ () if r : self . creatDialogButton . setText ( dialog . text ) app = QtGui . QApplication ( sys . argv ) win = Window () win . show () app . exec_ () 运行效果： 资源文件 Qt中资源文件是以'.ui'为后缀的文件。Qt提供Qt Designer用于创建资源文件。使用Qt Designer创建的资源文件可以在pyqt中使用。使用资源文件可以简化界面设计，也可以将界面和代码分离，提高程序的可维护性。 示例 #coding=utf-8 import sys from PyQt4 import QtGui , QtCore , uic class MyDialog ( QtGui . QDialog ): def __init__ ( self ): QtGui . QDialog . __init__ ( self ) uic . loadUi ( \"res.ui\" , self ) # 载入资源文件 class MyWindow ( QtGui . QWidget ): def __init__ ( self ): super ( MyWindow , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 self . button = QtGui . QPushButton ( \"CreateDialog\" ) # 生成button1 gridlayout . addWidget ( self . button , 1 , 1 ) self . setLayout ( gridlayout ) self . connect ( self . button , QtCore . SIGNAL ( 'clicked()' ), self . OnButton ) def OnButton ( self ): dialog = MyDialog () r = dialog . exec_ (); if r : self . button . setText ( dialog . lineEdit . text ()) app = QtGui . QApplication ( sys . argv ) demo = MyWindow () demo . show () app . exec_ ()","tags":"Python-pyqt","title":"pyqt基本操作(三）"},{"url":"http://king32783784.github.io/2016/11/13/python/","text":"pyqt是对Qt的封装。Ｑt是面向对象的图形用户界面库，可以在多个操作系统上使用。 PyQt基本操作 基本的界面： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/env python #*-* coding=utf-8 *-* import sys from PyQt4 import QtCore , QtGui # 导入PyQt模块 class MyWindow ( QtGui . QMainWindow ): # 通过继承QtGui.QMainWindow创建类 def __init__ ( self ): # 初始化方法 QtGui . QMainWindow . __init__ ( self ) # 调用父类的初始化方法 self . setWindowTitle ( \"pyQt\" ) # 设置窗口标题 self . resize ( 400 , 600 ) # 设置窗口大小 app = QtGui . QApplication ( sys . argv ) # 创建QApplication对象 mywindow = MyWindow () # 创建MyWindow对象 mywindow . show () # 显示窗口 app . exec_ () # 进入消息循环 运行效果： 添加一个标签： PyQt提供了丰富的组件进行GUI编程，可以方便的使用组件，并使用信号/插槽进行组件的通信，处理组件事件。 使用QtGui.QLabel可以创建标签。使用setText方法可以设置标签的文字。使用setTextFormat可以设置中文字的格式。当创建标签后使用QMainWindow 的setCentralWidget方法将标签添加到窗口中。常见的方法： setPicture():设置标签中的图片 setText():设置标签中的文字 setTextFormat:设置标签文字的格式 setAlignment:设置标签中文本的对齐方式 下面将创建一个标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #! /usr/bin/env python # *-* coding=utf-8 *-* import sys from PyQt4 import QtCore , QtGui class Window ( QtGui . QMainWindow ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) set . resize ( 400 , 600 ) #添加标签 label = QtGui . QLabel ( \"start test\" ) # 创建标签 label . setAlignment ( QtCore . Qt . AlignCenter ) # 设置标签文字的对齐样式 self . setCentralWidget ( label ) # 向窗口添加标签 app = QtGui . QApplicatin ( sys . argv ) demo = Window () demo . show () app . exec_ () 运行效果： 布局组件和空白项 布局组件 在窗口中使用setCentralWidget只能添加一个组件。如果想添加多个组件，可以使用布局组件。空白项用于占位，配合布局组件更好的控制界面。 布局组件：主要用于控制内部组件的大小、位置等。布局组件可以包含其他的组件，也可以嵌套其他的布局组件。 常见的布局组件： QLayout: 基本的布局组件，只能被继承 QHBoxLayout: 横向Box布局组件 QVBoxLayout: 竖向Box布局组件 QGridLayout: Grid布局组件 布局组件共有的方法： addWidget():添加组件 addLayout():添加其他布局组件 下面是一个使用布局组件布置标签的例子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/env python # *-* coding=utf-8 *-* import sys from PyQt4 import QtCore , QtGui class Window ( QtGui . QWidget ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb-i\" ) self . resize ( 500 , 600 ） label1 = QtGui . QLabel ( \"sysbench\" ) # 创建标签 label2 = QtGui . QLabel ( \"iozone\" ) label3 = QtGui . QLabel ( \"lmbench\" ) label4 = QtGui . QLabel ( \"netperf\" ) label5 = QtGui . QLabel ( \"pingpong\" ) label6 = QtGui . QLabel ( \"unixbench\" ) gridLayout = QtGui . QGridLayout () # 创建网格布局组件 gridLayout . addWidget ( label1 , 0 , 0 ) # 向布局中添加标签，第１行第一列 gridLayout . addWidget ( label2 , 0 , 1 ) gridLayout . addWidget ( label3 , 0 , 2 ) gridLayout . addWidget ( label4 , 1 , 0 ) gridLayout . addWidget ( label5 , 1 , 1 ) gridLayout . addWidget ( label6 , 1 , 2 ) self . setLayout ( gridLayout ) ＃ 设置布局组件 # 添加水平布局 # hBoxLayout1 = QtGui.QHBoxLayout() # 创建横向布局组件 # hBoxLayout1.addWidget(label1) # hBoxLayout1.addWidget(label2) # hBoxLayout1.addWidget(label3) # hBoxLayout1.addWidget(label4) # hBoxLayout1.addWidget(label5) # hBoxLayout1.addWidget(label6) # self.setLayout( hBoxLayout1) # 添加垂直布局 # vBoxLayout = QtGui.QVBoxLayout() # 创建垂直布局组件 # vBoxLayout.addWidget(label1) # vBoxLayout.addWidget(label2) # vBoxLayout.addWidget(label3) # vBoxLayout.addWidget(label4) # vBoxLayout.addWidget(label5) # vBoxLayout.addWidget(label6) # self.setLayout(vBoxLayout) app = QtGui . QApplication ( sys . argv ) demo = Window () demo . show () app . exec_ () 运行效果： 空白项 PyQt中的空白项可以占据位置，这样就可以更好的布置其他的组件。使用QtGui.QSpaerItem创建空白项，可以使用宽度和高度进行设置。 使用布局组件的addItem方法将其添加到布局组件中。 下面看一个例子： #!/usr/bin/env python # - - coding:utf-8 - - import sys from PyQt4 import QtCore , QtGui class MyWindow ( QtGui . QWidget ): def __init__ ( self ): QtGui . QWidget . __init__ ( self ) self . setWindowTitle ( 'test' ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 spacer1 = QtGui . QSpacerItem ( 300 , 40 ) # 创建空白项 spacer2 = QtGui . QSpacerItem ( 300 , 40 ) label = QtGui . QLabel ( 'Label' , self ) # 创建标签 label . setAlignment ( QtCore . Qt . AlignCenter ) #设置标签文本样式 gridlayout . addItem ( spacer1 , 0 , 0 ) # 添加空白项 gridlayout . addWidget ( label , 1 , 0 ) # 添加标签 gridlayout . addItem ( spacer2 , 2 , 0 ) self . setLayout ( gridlayout ) # 向窗口中添加布局组件 app = QtGui . QApplication ( sys . argv ) mywindow = MyWindow () mywindow . show () app . exec_ () 运行效果： 按钮基本使用 使用PyQt中的QtGui.QPushButton可以创建按钮。在PyQt中按钮事件是以信号/插槽的形式进行的，将按钮事件绑定到类的方法上。 创建按钮 当使用QtGui.QPushButton创建按钮后可以使用一下几种方法设置按钮的样式、属性等。 setDefault():将按钮设置为默认按钮 setFlat(): 将按钮设置为平坦模式 setMenu(): 设置按钮关联的菜单。 menu(): 获得按钮关联的菜单 下面例子创建两个按钮 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/usr/bin/env python # *-* coding=utf-8 *-* import sys from PyQt4 import QtGui , QtCore class Window ( QtGui . QWidget ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb-i\" ) self . resize ( 400 , 600 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 button1 = QtGui . QPushButton ( \"spec2000\" ) # 生成button1 gridlayout . addWidget ( button1 , 0 , 0 , 1 , 3 ) # 添加button1 button2 = QtGui . QPushButton ( \"iozone\" ) button2 . setFlat ( True ) gridlayout . addWidget ( button2 , 1 , 1 , 1 , 3 ) self . setLayout ( gridlayout ) # 向窗口中添加布局组件 app = QtGui . QApplication ( sys . argv ) demo = Window () demo . show () app . exec_ () 运行效果 信号和信号槽 Qt中的组件使用信号和信号槽的形式来进行通信。Qt的组件中有很多预定义的信号，当事件触发时，组件发出对应的信号。信号被发送给信号槽进行处理。信号槽是处理特定信号的函数。在PyQt同样，需要使用组件的connect方法将组件信号绑定到其处理插槽上。connect方法的原型如下： connect(QObject, SIGNAL(), SLOT(), Qt.ConnectionType) 参数含义如下： QObject: 发送信号的组件 SIGNAL(): 组件发送的信号 SLOT(): 信号槽函数 Qt.ConnectionType: 可选参数，连接类型 下面的例子使用connect方法将按钮的\"clicked()\"信号连接到事件处理信息槽的函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/usr/bin/env python # -*- coding:utf-8 -*- import sys from PyQt4 import QtCore , QtGui class MyWindow ( QtGui . QWidget ): def __init__ ( self ): QtGui . QWidget . __init__ ( self ) self . setWindowTitle ( 'test' ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 self . button1 = QtGui . QPushButton ( 'Button1' ) gridlayout . addWidget ( self . button1 , 1 , 1 , 1 , 3 ) self . button2 = QtGui . QPushButton ( 'Button2' ) gridlayout . addWidget ( self . button2 , 2 , 2 ) self . setLayout ( gridlayout ) # 向窗口添加布局组件 self . connect ( self . button1 , # button1事件 QtCore . SIGNAL ( 'clicked()' ), # clicked()信号 self . OnButton1 ) # 信号处理函数 self . connect ( self . button2 , # button2事件 QtCore . SIGNAL ( 'clicked()' ), # clicked()信号 self . OnButton2 ) # 信号处理函数 def OnButton1 ( self ): self . button1 . setText ( 'clicked' ) print ( \"button1 is cliecked\" ) def OnButton2 ( self ): self . button2 . setText ( 'clicked' ) print ( \"button2 is cliecked\" ) app = QtGui . QApplication ( sys . argv ) mywindow = MyWindow () mywindow . show () app . exec_ () 运行效果如下：","tags":"Python-pyqt","title":"pyqt基本操作"},{"url":"http://king32783784.github.io/2016/11/12/自动化测试/","text":"编写Avocado测试 现在我们开始使用python编写Avocado测试，测试继承于avocado.Test. 基本例子 创建一个时间测试，sleeptest,测试非常简单，只是sleep一会： import time from avocado import Test class SleepTest ( Test ): def test ( self ): sleep_length = self . params . get ( 'sleep_length' , default = 1 ) self . log . debug ( \"Sleep for %.2f seconds\" , sleep_length ) time sleep ( sleep_length ) 这是为avocado编写的一个简单示例，可以使用其他power API编写。 从上面的例子可以看出，avocado测试从avocado.Test继承的test方法入手。 多个测试和命名约定 可以在一个类中存在多个测试。 要想做多个测试，只需要在命名方法前加test,例如test_foo,test_bar等。建议遵守这个命名风格，就像 PEP8 Function Names . 对于class名称，可以任意命名，当最好还是遵从CamelCase命名，参考PEP8 中 Class Names 方便属性 测试类提供了一定数量的方便属性： 为测试添加测试log,可以使用self.log.可以定义log debug,info,error和warning信息。 参数解析系统，可以访问self.parms使用。可以在后面的Test variants - Mux文章查看更多信息。 保存生成的数据 每个测试都提供一个所谓的whiteboard,可以通过self.whiteboard访问。Witeboard是一个可以自动保存到测试结果（可以支持的output格式）字符串。你同样可以选择保存二进制数据到whiteboard,但你需要先进行编码转换（base64). 基于上面的sleeptest，假设想保存sleep_length用于其他脚本或数据分析工具： def test(self): sleep_length = self.params.get('sleep_length', default=1) self.log.debug(\"Sleeping for %.2f second\", sleep_length) time.sleep(sleep_length) slef.writeboard = \"%.2f\" % sleep_length whiteboard可以并应当接收由可用的测试结果插件生成的文件。Result.json文件已经为每个测试包含了whiteboard.此外，会用一个命名为whiteboard的文件保存和results.json相同级别的信息（也许你想使用与你定制的脚本配套的结果处理工具，该文件会保存白板内容的原始副本）。 访问测试参数 每个测试都有一组可以通过self.params.get($name, $path=None, $default=None)访问的参数.Avocado会从Multiplex 配置文件中发现所有参数并填充到self.params.比如上面的例子，sleeptest的multiplex文件： sleeptest : type : \"builtin\" length : ! Mux short : sleep_length : 0.5 medium : sleep_length : 1 long : sleep_length : 5 当我们用avocado run $test --mux-yaml $file.yaml运行这个例子，3个variants会执行并且内容会插入/run的命名空间。每个variant包含变量的\"type\"和\"sleep_length\"。要获取有效值，需要名称（\"sleep_length)和path。需要选择路径 ,在这个例子：/run/sleeptest/length/ 或sleeptest/ ,取决于如何设置。 默认的参数是可选的，但是要处理好这部分。可能有人运行你的测试时选择不同的参数或没有参数，它仍然能够很好的运行。 所以关于如何访问\"sleep_length\"的完整示例： self.params.get(\"sleep_length\", \"/*/sleeptest/*\", 1) 还有一种更简单的方式。它用于定义解析顺序，简单的查询可以简单的指定路径： self.params.get(\"sleep_length\", None, 1) self.params.get(\"sleep_length\", '*', 1) self.params.get(\"sleep_length\", default=1) 应该避免参数冲突（不同的匹配值应该指定不同的路径）。如果不能这样（例如使用复合yaml文件）可以通过 --mux-path进行默认路径的修改。它将对参数和操作通过路径进行一个接一个的切片。当第一个切片匹配后会返回，不再尝试其他切片。虽然相对查询只匹配来自--mux-path的切片。 有很多方式使用paths分离存在冲突的params或只是使查询更清晰。通常tests中使用\"*\"就足够了，namespacing不是必须的，但是有助于高级用法更清晰简单。 关于路径的考虑基本是从用户角度。更多信息参考 The variants-Mux 使用multplex文件 Ａvocado可以使用multplex文件提供params和生成generation来运行sleeptest: $ avocado run sleeptest.py --mux-yaml examples/tests/sleeptest.py.date/sleeptest.yaml JOB ID : d565e8dec576d6040f894841f32a836c751f968f JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.44-d565e8de/job.log TESTS : 3 ( 1/3 ) sleeptest.py:SleepTest.test ; 1: PASS ( 0.50 s ) ( 2/3 ) sleeptest.py:SleepTest.test ; 2: PASS ( 1.00 s ) ( 3/3 ) sleeptest.py:SleepTest.test ; 3: PASS ( 5.00 s ) RESULTS : PASS 3 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 6.50 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.44-d565e8de/html/results.html The --mux-yaml accepts either only \\(FILE_LOCATION or $INJECT_TO:\\) FILE_LOCATION. As explained in Test variants - Mux without any path the content gets injected into /run in order to be in the default relative path location. The \\(INJECT_TO can be either relative path, then it's injected into /run/\\) INJECT_TO location, or absolute path (starting with '/'), then it's injected directly into the specified path and it's up to the test/framework developer to get the value from this location (using path or adding the path to mux-path). To understand the difference execute those commands: $ avocado multiplex -t -m examples/tests/sleeptest.py.data/sleeptest.yaml $ avocado multiplex -t -m duration:examples/tests/sleeptest.py.data/sleeptest.yaml $ avocado multiplex -t -m /my/location:examples/tests/sleeptest.pt.data/sleeptest.yaml 注意，因为multiplex文件为sleeptest指定了所有参数，所以不能将ID留空： $ scripts/avocado run --mux-yaml examples/tests/sleeptest/sleeptest.yaml Empty test ID. A test path or alias must be provided 可以使用同一个multiplex文件启动多个测试： $avocado run sleeptest . py synctest . py -- mux-yaml examples/tests/sleeptest . py . data/sleeptest . yaml JOB ID : cd20fc8d1714da6d4791c19322374686da68c45c JOB LOG : $HOME/avocado/job-results/job-2016-05-04T09 . 25 - cd20fc8/job . log TESTS : 8 ( 1 / 8 ) sleeptest . py : SleepTest . test;1 : PASS ( 0.50 s ) ( 2 / 8 ) sleeptest . py : SleepTest . test;2 : PASS ( 1.00 s ) ( 3 / 8 ) sleeptest . py : SleepTest . test;3 : PASS ( 5.01 s ) ( 4 / 8 ) sleeptest . py : SleepTest . test;4 : PASS ( 10.00 s ) ( 5 / 8 ) synctest . py : SyncTest . test;1 : PASS ( 2.38 s ) ( 6 / 8 ) synctest . py : SyncTest . test;2 : PASS ( 2.47 s ) ( 7 / 8 ) synctest . py : SyncTest . test;3 : PASS ( 2.46 s ) ( 8 / 8 ) synctest . py : SyncTest . test;4 : PASS ( 2.45 s ) RESULTS : PASS 8 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 26.26 s JOB HTML : $HOME/avocado/job-results/job-2016-05-04T09 . 25 - cd20fc8/html/results . html 高级日志功能 Avocado 在测试的同时提供高级日志功能。这些可以和标准python API库组合。 一个常见的例子是需要在更长或更复杂的测试中遵循具体的进展。 让我们看一个非常简单的测试示例，但在单个测试中有一个多个明确的阶段： import logging import time from avocado import Test progress_log = logging . getLogger ( \"progress\" class Plant ( Test ): def test_plant_organic ( self ): rows = self . params . get ( \"rows\" , default = 3 ) #Preparing soil for row in range ( rows ): progress_log . info ( \" %s : Preparing soil on row %s \" , self . name , row ) # Letting soil rest progress_log . info ( \" %s : letting soil rest before throwing seeds\" , self . name ) time . sleep ( 2 ) # Throwing seeds for row in range ( rows ): progress_log . info ( \" %s : throwing seeds on row %s \" , self . name , row ) # Let them grow progress_log . info ( \" %s : waiting for Avocados to grow\" , self . name ) time . sleep ( 5 ) # Harvest them for row in range ( rows ): progress_log . info ( \" %s : harvesting organic avocados on row %s \" , self . name , row ) 这时，可以请求avocaod显示你的日志流，独占或则加入其他内建流： $ avocado --show app, progress run plant.py 结果类似于： JOB ID : af786f86db530bff26cd6a92c36e99bedcdca95b JOB LOG : / home/cleber/avocado/job-results/job-2016-03-18T10 . 29 - af786f8/job . log TESTS : 1 ( 1 / 1 ) plant . py : Plant . test_plant_organic : progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 0 progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 1 progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 2 progress : 1 - plant . py : Plant . test_plant_organic : letting soil rest before throwing seeds - progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 0 progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 1 progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 2 progress : 1 - plant . py : Plant . test_plant_organic : waiting for Avocados to grow \\progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 0 progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 1 progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 2 PASS ( 7.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 7.01 s JOB HTML : / home/cleber/avocado/job-results/job-2016-03-18T10 . 29 - af786f8/html/results . html 自定义的progress流和app输出混合在一起，可能不太适合。如果想让progress流输入到一个独立文件，这样会清晰。 $ avocado run plant.py --store-loggin-stream progress 这样，除了所有其他日志文件通常生成，会有另一个名为日志文件progress.INFO在作业结果目录。 在测试运行期间，可以观察进度： $ tail -f ~/avocado/job-results/latest/progress.INFO 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 0 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 1 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 2 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: letting soil rest before throwing seeds 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 0 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 1 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 2 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: waiting for Avocados to grow 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 0 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 1 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 2 同一个progress日志记录器，可以在多个测试方法和在多个测试模块一起使用。 在给出的示例中，测试名称用于给出额外的上下文。 <未完待续> if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"自动化测试-Avocado","title":"Avocado-编写Avocado测试"},{"url":"http://king32783784.github.io/2016/11/03/自动化测试/","text":"1.Avocado 安装 1.1 通过包安装 像 Fedora 可以通过rpm包进行安装，其他通过RPM管理的发行版需要自己制作相关包。Avocado同样支持DEP包的安装可以在contrib/packages/debian找到。 Fedora 首先通过下面的命令获取仓库配置文件。 sudo curl https://repos-avocadoproject.rhcloud.com/static/avocado-fedora.repo -o /etc/yum.repos.d/avocado.repo 检查是否有了Avocodo和Avocado-lts的仓库配置： sudo dnf repolist avocado avocado-lts ... repo id repo name status avocado Avocado 50 avocado-lts Avocado LTS (Long Term Stability) disabled Avocao了解更多的LTS信息，参考 Avocado Long Term Stability 接下来，可以进行avocado安装啦： sudo dnf install avocado 另外还有两个包需要安装： avocado-examples: 包含测试例子和示例文件 avocado-plugins-output-html: HTML job 报告的插件 RHEL7 如果要运行在红帽商业版或CentOS上，需要进行下面设置： # If not already, enable epel (for RHEL7 it's following cmd) sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm # Add avocado repository and install avocado sudo curl https://repos-avocadoproject.rhcloud.com/static/avocado-el.repo -o /etc/yum.repos.d/avocado.repo sudo yum install avocado 同fedora一样，需要安装以下包： avocado-examples: 包含测试例子和示例文件 avocado-plugins-output-html: HTML job 报告的插件 OpenSUSE Avocado同样支持，执行运行以下命令即可： sudo zypper install avocado 1.2 源码安装 首先确保系统有基本的编译环境，如fedora： sudo yum install -y git gcc python-devel python-pip libvirt-devel libyaml-devel redhat-rpm-config xz-devel 然后，获取源码： git clone git://github.com/avocado-framework/avocado.git cd avocado sudo make requirements sudo python setup.py install 注意，python和pip需要2.7.x版本。如果安装出现问题，需要指明python2.7 和 pip2.7. Avocodo可能需要一些插件： cd optional_plugins/html sudo python setup.py install 安装python依赖工具 avocado可以通过pip安装。 pip install avocado-framework 注意：只有基本的avocado基本的test runner安装，导入插件时可能会失败，需要根据不同的系统安装不同的依赖。 如果想安装全部插件，需要执行以下命令： pip install -r https://raw.githubusercontent.com/avocado-framework/avocado/master/requirements.txt 2. Avocado使用 首先 要使用命令行工具test runner,用来运行你的测试和收集测试结果。 2.1 运行测试 可以运行avocado加 run子命令，后面跟一个测试，例如： $ avocado run /bin/true JOB ID : 381b849a62784228d2fd208d929cc49f310412dc JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.39-381b849a/job.log TESTS : 1 ( 1/1 ) /bin/true: PASS ( 0.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.01 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.39-381b849a/html/results.html 可以看到，我们把/bin/true作为一个测试运行，并记录了测试过程。这是一个简单的例子，这是支持测试的一种类型。 Test Types 了解更多的测试类型。 注意： 尽管可以通过 avocao run \\(test1 $test3... 运行多个测试，但可以导致崩溃。一个安全的方式为： avocodo run --\\) argument1 --$argument2 -- $test1 $test2. 后面所有内容都会当做位置参数。 2.2 列出测试项 有两种方式覆盖这些测试。可以通过--dry-run 参数模拟： avocado run / bin/true -- dry-run JOB ID : 0000000000000000000000000000000000000000 JOB LOG : / tmp/avocado-dry-runSeWniM/job-2015-10-16T15 . 46 - 0000000 / job . log TESTS : 1 ( 1 / 1 ) / bin/true : SKIP RESULTS : PASS 0 | ERROR 0 | FAIL 0 | SKIP 1 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.00 s JOB HTML : / tmp/avocado-dry-runSeWniM/job-2015-10-16T15 . 46 - 0000000 / html/results . html 另一个方式是使用list参数列出支持的测试参数。如： $ avocado list INSTRUMENTED /usr/share/avocado/tests/abort.py INSTRUMENTED /usr/share/avocado/tests/datadir.py INSTRUMENTED /usr/share/avocado/tests/doublefail.py INSTRUMENTED /usr/share/avocado/tests/doublefree.py INSTRUMENTED /usr/share/avocado/tests/errortest.py INSTRUMENTED /usr/share/avocado/tests/failtest.py INSTRUMENTED /usr/share/avocado/tests/fiotest.py INSTRUMENTED /usr/share/avocado/tests/gdbtest.py INSTRUMENTED /usr/share/avocado/tests/gendata.py INSTRUMENTED /usr/share/avocado/tests/linuxbuild.py INSTRUMENTED /usr/share/avocado/tests/multiplextest.py INSTRUMENTED /usr/share/avocado/tests/passtest.py INSTRUMENTED /usr/share/avocado/tests/sleeptenmin.py INSTRUMENTED /usr/share/avocado/tests/sleeptest.py INSTRUMENTED /usr/share/avocado/tests/synctest.py INSTRUMENTED /usr/share/avocado/tests/timeouttest.py INSTRUMENTED /usr/share/avocado/tests/trinity.py INSTRUMENTED /usr/share/avocado/tests/warntest.py INSTRUMENTED /usr/share/avocado/tests/whiteboard.py ... 这些测试文件被Avocodo视为包含在INSTRUMENTED测试。 我们可以只列出可执行shell脚本： $ avocado list | grep &#94;SIMPLE SIMPLE /usr/share/avocado/tests/env_variables.sh SIMPLE /usr/share/avocado/tests/output_check.sh SIMPLE /usr/share/avocado/tests/simplewarning.sh SIMPLE /usr/share/avocado/tests/failtest.sh SIMPLE /usr/share/avocado/tests/passtest.sh 如前面说的那样，SIMPLE表示这些文件是一些简单的可执行的测试。 可以通过--verbose 或 -V,列出avocado中不是测试的文件。 $ avocado list examples/gdb-prerun-scripts/ -V Type file NOT_A_TEST examples/gdb-prerun-scripts/README NOT_A_TEST examples/gdb-prerun-scripts/pass-sigusr1 SIMPLE: 0 INSTRUMENTED: 0 MISSING: 0 NOT_A_TEST: 2 3.编写一个简单的测试 下面是一个 simple 测试的简单示例： $ echo '#!/bin/bash' > /tmp/simple_test.sh $ echo 'exit 0 ' >> /tmp/simple_test.sh $ chmod +x /tmp/simple_test.sh 注意，我们给这个文件增加了执行权限，它会被avocado当做一个simple test. 4.运行一个较复杂的测试 你 可以以任意顺序执行任意数量的测试，而且可以混合不同类型的测试： $ avocado run failtest.py sleeptest.py synctest.py failtest.py synctest.py /tmp/simple_test.sh JOB ID : 86911e49b5f2c36caeea41307cee4fecdcdfa121 JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.42-86911e49/job.log TESTS : 6 ( 1/6 ) failtest.py:FailTest.test: FAIL ( 0.00 s ) ( 2/6 ) sleeptest.py:SleepTest.test: PASS ( 1.00 s ) ( 3/6 ) synctest.py:SyncTest.test: PASS ( 2.43 s ) ( 4/6 ) failtest.py:FailTest.test: FAIL ( 0.00 s ) ( 5/6 ) synctest.py:SyncTest.test: PASS ( 2.44 s ) ( 6/6 ) /bin/true: PASS ( 0.00 s ) ( 6/6 ) /tmp/simple_test.sh.1: PASS ( 0.02 s ) RESULTS : PASS 2 | ERROR 2 | FAIL 2 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 5.88 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.42-86911e49/html/results.html 5.出现fail后中断测试 Avocado run 命令包含 --failfast on 参数，当出现错误是会退出测试： $ avocado run --failfast on /bin/true /bin/false /bin/true /bin/true JOB ID : eaf51b8c7d6be966bdf5562c9611b1ec2db3f68a JOB LOG : $HOME /avocado/job-results/job-2016-07-19T09.43-eaf51b8/job.log TESTS : 4 ( 1/4 ) /bin/true: PASS ( 0.01 s ) ( 2/4 ) /bin/false: FAIL ( 0.01 s ) Interrupting job ( failfast ) . RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 2 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.02 s JOB HTML : /home/apahim/avocado/job-results/job-2016-07-19T09.43-eaf51b8/html/results.html 6.通过外部Runner 运行测试 大 部软件都存在自己的测试集。通常包括一个定制的runner,它可以找到并运行自己的测试。 Avocado能支持运行这些测试，而且可以支持生成不同格式的结果，收集系统信息以及这些测试（Avocado的sysinfo功能）等等。 大部分方式如下： $ avocado run --external -runner=/path/to/external_runner foo bar baz 这个例子，avocado会产生foo bar baz的测试结果。实际结果将来源于执行 /path/to/external_runner foo /path/to/external_runner bar和/path/to/external_runner baz 另一种方式展示这一特性，就是思考\"外部runner\"可以是解释器和可以解释执行任何测试。UNIXshell,/bin/sh就可以被当做外部执行引擎，而且shell脚本就可以当成它的测试： $ echo \"exit 0\" > /tmp/pass $ echo \"exit 1\" > /tmp/fail $ avocado run --external-runner = /bin/sh /tmp/pass /tmp/fail JOB ID : 4a2a1d259690cc7b226e33facdde4f628ab30741 JOB LOG : /home/<user>/avocado/job-results/job-<date>-<shortid>/job.log TESTS : 2 ( 1/2 ) /tmp/pass: PASS ( 0.01 s ) ( 2/2 ) /tmp/fail: FAIL ( 0.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.01 s JOB HTML : /home/<user>/avocado/job-results/job-<date>-<shortid>/html/results.html 这个例子很明显，可以通过给/tmp/pass和/tmp/fail ，shell\"shebangs\"（＃！/ bin / sh）来实现，使它们可执行（chmod + x / tmp / pass / tmp / ，并将其作为\"简单\"测试运行。 下面看另一个例子： $ avocado run --external-runner = /bin/curl http://local-avocado-server:9405/jobs/ \\ http://remote-avocado-server:9405/jobs/ JOB ID : 56016a1ffffaba02492fdbd5662ac0b958f51e11 JOB LOG : /home/<user>/avocado/job-results/job-<date>-<shortid>/job.log TESTS : 2 ( 1/2 ) http://local-avocado-server:9405/jobs/: PASS ( 0.02 s ) ( 2/2 ) http://remote-avocado-server:9405/jobs/: FAIL ( 3.02 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 3.04 s JOB HTML : /home/<user>/avocado/job-results/job-<date>-<shortid>/html/results.html 这个例子是把\"/bin/curl\"当做\"external test runner\". 7. 测试调试 当 开发一个新的测试时，经常做的就是查看一个测试job的运行日志。 为了实现这个目的， 可以通过 avocado --show test run ... 或 avocado run --show-job-log ... 例如： $ avocado --show test run examples/tests/sleeptest.py ... Job ID: f9ea1742134e5352dec82335af584d1f151d4b85 START 1-sleeptest.py:SleepTest.test PARAMS (key=timeout, path=*, default=None) => None PARAMS (key=sleep_length, path=*, default=1) => 1 Sleeping for 1.00 seconds PASS 1-sleeptest.py:SleepTest.test Test results available in $ HOME /avocado/job-results/job-2015-06-02T10.45-f9ea174 UI输出被抑制，只显示作业日志，这使得它成为测试开发和调试的有用功能。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"自动化测试-Avocado","title":"Avocado-入门"},{"url":"http://king32783784.github.io/2016/11/01/自动化测试/","text":"Avocado 用户指南 内容： 关于Avocado 入门 安装Avocado 使用Avocado 写一个简单测试 运行一个较复杂的测试 第一个测试失败时中断测试job 结合外部runner运行测试 测试调试 编写Avocado测试 基本例子 保存测试生成的数据（自定义） 访问测试参数 使用multplex文件 高级日志功能 unittest.TestCase 继承 Setup和cleanup方法 运行第三方测试集 获取资源文件 测试输出检查和输出记录模式 Avocado Testlog，stdout和stderr模块 独立进程中运行Avocado测试 设置测试超时 测试标签 Python unitest 兼容测试和警告 简单测试的环境变量 简单测试的BASH扩展 Wrap up 结果格式 人性化测试结果 机器可读的结果 一次多种结果 Exit Codes 实现其他结果格式 配置 配置文件的解析顺序 插件设置文件 解析订单概述 测试中使用值的优先级 设置插件 Avocado数据目录 测试发现 测试载入的顺序 日志系统 UI调整 存储用户日志 分页器 测试变种－Mux Mux内部 Mux API 节点 键和值 变体 分辨顺序 插入文件 复合文件 高级YAML标记 !include !using !remove_node !remove_value !mux 完整示例 Job重放 Job对比 运行远程测试 远程Host运行测试 虚拟机上运行测试 Docker容器上运行测试 环境变量 使用GDB调试 透明执行可执行文件 avocado.uitls.gdb APIs 封装测试执行文件 用法 警告 插件系统 插件列表 制作插件 高级主题和维护 参考指南 job,test和identifiers 测试类型 测试状态 库和APIs 测试解析 结果规格 job前后脚本 job清理 Avocado 开发tips 中断测试 In tree utils Line-profiler 使用Eclipse远程debug 在Eclipase中使用Trello avocado发布 删除版本号 应当注意哪些项目库 所有库的标记 构建rpms 包命名 上传包到仓库 书写发行注记 发送电子邮件到avocado-devel和其他地方 API参考 测试APIs 工具APIs 内部(核心)APIs 外部(插件)APIs Avocado 发行注记 发行注记 关于Avocado Avocado 是一套帮助自动化测试工具和库。 可以把它称作为测试框架。内部测试是通过python编写的，并且遵从unittest模式，但是它也可以将执行任何外部可执行文件作为测试。 组成部分： 一个可以引导执行测试的Test runner。这些测试可以是选择任意语言编写的测试，或则通过python编写，并使用可用的库。这两种情况，你都可以获取自动日志和系统信息收集功能。 提供一个帮助你通过一种concise,yet expressive 和 powerful的方式编写测试。你可以通过后面 库和API 章节了解更多这方面的信息。 插件，可以扩展和增加框架的功能 Avocado尽可能尝试遵守标准的Python测试技术。 使用Avocado API编写的测试是从unittest类派生，而添加了适合于功能和性能测试的其他方法。 测试运行器旨在帮助人们运行测试，同时提供各种系统和日志记录工具。 接下来的专题，会按照本文的目录详细介绍Avocado Top &#94; 下一篇 Avocado-入门","tags":"自动化测试-Avocado","title":"Avocado User's Guide"},{"url":"http://king32783784.github.io/2016/09/01/bei-jing-zhe-die-hao-jing-fang/","text":"第一幕 清晨4:50，老刀穿过熙熙攘攘的步行街，去找彭蠡。 从垃圾站下班之后，老刀回家洗了个澡，换了衣服。白色衬衫和褐色裤子，这是他唯一一套体面衣服，衬衫袖口磨了边，他把袖子卷到胳膊肘。老刀四十八岁，没结婚，已经过了注意外表的年龄，又没人照顾起居，这一套衣服留着穿了很多年，每次穿一天，回家就脱了叠上。他在垃圾站上班，没必要穿得体面，偶尔参加谁家小孩的婚礼，才拿出来穿在身上。这一次他不想脏兮兮地见陌生人。他在垃圾站连续工作了五小时，很担心身上会有味道。 步行街上挤满了刚刚下班的人。拥挤的男人女人围着小摊子挑土特产，大声讨价还价。食客围着塑料桌子，埋头在酸辣粉的热气腾腾中，饿虎扑食一般，白色蒸汽遮住了脸。油炸的香味弥漫。货摊上的酸枣和核桃堆成山，腊肉在头顶摇摆。这个点是全天最热闹的时间，基本都收工了，忙碌了几个小时的人们都赶过来吃一顿饱饭，人声鼎沸。 老刀艰难地穿过人群。端盘子的伙计一边喊着让让一边推开挡道的人，开出一条路来，老刀跟在后面。 彭蠡家在小街深处。老刀上楼，彭蠡不在家。问邻居，邻居说他每天快到关门才回来，具体几点不清楚。 老刀有点担忧，看了看手表，清晨5点。 他回到楼门口等着。两旁狼吞虎咽的饥饿少年围绕着他。他认识其中两个，原来在彭蠡家见过一两次。少年每人面前摆着一盘炒面或炒粉，几个人分吃两个菜，盘子里一片狼藉，筷子扔在无望而锲而不舍地拨动，寻找辣椒丛中的肉星。老刀又下意识闻了闻小臂，不知道身上还有没有垃圾的腥味。周围的一切嘈杂而庸常，和每个清晨一样。 \"哎，你们知道那儿一盘回锅肉多少钱吗？\"那个叫小李的少年说。 \"靠，菜里有沙子。\"另外一个叫小丁的胖少年突然捂住嘴说，他的指甲里还带着黑泥， \"坑人啊。得找老板退钱！\" \"人家那儿一盘回锅肉，就三百四。\"小李说，\"三百四！一盘水煮牛肉四百二呢。\" \"什么玩意？这么贵。\"小丁捂着腮帮子咕哝道。 另外两个少年对谈话没兴趣，还在埋头吃面，小李低头看着他们，眼睛似乎穿过他们，看到了某个看不见的地方，目光里有热切。 老刀的肚子也感觉到饥饿。他迅速转开眼睛，可是来不及了，那种感觉迅速席卷了他，胃的空虚像是一个深渊，让他身体微微发颤。他有一个月不吃清晨这顿饭了。一顿饭差不多一百块，一个月三千块，攒上一年就够糖糖两个月的幼儿园开销了。 他向远处看，城市清理队的车辆已经缓缓开过来了。 他开始做准备，若彭蠡一时再不回来，他就要考虑自己行动了。虽然会带来不少困难，但时间不等人，总得走才行。身边卖大枣的女人高声叫卖，不时打断他的思绪，声音的洪亮刺得他头疼。步行街一端的小摊子开始收拾，人群像用棍子搅动的池塘里的鱼，倏一下散去。没人会在这时候和清理队较劲。小摊子收拾得比较慢，清理队的车耐心地移动。步行街通常只是步行街，但对清理队的车除外。谁若走得慢了，就被强行收拢起来。 这时彭蠡出现了。他剔着牙，敞着衬衫的扣子，不紧不慢地踱回来，不时打饱嗝。彭蠡六十多了，变得懒散不修边幅，两颊像沙皮狗一样耷拉着，让嘴角显得总是不满意地撇着。如果只看这幅模样，不知道他年轻时的样子，会以为他只是个胸无大志只知道吃喝的怂包。但从老刀很小的时候，他就听父亲讲过彭蠡的事。 老刀迎上前去。彭蠡看到他要打招呼，老刀却打断他：\"我没时间和你解释。我需要去第一空间，你告诉我怎么走。\" 彭蠡愣住了，已经有十年没人跟他提过第一空间的事，他的牙签捏在手里，不知不觉掰断了。他有片刻没回答，见老刀实在有点急了，才拽着他向楼里走。\"回我家说，\"彭蠡说，\"要走也从那儿走。\" 在他们身后，清理队已经缓缓开了过来，像秋风扫落叶一样将人们扫回家。\"回家啦，回家啦。转换马上开始了。\"车上有人吆喝着。 彭蠡带老刀上楼，进屋。他的单人小房子和一般公租屋无异，六平米房间，一个厕所，一个能做菜的角落，一张桌子一把椅子，胶囊床铺，胶囊下是抽拉式箱柜，可以放衣服物品。墙面上有水渍和鞋印，没做任何修饰，只是歪斜着贴了几个挂钩，挂着夹克和裤子。进屋后，彭蠡把墙上的衣服毛巾都取下来，塞到最靠边的抽屉里。转换的时候，什么都不能挂出来。老刀以前也住这样的单人公租房。一进屋，他就感到一股旧日的气息。 彭蠡直截了当地瞪着老刀：\"你不告诉我为什么，我就不告诉你怎么走。\" 已经5点半了，还有半个小时。 老刀简单讲了事情的始末。从他捡到纸条瓶子，到他偷偷躲入垃圾道，到他在第二空间接到的委托，再到他的行动。他没有时间描述太多，最好马上就走。 \"你躲在垃圾道里？去第二空间？\"彭蠡皱着眉，\"那你得等24小时啊。\" \"二十万块。\"老刀说，\"等一礼拜也值啊。\" \"你就这么缺钱花？\" 老刀沉默了一下。\"糖糖还有一年多该去幼儿园了。\"他说，\"我来不及了。\" 老刀去幼儿园咨询的时候，着实被吓到了。稍微好一点的幼儿园招生前两天，就有家长带着铺盖卷在幼儿园门口排队，两个家长轮着，一个吃喝拉撒，另一个坐在幼儿园门口等。就这么等上四十多个小时，还不一定能排进去。前面的名额早用钱买断了，只有最后剩下的寥寥几个名额分给苦熬排队的爹妈。这只是一般不错的幼儿园，更好一点的连排队都不行，从一开始就是钱买机会。老刀本来没什么奢望，可是自从糖糖一岁半之后，就特别喜欢音乐，每次在外面听见音乐，她就小脸放光，跟着扭动身子手舞足蹈。那个时候她特别好看。老刀对此毫无抵抗力，他就像被舞台上的灯光层层围绕着，只看到一片耀眼。无论付出什么代价，他都想送糖糖去一个能教音乐和跳舞的幼儿园。 彭蠡脱下外衣，一边洗脸，一边和老刀说话。说是洗脸，不过只是用水随便抹一抹。水马上就要停了，水流已经变得很小。彭蠡从墙上拽下一条脏兮兮的毛巾，随意蹭了蹭，又将毛巾塞进抽屉。他湿漉漉的头发显出油腻的光泽。 \"你真是作死，\"彭蠡说，\"她又不是你闺女，犯得着吗。\" \"别说这些了。快告我怎么走。\"老刀说。 彭蠡叹了口气：\"你可得知道，万一被抓着，可不只是罚款，得关上好几个月。\" \"你不是去过好多次吗？\" \"只有四次。第五次就被抓了。\" \"那也够了。我要是能去四次，抓一次也无所谓。\" 老刀要去第一空间送一样东西，送到了挣十万块，带来回信挣二十万。这不过是冒违规的大不韪，只要路径和方法对，被抓住的几率并不大，挣的却是实实在在的钞票。他不知道有什么理由拒绝。他知道彭蠡年轻的时候为了几笔风险钱，曾经偷偷进入第一空间好几次，贩卖私酒和烟。他知道这条路能走。 5:45。他必须马上走了。 彭蠡又叹口气，知道劝也没用。他已经上了年纪，对事懒散倦怠了，但他明白，自己在五十岁前也会和老刀一样。那时他不在乎坐牢之类的事。不过是熬几个月出来，挨两顿打，但挣的钱是实实在在的。只要抵死不说钱的下落，最后总能过去。秩序局的条子也不过就是例行公事。他把老刀带到窗口，向下指向一条被阴影覆盖的小路。 \"从我房子底下爬下去，顺着排水管，毡布底下有我原来安上去的脚蹬，身子贴得足够紧了就能避开摄像头。从那儿过去，沿着阴影爬到边上。你能摸着也能看见那道缝。沿着缝往北走。一定得往北。千万别错了。\" 彭蠡接着解释了爬过土地的诀窍。要借着升起的势头，从升高的一侧沿截面爬过五十米，到另一侧地面，爬上去，然后向东，那里会有一丛灌木，在土地合拢的时候可以抓住并隐藏自己。老刀没有听完，就已经将身子探出窗口，准备向下爬了。 彭蠡帮老刀爬出窗子，扶着他踩稳了窗下的踏脚。彭蠡突然停下来。\"说句不好听的，\"他说，\"我还是劝你最好别去。那边可不是什么好地儿，去了之后没别的，只能感觉自己的日子有多操蛋。没劲。\" 老刀的脚正在向下试探，身子还扒着窗台。\"没事。\"他说得有点费劲，\"我不去也知道自己的日子有多操蛋。\" \"好自为之吧。\"彭蠡最后说。 老刀顺着彭蠡指出的路径快速向下爬。脚蹬的位置非常舒服。他看到彭蠡在窗口的身影，点了根烟，非常大口地快速抽了几口，又掐了。彭蠡一度从窗口探出身子，似乎想说什么，但最终还是缩了回去。窗子关上了，发着幽幽的光。老刀知道，彭蠡会在转换前最后一分钟钻进胶囊，和整个城市数千万人一样，受胶囊定时释放出的气体催眠，陷入深深睡眠，身子随着世界颠倒来去，头脑却一无所知，一睡就是整整40个小时，到次日晚上再睁开眼睛。彭蠡已经老了，他终于和这个世界其他五千万人一样了。 老刀用自己最快的速度向下，一蹦一跳，在离地足够近的时候纵身一跃，匍匐在地上。彭蠡的房子在四层，离地不远。爬起身，沿高楼在湖边投下的阴影奔跑。他能看到草地上的裂隙，那是翻转的地方。还没跑到，就听到身后在压抑中轰鸣的隆隆和偶尔清脆的嘎啦声。老刀转过头，高楼拦腰截断，上半截正从天上倒下，缓慢却不容置疑地压迫过来。 老刀被震住了，怔怔看了好一会儿。他跑到缝隙，伏在地上。 转换开始了。这是24小时周期的分隔时刻。整个世界开始翻转。钢筋砖块合拢的声音连成一片，像出了故障的流水线。高楼收拢合并，折叠成立方体。霓虹灯、店铺招牌、阳台和附加结构都被吸收入墙体，贴成楼的肌肤。结构见缝插针，每一寸空间都被占满。 大地在升起。老刀观察着地面的走势，来到缝的边缘，又随着缝隙的升起不断向上爬。他手脚并用，从大理石铺就的地面边缘起始，沿着泥土的截面，抓住土里埋藏的金属断茬，最初是向下，用脚试探着退行，很快，随着整快土地的翻转，他被带到空中。 老刀想到前一天晚上城市的样子。 当时他从垃圾堆中抬起眼睛，警觉地听着门外的声音。周围发酵腐烂的垃圾散发出刺鼻的气息，带一股发腥的甜腻味。他倚在门前。铁门外的世界在苏醒。 当铁门掀开的缝隙透入第一道街灯的黄色光芒，他俯下身去，从缓缓扩大的缝隙中钻出。街上空无一人，高楼灯光逐层亮起，附加结构从楼两侧探出，向两旁一节一节伸展，门廊从楼体内延伸，房檐延轴旋转，缓缓落下，楼梯降落延伸到马迷途上。步行街的两侧，一个又一个黑色立方体从中间断裂，向两侧打开，露出其中货架的结构。立方体顶端伸出招牌，连成商铺的走廊，两侧的塑料棚向头顶延伸闭合。街道空旷得如同梦境。 霓虹灯亮了，商铺顶端闪烁的小灯打出新疆大枣、东北拉皮、上海烤麸和湖南腊肉。 整整一天，老刀头脑中都忘不了这一幕。他在这里生活了四十八年，还从来没有见过这一切。他的日子总是从胶囊起，至胶囊终，在脏兮兮的餐桌和被争吵萦绕的货摊之间穿行。这是他第一次看到世界纯粹的模样。 每个清晨，如果有人从远处观望——就像大货车司机在高速北京入口处等待时那样——他会看到整座城市的伸展与折叠。 清晨六点，司机们总会走下车，站在高速边上，揉着经过一夜潦草睡眠而昏沉的眼睛，打着哈欠，相互指点着望向远处的城市中央。高速截断在七环之外，所有的翻转都在六环内发生。不远不近的距离，就像遥望西山或是海上的一座孤岛。 晨光熹微中，一座城市折叠自身，向地面收拢。高楼像最卑微的仆人，弯下腰，让自己低声下气切断身体，头碰着脚，紧紧贴在一起，然后再次断裂弯腰，将头顶手臂扭曲弯折，插入空隙。高楼弯折之后重新组合，蜷缩成致密的巨大魔方，密密匝匝地聚合到一起，陷入沉睡。然后地面翻转，小块小块土地围绕其轴，一百八十度翻转到另一面，将另一面的建筑楼宇露出地表。楼宇由折叠中站立起身，在灰蓝色的天空中像苏醒的兽类。城市孤岛在橘黄色晨光中落位，展开，站定，腾起弥漫的灰色苍云。 司机们就在困倦与饥饿中欣赏这一幕无穷循环的城市戏剧。 第二幕 折叠城市分三层空间。大地的一面是第一空间，五百万人口，生存时间是从清晨六点到第二天清晨六点。空间休眠，大地翻转。翻转后的另一面是第二空间和第三空间。第二空间生活着两千五百万人口，从次日清晨六点到夜晚十点，第三空间生活着五千万人，从十点到清晨六点，然后回到第一空间。时间经过了精心规划和最优分配，小心翼翼隔离，五百万人享用二十四小时，七千五百万人享用另外二十四小时。 大地的两侧重量并不均衡，为了平衡这种不均，第一空间的土地更厚，土壤里埋藏配重物质。人口和建筑的失衡用土地来换。第一空间居民也因而认为自身的底蕴更厚。 老刀从小生活在第三空间。他知道自己的日子是什么样，不用彭蠡说他也知道。他是个垃圾工，做了二十八年垃圾工，在可预见的未来还将一直做下去。他还没找到可以独自生存的意义和最后的怀疑主义。他仍然在卑微生活的间隙占据一席。 老刀生在北京城，父亲就是垃圾工。据父亲说，他出生的时候父亲刚好找到这份工作，为此庆贺了整整三天。父亲本是建筑工，和数千万其他建筑工一样，从四方涌到北京寻工作，这座折叠城市就是父亲和其他人一起亲手建的。一个区一个区改造旧城市，像白蚁漫过木屋一样啃噬昔日的屋檐门槛，再把土地翻起，建筑全新的楼宇。他们埋头斧凿，用累累砖块将自己包围在中间，抬起头来也看不见天空，沙尘遮挡视线，他们不知晓自己建起的是怎样的恢弘。直到建成的日子高楼如活人一般站立而起，他们才像惊呆了一样四处奔逃，仿佛自己生下了一个怪胎。奔逃之后，镇静下来，又意识到未来生存在这样的城市会是怎样一种殊荣，便继续辛苦摩擦手脚，低眉顺眼勤恳，寻找各种存留下来的机会。据说城市建成的时候，有八千万想要寻找工作留下来的建筑工，最后能留下来的，不过两千万。 垃圾站的工作能找到也不容易，虽然只是垃圾分类处理，但还是层层筛选，要有力气有技巧，能分辨能整理，不怕辛苦不怕恶臭，不对环境挑三拣四。老刀的父亲靠强健的意志在汹涌的人流中抓住机会的细草，待人潮退去，留在干涸的沙滩上，抓住工作机会，低头俯身，艰难浸在人海和垃圾混合的酸朽气味中，一干就是二十年。他既是这座城市的建造者，也是城市的居住者和分解者。 老刀出生时，折叠城市才建好两年，他从来没去过其他地方，也没想过要去其他地方。他上了小学、中学。考了三年大学，没考上，最后还是做了垃圾工。他每天上五个小时班，从夜晚十一点到清晨四点，在垃圾站和数万同事一起，快速而机械地用双手处理废物垃圾，将第一空间和第二空间传来的生活碎屑转化为可利用的分类的材质，再丢入再处理的熔炉。他每天面对垃圾传送带上如溪水涌出的残渣碎片，从塑料碗里抠去吃剩的菜叶，将破碎酒瓶拎出，把带血的卫生巾后面未受污染的一层薄膜撕下，丢入可回收的带着绿色条纹的圆筒。他们就这么干着，以速度换生命，以数量换取薄如蝉翼的仅有的奖金。 第三空间有两千万垃圾工，他们是夜晚的主人。另三千万人靠贩卖衣服食物燃料和保险过活，但绝大多数人心知肚明，垃圾工才是第三空间繁荣的支柱。每每在繁花似锦的霓虹灯下漫步，老刀就觉得头顶都是食物残渣构成的彩虹。这种感觉他没法和人交流，年轻一代不喜欢做垃圾工，他们千方百计在舞厅里表现自己，希望能找到一个打碟或伴舞的工作。在服装店做一个店员也是好的选择，手指只拂过轻巧衣物，不必在泛着酸味的腐烂物中寻找塑料和金属。少年们已经不那么恐惧生存，他们更在意外表。 老刀并不嫌弃自己的工作，但他去第二空间的时候，非常害怕被人嫌弃。 那是前一天清晨的事。他捏着小纸条，偷偷从垃圾道里爬出，按地址找到写纸条的人。第二空间和第三空间的距离没那么远，它们都在大地的同一面，只是不同时间出没。转换时，一个空间高楼折起，收回地面，另一个空间高楼从地面中节节升高，踩着前一个空间的楼顶作为地面。唯一的差别是楼的密度。他在垃圾道里躲了一昼夜才等到空间敞开。他第一次到第二空间，并不紧张，唯一担心的是身上腐坏的气味。 所幸秦天是宽容大度的人。也许他早已想到自己将招来什么样的人，当小纸条放入瓶中的时候，他就知道自己将面对的是谁。 秦天很和气，一眼就明白老刀前来的目的，将他拉入房中，给他热水洗澡，还给他一件浴袍换上。\"我只有依靠你了。\"秦天说。 秦天是研究生，住学生公寓。一个公寓四个房间，四个人一人一间，一个厨房两个厕所。老刀从来没在这么大的厕所洗过澡。他很想多洗一会儿，将身上气味好好冲一冲，但又担心将澡盆弄脏，不敢用力搓动。墙上喷出泡沫的时候他吓了一跳，热蒸汽烘干也让他不适应。洗完澡，他拿起秦天递过来的浴袍，犹豫了很久才穿上。他把自己的衣服洗了，又洗了厕所盆里随意扔着的几件衣服。生意是生意，他不想欠人情。 秦天要送礼物给他相好的女孩子。他们在工作中认识，当时秦天有机会去第一空间实习，联合国经济司，她也在那边实习。只可惜只有一个月，回来就没法再去了。他说她生在第一空间，家教严格，父亲不让她交往第二空间的男孩，所以不敢用官方通道寄给她。他对未来充满乐观，等他毕业就去申请联合国新青年项目，如果能入选，就也能去第一空间工作。他现在研一，还有一年毕业。他心急如焚，想她想得发疯。他给她做了一个项链坠，能发光的材质，透明的，玫瑰花造型，作为他的求婚信物。 \"我当时是在一个专题研讨会，就是上回讨论联合国国债那个会，你应该听说过吧？就是那个……anyway，我当时一看，啊……立刻跑过去跟她说话，她给嘉宾引导座位，我也不知道应该说点什么，就在她身后走过来又走过去。最后我假装要找同传，让她带我去找。她特温柔，说话细声细气的。我压根就没追过姑娘，特别紧张，……后来我们俩好了之后有一次说起这件事……你笑什么？……对，我们是好了。……还没到那种关系，就是……不过我亲过她了。\"秦天也笑了，有点不好意思，\"是真的。你不信吗？是。连我自己也不信。你说她会喜欢我吗？\" \"我不知道啊。\"老刀说，\"我又没见过她。\" 这时，秦天同屋的一个男生凑过来，笑道：\"大叔，您这么认真干吗？这家伙哪是问你，他就是想听人说‘你这么帅，她当然会喜欢你'。\" \"她很漂亮吧？\" \"我跟你说也不怕你笑话。\"秦天在屋里走来走去，\"你见到她就知道什么叫清雅绝伦。\" 秦天突然顿住了，不说了，陷入回忆。他想起依言的嘴，他最喜欢的就是她的嘴，那么小小的，莹润的，下嘴唇饱满，带着天然的粉红色，让人看着看着就忍不住想咬一口。她的脖子也让他动心，虽然有时瘦得露出筋，但线条是纤直而好看的，皮肤又白又细致，从脖子一直延伸到衬衫里，让人的视线忍不住停在衬衫的第二个扣子那里。他第一次轻吻她一下，她躲开，他又吻，最后她退无可退，就把眼睛闭上了，像任人宰割的囚犯，引他一阵怜惜。她的唇很软，他用手反复感受她腰和臀部的曲线。从那天开始，他就居住在思念中。她是他夜晚的梦境，是他抖动自己时看到的光芒。 秦天的同学叫张显，和老刀开始聊天，聊得很欢。 张显问老刀第三空间的生活如何，又说他自己也想去第三空间住一段。他听人说，如果将来想往上爬，有过第三空间的管理经验是很有用的。现在几个当红的人物，当初都是先到第三空间做管理者，然后才升到第一空间，若是停留在第二空间，就什么前途都没有，就算当个行政干部，一辈子级别也高不了。他将来想要进政府，已经想好了路。不过他说他现在想先挣两年钱再说，去银行来钱快。他见老刀的反应很迟钝，几乎不置可否，以为老刀厌恶这条路，就忙不迭地又加了几句解释。 \"现在政府太混沌了，做事太慢，僵化，体系也改不动。\"他说，\"等我将来有了机会，我就推快速工作作风改革。干得不行就滚蛋。\"他看老刀还是没说话，又说，\"选拔也要放开。也向第三空间放开。\" 老刀没回答。他其实不是厌恶，只是不大相信。 张显一边跟老刀聊天，一边对着镜子打领带，喷发胶。他已经穿好了衬衫，浅蓝色条纹，亮蓝色领带。喷发胶的时候一边闭着眼睛皱着眉毛避开喷雾，一边吹口哨。 张显夹着包走了，去银行实习上班。秦天说着话也要走。他还有课，要上到下午四点。临走前，他当着老刀的面把五万块定金从网上转到老刀卡里，说好了剩下的钱等他送到再付。老刀问他这笔钱是不是攒了很久，看他是学生，如果拮据，少要一点也可以。秦天说没事，他现在实习，给金融咨询公司打工，一个月十万块差不多。这也就是两个月工资，还出得起。老刀一个月一万块标准工资，他看到差距，但他没有说。秦天要老刀务必带回信回来，老刀说试试。秦天给老刀指了吃喝的所在，叫他安心在房间里等转换。 老刀从窗口看向街道。他很不适应窗外的日光。太阳居然是淡白色，不是黄色。日光下的街道也显得宽阔，老刀不知道是不是错觉，这街道看上去有第三空间的两倍宽。楼并不高，比第三空间矮很多。路上的人很多，匆匆忙忙都在急着赶路，不时有人小跑着想穿过人群，前面的人就也加起速，穿过路口的时候，所有人都像是小跑着。大多数人穿得整齐，男孩子穿西装，女孩子穿衬衫和短裙，脖子上围巾低垂，手里拎着线条硬朗的小包，看上去精干。街上汽车很多，在路口等待的时候，不时有看车的人从车窗伸出头，焦急地向前张望。老刀很少见到这么多车，他平时习惯了磁悬浮，挤满人的车厢从身边加速，呼一阵风。 中午十二点的时候，走廊里一阵声响。老刀从门上的小窗向外看。楼道地面化为传送带开始滚动，将各屋门口的垃圾袋推入尽头的垃圾道。楼道里腾起雾，化为密实的肥皂泡沫，飘飘忽忽地沉降，然后是一阵水，水过了又一阵热蒸汽。 背后突然有声音，吓了老刀一跳。他转过身，发现公寓里还有一个男生，刚从自己房间里出来。男生面无表情，看到老刀也没有打招呼。他走到阳台旁边一台机器旁边，点了点，机器里传出咔咔刷刷轰轰嚓的声音，一阵香味飘来，男生端出一盘菜又回了房间。从他半开的门缝看过去，男孩坐在地上的被子和袜子中间，瞪着空无一物的墙，一边吃一边咯咯地笑。他不时用手推一推眼镜。吃完把盘子放在脚边，站起身，同样对着空墙做击打动作，费力气顶住某个透明的影子，偶尔来一个背摔，气喘吁吁。 老刀对第二空间最后的记忆是街上撤退时的优雅。从公寓楼的窗口望下去，一切都带着令人羡慕的秩序感。九点十五分开始，街上一间间卖衣服的小店开始关灯，聚餐之后的团体面色红润，相互告别。年轻男女在出租车外亲吻。然后所有人回楼，世界蛰伏。 夜晚十点到了。他回到他的世界，回去上班。 第三幕 第一和第三空间之间没有连通的垃圾道，第一空间的垃圾经过一道铁闸，运到第三空间之后，铁闸迅速合拢。老刀不喜欢从地表翻越，但他没有办法。 他在呼啸的风中爬过翻转的土地，抓住每一寸零落的金属残渣，找到身体和心理平衡，最后匍匐在离他最遥远的一重世界的土地上。他被整个攀爬弄得头晕脑胀，胃口也不舒服。他忍住呕吐，在地上趴了一会儿。 当他爬起身的时候，天亮了。 老刀从来没有见过这样的景象。太阳缓缓升起，天边是深远而纯净的蓝，蓝色下沿是橙黄色，有斜向上的条状薄云。太阳被一处屋檐遮住，屋檐显得异常黑，屋檐背后明亮夺目。太阳升起时，天的蓝色变浅了，但是更宁静透彻。老刀站起身，向太阳的方向奔跑。他想要抓住那道褪去的金色。蓝天中能看见树枝的剪影。他的心狂跳不已。他从来不知道太阳升起竟然如此动人。 他跑了一段路，停下来，冷静了。他站在街道中央。路的两旁是高大树木和大片草坪。他环视四周，目力所及，远远近近都没有一座高楼。他迷惑了，不确定自己是不是真的到了第一空间。他能看见两排粗壮的银杏。 他又退回几步，看着自己跑来的方向。街边有一个路牌。他打开手机里存的地图，虽然没有第一空间动态图权限，但有事先下载的静态图。他找到了自己的位置和他要去的地方。他刚从一座巨大的园子里奔出来，翻转的地方就在园子的湖边。 老刀在万籁俱寂的街上跑了一公里，很容易找到了要找的小区。他躲在一丛灌木背后，远远地望着那座漂亮的房子。 8:30，依言出来了。 她像秦天描述的一样清秀，只是没有那么漂亮。老刀早就能想到这点。不会有任何女孩长得像秦天描述的那么漂亮。他明白了为什么秦天着重讲她的嘴。她的眼睛和鼻子很普通，只是比较秀气，没什么好讲的。她的身材还不错，骨架比较小，虽然高，但看上去很纤细。穿了一条乳白色连衣裙，有飘逸的裙摆，腰带上有珍珠，黑色高跟皮鞋。 老刀悄悄走上前去。为了不吓到她，他特意从正面走过去，离得远远的就鞠了一躬。 她站住了，惊讶地看着他。 老刀走近了，说明来意，将包裹着情书和项链坠的信封从怀里掏出来。 她的脸上滑过一丝惊慌，小声说：\"你先走，我现在不能和你说。\" \"呃……我其实没什么要说的，\"老刀说，\"我只是送信的。\" 她不接，双手紧紧地搅握着，只是说：\"我现在不能收。你先走。我是说真的，拜托了，你先走吧好吗？\"她说着低头，从包里掏出一张名片，\"中午到这里找我。\" 老刀低头看看，名片上写着一个银行的名字。 \"十二点。到地下超市等我。\"她又说。 老刀看得出她过分的不安，于是点头收起名片，回到隐身的灌木丛后，远远地观望着。很快，又有一个男人从房子里出来，到她身边。男人看上去和老刀年龄相仿，或者年轻两岁，穿着一套很合身的深灰色西装，身材高而宽阔，虽没有突出的肚子，但是觉得整个身体很厚。男人的脸无甚特色，戴眼镜，圆脸，头发向一侧梳得整齐。 男人搂住依言的腰，吻了她嘴唇一下。依言想躲，但没躲开，颤抖了一下，手挡在身前显得非常勉强。 老刀开始明白了。 一辆小车开到房子门前。单人双轮小车，黑色，敞篷，就像电视里看到的古代的马车或黄包车，只是没有马拉，也没有车夫。小车停下，歪向前，依言踏上去，坐下，拢住裙子，让裙摆均匀覆盖膝盖，散到地上。小车缓缓开动了，就像有一匹看不见的马拉着一样。依言坐在车里，小车缓慢而波澜不惊。等依言离开，一辆无人驾驶的汽车开过来，男人上了车。 老刀在原地来回踱着步子。他觉得有些东西非常憋闷，但又说不出来。他站在阳光里，闭上眼睛，清晨蓝天下清凛干净的空气沁入他的肺。空气给他一种冷静的安慰。 片刻之后，他才上路。依言给的地址在她家东面，3公里多一点。街上人很少。8车道的宽阔道路上行驶着零星车辆，快速经过，让人看不清车的细节。偶尔有华服的女人乘坐着双轮小车缓缓飘过他身旁，沿步行街，像一场时装秀，端坐着姿态优美。没有人注意到老刀。绿树摇曳，树叶下的林荫路留下长裙的气味。 依言的办公地在西单某处。这里完全没有高楼，只是围绕着一座花园有零星分布的小楼，楼与楼之间的联系气若游丝，几乎看不出它们是一体。走到地下，才看到相连的通道。 老刀找到超市。时间还早。一进入超市，就有一辆小车跟上他，每次他停留在货架旁，小车上的屏幕上就显示出这件货物的介绍、评分和同类货物质量比。超市里的东西都写着他看不懂的文字。食物包装精致，小块糕点和水果用诱人的方式摆在盘里，等人自取。他没有触碰任何东西。不过整个超市似乎并没有警卫或店员。 还不到十二点，顾客就多了起来。有穿西装的男人走进超市，取三明治，在门口刷一下就匆匆离开。还是没有人特别注意老刀。他在门口不起眼的位置等着。 依言出现了。老刀迎上前去，依言看了看左右，没说话，带他去了隔壁的一家小餐厅。两个穿格子裙子的小机器人迎上来，接过依言手里的小包，又带他们到位子上，递上菜单。依言在菜单上按了几下，小机器人转身，轮子平稳地滑回了后厨。 两个人面对面坐了片刻，老刀又掏出信封。 依言却没有接：\"……你能听我解释一下吗？\" 老刀把信封推到她面前：\"你先收下这个。\" 依言推回给他。 \"你先听我解释一下行吗？\"依言又说。 \"你没必要跟我解释，\"老刀说，\"信不是我写的。我只是送信而已。\" \"可是你回去要告诉说的。\"依言低了低头。小机器人送上了两个小盘子，一人一份，是某种红色的生鱼片，薄薄两片，摆成花瓣的形状。依言没有动筷子，老刀也没有。信封被小盘子隔在中央，两个人谁也没再推。\"我不是背叛他。去年他来的时候我就已经订婚了。我也不是故意瞒他或欺骗他，或者说……是的，我骗了他，但那是他自己猜的。他见到吴闻来接我，就问是不是我爸爸。我……我没法回答他。你知道，那太尴尬了。我……\" 依言说不下去了。 老刀等了一会儿说：\"我不想追问你们之前的事。你收下信就行了。\" 依言低头好一会儿又抬起来：\"你回去以后，能不能替我瞒着他？\" \"为什么？\" \"我不想让他以为我是坏女人耍他。其实我心里是喜欢他的。我也很矛盾。\" \"这些和我没关系。\" \"求你了……我是真的喜欢他。\" 老刀沉默了一会儿，他需要做一个决定。 \"可是你还是结婚了？\"他问她。 \"吴闻对我很好。好几年了。\"依言说，\"他认识我爸妈。我们订婚也很久了。况且……我比秦天大三岁，我怕他不能接受。秦天以为我是实习生。这点也是我不好，我没说实话。最开始只是随口说的，到后来就没法改口了。我真的没想到他是认真的。\" 依言慢慢透露了她的信息。她是这个银行的总裁助理，已经工作两年多了，只是被派往联合国参加培训，赶上那次会议，就帮忙参与了组织。她不需要上班，老公挣的钱足够多，可她不希望总是一个人呆在家里，才出来上班，每天只工作半天，拿半薪。其余的时间自己安排，可以学一些东西。她喜欢学新东西，喜欢认识新人，也喜欢联合国培训的那几个月。她说像她这样的太太很多，半职工作也很多。中午她下了班，下午会有另一个太太去做助理。她说虽然对秦天没有说实话，可是她的心是真诚的。 \"所以，\"她给老刀夹了新上来的热菜，\"你能不能暂时不告诉他？等我……有机会亲自向他解释可以吗？\" 老刀没有动筷子。他很饿，可是他觉得这时不能吃。 \"可是这等于说我也得撒谎。\"老刀说。 依言回身将小包打开，将钱包取出来，掏出五张一万块的纸币推给老刀。\"一点心意，你收下。\" 老刀愣住了。他从来没见过一万块钱的纸钞。他生活里从来不需要花这么大的面额。他不自觉地站起身，感到恼怒。依言推出钱的样子就像是早预料到他会讹诈，这让他受不了。他觉得自己如果拿了，就是接受贿赂，将秦天出卖。虽然他和秦天并没有任何结盟关系，但他觉得自己在背叛他。老刀很希望自己这个时候能将钱扔在地上，转身离去，可是他做不到这一步。他又看了几眼那几张钱，五张薄薄的纸散开摊在桌子上，像一把破扇子。他能感觉它们在他体内产生的力量。它们是淡蓝色，和一千块的褐色与一百块的红色都不一样，显得更加幽深遥远，像是一种挑逗。他几次想再看一眼就离开，可是一直没做到。 她仍然匆匆翻动小包，前前后后都翻了，最后从一个内袋里又拿出五万块，和刚才的钱摆在一起。\"我只带了这么多，你都收下吧。\"她说，\"你帮帮我。其实我之所以不想告诉他，也是不确定以后会怎么样。也许我有一天真的会有勇气和他在一起呢。\" 老刀看看那十张纸币，又看看她。他觉得她并不相信自己的话，她的声音充满迟疑，出卖了她的心。她只是将一切都推到将来，以消解此时此刻的难堪。她很可能不会和秦天私奔，可是也不想让他讨厌她，于是留着可能性，让自己好过一点。老刀能看出她骗她自己，可是他也想骗自己。他对自己说，他对秦天没有任何义务，秦天只是委托他送信，他把信送到了，现在这笔钱是另一项委托，保守秘密的委托。他又对自己说，也许她和秦天将来真的能在一起也说不定，那样就是成人之美。他还说，想想糖糖，为什么去管别人的事而不管糖糖呢。他似乎安定了一些，手指不知不觉触到了钱的边缘。 \"这钱……太多了。\"他给自己一个台阶下，\"我不能拿这么多。\" \"拿着吧，没事。\"她把钱塞到他手里，\"我一个礼拜就挣出来了。没事的。\" \"……那我怎么跟他说？\" \"你就说我现在不能和他在一起，但是我真的喜欢他。我给你写个字条，你帮我带给他。\"依言从包里找出一个画着孔雀绣着金边的小本子，轻盈地撕下一张纸，低头写字。她的字看上去像倾斜的芦苇。 最后，老刀离开餐厅的时候，又回头看了一眼。依言的眼睛注视着墙上的一幅画。她的姿态静默优雅，看上去就像永远都不会离开这里似的。 他用手捏了捏裤子口袋里的纸币。他讨厌自己，可是他想把纸币抓牢。 第四幕 老刀从西单出来，依原路返回。重新走早上的路，他觉得倦意丛生，一步也跑不动了。宽阔的步行街两侧是一排垂柳和一排梧桐，正是晚春，都是鲜亮的绿色。他让暖意丛生的午后阳光照亮僵硬的面孔，也照亮空乏的心底。 他回到早上离开的园子，赫然发现园子里来往的人很多。园子外面两排银杏树庄严茂盛。园门口有黑色小汽车驶入。园里的人多半穿着材质顺滑、剪裁合体的西装，也有穿黑色中式正装的，看上去都有一番眼高于顶的气质。也有外国人。他们有的正在和身边人讨论什么，有的远远地相互打招呼，笑着携手向前走。 老刀犹豫了一下要到哪里去，街上人很少，他一个人站着极为显眼，去公共场所又容易被注意，他很想回到园子里，早一点找到转换地，到一个没人的角落睡上一觉。他太困了，又不敢在街上睡。他见出入园子的车辆并无停滞，就也尝试着向里走。直到走到园门边上，他才发现有两个小机器人左右逡巡。其他人和车走过都毫无问题，到了老刀这里，小机器人忽然发出嘀嘀的叫声，转着轮子向他驶来。声音在宁静的午后显得刺耳。园里人的目光汇集到他身上。他慌了，不知道是不是自己的衬衫太寒酸。他尝试着低声对小机器人说话，说他的西装落在里面了，可是小机器人只是嘀嘀嗒嗒地叫着，头顶红灯闪烁，什么都不听。园里的人们停下脚步看着他，像是看到小偷或奇怪的人。很快，从最近的建筑中走出三个男人，步履匆匆地向他们跑过来。老刀紧张极了，他想退出去，已经太晚了。 \"出什么事了？\"领头的人高声询问着。 老刀想不出解释的话，手下意识地搓着裤子。 一个三十几岁的男人走在最前面，一到跟前就用一个纽扣一样的小银盘上上下下地晃，手的轨迹围绕着老刀。他用怀疑的眼神打量他，像用罐头刀试图撬开他的外壳。 \"没记录。\"男人将手中的小银盘向身后更年长的男人示意，\"带回去吧？\" 老刀突然向后跑，向园外跑。 可没等他跑出去，两个小机器人悄无声息挡在他面前，扣住他的小腿。它们的手臂是箍，轻轻一扣就合上。他一下子踉跄了，差点摔倒又摔不倒，手臂在空中无力的乱划。 \"跑什么？\"年轻男人更严厉地走到他面前，瞪着他的眼睛。 \"我……\"老刀头脑嗡嗡响。 两个小机器人将他的两条小腿扣紧，抬起，放在它们轮子边上的平台上，然后异常同步地向最近的房子驶去，平稳迅速，保持并肩，从远处看上去，或许会以为老刀脚踩风火轮。老刀毫无办法，除了心里暗喊一声糟糕，简直没有别的话说。他懊恼自己如此大意，人这么多的地方，怎么可能没有安全保障。他责怪自己是困倦得昏了头，竟然在这样大的安全关节上犯如此低级的错误。这下一切完蛋了，他想，钱都没了，还要坐牢。 小机器人从小路绕向建筑后门，在后门的门廊里停下来。三个男人跟了上来。年轻男人和年长男人似乎就老刀的处理问题起了争执，但他们的声音很低，老刀听不见。片刻之后，年长男人走到他身边，将小机器人解锁，然后拉着他的大臂走上二楼。 老刀叹了一口气，横下一条心，觉得事到如今，只好认命。 年长者带他进入一个房间。他发现这是一个旅馆房间，非常大，比秦天的公寓客厅还大，似乎有自己租的房子两倍大。房间的色调是暗沉的金褐色，一张极宽大的双人床摆在中央。床头背后的墙面上是颜色过渡的抽象图案，落地窗，白色半透明纱帘，窗前是一个小圆桌和两张沙发。他心里惴惴。不知道年长者的身份和态度。 \"坐吧，坐吧。\"年长者拍拍他肩膀，笑笑，\"没事了。\" 老刀狐疑地看着他。 \"你是第三空间来的吧？\"年长者把他拉到沙发边上，伸手示意。 \"您怎么知道？\"老刀无法撒谎。 \"从你裤子上。\"年长者用手指指他的裤腰，\"你那商标还没剪呢。这牌子只有第三空间有卖的。我小时候我妈就喜欢给我爸买这牌子。\" \"您是……\" \"别您您的，叫你吧。我估摸着我也比你大不了几岁。你今年多大？我五十二。……你看看，就比你大四岁。\"他顿了一下，又说，\"我叫葛大平，你叫我老葛吧。\" 老刀放松了些。老葛把西装脱了，活动了一下膀子，从墙壁里接了一杯热水，递给老刀。他长长的脸，眼角眉梢和两颊都有些下坠，戴一副眼镜，也向下耷拉着，头发有点自来卷，蓬松地堆在头顶，说起话来眉毛一跳一跳，很有喜剧效果。他自己泡了点茶，问老刀要不要，老刀摇摇头。 \"我原来也是第三空间的。咱也算半个老乡吧。\"老葛说，\"所以不用太拘束。我还是能管点事儿，不会把你送出去的。\" 老刀长长地出了口气，心里感叹万幸。他于是把自己到第二、第一空间的始末讲了一遍，略去依言感情的细节，只说送到了信，就等着回去。 老葛于是也不见外，把他自己的情况讲了。他从小也在第三空间长大，父母都给人送货。十五岁的时候考上了军校，后来一直当兵，文化兵，研究雷达，能吃苦，技术又做得不错，赶上机遇又好，居然升到了雷达部门主管，大校军衔。家里没背景不可能再升，就申请转业，到了第一空间一个支持性部门，专给政府企业做后勤保障，组织会议出行，安排各种场面。虽然是蓝领的活儿，但因为涉及的都是政要，又要协调管理，就一直住在第一空间。这种人也不少，厨师、大夫、秘书、管家，都算是高级蓝领了。他们这个机构安排过很多重大场合，老葛现在是主任。老刀知道，老葛说的谦虚，说是蓝领，其实能在第一空间做事的都是牛人，即使厨师也不简单，更何况他从第三空间上来，能管雷达。 \"你在这儿睡一会儿。待会儿晚上我带你吃饭去。\"老葛说。 老刀受宠若惊，不大相信自己的好运。他心里还有担心，但是白色的床单和错落堆积的枕头显出召唤气息，他的腿立刻发软了，倒头昏昏沉沉睡了几个小时。 醒来的时候天色暗了，老葛正对着镜子捋头发。他向老刀指了指沙发上的一套西装制服，让他换上，又给他胸口别上一个微微闪着红光的小徽章，身份认证。 下楼来，老刀发现原来这里有这么多人。似乎刚刚散会，在大厅里聚集三三两两说话。大厅一侧是会场，门还开着，门看上去很厚，包着红褐色皮子；另一侧是一个一个铺着白色桌布的高脚桌，桌布在桌面下用金色缎带打了蝴蝶结，桌中央的小花瓶插着一只百合，花瓶旁边摆着饼干和干果，一旁的长桌上则有红酒和咖啡供应。聊天的人们在高脚桌之间穿梭，小机器人头顶托盘，收拾喝光的酒杯。 老刀尽量镇定地跟着老葛。走到会场内，他忽然看到一面巨大的展示牌，上面写着： 折叠城市五十年。 \"这是……什么？\"他问老葛。 \"哦，庆典啊。\"老葛正在监督场内布置，\"小赵，你来一下，你去把桌签再核对一遍。机器人有时候还是不如人靠谱，它们认死理儿。\" 老刀看到，会场里现在是晚宴的布置，每张大圆桌上都摆着鲜艳的花朵。 他有一种恍惚的感觉，站在角落里，看着会场中央巨大的吊灯，像是被某种光芒四射的现实笼罩，却只存在在它的边缘。舞台中央是演讲的高台，背后的布景流动播映着北京城的画面。大概是航拍，拍到了全城的风景，清晨和日暮的光影，紫红色暗蓝色天空，云层快速流转，月亮从角落上升起，太阳在屋檐上沉落。大气中正的布局，沿中轴线对称的城市设计，延伸到六环的青砖院落和大面积绿地花园。中式风格的剧院，日本式美术馆，极简主义风格的音乐厅建筑群。然后是城市的全景，真正意义上的全景，包含转换的整个城市双面镜头：大地翻转，另一面城市，边角锐利的写字楼，朝气蓬勃的上班族；夜晚的霓虹，白昼一样的天空，高耸入云的公租房，影院和舞厅的娱乐。 只是没有老刀上班的地方。 他仔细地盯着屏幕，不知道其中会不会展示建城时的历史。他希望能看见父亲的时代。小时候父亲总是用手指着窗外的楼，说\"当时我们\"。狭小的房间正中央挂着陈旧的照片，照片里的父亲重复着垒砖的动作，一遍一遍无穷无尽。他那时每天都要看见那照片很多遍，几乎已经腻烦了，可是这时他希望影像中出现哪怕一小段垒砖的镜头。 他沉浸在自己的恍惚中。这也是他第一次看到转换的全景。他几乎没注意到自己是怎么坐下的，也没注意到周围人的落座，台上人讲话的前几分钟，他并没有注意听。 \"……有利于服务业的发展，服务业依赖于人口规模和密度。我们现在的城市服务业已经占到GDP85%以上，符合世界第一流都市的普遍特征。另外最重要的就是绿色经济和循环经济。\"这句话抓住了老刀的注意力，循环经济和绿色经济是他们工作站的口号，写得比人还大贴在墙上。他望向台上的演讲人，是个白发老人，但是精神显得异常饱满，\"……通过垃圾的完全分类处理，我们提前实现了本世纪节能减排的目标，减少污染，也发展出成体系成规模的循环经济，每年废旧电子产品中回收的贵金属已经完全投入再生产，塑料的回收率也已达到80%以上。回收直接与再加工工厂相连……\" 老刀有远亲在再加工工厂工作，在科技园区，远离城市，只有工厂和工厂和工厂。据说那边的工厂都差不多，机器自动作业，工人很少，少量工人晚上聚集着，就像荒野部落。 他仍然恍惚着。演讲结束之后，热烈的掌声响起，才将他从自己的纷乱念头中拉出来，他也跟着鼓了掌，虽然不知道为什么。他看到演讲人从舞台上走下来，回到主桌上正中间的座位。所有人的目光都跟着他。 忽然老刀看到了吴闻。 吴闻坐在主桌旁边一桌，见演讲人回来就起身去敬酒，然后似乎有什么话要问演讲人。演讲人又站起身，跟吴闻一起到大厅里。老刀不自觉地站起来，心里充满好奇，也跟着他们。老葛不知道到哪里去了，周围开始上菜。 老刀到了大厅，远远地观望，对话只能听见片段。 \"……批这个有很多好处。\"吴闻说，\"是，我看过他们的设备了……自动化处理垃圾，用溶液消解，大规模提取材质……清洁，成本也低……您能不能考虑一下？\" 吴闻的声音不高，但老刀清楚地听见\"处理垃圾\"的字眼，不由自主凑上前去。 白发老人的表情相当复杂，他等吴闻说完，过了一会儿才问：\"你确定溶液无污染？\" 吴闻有点犹豫：\"现在还是有一点……不过很快就能减低到最低。\" 老刀离得很近了。 白发老人摇了摇头，眼睛盯着吴闻：\"事情哪是那么简单的，你这个项目要是上马了，大规模一改造，又不需要工人，现在那些劳动力怎么办，上千万垃圾工失业怎么办？\" 白发老人说完转过身，又返回会场。吴闻呆愣愣地站在原地。一个从始至终跟着老人的秘书模样的人走到吴闻身旁，同情地说：\"您回去好好吃饭吧。别想了。其实您应该明白这道理，就业的事是顶天的事。您以为这种技术以前就没人做吗？\" 老刀能听出这是与他有关的事，但他摸不准怎样是好的。吴闻的脸显出一种迷惑、懊恼而又顺从的神情，老刀忽然觉得，他也有软弱的地方。 这时，白发老人的秘书忽然注意到老刀。 \"你是新来的？\"他突然问。 \"啊……嗯。\"老刀吓了一跳。 \"叫什么名字？我怎么不知道最近进人了。\" 老刀有些慌，心砰砰跳，他不知道该说些什么。他指了指胸口上别着的工作人员徽章，仿佛期望那上面有个名字浮现出来。但徽章上什么都没有。他的手心涌出汗。秘书看着他，眼中的怀疑更甚了。他随手拉着一个会务人员，那人说不认识老刀。 秘书的脸铁青着，一只手抓住老刀的手臂，另一只手拨了通讯器。 老刀的心提到嗓子眼，就在那一刹那，他看到了老葛的身影。 老葛一边匆匆跑过来，一边按下通讯器，笑着和秘书打招呼，点头弯腰，向秘书解释说这是临时从其他单位借调过来的同事，开会人手不够，临时帮忙的。秘书见老葛知情，也就不再追究，返回会场。老葛将老刀又带回自己的房间，免得再被人撞见查检。深究起来没有身份认证，老葛也做不得主。 \"没有吃席的命啊。\"老葛笑道，\"你等着吧，待会儿我给你弄点吃的回来。\" 老刀躺在床上，又迷迷糊糊睡了。他反复想着吴闻和白发老人说的话，自动垃圾处理，这是什么样的呢，如果真的这样，是好还是不好呢。 再次醒来时，老刀闻到一碟子香味，老葛已经在小圆桌上摆了几碟子菜，还正在从墙上的烤箱中把剩下一个菜端出来。老葛又拿来半瓶白酒和两个玻璃杯，倒上。 \"有一桌就坐了俩人，我把没怎么动过的菜弄了点回来，你凑合吃，别嫌弃就行。他们吃了一会儿就走了。\"老葛说。 \"哪儿能嫌弃呢。\"老刀说，\"有口吃的就感激不尽了。这么好的菜。这些菜很贵吧？\" \"这儿的菜不对外，所以都不标价。我也不知道多少钱。\"老葛已经开动了筷子，\"也就一般吧。估计一两万之间，个别贵一点可能三四万。就那么回事。\" 老刀吃了两口就真的觉得饿了。他有抗饥饿的办法，忍上一天不吃东西也可以，身体会有些颤抖发飘，但精神不受影响。直到这时，他才发觉自己的饥饿。他只想快点咀嚼，牙齿的速度赶不上胃口空虚的速度。吃得急了，就喝一口。这白酒很香，不辣。老葛慢悠悠的，微笑着看着他。 \"对了，\"老刀吃得半饱时，想起刚才的事，\"今天那个演讲人是谁？我看着很面熟。\" \"也总上电视嘛。\"老葛说，\"我们的顶头上司。很厉害的老头儿。他可是管实事儿的，城市运作的事儿都归他管。\" \"他们今天说起垃圾自动处理的事儿。你说以后会改造吗？\" \"这事儿啊，不好说，\"老葛砸了口酒，打了个嗝，\"我看够呛。关键是，你得知道当初为啥弄人工处理。其实当初的情况就跟欧洲二十世纪末差不多，经济发展，但失业率上升，印钱也不管用，菲利普斯曲线不符合。\" 他看老刀一脸茫然，呵呵笑了起来：\"算了，这些东西你也不懂。\" 他跟老刀碰了碰杯子，两人一齐喝了又斟上。 \"反正就说失业吧，这你肯定懂。\"老葛接着说，\"人工成本往上涨，机器成本往下降，到一定时候就是机器便宜，生产力一改造，升级了，GDP上去了，失业也上去了。怎么办？政策保护？福利？越保护工厂越不雇人。你现在上城外看看，那几公里的厂区就没几个人。农场不也是吗。大农场一搞几千亩地，全设备耕种，根本要不了几个人。咱们当时怎么搞过欧美的，不就是这么规模化搞的吗。但问题是，地都腾出来了，人都省出来了，这些人干嘛去呢。欧洲那边是强行减少每人工作时间，增加就业机会，可是这样没活力你明白吗。最好的办法是彻底减少一些人的生活时间，再给他们找到活儿干。你明白了吧？就是塞到夜里。这样还有一个好处，就是每次通货膨胀几乎传不到底层去，印钞票、花钞票都是能贷款的人消化了，GDP涨了，底下的物价却不涨。人们根本不知道。\" 老刀听得似懂非懂，但是老葛的话里有一股凉意，他还是能听出来的。老葛还是嬉笑的腔调，但与其说是嬉笑，倒不如说是不愿意让自己的语气太直白而故意如此。 \"这话说着有点冷。\"老葛自己也承认，\"可就是这么回事。我也不是住在这儿了就说话向着这儿。只是这么多年过来，人就木了，好多事儿没法改变，也只当那么回事了。\" 老刀有点明白老葛的意思了，可他不知道该说什么好。 两人都有点醉。他们趁着醉意，聊了不少以前的事，聊小时候吃的东西，学校的打架。老葛最喜欢吃酸辣粉和臭豆腐，在第一空间这么久都吃不到，心里想得痒痒。老葛说起自己的父母，他们还在第三空间，他也不能总回去，每次回去都要打报告申请，实在不太方便。他说第三空间和第一空间之间有官方通道，有不少特殊的人也总是在其中往来。他希望老刀帮他带点东西回去，弥补一下他自己亏欠的心。老刀讲了他孤独的少年时光。 昏黄的灯光中，老刀想起过去。一个人游荡在垃圾场边缘的所有时光。 不知不觉已经是深夜。老葛还要去看一下夜里会场的安置，就又带老刀下楼。楼下还有未结束的舞会末尾，三三两两男女正从舞厅中走出。老葛说企业家大半精力旺盛，经常跳舞到凌晨。散场的舞厅器物凌乱，像女人卸了妆。老葛看着小机器人在狼藉中一一收拾，笑称这是第一空间唯一真实的片刻。 老刀看了看时间，还有三个小时转换。他收拾了一下心情，该走了。 第五幕 白发演讲人在晚宴之后回到自己的办公室，处理了一些文件，又和欧洲进行了视频通话。十二点感觉疲劳，摘下眼镜揉了揉鼻梁两侧，准备回家。他经常工作到午夜。 电话突然响了，他按下耳机。是秘书。 大会研究组出了状况。之前印好的大会宣言中有一个数据之前计算结果有误，白天突然有人发现。宣言在会议第二天要向世界宣读，因而会议组请示要不要把宣言重新印刷。白发老人当即批准。这是大事，不能有误。他问是谁负责此事，秘书说，是吴闻主任。 他靠在沙发上小睡。清晨四点，电话又响了。印刷有点慢，预计还要一个小时。 他起身望向窗外。夜深人静，漆黑的夜空能看到静谧的猎户座亮星。 猎户座亮星映在镜面般的湖水中。老刀坐在湖水边上，等待转换来临。 他看着夜色中的园林，猜想这可能是自己最后一次看这片风景。他并不忧伤留恋，这里虽然静美，可是和他没关系，他并不钦羡嫉妒。他只是很想记住这段经历。夜里灯光很少，比第三空间遍布的霓虹灯少很多，建筑散发着沉睡的呼吸，幽静安宁。 清晨五点，秘书打电话说，材料印好了，还没出车间，问是否人为推迟转换的时间。 白发老人斩钉截铁地说，废话，当然推迟。 清晨五点四十分，印刷品抵达会场，但还需要分装在三千个会议夹子中。 老刀看到了依稀的晨光，这个季节六点还没有天亮，但已经能看到蒙蒙曙光。 他做好了一切准备，反复看手机上的时间。有一点奇怪，已经只有一两分钟到六点了，还是没有任何动静。他猜想也许第一空间的转换更平稳顺滑。 清晨六点十分，分装结束。 白发老人松了一口气，下令转换开始。 老刀发现地面终于动了，他站起身，活动了一下有点麻木的手脚，小心翼翼来到边缘。土地的缝隙开始拉大，缝隙两边同时向上掀起。他沿着其中一边往截面上移动，背身挪移，先用脚试探着，手扶住地面退行。大地开始翻转。 六点二十分，秘书打来紧急电话，说吴闻主任不小心将存着重要文件的数据key遗忘在会场，担心会被机器人清理，需要立即取回。 白发老人有点恼怒，但也只好令转换停止，恢复原状。 老刀在截面上正慢慢挪移，忽然感觉土地的移动停止了，接着开始调转方向，已错开的土地开始合拢。他吓了一跳，连忙向回攀爬。他害怕滚落，手脚并用，异常小心。 土地回归的速度比他想象的快，就在他爬到地表的时候，土地合拢了，他的一条小腿被两块土地夹在中间，尽管是泥土，不足以切筋断骨，但力量十足，他试了几次也无法脱出。他心里大叫糟糕，头顶因为焦急和疼痛渗出汗水。他不知道是否被人发现了。 老刀趴在地上，静听着周围的声音。他似乎听到匆匆接近的脚步声。他想象着很快就有警察过来，将他抓起来，夹住的小腿会被砍断，带着疮口扔到监牢里。他不知道自己是什么时候暴露了身份。他伏在青草覆盖的泥土上，感觉到晨露的冰凉。湿气从领口和袖口透入他的身体，让他觉得清醒，却又忍不住战栗。他默数着时间，期盼这只是技术故障。他设想着自己如果被抓住了该说些什么。也许他该交待自己二十八年工作的勤恳诚实，赚一点同情分。他不知道自己会不会被审判。命运在前方逼人不已。 命运直抵胸膛。回想这四十八小时的全部经历，最让他印象深刻的是最后一晚老葛说过的话。他觉得自己似乎接近了些许真相，因而见到命运的轮廓。可是那轮廓太远，太冷静，太遥不可及。他不知道了解一切有什么意义，如果只是看清楚一些事情，却不能改变，又有什么意义。他连看都还无法看清，命运对他就像偶尔显出形状的云朵，倏忽之间又看不到了。他知道自己仍然是数字。在5128万这个数字中，他只是最普通的一个。如果偏生是那128万中的一个，还会被四舍五入，就像从来没存在过，连尘土都不算。他抓住地上的草。 六点三十分，吴闻取回数据key。六点四十分，吴闻回到房间。 六点四十五分，白发老人终于疲倦地倒在办公室的小床上。指令已经按下，世界的齿轮开始缓缓运转。书桌和茶几表面伸出透明的塑料盖子，将一切物品罩住并固定。小床散发出催眠气体，四周立起围栏，然后从地面脱离，地面翻转，床像一只篮子始终保持水平。 转换重新启动了。 老刀在三十分钟的绝望之后突然看到生机。大地又动了起来。他在第一时间拼尽力气将小腿抽离出来，在土地掀起足够高度的时候重新回到截面上。他更小心地撤退。血液复苏的小腿开始刺痒疼痛，如百爪挠心，几次让他摔倒，疼得无法忍受，只好用牙齿咬住拳头。他摔倒爬起，又摔倒又爬起，在角度飞速变化的土地截面上维持艰难地平衡。 他不记得自己怎么拖着腿上楼，只记得秦天开门时，他昏了过去。 在第二空间，老刀睡了十个小时。秦天找同学来帮他处理了腿伤。肌肉和软组织大面积受损，很长一段时间会妨碍走路，但所幸骨头没断。他醒来后将依言的信交给秦天，看秦天幸福而又失落的样子，什么话也没有说。他知道，秦天会沉浸距离的期冀中很长时间。 再回到第三空间，他感觉像是已经走了一个月。城市仍然在缓慢苏醒，城市居民只过了平常的一场睡眠，和前一天连续。不会有人发现老刀的离开。 他在步行街营业的第一时间坐到塑料桌旁，要了一盘炒面，生平第一次加了一份肉丝。只是一次而已，他想，可以犒劳一下自己。然后他去了老葛家，将老葛给父母的两盒药带给他们。两位老人都已经不大能走动了，一个木讷的小姑娘住在家里看护他们。 他拖着伤腿缓缓踱回自己租的房子。楼道里喧扰嘈杂，充满刚睡醒时洗漱冲厕所和吵闹的声音，蓬乱的头发和乱敞的睡衣在门里门外穿梭。他等了很久电梯，刚上楼就听见争吵。他仔细一看，是隔壁的女孩阑阑和阿贝在和收租的老太太争吵。整栋楼是公租房，但是社区有统一收租的代理人，每栋楼又有分包，甚至每层有单独的收租人。老太太也是老住户了，儿子不知道跑到哪里去了，她长得瘦又干，单独一个人住着，房门总是关闭，不和人来往。阑阑和阿贝在这一层算是新人，两个卖衣服的女孩子。阿贝的声音很高，阑阑拉着她，阿贝抢白了阑阑几句，阑阑倒哭了。 \"咱们都是按合同来的哦。\"老太太用手戳着墙壁上屏幕里滚动的条文，\"我这个人从不撒谎唉。你们知不知道什么是合同咧？秋冬加收10%取暖费，合同里写得清清楚楚唉。\" \"凭什么啊？凭什么？\"阿贝扬着下巴，一边狠狠地梳着头发，\"你以为你那点小猫腻我们不知道？我们上班时你全把空调关了，最后你这按电费交钱，我们这给你白交供暖费。你蒙谁啊你！每天下班回来这屋里冷得跟冰一样。你以为我们新来的好欺负吗？\" 阿贝的声音尖而脆，划得空气道道裂痕。老刀看着阿贝的脸，年轻、饱满而意气的脸，很漂亮。她和阑阑帮他很多，他不在家的时候，她们经常帮他照看糖糖，也会给他熬点粥。他忽然想让阿贝不要吵了，忘了这些细节，只是不要吵了。他想告诉她女孩子应该安安静静坐着，让裙子盖住膝盖，微微一笑露出好看的牙齿，轻声说话，那样才有人爱。可是他知道她们需要的不是这些。 他从衣服的内衬掏出一张一万块的钞票，虚弱地递给老太太。老太太目瞪口呆，阿贝、阑阑看得傻了。他不想解释，摆摆手回到自己的房间。 摇篮里，糖糖刚刚睡醒，正迷糊着揉眼睛。他看着糖糖的脸，疲倦了一天的心软下来。他想起最初在垃圾站门口抱起糖糖时，她那张脏兮兮的哭累了的小脸。他从没后悔将她抱来。她笑了，吧唧了一下小嘴。他觉得自己还是幸运的。尽管伤了腿，但毕竟没被抓住，还带了钱回来。他不知道糖糖什么时候才能学会唱歌跳舞，成为一个淑女。 他看看时间，该去上班了。 （全文完）","tags":"其他","title":"北京折叠－郝景芳"},{"url":"http://king32783784.github.io/2016/08/12/Docker/","text":"在 Docker基础技术：Linux Namespace（上篇) 中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。 好，下面我们就介绍一下还剩下的这两个Namespace。 User Namespace User Namespace 主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。 要把容器中的uid和真实系统的uid给映射在一起，需要修改 /proc/ /uid_map 和 /proc/ /gid_map 这两个文件。这两个文件的格式为： ID-inside-ns ID-outside-ns length 其中： 第一个字段ID-inside-ns表示在容器显示的UID或GID， 第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。 第三个字段表示映射的范围，一般填1，表示一一对应。 比如，把真实的uid=1000映射成容器内的uid=0 $ cat /proc/2465/uid_map 0 1000 1 再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形 $ cat /proc/ $$ /uid_map 0 0 4294967295 另外，需要注意的是： 写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看Capabilities） 写入的进程必须是此user namespace的父或子的user namespace进程。 另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。 这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂): code: #define _GNU_SOURCE #include <stdio.h> #include <stdlib.h> #include <sys/types.h> #include <sys/wait.h> #include <sys/mount.h> #include <sys/capability.h> #include <stdio.h> #include <sched.h> #include <signal.h> #include <unistd.h> #define STACK_SIZE (1024 * 1024) static char container_stack [ STACK_SIZE ]; char * const container_args [] = { \"/bin/bash\" , NULL }; int pipefd [ 2 ]; void set_map ( char * file , int inside_id , int outside_id , int len ) { FILE * mapfd = fopen ( file , \"w\" ); if ( NULL == mapfd ) { perror ( \"open file error\" ); return ; } fprintf ( mapfd , \"%d %d %d\" , inside_id , outside_id , len ); fclose ( mapfd ); } void set_uid_map ( pid_t pid , int inside_id , int outside_id , int len ) { char file [ 256 ]; sprintf ( file , \"/proc/%d/uid_map\" , pid ); set_map ( file , inside_id , outside_id , len ); } void set_gid_map ( pid_t pid , int inside_id , int outside_id , int len ) { char file [ 256 ]; sprintf ( file , \"/proc/%d/gid_map\" , pid ); set_map ( file , inside_id , outside_id , len ); } int container_main ( void * arg ) { printf ( \"Container [%5d] - inside the container! \\n \" , getpid ()); printf ( \"Container: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld \\n \" , ( long ) geteuid (), ( long ) getegid (), ( long ) getuid (), ( long ) getgid ()); /* 等待父进程通知后再往下执行（进程间的同步） */ char ch ; close ( pipefd [ 1 ]); read ( pipefd [ 0 ], & ch , 1 ); printf ( \"Container [%5d] - setup hostname! \\n \" , getpid ()); //set hostname sethostname ( \"container\" , 10 ); //remount \"/proc\" to make sure the \"top\" and \"ps\" show container's information mount ( \"proc\" , \"/proc\" , \"proc\" , 0 , NULL ); execv ( container_args [ 0 ], container_args ); printf ( \"Something's wrong! \\n \" ); return 1 ; } int main () { const int gid = getgid (), uid = getuid (); printf ( \"Parent: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld \\n \" , ( long ) geteuid (), ( long ) getegid (), ( long ) getuid (), ( long ) getgid ()); pipe ( pipefd ); printf ( \"Parent [%5d] - start a container! \\n \" , getpid ()); int container_pid = clone ( container_main , container_stack + STACK_SIZE , CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD , NULL ); printf ( \"Parent [%5d] - Container [%5d]! \\n \" , getpid (), container_pid ); //To map the uid/gid, // we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent //The file format is // ID-inside-ns ID-outside-ns length //if no mapping, // the uid will be taken from /proc/sys/kernel/overflowuid // the gid will be taken from /proc/sys/kernel/overflowgid set_uid_map ( container_pid , 0 , uid , 1 ); set_gid_map ( container_pid , 0 , gid , 1 ); printf ( \"Parent [%5d] - user/group mapping done! \\n \" , getpid ()); /* 通知子进程 */ close ( pipefd [ 1 ]); waitpid ( container_pid , NULL , 0 ); printf ( \"Parent - container stopped! \\n \" ); return 0 ; } 上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。 整个程序的运行效果如下： hchen@ubuntu:~ \\( id uid=1000(hchen) gid=1000(hchen) groups=1000(hchen) hchen@ubuntu:~\\) ./user #<--以hchen用户运行 Parent: eUID = 1000; eGID = 1000, UID=1000, GID=1000 Parent [ 3262] - start a container! Parent [ 3262] - Container [ 3263]! Parent [ 3262] - user/group mapping done! Container [ 1] - inside the container! Container: eUID = 0; eGID = 0, UID=0, GID=0 #<---Container里的UID/GID都为0了 Container [ 1] - setup hostname! root@container:~# id #<----我们可以看到容器里的用户和命令行提示符是root用户了 uid=0(root) gid=0(root) groups=0(root),65534(nogroup) 虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，我们容器的安全性会得到提高。 我们注意到，User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。 Network Namespace Network的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些\"奇怪\"的数据，呵呵）。这里，我还是用ip命令讲解一下。 首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的\"物理网卡\"其实也就是一个有可以路由的IP的网卡） 上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。 当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）： hchen@ubuntu:~$ ip link show 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state ... link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc ... link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff 3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 ... link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff 5: veth22a38e6: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc ... link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff 那么，要做成这个样子应该怎么办呢？我们来看一组命令： ## 首先，我们先增加一个网桥lxcbr0，模仿docker0 brctl addbr lxcbr0 brctl stp lxcbr0 off ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址 ## 接下来，我们要创建一个network namespace - ns1 # 增加一个namesapce 命令为 ns1 （使用ip netns add命令） ip netns add ns1 # 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令） ip netns exec ns1 ip link set dev lo up ## 然后，我们需要增加一对虚拟网卡 # 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中 ip link add veth-ns1 type veth peer name lxcbr0.1 # 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了 ip link set veth-ns1 netns ns1 # 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了） ip netns exec ns1 ip link set dev veth-ns1 name eth0 # 为容器中的网卡分配一个IP地址，并激活它 ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up # 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上 brctl addif lxcbr0 lxcbr0.1 # 为容器增加一个路由规则，让容器可以访问外面的网络 ip netns exec ns1 ip route add default via 192.168.10.1 # 在/etc/netns下创建network namespce名称为ns1的目录， # 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了 mkdir -p /etc/netns/ns1 echo \"nameserver 8.8.8.8\" > /etc/netns/ns1/resolv.conf 上面基本上就是docker网络的原理了，只不过， Docker的resolv.conf没有用这样的方式，而是用了上篇中的Mount Namesapce的那种方式 另外，docker是用进程的PID来做Network Namespace的名称的。 了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡： ip link add peerA type veth peer name peerB brctl addif docker0 peerA ip link set peerA up ip link set peerB netns ${ container - pid } ip netns exec ${ container - pid } ip link set dev peerB name eth1 ip netns exec ${ container - pid } ip link set eth1 up ; ip netns exec ${ container - pid } ip addr add ${ ROUTEABLE_IP } dev eth1 ; 上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。 这个需要把外部的\"物理网卡\"配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到\"物理网卡\"上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。 当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。 这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个IPVLAN的驱动，这基本上就是为Docker量身定制的。 Namespace文件 上面就是目前Linux Namespace的玩法。 现在，我来看一下其它的相关东西。 让我们运行一下上篇中的那个pid.mnt的程序（也就是PID Namespace中那个mount proc的程序），然后不要退出。 $ sudo ./pid.mnt [ sudo ] password for hchen: Parent [ 4599 ] - start a container! Container [ 1 ] - inside the container! 我们到另一个shell中查看一下父子进程的PID： hchen@ubuntu:~$ pstree -p 4599 pid.mnt(4599)───bash(4600) 我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上）。 下面是父进程的： hchen@ubuntu:~$ sudo ls -l /proc/4599/ns total 0 lrwxrwxrwx 1 root root 0 4月 7 22:01 ipc -> ipc:[4026531839] lrwxrwxrwx 1 root root 0 4月 7 22:01 mnt -> mnt:[4026531840] lrwxrwxrwx 1 root root 0 4月 7 22:01 net -> net:[4026531956] lrwxrwxrwx 1 root root 0 4月 7 22:01 pid -> pid:[4026531836] lrwxrwxrwx 1 root root 0 4月 7 22:01 user -> user:[4026531837] lrwxrwxrwx 1 root root 0 4月 7 22:01 uts -> uts:[4026531838] 下面是子进程的： hchen@ubuntu:~$ sudo ls -l /proc/4600/ns total 0 lrwxrwxrwx 1 root root 0 4月 7 22:01 ipc -> ipc:[4026531839] lrwxrwxrwx 1 root root 0 4月 7 22:01 mnt -> mnt:[4026532520] lrwxrwxrwx 1 root root 0 4月 7 22:01 net -> net:[4026531956] lrwxrwxrwx 1 root root 0 4月 7 22:01 pid -> pid:[4026532522] lrwxrwxrwx 1 root root 0 4月 7 22:01 user -> user:[4026531837] lrwxrwxrwx 1 root root 0 4月 7 22:01 uts -> uts:[4026532521] 我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。 这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount –bind /proc/4600/ns/uts ~/uts 来hold这个namespace。 另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下： int setns(int fd, int nstype); 其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如： fd = open(\"/proc/4600/ns/nts\", O_RDONLY); // 获取namespace文件描述符 setns(fd, 0); // 加入新的namespace 参考文档 Namespaces in operation Linux Namespace Man Page Creat Containers – Part 1 Introduction to Linux namespaces （全文完） if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Docker专题","title":"Docker基础技术：Linux Namespace（下）<转>"},{"url":"http://king32783784.github.io/2016/08/11/Docker/","text":"时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New \"Old Stuff\"。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。 当然，文章的风格一定会尊重时下的\"流行\"——我们再也没有整块整块的时间去看书去专研，而我们只有看微博微信那样的碎片时间（那怕我们有整块的时间，也被那些在手机上的APP碎片化了）。所以，这些文章的风格必然坚持\"马桶风格\"（希望简单到占用你拉一泡屎就时间，而且你还不用动脑子，并能学到些东西） 废话少说，我们开始。先从Linux Namespace开始。 简介 Linux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。 举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程 看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID namespace中的进程无法看到彼此） Linux Namespace 有如下种类，官方文档在这里 《Namespace in Operation》 分类 系统调用参数 相关内核版本 Mount namespaces CLONE_NEWNS Linux 2.4.19 UTS namespaces CLONE_NEWUTS Linux 2.6.19 IPC namespaces CLONE_NEWIPC Linux 2.6.19 PID namespaces CLONE_NEWPID Linux 2.6.24 Network namespaces CLONE_NEWNET 始于Linux 2.6.24 完成于 Linux 2.6.29 User namespaces CLONE_NEWUSER 始于 Linux 2.6.23 完成于 Linux 3.8 主要是三个系统调用 clone() – 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。 unshare() – 使某进程脱离某个namespace setns() – 把某进程加入到某个namespace unshare() 和 setns() 都比较简单，大家可以自己man，我这里不说了。 下面还是让我们来看一些示例（以下的测试程序最好在Linux 内核为3.8以上的版本中运行，我用的是ubuntu 14.04）。 clone()系统调用 首先，我们来看一下一个最简单的clone()系统调用的示例，（后面，我们的程序都会基于这个程序做修改）： ```c #define _GNU_SOURCE #include #include #include #include #include #include /* 定义一个给 clone 用的栈，栈大小1M */ # define STACK_SIZE ( 1024 * 1024 ) static char container_stack [ STACK_SIZE ]; char * const container_args [] = { \"/bin/bash\" , NULL }; int container_main ( void * arg ) { printf ( \"Container - inside the container!\\n\" ) ; /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */ execv ( container_args [ 0 ] , container_args ) ; printf ( \"Something's wrong!\\n\" ) ; return 1 ; } int main () { printf ( \"Parent - start a container!\\n\" ) ; /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针， 因为栈是反着的） */ int container_pid = clone ( container_main , container_stack + STACK_SIZE , SIGCHLD , NULL ) ; /* 等待子进程结束 */ waitpid ( container_pid , NULL , 0 ) ; printf ( \"Parent - container stopped!\\n\" ) ; return 0 ; } 从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。 下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。 #### UTS Namespace 下面的代码，我略去了上面那些头文件和数据结构的定义，只有最重要的部分。 ```c int container_main(void* arg) { printf(\"Container - inside the container!\\n\"); sethostname(\"container\",10); /* 设置hostname */ execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent - start a container!\\n\"); int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */ waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container。 hchen@ubuntu:~$ sudo ./uts Parent - start a container! Container - inside the container! root@container:~# hostname container root@container:~# uname -n container IPC Namespace IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。 要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了。 int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL); 首先，我们先创建一个IPC的Queue（如下所示，全局的Queue ID是0） hchen@ubuntu:~$ ipcmk -Q Message queue id: 0 hchen@ubuntu:~$ ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 0xd0d56eb2 0 hchen 644 0 0 如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC Queue。 hchen@ubuntu:~$ sudo ./uts Parent - start a container! Container - inside the container! root@container:~# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 0xd0d56eb2 0 hchen 644 0 0 但是，如果我们运行加上了CLONE_NEWIPC的程序，我们就会下面的结果： root@ubuntu:~$ sudo./ipc Parent - start a container! Container - inside the container! root@container:~/linux_namespace# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 我们可以看到IPC已经被隔离了。 PID Namespace 我们继续修改上面的程序： int container_main(void* arg) { /* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */ printf(\"Container [%5d] - inside the container!\\n\", getpid()); sethostname(\"container\",10); execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent [%5d] - start a container!\\n\", getpid()); /*启用PID namespace - CLONE_NEWPID*/ int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, NULL); waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 运行结果如下（我们可以看到，子进程的pid是1了）： hchen@ubuntu:~$ sudo ./pid Parent [ 3474] - start a container! Container [ 1] - inside the container! root@container:~# echo $$ 1 你可能会问，PID为1有个毛用啊？我们知道，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。 但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。 所以，我们还需要对文件系统进行隔离。 Mount Namespace 下面的例程中，我们在启用了mount namespace并在子进程中重新mount了/proc文件系统。 int container_main(void* arg) { printf(\"Container [%5d] - inside the container!\\n\", getpid()); sethostname(\"container\",10); /* 重新mount proc文件系统到 /proc下 */ system(\"mount -t proc proc /proc\"); execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent [%5d] - start a container!\\n\", getpid()); /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */ int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL); waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 运行结果如下： hchen@ubuntu:~$ sudo ./pid.mnt Parent [ 3502] - start a container! Container [ 1] - inside the container! root@container:~# ps -elf F S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD 4 S root 1 0 0 80 0 - 6917 wait 19:55 pts/2 00:00:00 /bin/bash 0 R root 14 1 0 80 0 - 5671 - 19:56 pts/2 00:00:00 ps -elf 上面，我们可以看到只有两个进程 ，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多： root@container:~# ls /proc 1 dma key-users net sysvipc 16 driver kmsg pagetypeinfo timer_list acpi execdomains kpagecount partitions timer_stats asound fb kpageflags sched_debug tty buddyinfo filesystems loadavg schedstat uptime bus fs locks scsi version cgroups interrupts mdstat self version_signature cmdline iomem meminfo slabinfo vmallocinfo consoles ioports misc softirqs vmstat cpuinfo irq modules stat zoneinfo crypto kallsyms mounts swaps devices kcore mpt sys diskstats keys mtrr sysrq-trigger 这里，多说一下。在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。 你可能会问，我们是不是还有别的一些文件系统也需要这样mount? 是的。 Docker的 Mount Namespace 下面我将向演示一个\"山寨镜像\"，其模仿了Docker的Mount Namespace。 首先，我们需要一个rootfs，也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录： hchen@ubuntu:~/rootfs$ ls bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var 然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ） hchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin ./bin: bash chown gzip less mount netstat rm tabs tee top tty cat cp hostname ln mountpoint ping sed tac test touch umount chgrp echo ip ls mv ps sh tail timeout tr uname chmod grep kill more nc pwd sleep tar toe truncate which ./usr/bin: awk env groups head id mesg sort strace tail top uniq vi wc xargs 注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录： hchen@ubuntu:~/rootfs/bin$ ldd bash linux-vdso.so.1 => (0x00007fffd33fc000) libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000) libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000) /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000) 下面是我的rootfs中的一些so文件： hchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/ ./lib64: ld-linux-x86-64.so.2 ./lib/x86_64-linux-gnu/: libacl.so.1 libmemusage.so libnss_files-2.19.so libpython3.4m.so.1 libacl.so.1.1.0 libmount.so.1 libnss_files.so.2 libpython3.4m.so.1.0 libattr.so.1 libmount.so.1.1.0 libnss_hesiod-2.19.so libresolv-2.19.so libblkid.so.1 libm.so.6 libnss_hesiod.so.2 libresolv.so.2 libc-2.19.so libncurses.so.5 libnss_nis-2.19.so libselinux.so.1 libcap.a libncurses.so.5.9 libnss_nisplus-2.19.so libtinfo.so.5 libcap.so libncursesw.so.5 libnss_nisplus.so.2 libtinfo.so.5.9 libcap.so.2 libncursesw.so.5.9 libnss_nis.so.2 libutil-2.19.so libcap.so.2.24 libnsl-2.19.so libpcre.so.3 libutil.so.1 libc.so.6 libnsl.so.1 libprocps.so.3 libuuid.so.1 libdl-2.19.so libnss_compat-2.19.so libpthread-2.19.so libz.so.1 libdl.so.2 libnss_compat.so.2 libpthread.so.0 libgpm.so.2 libnss_dns-2.19.so libpython2.7.so.1 libm-2.19.so libnss_dns.so.2 libpython2.7.so.1.0 包括这些命令依赖的一些配置文件： hchen@ubuntu:~/rootfs$ ls ./etc bash.bashrc group hostname hosts ld.so.cache nsswitch.conf passwd profile resolv.conf shadow 你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中。 hchen@ubuntu:~$ ls ./conf hostname hosts resolv.conf 这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。 好了，终于到了我们的程序。 #define _GNU_SOURCE #include <sys/types.h> #include <sys/wait.h> #include <sys/mount.h> #include <stdio.h> #include <sched.h> #include <signal.h> #include <unistd.h> #define STACK_SIZE (1024 * 1024) static char container_stack [ STACK_SIZE ]; char * const container_args [] = { \"/bin/bash\" , \"-l\" , NULL }; int container_main ( void * arg ) { printf ( \"Container [%5d] - inside the container! \\n \" , getpid ()); //set hostname sethostname ( \"container\" , 10 ); //remount \"/proc\" to make sure the \"top\" and \"ps\" show container's information if ( mount ( \"proc\" , \"rootfs/proc\" , \"proc\" , 0 , NULL ) != 0 ) { perror ( \"proc\" ); } if ( mount ( \"sysfs\" , \"rootfs/sys\" , \"sysfs\" , 0 , NULL ) != 0 ) { perror ( \"sys\" ); } if ( mount ( \"none\" , \"rootfs/tmp\" , \"tmpfs\" , 0 , NULL ) != 0 ) { perror ( \"tmp\" ); } if ( mount ( \"udev\" , \"rootfs/dev\" , \"devtmpfs\" , 0 , NULL ) != 0 ) { perror ( \"dev\" ); } if ( mount ( \"devpts\" , \"rootfs/dev/pts\" , \"devpts\" , 0 , NULL ) != 0 ) { perror ( \"dev/pts\" ); } if ( mount ( \"shm\" , \"rootfs/dev/shm\" , \"tmpfs\" , 0 , NULL ) != 0 ) { perror ( \"dev/shm\" ); } if ( mount ( \"tmpfs\" , \"rootfs/run\" , \"tmpfs\" , 0 , NULL ) != 0 ) { perror ( \"run\" ); } /* * 模仿Docker的从外向容器里mount相关的配置文件 * 你可以查看：/var/lib/docker/containers/<container_id>/目录， * 你会看到docker的这些文件的。 */ if ( mount ( \"conf/hosts\" , \"rootfs/etc/hosts\" , \"none\" , MS_BIND , NULL ) != 0 || mount ( \"conf/hostname\" , \"rootfs/etc/hostname\" , \"none\" , MS_BIND , NULL ) != 0 || mount ( \"conf/resolv.conf\" , \"rootfs/etc/resolv.conf\" , \"none\" , MS_BIND , NULL ) != 0 ) { perror ( \"conf\" ); } /* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */ if ( mount ( \"/tmp/t1\" , \"rootfs/mnt\" , \"none\" , MS_BIND , NULL ) != 0 ) { perror ( \"mnt\" ); } /* chroot 隔离目录 */ if ( chdir ( \"./rootfs\" ) != 0 || chroot ( \"./\" ) != 0 ){ perror ( \"chdir/chroot\" ); } execv ( container_args [ 0 ], container_args ); perror ( \"exec\" ); printf ( \"Something's wrong! \\n \" ); return 1 ; } int main () { printf ( \"Parent [%5d] - start a container! \\n \" , getpid ()); int container_pid = clone ( container_main , container_stack + STACK_SIZE , CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD , NULL ); waitpid ( container_pid , NULL , 0 ); printf ( \"Parent - container stopped! \\n \" ); return 0 ; } sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的\"镜像\"： hchen@ubuntu:~$ sudo ./mount Parent [ 4517] - start a container! Container [ 1] - inside the container! root@container:/# mount proc on /proc type proc (rw,relatime) sysfs on /sys type sysfs (rw,relatime) none on /tmp type tmpfs (rw,relatime) udev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755) devpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000) tmpfs on /run type tmpfs (rw,relatime) /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered) /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered) /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered) root@container:/# ls /bin /usr/bin /bin: bash chmod echo hostname less more mv ping rm sleep tail test top truncate uname cat chown grep ip ln mount nc ps sed tabs tar timeout touch tty which chgrp cp gzip kill ls mountpoint netstat pwd sh tac tee toe tr umount /usr/bin: awk env groups head id mesg sort strace tail top uniq vi wc xargs 关于如何做一个chroot的目录，这里有个工具叫 DebootstrapChroot ，你可以顺着链接去看看（英文的哦） 接下来的事情，你可以自己玩了，我相信你的想像力 。：） 在下一篇，我将向你介绍User Namespace、Network Namespace以及Namespace的其它东西。 Docker基础技术：Linux Namespace（下)>>> （上篇完，请参看下篇）","tags":"Docker专题","title":"Docker基础技术：Linux Namespace（上）<转>"},{"url":"http://king32783784.github.io/2016/08/11/Performance/","text":"偶然间看到了阿里中间件Dubbo的性能测试报告，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。 首先，这份测试报告里的主要问题如下： 用的全是平均值。老实说，平均值是非常不靠谱的。 响应时间没有和吞吐量TPS/QPS挂钩。而只是测试了低速率的情况，这是完全错误的。 响应时间和吞吐量没有和成功率挂钩。 为什么平均值不靠谱 关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到， 平均工资 ， 平均房价 ， 平均支出 ，等等这样的字眼，你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力） 软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章《Why Averages Suck and Percentiles are Great》，我在这里简单说一下。 我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如， 测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况，也许那1s的请求就是一个不正常的值，是个噪点，应该去掉。 所以，我们会在一些评委打分中看到要去掉一个最高分一个最低分，然后再算平均值。 另外，中位数（Mean）可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。 当然，最为正确的统计做法是用百分比分布统计。也就是英文中的 TP – Top Percentile ，TP50的意思在，50%的请求都小于某个值，TP90表示90%的请求小于某个时间。 比如：我们有一组数据：[ 10ms, 1s, 200ms, 100ms]，我们把其从小到大排个序：[10ms, 100ms, 200ms, 1s]，于是我们知道，TP50，就是50%的请求ceil(4 0.5)=2时间是小于100ms的，TP90就是90%的请求ceil(4 0.9)=4时间小于1s。于是：TP50就是100ms，TP90就是1s。 我以前在路透做的金融系统响应时间的性能测试的要求是这样的， 99.9%的请求必须小于1ms，所有的平均时间必须小于1ms。两个条件的限制。 为什么响应时间（latency）要和吞吐量（Thoughput）挂钩 系统的性能如果只看吞吐量，不看响应时间是没有意义的。我的系统可以顶10万请求，但是响应时间已经到了5秒钟，这样的系统已经不可用了，这样的吞吐量也是没有意义的。 我们知道，当并发量（吞吐量）上涨的时候，系统会变得越来越不稳定，响应时间的波动也会越来越大，响应时间也会变得越来越慢，而吞吐率也越来越上不去（如下图所示），包括CPU的使用率情况也会如此。所以，当系统变得不稳定的时候，吞吐量已经没有意义了。吞吐量有意义的时候仅当系统稳定的时候。 BenchmarkOptimalRate 所以，吞吐量的值必需有响应时间来卡。比如：TP99小于100ms的时候，系统可以承载的最大并发数是1000qps。这意味着，我们要不断的在不同的并发数上测试，以找到软件的最稳定时的最大吞吐量。 为什么响应时间吞吐量和成功率要挂钩 我们这应该不难理解了，如果请求不成功的话，都还做毛的性能测试。比如，我说我的系统并发可以达到10万，但是失败率是 40%，那么，这10万的并发完全就是一个笑话了。 性能测试的失败率的容忍应该是非常低的。对于一些关键系统，成功请求数必须在100%，一点都不能含糊。 如何严谨地做性能测试 一般来说，性能测试要统一考虑这么几个因素： Thoughput吞吐量，Latency响应时间，资源利用 （CPU/MEM/IO/Bandwidth…）， 成功率，系统稳定性 。 下面的这些性能测试的方式基本上来源自我的老老东家汤森路透，一家做real-time的金融数据系统的公司。 一，你得定义一个系统的响应时间latency，建议是TP99，以及成功率。 比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。 二，在这个响应时间的限制下，找到最高的吞吐量。 测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。 三，在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。 然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能 四，找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。 五，做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。 收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。 六、低吞吐量和网络小包的测试。 有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。 （注：在路透，路透会用第二步得到的吞吐量乘以66.7%来做为系统的软报警线，80%做为系统的硬报警线，而极限值仅仅用来扛突发的peak） 是不是很繁锁？是的，只因为，这是工程，工程是一门科学，科学是严谨的。 欢迎大家也分享一下你们性能测试的经验和方法。 （全文完） （本文来源于酷 壳 – CoolShell.cn ，请勿用于任何商业用途）","tags":"性能测试","title":"如何做性能测试<转>"},{"url":"http://king32783784.github.io/2016/08/05/LTP/","text":"accept用例分析 case本身说明： Verify that accept() returns the proper errno for various failure cases 验证accept()是否返回正确的errno. 测试log accept01 1 TPASS : bad file descriptor successful accept01 2 TPASS : bad file descriptor successful accept01 3 TPASS : invalid socket buffer successful accept01 4 TPASS : invalid salen successful accept01 5 TPASS : invalid salen successful accept01 6 TPASS : no queued connections successful accept01 7 TPASS : UDP accept successful ~ 测试错误类型包括: bad file descriptor、invalid socket buffer、invalid salen、no queued connections、 UDP accept等 accept函数 accept() 接收一个套接字中已建立的连接 使用格式 #include <sys/types.h> #include <sys/socket.h> int accept ( int sockfd , struct sockaddr * addr , socklen_t * addrlen ); 功能参数描述 accept()系统调用主要用在基于链接的套接字类型，比如SOCK_STREAM和SOCK_SEQPACKET.它提取出所监听套接字的等待连接队列中第一个连接请求，创建一个新的套接字，并返回指向该套接字的文件描述符。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。 备注： 新建立的套接字准备发送send()和接收数据recv(). 参数： sockfd, 利用系统调用socket()建立的套接字描述符，通过bind()绑定到一个本地地址（一般为服务器的套接字），并且通过listen()一直在监听连接。 addr, 指向struct sockaddr的指针，该结构用通讯层服务器对等套接字的地址（一般为客户端地址）填写，返回地址addr的确切格式由套接字的地址类别（比如tcp或udp)决定；若addr为NULL，没有有效地址填写，这种情况下，addrlen也不使用，应该置为NULL； 备注： addr是个指向局部数据结构sockaddr_in的指针，这就是要求接入的信息本地的套接字（地址和指针） addrlen, 一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值，函数返回时包含对等地址（一般为服务器地址）的实际数值； 备注： addrlen 是个局部整型变量， 设置为sizeof(struct sockaddr_in) 如果队列中没有等待的连接，套接字也没有被标记为Non-blocking, accept()会阻塞调用函数知道连接出现；如果套接字被标记为Non-blocking, 队列中也没有等待的连接，accept返回错误EAGAIN或EWOULDBLOCK. 备注： 一般来说，实现时accept()为阻塞函数，当监听socket调用accept()时，它先到自己的receive_buf中查看是否有连接数据包； 若有，把数据拷贝处理啊，删掉接收到的数据包，创建新的socket与客户发来的地址建立链接； 若没有，就阻塞等待； 为了在套接字中有到来的连接时得到通知，可以使用select()或poll().当尝试建立新连接时，系统发送一个可读事件，然后调用accept()为该链接获取套接字。另一种方法是，当套接字中有连接到来时设定套接字发送SIGIO信号。 返回值 成功时，返回非负整数，该整数是接收到套接字的描述符；出错时，返回－１，相应的设定全局变量errno. 错误处理 Linux下，accept()把已等待的网络错误传给新建立的连接，当作是accept()返回的错误。这与其他的BSD实现是不同的。为了可靠运行，应该在accept()之后检测协议已定义的一些网络错误，并把这些错误当作EAGAIN并重试。对于tcp/ip协议来说，主要有：ENETDOWN,EPROTO,ENOPROTOOPT,EHOSTDOWN,ENONET,EHOSTUNREACH,EOPNOTSUPP和ENETUNREACH。 accept01.c代码分析 主要函数包括mian、setup、cleanup、setup0、cleanup0、setup1、cleanup1、setup2、setup3 test_case_t结构体 struct test_caset { int domain; /*AF_INIT, AF_UNIX,....*/ int type; /* SOCK_STREAM, SOCK_DGRAM...*/ int proto; /* protocol number(usually 0 = default) */ struct sockaddr *sockaddr; /*socket address buffer */ socklen_t *salen; /* accept's 3rd argument */ int retval; /* syscall return value */ int experrno; /* expected errno */ void (*setup)(void); void(*cleanup)(void); char *desc; } tdat[] = { {PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EBADF, setup0, cleanup0, \"bad file descriptor\"}, //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, ENOTSOCK, setup0, cleanup0, \"bad file descriptor\"}, { //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)3, &sinlen, -1, EINVAL, setup1, cleanup1, \"invalid socket buffer\"}, { //无效套接字缓存区 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, (socklen_t *) 1, -1, EINVAL, setup1, cleanup1, \"invalid salen\"}, { //无效的salen PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup2, cleanup1, \"invalid salen\"}, { PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup3, cleanup1, \"no queued connections\"}, { //队列中没有等待的连接 PF_INET, SOCK_DGRAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EOPNOTSUPP, setup1, cleanup1, \"UDP accept\"},}; int TST_TOTAL = sizeof(tdat) / sizeof(tdat[0]); /*通过数组的长度，计算测试用例数量*/ 先定义测试case需要的结构体，然后进行了 结构体初始化 ，定义了7种错误类型，对应7个测试case，和测试log是对应的。 顺便看一下 SOCK_STREAM和SOCK_DGRAM的区别： sock_stream 是有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料（如文件）传送。 sock_dgram 是无保障的面向消息的socket ， 主要用于在网络上发广播信息。 SOCK_STREAM是基于TCP的，数据传输比较有保障。SOCK_DGRAM是基于UDP的，专门用于局域网，基于广播 SOCK_STREAM 是数据流,一般是tcp/ip协议的编程,SOCK_DGRAM分是数据抱,是udp协议网络编程 再看说一下AF_INET和PF_INET的差别： 在Unix/Linux系统中，在不同的版本中这两者有微小差别.对于BSD,是AF,对于POSIX是PF.理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx 分别看一下这几个错误码 EBADF: 当作为参数的套接字不是一个有效的文件描述符(在Linux下用文件描述符来表示设备文件和普通文件。文件描述符是一个整型的数据，所有对文件的操作都通过文件描述符实现。文件描述符是文件系统中链接用户空间和内核空间的枢纽)时，抛出这个错误码。无效的文件描述符是什么意思呢？就是fd已经close的，或者本身就不是个有效的socket的fd。 ENOTSOCK: 在非socket上执行socket操作。 EINVAL： 无效参数。提供的参数非法。有时也会与socket的当前状态相关，如一个socket并没有进入listening状态，此时调用accept，就会产生EINVAL错误。 EOPNOTSUPP: 不支持的操作。 引用对象的类型不支持尝试的操作。通常，这发生在套接字描述符不支持此操作，例如，试着接受数据报套接字上的连接的套接字。 接下来看几个辅助函数。 1.setup函数 static void setup(void) { TEST_PAUSE; /*初始化本地 sockaddr*/ sin0.sin_family = AF_INET; //绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_INET，即使用IP sin0.sin_port = 0; sin0.sin_addr.s_addr = INADDR_ANY; //指定地址为0.0.0.0的地址 } TEST_PAUSE是一个 宏定义 ，代表usc_global_setup_hook()函数。作用是当设置了暂停标志后，暂停 SIGUSR1 ，当新的信号来时，再继续。下面是usc_global_setup_hook函数实现： #define TEST_PAUSE usc_global_setup_hook(); int usc_global_setup_hook () int usc_global_setup_hook ( void ) { #ifndef UCLINUX /*定义temp变量存储信号旧信号的动作，中断后恢复*/ int ( * _TMP_FUNC ) ( void ); /*中断等待sigusr1.*/ if ( STD_PAUSE ) { _TMP_FUNC = ( int ( * )()) singnal ( SIGUSR1 , STD_go ); pause () signal ( SIGUSR1 , ( void ( * )()) _TMP_FUNC ); } if ( STD_TP_sbrk ) || STD_LP_sbrk ) STD_start_break = sbrk ( 0 ); /*获取原始sbreak大小*/ if ( STD_TP_sbrk ){ sbrk ( STD_TP_sbrk ) : if ( Debug ) print ( \"after sbrk(%d) \\n \" , STD_TP_sbrk ); } #endif return 0 ; } 2.setup0函数case1测试前设置 static void setup0(void) 3.setup2 static void setup2(void) { setup1(); //调用setup1()获取套接字s sinlen = 1; //s置为无效 } 4.setup3 static void setup3(void) { int one = 1; setup1(); SAFE_IOCTL(cleanup, s, FIONBIO, &one); } SAFE_IOCTL #define SAFE_IOCTL ( cleanup_fn , fd , request , ...) \\ ( { int ret = ioctl ( fd , request , __VA_ARGS__ ); \\ ret < 0 ? \\ tst_brkm ( TBROK | TERRNO , cleanup_fn , \\ \"ioctl(%i,%s,...) failed\" , fd , #reques t ) \\ safe_ : ret ;} ) 6.cleanup、cleanup0, cleanup1 static void cleanup(void) { } static void cleanup0(void) { s = -1; } static void cleanup1(void) { (void)close(s); s = -1; } 重新设置s = -1 OK,现在看一下main函数。 int main(int ac, char *av[]) { int lc; tst_parse_opts(ac, av, NULL, NULL); //ltp参数解析函数 setup(); for (lc = 0; TEST_LOOPING(lc); ++lc){ test_count = 0; for (testno = 0; testno < TST_TOTAL; ++testno){ tdat[testno].setup(); TEST(accept(s, tdat[testno].sockaddr, tdat[testno].salen)); if (TEST_RETURN > 0) TEST_RETURN = 0; if (TEST_RETURN != tdat[testno].retval || (TEST_RETURN < 0 && TEST_ERRNO != tdat[testno].experrno)){ \"%ld(expected %d), errno %d (expected\" \"%d)\", tdat[testno].desc, TEST_RETURN, tdat[testno].desc, TEST_ERRNO, tdat[testno].experrno); } else { tst_resm(TPASS, \"%s successful\", tdat[testno].desc); } tdat[testno].cleanup(); } } cleanup(); tst_exit(); } 先看一下tst_parse_opts()函数 void tst_parse_opts(int argc, char *argv[], const option_t *user_optarg, void (*user_help)(void)) { const char *msg; msg = parse_opts(argc, argv, user_optarg, user_help); //parse_opts是参数解析函数，后面文章再进行介绍 if(msg) tst_brkm(TBROK, NULL, \"OPTION PARSING ERROR - %s \", msg); } 接下来调用setup，准备测试环境，初始化本地IP地址。然后是一个嵌套的两层循环，第一次是测试次数的遍历，通过TEST_LOOPING实现。 TEST_LOOPING是int usc_test_looping(int counter)函数，该函数后面的文章再进行解释。tst_count初始化为0。 第二层循环是遍历case数组。tdat[testno].setup()，调用对应setup准备case的特殊设置。 TEST启动测试， #define TEST(SCALL) \\ do { \\ errno = 0; \\ TEST_RETURN = SCALL; \\ TEST_ERRNO = errno; \\ } 然后将tdat中的对应参数，分别执行accept函数，如果预期的返回值不符或则返回值小于0且和预期的错误类型不匹配，则调用tst_resm()，进行出错处理。tst_resm将在后面进行分析。如果符合预期，则打印TPASS，然后调用tdat[testno].clearnup()分别清理环境。 最后调用cleanup()清理，tst_exit()退出，tst_exit()在单独分析ltp测试框架时分析。 到此，我们就清楚accept测试的内容了。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-accept()"},{"url":"http://king32783784.github.io/2016/08/02/LTP/","text":"从本文开始，开始分析kernel部分的测试用例，该部分测试用例大部分为Ｃ语言编写，因此会穿插加入一定的Ｃ语言或unix环境编程的知识。 abort 设计说明 测试策略 Fork child. Child出现abort,检查返回状态 限制 Core file大小的限制必须大于０ abort 函数名: abort 功 能: 异常终止一个进程 用 法: void abort(void); abort()是使异常程序终止，同时发送SIGABRT信号给调用进程。 #include <stdlib.h> void abort ( void ); 该函数不返回 此函数将SIGABRT信号发送给调用进程（进程不应忽略此信号).ISO C规定，调用abort将向主机环境递送一个未成功终止的通知，其方法是调用raise(SIGABRT)函数。 ISO C要求若捕捉此信号而且相应信号处理程序返回，abort仍不会返回其调用者。如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、_Exit、longjmp或sigloogjmp.POSIX.1也说明 abort并不理会进程对此信号的阻塞和忽略。 让进程捕捉SIGABRT的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不在信号处理程序中终止自己，POSIX.1声明当信号处理程序返回时，abort终止该进程。 ISO C针对此函数的规范将下列问题留由实现决定： 是否要冲洗输出流以及是否删除临时文件。POSIX.1的要求更进一步，要求如果abort调用终止进程，则它对所有打开标准I/O流的效果应当与进程终止前对每个流调用fclose相同。 系统V早期的版本中，abort函数产生SIGIOT信号。更进一步，进程忽略此信号，或者捕捉它并从信号处理程序返回都是可能的，在返回情况下，abort返回到它的调用者。 4.3BSD产生SIGILL信号。在此之前，该函数解除对此信号的阻塞，将其配置恢复为SIG_DFL (终止并构造core文件)。这阻止一个进程忽略或捕捉此信号。 SVR4在产生此信号之前关闭所有I/O流。在另一方面，4.3+BSD则不做此操作。对于保护性的程序设计，如果希望刷新标准I/O流，则在调用abort之前要做这种操作。在err_dump函数中实现了这一点 因为大多数UNIX tmpfile(临时文件)的实现在创建该文件之后立即调用unlink，所以ANSI C关于临时文件的警告通常与我们无关。 abort的POSIX.1实现 #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> void abort ( void ) /*POSIX.1风格的abort()实现*/ { sigset_t mask ; struct sigaction action ; /* * Caller can't igore SIGABRT, if so reset to default. */ sigaction ( SIGABRT , NULL , & action ); if ( action . sa_handler == SIG_IGN ) { action . sa_handler == SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); } if ( action . sa_handler == SIG_DFL ) fflush ( NULL ) /* flush all open stdio stream */ /* * Caller can't block SIGABRT; make sure it's unblocked. */ sigfillset ( & mask ) sigdelset ( & mask , SIGABRT ); /* mask has only SIGABRT turned off */ sigprocmask ( SIG_SETMASK , & mask , NULL ); kill ( getpid (), SIGABRT ); /* send the signal */ /* * if we're here, process caught SIGABRT and returned. */ fflush ( NULL ); /*flush all open stdio streams*/ action . sa_handler = SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); /* reset to default */ sigprocmask ( SIG_SETMASK , & mask , NULL ); /* just in case ...*/ kill ( getpid (), SIGABRT ); /* and one more time*/ exit ( 1 ); /*this should never be executed...*/ 说明：首先查看是否将执行默认动作，若是则冲洗所有标准I/O流。这并不等价于对所有打开的流调用fclose(因为只冲洗，并不关闭它们），但是当进程终止时，系统会关闭所有打开的文件。如果进程捕捉此信号并返回， 那么因为进程产生了更多的输出，所以再一次冲洗所有的流。不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调用_exit或_Exit.这种情况下，内存中任何未冲洗的标准I/O缓冲区都被丢弃。我们假定捕捉此信号，而且_exit或_Exit的调用者并不想要冲洗缓冲区。 应用例子： #include <stdio.h> #include <stdlib.h> void main ( void ) { FILE * stream ; if (( stream = fopen ( \"NOSUCHF.ILE\" , \"r\" )) == NULL ) { perror ( \"Couldn't open file\" ); abort (); } } else fclose ( stream ); } 编译运行一下，看一下执行情况片段： execve(\"./test.o\", [\"./test.o\"], [/* 97 vars */]) = 0 open(\"NOSUCHF.ILE\", O_RDONLY) = -1 ENOENT (No such file or directory) dup(2) = 3 fcntl(3, F_GETFL) = 0x8402 (flags O_RDWR|O_APPEND|O_LARGEFILE) fstat(3, {st_mode=S_IFCHR|0600, st_rdev=makedev(136, 3), ...}) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd18aa86000 write(3, \"Couldn't open file: No such file\"..., 46Couldn't open file: No such file or directory ) = 46 close(3) = 0 munmap(0x7fd18aa86000, 4096) = 0 rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0 gettid() = 18489 tgkill(18489, 18489, SIGABRT) = 0 SIGABRT {si_signo=SIGABRT, si_code=SI_TKILL, si_pid=18489, si_uid=0} --- +++ killed by SIGABRT +++ 已放弃 abort测试代码说明 代码大体结构 |- macro || NUM || MIN_RLIMIT_CORE | |- variable || TCID || TST_TOTAL | |- function || main || setup || cleanup || do_child || instress 先看一下头文件： #include <sys/types.h> #include <sys/wait.h> #include <errno.h> #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/resource.h> #include \"test.h\" #include \"safe_macros.h\" 什么是头文件呢？ 在C语言家族程序中，头文件被大量使用。一般而言，每个C++/C程序通常由头文件(header files)和定义文件(definition files)组成。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明(declaration)，而定义文件用于保存程序的实现 (implementation) 让我们来看，经典程序 \"Hello world!\" 定义文件名\"First.c\" main() <sample-1> 看看上面的程序，没有.h文件,因为程序太简单，没有需要保存的声明。 文件名 First.c 变形 printStr() { printf(\"Hello world!\"); } main() { printStr() } <sample-2> 还是没有, 那就让我们把这个程序再稍微改动一下. 文件名 First.c main() { printStr() } printStr() { printf(\"Hello world!\"); } <sample-3> sample3和sample2是不同的，pritStr()函数定义的顺序不同。sample3是编译不通过的。这里面涉及作用域的问题。在这里只讲述与.h文件相关的顶层作用域。 顶层作用域就是从声明点延伸到源程序文本结束, 就printStr()这个函数来说，他没有单独的声明,只有定义,那么就从他定义的行开始,到first.c文件结束。sample2中，printStr的定义在main函数前面，所以作用域覆盖main函数，而sample3则没有。 这种情况怎么办呢? 有两种方法 ,一个pritStr函数定义到main函数之前，那就让我们来看另一个例子,让我们看看这个方法是不是在任何时候都会起作用. 文件名 First.c play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… } main() { play1() } <sample-4> 函数嵌套, 那么play1和play2这两个函数哪个放到前面呢? 这时就需要我们来使用第二种方法,使用声明. 文件名 First.c play1(); play2(); play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-5> 一个大型的软件项目,可能有几千个,上万个play, 而不只是play1,play2这么简单, 这样就可能有N个类似 play1(); play2(); 这样的声明, 这个时候就需要我们想办法把这样的play1(); play2(); 也另行管理, 而不是把他放在.c文件中, 于是.h文件出现了. 文件名 First.h play1(); play2(); 文件名 First.C #include \"first.h\" play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-6> 如在second.c中还有一个函数需要调用first.c文件中的play1函数, 如何实现呢? Sencond.h 文件 play1(); sencond.c文件 ***() { ……………. Play(); ………………. } <sample-7> 在sencond.h文件内声明play1函数，怎么能调用到first.c文件中的哪个play1函数中呢? 是不是搞错了，没有搞错, 这里涉及到c语言的另一个特性:存储类说明符. C语言的存储类说明符有以下几个, 我来列表说明一下 说明符 用法 Auto 只在块内变量声明中被允许, 表示变量具有本地生存期. Extern 出现在顶层或块的外部变量函数与变量声明中，表示声明的对象具有静态生存期, 连接程序知道其名字. Static 可以放在函数与变量声明中. 在函数定义时, 其只用于指定函数名,而不将函数导出到连接程序. 在函数声明中,表示其后面会有定义声明的函数, 存储类为static. 在数据声明中, 总是表示定义的声明不导出到连接程序. 无疑, 在sample7中的second.h和first.h中,需要我们用extern标志符来修饰play1函数的声明,这样,play1()函数就可以被导出到连接程序, 也就是实现了无论在first.c文件中调用,还是在second.c文件中调用,连接程序都会很聪明的按照我们的意愿,把他连接到first.c文件中的play1函数的定义上去, 而不必我们在second.c文件中也要再写一个一样的play1函数. 但随之有一个小问题, 在sample7中,我们并没有用extern标志符来修饰play1啊, 这里涉及到另一个问题, C语言中有默认的存储类标志符. C99中规定, 所有顶层的默认存储类标志符都是extern . 那么我们如何来区分哪个头文件中的声明在其对应的.c文件中有定义,而哪个又没有呢? 这也许不是必须的，因为无论在哪个文件中定义，聪明的连接程序都会义无返顾的帮我们找到，并导出到连接程序, 但我觉得他确实必要的. 因为我们需要知道这个函数的具体内容是什么,有什么功能, 有了新需求后我也许要修改他， 我需要在短时间内能找到这个函数的定义, 那么我来介绍一下在C语言中一个人为的规范: 在.h文件中声明的函数,如果在其对应的.c文件中有定义,那么我们在声明这个函数时,不使用extern修饰符, 如果反之,则必须显示使用extern修饰符. 这样,在C语言的.h文件中,我们会看到两种类型的函数声明. 带extern的,还不带extern的, 简单明了,一个是引用外部函数，一个是自己声明并定义的函数. 最终如下: Sencond.h 文件 Extern play1(); 那么多都是针对函数的，而实际上.h文件却不是为函数所专用的，还有全局变量. 在大型项目中，对全局变量的使用不可避免, 比如,在first.c中需要使用一个全局变量G_test, 那么我们可以在first.h中,定义 TPYE G_test. 与对函数的使用类似, 在second.c中我们的开发人员发现他也需要使用这个全局变量, 而且要与first.c中一样的那个, 如何处理? 对,我们可以仿照函数中的处理方法, 在second.h中再次声明TPYE G_test, 根据extern的用法,以及c语言中默认的存储类型, 在两个头文件中声明的TPYE G_test,其实其存储类型都是extern, 也就是说不必我们操心, 连接程序会帮助我们处理一切. 但我们又如何区分全局变量哪个是定义声明,哪个是引用声明呢?这个比函数要复杂一些, 一般在C语言中有如下几种模型来区分: 1、 初始化语句模型 顶层声明中，存在初始化语句是，表示这个声明是定义声明，其他声明是引用声明。C语言的所有文件之中，只能有一个定义声明。 按照这个模型，我们可以在first.h中定义如下TPYE G_test=1；那么就确定在first中的是定义声明，在其他的所有声明都是引用声明。 2、 省略存储类型说明 在这个模型中，所有引用声明要显示的包括存储类extern， 而每个外部变量的唯一定义声明中省略存储类说明符。 这个与我们对函数的处理方法类似，不再举例说明。 这里还有一个需要说明，数组全局变量。 在声明定义时，定义数组如下： int G_glob[100]; 在另一个文件中引用声明如下： int * G_glob; 在vc中，是可以编译通过的， 这种情况大家都比较模糊并且需要注意，数组与指针类似，但并不等于说对数组的声明起变量就是指针。 上面所说的的程序在运行时发现了问题，在引用声明的那个文件中，使用这个指针时总是提示内存访问错误，原来我们的连接程序并不把指针与数组等同，连接时，也不把他们当做同一个定义，而是认为是不相关的两个定义，当然会出现错误。正确的使用方法是在引用声明中声明如下： int G_glob[10]; 并且最好再加上一个extern，更加明了。 extern int G_glob[10]; 另外需要说明的是，在引用声明中由于不需要涉及到内存分配，可以简化如下，这样在需要对全局变量的长度进行修改时，不用把所有的引用声明也全部修改了。 extern int G_glob[]; 接下来，看一下linux环境编程头文件常用的有哪些？ linux常用头文件 POSIX标准定义的头文件 | 文件名 | 内容 | | ------- | -------- | dirent.h | 目录项 | fcntl.h | 文件控制 | fnmatch.h | 文件名匹配类型 | glob.h | 路径名模式匹配类型 | grp.h | 组文件 | <netdb.h> | 网络数据库操作 | <pwd.h> | 口令文件 | <regex.h> | 正则表达式 | <tar.h> | TAR归档值 | <termios.h> | 终端I/O | <unistd.h> | 符号常量 | <utime.h> | 文件时间 | <wordexp.h> | 字符扩展类型 | <arpa/inet.h> | INTERNET定义 | <net/if.h> | 套接字本地接口 | <netinet/in.h> | INTERNET地址族 | <netinet/tcp.h> | 传输控制协议定义 | <sys/mman.h> | 内存管理声明 | <sys/select.h> | Select函数 | <sys/socket.h> | 套接字借口 | <sys/stat.h> | 文件状态 | <sys/times.h> | 进程时间 | <sys/types.h> | 基本系统数据类型 | <sys/un.h> | UNIX域套接字定义 | <sys/utsname.h> | 系统名 | <sys/wait.h> | 进程控制 POSIX定义的XSI扩展头文件 | 文件名 | 内容 | | ------- | -------- | <cpio.h> | cpio归档值 | <dlfcn.h> | 动态链接 | <fmtmsg.h> | 消息显示结构 | <ftw.h> | 文件树漫游 | <iconv.h> | 代码集转换使用程序 | <langinfo.h> | 语言信息常量 | <libgen.h> | 模式匹配函数定义 | <monetary.h> | 货币类型 | <ndbm.h> | 数据库操作 | <nl_types.h> | 消息类别 | <poll.h> | 轮询函数 | <search.h>| 搜索表 | <strings.h> | 字符串操作 | <syslog.h> | 系统出错日志记录 | <ucontext.h> | 用户上下文 | <ulimit.h> | 用户限制 | <utmpx.h> | 用户帐户数据库 | <sys/ipc.h> | IPC(命名管道) | <sys/msg.h> | 消息队列 | <sys/resource.h>| 资源操作 | <sys/sem.h> | 信号量 | <sys/shm.h> | 共享存储 | <sys/statvfs.h> | 文件系统信息 | <sys/time.h> | 时间类型 | <sys/timeb.h> | 附加的日期和时间定义 | <sys/uio.h> | 矢量I/O操作 POSIX定义的可选头文件 | 文件名 | 内容 | | ------- | -------- | <aio.h> | 异步I/O | <mqueue.h> | 消息队列 | <pthread.h> | 线程 | <sched.h> | 执行调度 | <semaphore.h> | 信号量 | <spawn.h> | 实时spawn接口 | <stropts.h> | XSI STREAMS接口 | <trace.h> | 事件跟踪 C/C++头文件一览 C语言 | 文件名 | 内容 | | ------- | -------- | <assert.h>| 设定插入点 | <ctype.h> | 字符处理 | <errno.h> | 定义错误码 | <float.h> | 浮点数处理 | <iso646.h> | 对应各种运算符的宏 | <limits.h> | 定义各种数据类型最值的常量 | <locale.h> | 定义本地化C函数 | <math.h> | 定义数学函数 | <setjmp.h> | 异常处理支持 | <signal.h> | 信号机制支持 | <stdarg.h> | 不定参数列表支持 | <stddef.h> | 常用常量 | <stdio.h> | 定义输入／输出函数 | <stdlib.h>| 定义杂项函数及内存分配函数 | <string.h> | 字符串处理 | <time.h> | 定义关于时间的函数 | <wchar.h> | 宽字符处理及输入／输出 | <wctype.h> | 宽字符分类 传统C++ | 文件名 | 内容 | | ------- | -------- | <fstream.h> | 改用<fstream> | <iomanip.h> | 改用<iomainip> | <iostream.h> | 改用<iostream> | <strstrea.h> | 该类不再支持，改用<sstream>中的stringstream 标准C++ | 文件名 | 内容 | | ------- | -------- | <algorithm> | 通用算法 | <bitset> | 位集容器 | <cctype> | 字符处理 | <cerrno> | 定义错误码 | <cfloat> | 浮点数处理 | <ciso646> | 对应各种运算符的宏 | <climits> | 定义各种数据类型最值的常量 | <clocale> | 定义本地化函数 | <cmath> | 定义数学函数 | <complex> | 复数类 | <csignal> | 信号机制支持 | <csetjmp> | 异常处理支持 | <cstdarg> | 不定参数列表支持 | <cstddef> | 常用常量 | <cstdio> | 定义输入／输出函数 | <cstdlib> | 定义杂项函数及内存分配函数 | <cstring> | 字符串处理 | <ctime> | 定义关于时间的函数 | <cwchar> | 宽字符处理及输入／输出 | <cwctype> | 宽字符分类 | <deque> | STL 双端队列容器 | <exception> | 异常处理类 | <fstream> | 文件输入／输出 | <al> | STL 定义运算函数（代替运算符） | <limits> | 定义各种数据类型最值常量 | <list> | STL 线性列表容器 | <locale> | 本地化特定信息 | <map> | STL 映射容器 | <memory> | STL通过分配器进行的内存分配 | <new> | 动态内存分配 | <numeric> | STL常用的数字操作 | <iomanip> | 参数化输入／输出 | <iOS> | 基本输入／输出支持 | <iosfwd> | 输入／输出系统使用的前置声明 | <iostream> | 数据流输入／输出 | <istream> | 基本输入流 | <iterator> | STL迭代器 | <ostream> | 基本输出流 | <queue> | STL 队列容器 | <set> | STL 集合容器 | <sstream> | 基于字符串的流 | <stack> | STL 堆栈容器 | <stdexcept> | 标准异常类 | <streambuf> | /底层输入／输出支持 | <string> | 字符串类 | <typeinfo> | 运行期间类型信息 | <utility> | STL 通用模板类 | <valarray> | 对包含值的数组的操作 | <vector> | STL 动态数组容器 C99增加的部分 | 文件名 | 内容 | | ------- | -------- | <complex.h> | 复数处理 | <fenv.h> | 浮点环境 | <inttypes.h> | 整数格式转换 | <stdbool.h> | 布尔环境 | <stdint.h> | 整型环境 | <tgmath.h> | 通用类型数学宏 回到abort01的测试上来。先看一下执行情况： abort01 0 TINFO : Adjusting RLIMIT_CORE to 1048576 abort01 1 TPASS : abort dumped core abort01 2 TPASS : abort raised SIGIOT abort01 3 TPASS : abort dumped core abort01 4 TPASS : abort raised SIGIOT abort01 5 TPASS : abort dumped core abort01 6 TPASS : abort raised SIGIOT 程序后台执行片段 chdir(\"/tmp/aboeHLyFk\") = 0 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19587 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19587 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19587, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 1 TPASS : abort d\"..., 43abort01 1 TPASS : abort dumped core ) = 43 write(1, \"abort01 2 TPASS : abort r\"..., 45abort01 2 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19588 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19588 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19588, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 3 TPASS : abort d\"..., 43abort01 3 TPASS : abort dumped core ) = 43 write(1, \"abort01 4 TPASS : abort r\"..., 45abort01 4 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19589 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19589 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19589, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 5 TPASS : abort d\"..., 43abort01 5 TPASS : abort dumped core ) = 43 write(1, \"abort01 6 TPASS : abort r\"..., 45abort01 6 TPASS : abort raised SIGIOT ) = 45 unlink(\"core\") 从测试log来看，abort01主要进行abort\"dumped core\"、和\"raised SIGIOT\"两种测试，并且测试了３遍。０为setup打印信息。 #define NUM 3 /*定义fork进程的数量*/ char *TCID; /* tescase的名字*/ int TST_TOTAL; /* testcases数量 */ 主要函数 static void setup(void); static void cleanup(void); static void do_child(); static int instress(); int main(int argc, char *argv[]) 分别分析这几个函数 setup #define MIN_RLIMIT_CORE (1024 * 1024) static void setup(void) { struct rlimit rlim; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); if (rlim.rlim_cur < MIN_RLIMIT_CORE) { test_resm(TINFO, \"Adjusting RLIMIT_CORE to %i\", MIN_RLIMIT_CORE); rlim.rlim_cur = MIN_RLIMIT_CORE; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); } tst_tmpdir() } setup函数的目的是为了调整RLIMIT_CORE的大小。在Linux系统中，Resouce limit指在一个进程的执行过程中，它所能得到的资源的限制，比如进程的core file的最大值，虚拟内存的最大值等。Resouce limit的大小可以直接影响进程的执行状况。其有两个最重要的概念：soft limit 和 hard limit。 struct rlimit { rlim_t rlim_cur; rlim_t rlim_max; }; 是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件 数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。 tst_tmpdir函数说明一下，该函数用来为ltp测试程序创建临时目录，目录名case名称＋随机字母。 cleanup函数 static void cleanup(void) { unlink(\"core\") tst_rmdir(); } 该函数比较简单，用来清理产生的临时文件和软连接。可以做下试验，将main函数中的该函数注释掉，会在tmp下看到产生的core文件。 do_child函数 static void do_child(void) { abort() fprintf(stderr, \"\\tchild - abort failed.\\n\"); exit(1); } abort的调用，进程退出。 instress函数 static int instress(void) { test_resm(TINFO, \"System resources may be too low; fork(), select() etc are likely to fail.\"); return 1; } 系统资源比较低的情况， 出现fork()等调用失败时的处理。也是为兼容UCLINUK测试（如嵌入式系统）。 main函数 控制测试流程和主要的测试代码，以下将重点介绍一些代码片段。 #ifdef WCOREDUMP int core ; core = 0 ; #endif WCOREDUMP(status) 如果孩子进程产生核心转储文件则返回真。这个宏只应该在 WIFSIGNALED 返回真时调用。这个没有在 POSIX.1-2001 里指定并且在一些 UNIX 实现(如 AIX、SunOS)里也没有提供。只在 #ifdef WCOREDUMP ... #endif 内部使用。 #ifdef UCLINUX maybe_run_child ( & do_child , \"\" ); /* UCLINUX的情况 */ #endif setup (); /*调用setup函数*/ for ( i = 0 ; i < NUM ; i ++ ) { /*连续创建３个进程调用do_child函数*/ kidpid = FORK_OR_VFORK (); if ( kidpid == 0 ) { #ifdef UCLINUX if ( self_exec ( argv [ 0 ], \"\" )) { if ( ! instress ()) { perror ( \"fork failed\" ); exit ( 1 ); } } #else do_child (); //调用do_child()函数 #endif } } if ( kidpid < 0 ) if ( ! instress ()) tst_brkm ( TBROK | TERRNO , cleanup , \"fork failed\" ); count = 0 ; while (( child = wait ( & status )) > 0 ) count ++ ; if ( count != 1 ) { tst_brkm ( TBROK , cleanup , \"wrong # children waited on; got %d, expected 1\" , count ); } #ifdef WCOREDUMP core = WCOREDUMP ( status ); //WCOFEDUMP情况 #endif sig = WTERMSIG ( status ); } if ( WIFEXITED ( status )) ex = WEXITSTATUS ( status ); #ifdef WCOREDUMP if ( core == 0 ) { tst_brkm ( TFAIL , cleanup , \"Child did not dump core; exit code = %d, \" \"signal = %d\" , ex , sig ); } else if ( core != - 1 ) { tst_resm ( TPASS , \"abort dumped core\" ); //core值等于０，则没有正常产生core文件，如果core不等于０且不等于-1，说明正常产生了core文件 } #endif if ( sig == SIGIOT ) { tst_resm ( TPASS , \"abort raised SIGIOT\" ); //发出的信号如果为SIGIOT说明信号触发正常 } else { tst_brkm ( TFAIL , cleanup , \"Child did not raise SIGIOT (%d); exit code = %d, \" \"signal = %d\" , SIGIOT , ex , sig ); } } abort测试分析结束。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-abort"},{"url":"http://king32783784.github.io/2016/08/01/LTP/","text":"syscalls ltp中kernel测试比重很大，尤其是syscalls，包括一下用例： 注：测试内容分析时补充。 用例名称 测试内容 abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev 接下来按照顺序分析系统调用的每一个case,并将每个case的测试内容补充到本文。 附linux系统主要系统调用列表 一、进程控制 fork 创建一个新进程 clone 按指定条件创建子进程 execve 运行可执行文件 exit 中止进程 _exit 立即中止当前进程 getdtablesize 进程所能打开的最大文件数 getpgid 获取指定进程组标识号 setpgid 设置指定进程组标志号 getpgrp 获取当前进程组标识号 setpgrp 设置当前进程组标志号 getpid 获取进程标识号 getppid 获取父进程标识号 getpriority 获取调度优先级 setpriority 设置调度优先级 modify_ldt 读写进程的本地描述表 nanosleep 使进程睡眠指定的时间 nice 改变分时进程的优先级 pause 挂起进程，等待信号 personality 设置进程运行域 prctl 对进程进行特定操作 ptrace 进程跟踪 sched_get_priority_max 取得静态优先级的上限 sched_get_priority_min 取得静态优先级的下限 sched_getparam 取得进程的调度参数 sched_getscheduler 取得指定进程的调度策略 sched_rr_get_interval 取得按RR算法调度的实时进程的时间片长度 sched_setparam 设置进程的调度参数 sched_setscheduler 设置指定进程的调度策略和参数 sched_yield 进程主动让出处理器,并将自己等候调度队列队尾 vfork 创建一个子进程，以供执行新程序，常与execve等同时使用 wait 等待子进程终止 wait3 参见wait waitpid 等待指定子进程终止 wait4 参见waitpid capget 获取进程权限 capset 设置进程权限 getsid 获取会晤标识号 setsid 设置会晤标识号 二、文件系统控制 1、文件读写操作 fcntl 文件控制 open 打开文件 creat 创建新文件 close 关闭文件描述字 read 读文件 write 写文件 readv 从文件读入数据到缓冲数组中 writev 将缓冲数组里的数据写入文件 pread 对文件随机读 pwrite 对文件随机写 lseek 移动文件指针 _llseek 在64位地址空间里移动文件指针 dup 复制已打开的文件描述字 dup2 按指定条件复制文件描述字 flock 文件加/解锁 poll I/O多路转换 truncate 截断文件 ftruncate 参见truncate umask 设置文件权限掩码 fsync 把文件在内存中的部分写回磁盘 2、文件系统操作 access 确定文件的可存取性 chdir 改变当前工作目录 fchdir 参见chdir chmod 改变文件方式 fchmod 参见chmod chown 改变文件的属主或用户组 fchown 参见chown lchown 参见chown chroot 改变根目录 stat 取文件状态信息 lstat 参见stat fstat 参见stat statfs 取文件系统信息 fstatfs 参见statfs readdir 读取目录项 getdents 读取目录项 mkdir 创建目录 mknod 创建索引节点 rmdir 删除目录 rename 文件改名 link 创建链接 symlink 创建符号链接 unlink 删除链接 readlink 读符号链接的值 mount 安装文件系统 umount 卸下文件系统 ustat 取文件系统信息 utime 改变文件的访问修改时间 utimes 参见utime quotactl 控制磁盘配额 三、系统控制 ioctl I/O总控制函数 _sysctl 读/写系统参数 acct 启用或禁止进程记账 getrlimit 获取系统资源上限 setrlimit 设置系统资源上限 getrusage 获取系统资源使用情况 uselib 选择要使用的二进制函数库 ioperm 设置端口I/O权限 iopl 改变进程I/O权限级别 outb 低级端口操作 reboot 重新启动 swapon 打开交换文件和设备 swapoff 关闭交换文件和设备 bdflush 控制bdflush守护进程 sysfs 取核心支持的文件系统类型 sysinfo 取得系统信息 adjtimex 调整系统时钟 alarm 设置进程的闹钟 getitimer 获取计时器值 setitimer 设置计时器值 gettimeofday 取时间和时区 settimeofday 设置时间和时区 stime 设置系统日期和时间 time 取得系统时间 times 取进程运行时间 uname 获取当前UNIX系统的名称、版本和主机等信息 vhangup 挂起当前终端 nfsservctl 对NFS守护进程进行控制 vm86 进入模拟8086模式 create_module 创建可装载的模块项 delete_module 删除可装载的模块项 init_module 初始化模块 query_module 查询模块信息 *get_kernel_syms 取得核心符号,已被query_module代替 四、内存管理 brk 改变数据段空间的分配 sbrk 参见brk mlock 内存页面加锁 munlock 内存页面解锁 mlockall 调用进程所有内存页面加锁 munlockall 调用进程所有内存页面解锁 mmap 映射虚拟内存页 munmap 去除内存页映射 mremap 重新映射虚拟内存地址 msync 将映射内存中的数据写回磁盘 mprotect 设置内存映像保护 getpagesize 获取页面大小 sync 将内存缓冲区数据写回硬盘 cacheflush 将指定缓冲区中的内容写回磁盘 五、网络管理 getdomainname 取域名 setdomainname 设置域名 gethostid 获取主机标识号 sethostid 设置主机标识号 gethostname 获取本主机名称 sethostname 设置主机名称 六、socket控制 socketcall socket系统调用 socket 建立socket bind 绑定socket到端口 connect 连接远程主机 accept 响应socket连接请求 send 通过socket发送信息 sendto 发送UDP信息 sendmsg 参见send recv 通过socket接收信息 recvfrom 接收UDP信息 recvmsg 参见recv listen 监听socket端口 select 对多路同步I/O进行轮询 shutdown 关闭socket上的连接 getsockname 取得本地socket名字 getpeername 获取通信对方的socket名字 getsockopt 取端口设置 setsockopt 设置端口参数 sendfile 在文件或端口间传输数据 socketpair 创建一对已联接的无名socket 七、用户管理 getuid 获取用户标识号 setuid 设置用户标志号 getgid 获取组标识号 setgid 设置组标志号 getegid 获取有效组标识号 setegid 设置有效组标识号 geteuid 获取有效用户标识号 seteuid 设置有效用户标识号 setregid 分别设置真实和有效的的组标识号 setreuid 分别设置真实和有效的用户标识号 getresgid 分别获取真实的,有效的和保存过的组标识号 setresgid 分别设置真实的,有效的和保存过的组标识号 getresuid 分别获取真实的,有效的和保存过的用户标识号 setresuid 分别设置真实的,有效的和保存过的用户标识号 setfsgid 设置文件系统检查时使用的组标识号 setfsuid 设置文件系统检查时使用的用户标识号 getgroups 获取后补组标志清单 setgroups 设置后补组标志清单 八、进程间通信 ipc 进程间通信总控制调用 1、信号 sigaction 设置对指定信号的处理方法 sigprocmask 根据参数对信号集中的信号执行阻塞/解除阻塞等操作 sigpending 为指定的被阻塞信号设置队列 sigsuspend 挂起进程等待特定信号 signal 参见signal kill 向进程或进程组发信号 *sigblock 向被阻塞信号掩码中添加信号,已被sigprocmask代替 *siggetmask 取得现有阻塞信号掩码,已被sigprocmask代替 *sigsetmask 用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替 *sigmask 将给定的信号转化为掩码,已被sigprocmask代替 *sigpause 作用同sigsuspend,已被sigsuspend代替 sigvec 为兼容BSD而设的信号处理函数,作用类似sigaction ssetmask ANSI C的信号处理函数,作用类似sigaction 2、消息 msgctl 消息控制操作 msgget 获取消息队列 msgsnd 发消息 msgrcv 取消息 3、管道 pipe 创建管道 4、信号量 semctl 信号量控制 semget 获取一组信号量 semop 信号量操作 5、共享内存 shmctl 控制共享内存 shmget 获取共享内存 shmat 连接共享内存 shmdt 拆卸共享内存","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls"},{"url":"http://king32783784.github.io/2016/06/03/LTP/","text":"file file 用例主要用于测试file命令。 file命令介绍 file命令可以通过查看文件内容来找出特定类型的文件，在UNIX/ Linux系统中，文件类型并不是由文件扩展名来决定的(windows中却正是这么做的),file命令的目的是从多个文件中收集文件类型统计信息。 file --help Usage: file [OPTION...] [FILE...] Determine type of FILEs. --help display this help and exit -v, --version output version information and exit -m, --magic-file LIST use LIST as a colon-separated list of magic number files -z, --uncompress try to look inside compressed files -Z, --uncompress-noreport only print the contents of compressed files -b, --brief do not prepend filenames to output lines -c, --checking-printout print the parsed form of the magic file, use in conjunction with -m to debug a new magic file before installing it -e, --exclude TEST exclude TEST from the list of test to be performed for file. Valid tests are: apptype, ascii, cdf, compress, elf, encoding, soft, tar, text, tokens -f, --files-from FILE read the filenames to be examined from FILE -F, --separator STRING use string as separator instead of `:' -i, --mime output MIME type strings (--mime-type and --mime-encoding) --apple output the Apple CREATOR/TYPE --extension output a slash-separated list of extnsions --mime-type output the MIME type --mime-encoding output the MIME encoding -k, --keep-going don't stop at the first match -l, --list list magic strength -L, --dereference follow symlinks (default) -h, --no-dereference don't follow symlinks -n, --no-buffer do not buffer output -N, --no-pad do not pad output -0, --print0 terminate filenames with ASCII NUL -p, --preserve-date preserve access times on files -P, --parameter set file engine parameter limits indir 15 recursion limit for indirection name 30 use limit for name/use magic elf_notes 256 max ELF notes processed elf_phnum 128 max ELF prog sections processed elf_shnum 32768 max ELF sections processed -r, --raw don't translate unprintable chars to \\ooo -s, --special-files treat special (block/char devices) files as ordinary ones -C, --compile compile file specified by -m -d, --debug print debugging messages 必要参数 -b 文件名不显示 -c 显示详细处理信息 -L 操作对象为符号链接所指向的对象 -z 压缩文件的处理 -C 列出magic.mgc的输出 -n 将结果输出到标准输出 -f<文件名> 指定文件名 -m<文件名> 指定魔法数字名 选择参数 --help 显示帮助信息 -v 显示版本信息 实例： 1.查看所有文件类型 file * 2.2.查看具体某一文件的类型：file filename 3.-b参数，打印出不包含文件名的文件类型信息: 4.-z 参数，可以获取用gzip、zip压缩过的文件的类型 5.-n参数，将信息标准输出 言归正传，file_test.sh 脚本主要验证是否支持多种文件格式，比如tar tar.gz rpm c ascii elf等。 用例设置： Test01：测试文件命令是否识别ASCII文本文件 1）将文本写入已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.txt 3）grep为关键字\"ASCII文本\"的输出 'file'命令 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test02：测试文件命令是否能识别bash shell脚本 1）将一个小shell脚本写入一个已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.sh 3）从'file'命令的输出中Grep关键字\"Bourne-Again shell脚本\" 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test03：测试文件命令是否能识别bash shell脚本 使用Korn shell脚本执行类似的测试（如Test02） Test04：测试文件命令是否可以识别C shell脚本 使用C shell脚本执行类似的测试（如Test02） Test05：测试文件命令是否可以识别C程序文本 使用test2类似方法测试c程序文本 Test06：测试文件命令是否可以识别ELF二进制可执行文件 1）使用readelf确定主机是大端还是小端,并分别为字符串\"MSB\"或\"LSB\"分配TEST_ARCH 2）将小C程序写入已知的\".c\"文件 3）使用\"cc\" Ex：cc xyz xyz.c 4）使用file命令获取对象文件的类型 5）在file输出中，grep ELF .*-bit $ TEST_ARCH executable, .* 字符。 6）如果上述命令成功，则将测试声明为PASS Test07：测试文件命令是否可以识别tar文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar 4）grep从上面的'file'命令的输出的中匹配字符串\"tar\" 5）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL Test08：测试文件命令是否可以tar zip文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用'gzip'命令来压缩tar文件 例如：gzip -f xyz.tar 4）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar.gz 5）grep从上面的文件commnand字符串\"gzip压缩数据，。*\" 6）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL 代码片段 测试file命令能识别出ASCII文本文件。 export TCID=file01 export TST_COUNT=1 $ LTPBIN /tst_resm TINFO \"TEST # 1:file command recogizes ASCII text files\" # log信息 cat > $ LTPTMP /test_file.txt <<EOF this is a text file to test file command EOF # 制作txt文本文件 ## 执行file命令并检查输出。 file $ LTPTMP /test_file.txt > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] # 判断返回值是否为０，验证file命令执行是否成功 then grep -q \"ASCII text\" $ LTPTMP /file.out # 匹配输出类型是否整齐 if [ $ ? -eq 0 ] then $ LTPBIN /test_resm TPASS \"file: Recognised ASCII file correctly\" rm -f $ LTPTMP /test_file.txt else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise ASCII file correctlyi. Reason:\" TFAILCNT= $(( $ TFAILCNT + 1 )) # error code＋１ fi else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: failed to recognize ASCII file correctly\\t\\t\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi TEST #2 测试是否识别shell脚本 export TCID=file02 export TST_COUNT=2 $ LTPBIN /tst_resm TINFO \"TEST # 2: file command recognizes bash shell scripts\" cat > $ LTPTMP /bash_script.sh <<EOF # ! /bin/bash echo \"this is a shell script\" echo \"used to test file command\" EOF file $ LTPTMP /bash_script.sh > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] then grep -q \"Bourne-Again shell script\" $ LTPTMP /file.out if [ $ ? -eq 0 ] then $ LTPBIN /tst_resm TPASS \"file: Recognised bash shell script correctly\" rm -f $ LTPTMP /bash_script.sh else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise bash shell script. Reason\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi else $ LTPBIN /tst_resm TFAIL \"file: Failed to recognize bash shell script\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi 其他测试代码同上面类似，不再一一分析。","tags":"自动化测试-LTP","title":"LTP－Command-file"},{"url":"http://king32783784.github.io/2016/06/02/LTP/","text":"本节将重点分析commands部分的用例。 Command主要用例 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which ade ade包括对ar、file、ld、ldd、nm、objdump、size命令的验证测试。 ar ar命令是Linux的一个备份压缩命令，可以创建、修改备存文件(archive)，或从备存文件中抽取成员文件。备存文件以一定的结构打包一个至多个其它文件（即成员文件），且成员文件的内容、模式、时间戳等信息将被保存在备存文件中。常见的应用是，使用ar命令将多个目标文件（ .o）打包为静态链接库文件（ .a)。 引出一个问题，库是什么？本质上讲库是一种可执行代码的二进制形式，可以被操作系统加载到内存执行。linux库分为两种：静态库和动态库。区别在于，静态库是在编译过程中已经被载入可执行程序，可执行程序一般较大；共享库（动态库）是可执行程序运行时才加载到内存，编译时仅简单的引用，因此可执行程序较小。库是如何产生的呢？静态库的后缀是.a，它的产生分为两步：１．由源码编译生成一堆.o，每个.o包含这个编译单元的符号表；２．ar命令将很多.o文件打包转换为.a,形成静态库。 ar命令的常用参数 在 ar 命令中，可以从集 cClosTv 中指定任何数量的可选标志。必须从标志集 dhmopqrstwx 中指定一个标志。如果选择-m 或 -r 标志，您可能还要指定一个位置标志（-a 、-b 或-i ）；对于 -a 、-b 或-i 标志，您必须还指定在 ArchiveFile （PositionName ）中一个文件的名称，此名称紧跟在标志列表后，并由空格隔开。 -a PositionName 在 PositionName 参数标识的现有文件后安置指定的文件。 -b PositionName 在 PositionName 参数标识的现有文件前安置指定的文件。 -c 禁止在创建库 时产生的正常消息。 -C 阻止解压缩的文件替换文件系统中同名的文件。 -d 从库中删除指定的文件。 -g 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-g 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成小格式，这样该标志可用来将大格式压缩文档转换成小格式压缩文档。包含 64 位XCOFF 对象的压缩文档不能创建成或转换至小格式。 -h 将指定的文件的成员报头中的修改时间设置为当前日期和时间。如果不指定任何文件名称，则 ar 命令设置所有成员报头的时间戳记。此标志不能和-z 标志一起使用。 -i PositionName 在 PositionName 参数标识的现有文件前安置指定的文件（和 -b 相同）。 -l 将临时文件置于当前（本地）目录中，而非 TMPDIR 目录中（缺省为 /tmp ）。 -m 将指定的文件移动到库中的某个其它位置。缺省情况下，它将指定的文件移动到库的末尾。使用位置标志（abi ）来指定某个其它位置。 -o 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-o 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成大格式，这样该标志可用来将小格式压缩文档转换成大格式压缩文档。 -p 将 Files 参数中指定的文件的内容或在 ArchiveFile 参数中指定的所有文件（如果您不指定任何文件）都写至标准输出。 -q 将指定的文件添加到库的末尾。另外，如果指定同一个文件两次，它可能被放入库中两次。 -r 如果指定的文件已经存在于库中，则替换它。因为指定的文件在库中占据它们替换的文件的同一个位置，位置标志没有任何附加的影响。当和 -u 标志（更新）一起使用时，-r 标志仅替换自从最后一次添加到库中以后修改的文件。 如果指定的文件不存在于库中，则 ar 命令添加它。在这种情况下，位置标志影响放置。如果不指定位置，则将新文件置于库的末尾。如果指定同一个文件两次，它可能被放入库中两次。 -s 无论 ar 命令是否修改了库内容都强制重新生成库符号表。请在库上使用 strip 命令之后，使用此标志来恢复库符号表。 -t 将库的目录写至标准输出。如果指定文件名称，则仅显示指定的那些文件。如果不指定任何文件，-t 标志列出库中的所有文件。 -T 如果压缩文档成员名称比文件系统支持的长，则允许文件名称截短。此选项无效，因为文件系统支持的名称长度等于 255 个字符的最大压缩文档成员名称。 -u 仅复制自它们最后一次复制起更改的文件（请参阅先前讨论过的 -r 标志）。 -v 将建立新库的详细的逐个文件的描述写至标准输出。当和 -t 标志一起使用时，它给出类似于 ls -l 命令给出的长列表。当和 -x 标志一起使用时，它在每个文件前加一个名称。当和 -h 标志一起使用，它列出成员名称和更新的修改时间。 -w 显示压缩文档符号表。每个符号和其中定义此符号的文件的名称一起列出。 -x 通过将指定的文件复制到当前目录来解压缩它们。这些副本和原始文件（保留在库中）具有相同的名称。如果不指定任何文件，-x 标志复制库中的所有文件。此过程不会更改库。 -Xmode 指定 ar 应检查的目标文件的类型。mode 必须是以下项之一： 32 仅处理 32 位目标文件 64 仅处理 64 位目标文件 32_64 处理 32 位 和 64 位目标文件 缺省值是处理 32 位目标文件（忽略 64 位对象）。mode 还可以用 OBJECT_MODE 环境变量来设置。例如，OBJECT_MODE=64 使 ar 处理任何 64 位对象并忽略 32 位对象。-X 标志覆盖 OBJECT_MODE 变量。 -z 创建压缩文档的临时副本并对副本执行所有要求的修改。当所有操作成功完成时，压缩文档的工作副本覆盖原始副本。此标志不能和 -h 标志一起使用。 ArchiveFile 指定压缩文档文件名称；必需。 MemberName ... 各压缩文档成员的名称。 示例１．ar rcs libxxxx.a xx1.o xx2.o 参数r: 在库中插入模块（替换）。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 参数c: 创建一个库。不管库是否存在，都将创建。 参数s: 创建目标文件索引 这在创建较大的库时能加快时间。（补充：如果不需要创建索引，可改成大写S参数；如果。a文件缺少索引，可以使用ranlib命令添加） 示例２．创建一个库 ar -v -q lib.a strlen.o strcpy.o 如果 lib.a 库不存在，则此命令创建它，并将文件 strlen.o 和 strcpy.o 的副本输入其中。如果 lib.a 库存在，则此命令在不检查相同成员的情况下，将新的成员添加到末尾。v 标志设置详细方式，在此方式中ar 命令在其进行时显示进程报告。 示例３．显示库的目录 ar -v -t lib.a 此命令列出了 lib.a 库的目录，显示类似于 ls -l 命令的输出的长列表。要只列出成员文件名称，则省略-v 标志。 示例4. 替换或添加新成员到库中 ar -v -r lib.a strlen.o strcat.o 此命令替换成员 strlen.o 和 strcat.o 。如果 lib.a 如示例 1 中显示的那样创建，则替换strlen.o 成员。因为不存在名为 strcat.o 的成员，所以它被添加到库的末尾。 示例５. 指定在何处插入新成员 ar -v -r -b strlen.o lib.a strcmp.o 此命令添加 strcmp.o 文件，并将该新成员置于 strlen.o 成员之前。 示例６．要更新一个已经更改过的成员 ar -v -r -u lib.a strcpy.o 此命令替换现有 strcpy.o 成员，但仅当文件 strcpy.o 自从最后一次添加到库后已经修改时才替换它。 示例７ 要更改库成员的顺序 ar -v -m -a strcmp.o lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 移动到紧跟在 strcmp.o 成员之后的位置。保留 strcat.o 和 strcpy.o 成员的相对顺序。换句话说，如果在移动之前strcpy.o 成员在 strcat.o 成员之前，那么（移动后）它依旧如此。 示例８ 要解压缩库成员 ar -v -x lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 分别复制到名为 strcat.o 和 strcpy.o 的文件。 示例９ 要解压缩并重命名一个成员 ar -p lib.a strcpy.o >stringcopy.o 此命令将成员 strcpy.o 复制到一个名为 stringcopy.o 的文件。 示例10 要删除一个成员 ar -v -d lib.a strlen.o 此命令从 lib.a 库中删除成员 strlen.o 。 示例11 要从多个用 ld 命令创建的共享模块中创建一个压缩文档库 ar -r -v libshr.a shrsub.o shrsub2.o shrsub3.o ... 此命令从名为 shrsub.o 、shrsub2.o 、shrsub3.o 等等的共享模块中创建名为libshr.a 的压缩文档库。要编译并链接使用 libshr.a 压缩文档库的 main 程序，请使用以下命令： cc -o main main.c -L/u/sharedlib -lshr main 程序现在是可执行的。main 程序引用的任何符号（包含在libshr.a 压缩文档库中）已经因延迟分辨率而作了标记。-l 标志指定应在libshr.a 库中搜索这些符号。 示例12 要列出 lib.a 的内容（忽略任何 32 位目标文件） ar -X64 -t -v lib.a 要从 lib.a 解压缩所有 32 位的目标文件 ar -X32 -x lib.a 要列出 lib.a 中的所有文件，无论是 32 位、64 位或非对象，请输入： ar -X32_64 -t -v lib.a 示例13 在shell脚本中使用 Bash代码 OS= uname -r ar rcs libhycu.a.$OS *.o 示例14 在makefile中使用 Makefile代码 $（BIN1）: $（BIN1_OBJS） ar rcs $@ $&#94; 示例15 创建并使用静态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 如果test.c无误，就会得到test.o这个目标文件。 第三步：由。o文件创建静态库。 ar rcs libtest.a test.o 第四步：在程序中使用静态库。 gcc -o main main.c -L. -ltest 因为是静态编译，生成的执行文件可以独立于。a文件运行。 第五步：执行。 ./main 示例16 创建并使用动态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 前面两步与创建静态库一致。 第三步：由。o文件创建动态库文件。 gcc -shared -fPIC -o libtest.so test.o 第四步：在程序中使用动态库。 gcc -o main main.c -L. -ltest 当静态库和动态库同名时，gcc命令将优先使用动态库。 第五步：执行。 LD_LIBRARY_PATH=. ./main 接下来，看一下ltp是如何测试ar命令的。 ar文件下包括： ar01 file0.in file10.in file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in Makefile等文件，其中ar01是shell编写的测试脚本。 测试目的，测试ar命令的不同选项的功能。测试策略，通过比较单独指定参数和组合参数测试结果进行判断，如果相同测试通过，如果不同，测试失败。 ar测试项的参数为: export TCdat=$LTPROOT/testcases/bin; ar01 直接执行ar01即可。 测试条件，系统存在ar命令。在运行config时，会进行check:如 configure : 4165 : checking for ar configure : 4181 : found /bin/ ar configure : 4192 : result : ar 程序分析： 创建用到的临时文件 LIST=\"file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in file10.in\" LIST=\" $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST \" # Setup function setup() { for i in $ LIST ;do touch $ i done } 结果判定，判断子case的返回值是否为０，TCRESULT为标志位，初始值为０，出错TCRESULT置为１，不同测试内容分别返回不同的编号。 # Cleanup funciton cleanup() { if [ $ TCRESULT = 0 ];then echo \"-----------ar command passed the system test --------\" exit 0 else echo \"-----------ar command failed the system test --------\" exit 1 fi } crtest() { if [ $ ? -ne 0] then TCRESULT=1 echo \"FAIL - could not create lib.a\" cleanup fi } ttest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not output table from lib.a to lib.a.stdout\" cleanup fi } rtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not add file into lib.a\" cleanup fi } mtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not move file into lib.a\" cleanup fi } 通过结果判定的设置来看，主要验证ar命令的库的创建、库列表信息导出、往库中添加文件、移除库中的文件。 测试代码片段： 标志\"a\"：在 PositionName 参数标识的现有文件后安置指定的文件。 ar -cr $ TCtmp /lib.a file1.in file3.in crtest ar -ra file1.in $ TCtmp /lib.a file2.in rtest ar -t $ TCtmp /lib.a > $ TCtmp /lib.a.stdout tttest if diff -b $ TCtmp /lib.a.exp $ TCtmp /lib.a.stdout > /dev/null 2>&1 then echo \"-)1\" else TCRESULT=1 echo \"FAIL -ar with -a option does not place file after \"posname\" fi 具体测试内容列表： （１）The 'a' flag causes files to be placed after 'posname'. （２）The 'a' flag with the 'm' option causes files to be moved after 'posname' （３）The 'b' flag causes files to be placed before 'posname'. （４）The 'b' flag with 'm' option causes files to be moved before 'posname'. （５）-c option suppress the messages （６）The 'qc' option causes suppresion of the default message when 'afile' is created （７）The -d option deletes files from archive when names are specified. （８）The -d option does not delete files from archive when no names are specified. （９）The -d does not affect behaviour of -s option. （10）The 'i' flag causes files to be placed before 'posname'. （11) The 'i' flag with 'm' option causes files to be moved before 'posname'. (12) m option moves the files to end of the archive (13) The -p option causes only printing of contents of file contained in archive. (14) The -p does not affect behaviour of -s option. (15) The command 'ar -q afile name' appends name to the end of 'afile'. (16) q option does not affect the behaviour of option s (17) The -s causes regeneration of symbol table even if a symbol table exists. (18) ar with -t print as desired (19) The -t does not affect behaviour of -s option. (20)The 'u' flag causes files only with later modification date than in archive are replaced. (21) ar with -v flag to print a line for each file (22) The -v option produces a verbose listing like ls -n (23) The 'v' option causes the 'x' option to display a filename for each file extracted. (24) The command 'ar -x afile ' causes all files from the archive to be extracted. (25) The command 'ar -x afile name name' causes only named files from the archive to be extracted. (26) This test will fail under pan, so it's commented out by default. (27) Signal SIGHUP (28) Signal SIGQUIT (29) Signal SIGHUP; ar should not remove archive that existed before invocation. (30) Signal SIGINIT; ar should not remove archive that existed before invocation. (31) Signal SIGQUIT; ar should not remove archive that existed before invocation.","tags":"自动化测试-LTP","title":"LTP－Command"},{"url":"http://king32783784.github.io/2016/06/01/LTP/","text":"该topic将深入分析ltp的测试内容，着重于具体每个case的测试内容及测试方法。通过对ltp case的分析，加强linux系统的理解和用例设计。本节主要整理ltp的包括测试case的类型和case列表。 整体情况 case主要分为\"commands\"、\"kdump\"、\"kernel\"、\"misc\"、\"network\"、\"open_posix_testsuite\"、\"realtime\"、\"lib\"等部分，主要内容如下： 分类 包含内容 commands ade cpio df eject gzip logrotate mail mkfs sshd tar unzip which at cron du fileutils insmod lsmod mkswap su tmp-tools wc kernel connectors controllers firmware hotplug input ipc logging mce-test module power_management sched syscalls tracing containers device-drivers fs include io lib mem numa pty security times misc crash f00f math network busy_poll dctcp iptables netstress nfsv4 rpc stress tcp_fstopen virt can dhcp iproute lib6 multicast nfs sockets tcp_cmds traceroute xinetd open_posix_testsuite functional tools bin conformance stress realtime perf profiles stress lib kdump commands 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which kernel 主要case包括: case 包含子case connectors connector pec containers libclone mountns mqns netns pidns share sysvipc userns utsname controllers cgroup cgroup_xattr cpuctl cpuset io-throttle memcg pids cgroup_fg cpuacct cpuctl_fj freezer libcontrollers memctl device-drivers acpi base cpufreq drm locking misc_modules pci tbio usb zram agp block dev_sim_framework nls rcu rtc uaccess v4l firmware fw_load_kernel fw_load_user fs acl dmapi ext4-new-features fs_blnd fs_inod fs_perms fsstress ftest iso9660 linktest mongo proc racer stram acls doio fs-bench fs_di fs_main fs_readonly fsx-linux inode lftest openfile quota_remount scsi hotplug cpu_hotplug memory_hotplug input input io aio direct_io disktest ltp-aiodio stress_cd stress_floppy writetest ipc pipeio semaphore logging kmsg mem cpuset mem mtest01 mtest06 oom shmt thp vma hugetlb ksm mmapstress mtest05 mtest07 page swapping tunable vmtests moudle create_module delete_module query_module numa numa power_management pm_ilb_test runpwtests01-06 runpwtests_exelusive01-06 pm_cpu_consolidation pm_include pm_sched_domain pty hangup ptem pty sched cfs-scheduler clisrv hypertherading nptl process_stress pthreads sched_stress tool security cap_bound filecaps integrity mmc_security prot_hsymlinks securbits smack tomoyo syscalls abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev timers clock_gettime clock_settime leapsec timer_create timer_delete timer_settime tracing ftrace misc case 包含子case crash crash f00f foof math abs atof float fptests nextafter network case 包含子case can filter-test dctcp dctcp dhcp dhcp_tests dhcp_lib dnsmasq_tests iproute ip_tests iptables iptables_tests lib6 asapi getaddrinfo in6 multicast mc_cmds mc_commo mc_gethost mc_member mc_opts netstress netstress nfs fsx-linux nfslock01 nfsstat01 nfs_stress nfsv4 acl locks rpc basic_tests rpc-tirpc sockets socket stress broken_ip dns ftp http icmp interface ipsec multicast ns-tools route ssh tcp udp tcp_cmds arping echo ftp netstat rcp rsh sendfile tcpdump trackpath clockdiff finger host ipneigh ping rdist rlogin rwho ssh telnet tcp_fastopen tcp_fastopen traceroute traceroute virt gre01 ipvlan macvlan macvtap vlan vxlan xinted xinted open_posix_testsuite case 包含子case bin run-all-posix-option-group-tests conformance behavior definitions interfaces functional mqueues semaphores threads timers stress mqueues semaphores signals threads timers realtime case 包含子case func async_handler hrtimer-prio matrix_mult periodic_cpu_load pi-tests prio-wake rt-migrate sched_jitter thrad_clock gtod_latency measurement pi_perf prio-preempt pthread_kill_latency sched_football sched_letency m4 m4 perf latency stress pi-tests 接下来会深入分析每个case的具体测试目的及内容。ltp测试用例主要采用shell和Ｃ编写。","tags":"自动化测试-LTP","title":"LTP－Case list"},{"url":"http://king32783784.github.io/2016/03/11/python-howtosyi/","text":"Python HOWTOS 是一些单一的、特定的主题并试图覆盖python大部分内容，参考linux howto形成的集合，部分内容比python库包含更多的内容。 目前，包括这些topic. 将python2代码移植到python3 移植扩展模块到python3 Curses编程 Descriptor 使用方法 函数式编程方法 Logging使用方法 Logging Cookbook 正则表达式使用方法 Socket编程方法 排序使用方法 Unicode使用方法 如何通过urllib包获取网络资源 Argparse教程 IP地址模块介绍 参数解析方法 CPython中DTrace和SystemTap使用 将python2代码移植到python3 Python3是python的未来，与此同时，Python2仍然在使用，使用这两个主流版本的python开发项目是件好事。本指南将帮助我们如何更好的使用python2&3.如果想查看扩展模块级的信息，可以查看移植扩展模块到python3[].如果想了解python3的出现原因，可以查看Nick Coghlan's Python 3 Q&A . 简要说明 为了使你的项目兼容python2/3，基本步骤是： 1.只担心支持python2.7 2.确保测试覆盖，（ coverage.py ；pip install coverage) 3.学习python2&3的不同 4.使用 Modernize 或 Futurize 去更新代码（pip install modernize 或 pip install future) 5.使用 Pylint 确保没有回退到不支持python3(pip install pylint) 6.使用 caniusepython3 找出哪些依赖影响了python3的使用（pip install caniusepython3) 7.但这些依赖不在影响集成，需要确保可以一直兼容python2&3( tox 可以帮助你应付不同版本的测试；pip install tox) 如果放弃对python2的支持，在学习了python2&3的差异之后，可以通过 2&3 转换代码，并可以忽略其他步骤。 详细信息 同时支持python2&3的关键是今天你就可以开始了。尽管你的依赖现在不支持python3，并不意味着你的代码现在不支持python3.大多为了支持python3，需要清理python2的代码。 另一个关键是更新python2支持python3已有大量的自动化工具。 虽然必须让一些文字数据和二进制数据API去支持Python 3，但底层的转换工作可以由自动化工具去转换。 当更新代码以支持python2&3时，一定要记住这些要点的详细信息。 Drop support for Python 2.6 and older 尽管可以让python2.5支持python3,但只使用python2.7要简单的多。如果不打算放弃python2.5， six 可以帮助兼容python2.5和python3(pip install six).但这个专题，几乎不能提供帮助。 如果跳过python2.5和之前版本，一些必要的修改可以让你的代码看起来像纯正的ｐｙｔｈｏｎ代码。最坏的情况需要用函数替换一些方法或import的一些内置函数。 如果要尽量支持python2.7,python2.6以后将不再支持和进行bug 修复。 Make sure you specify the proper version support in your setup.py file 在setup.py文件中，需要你在 trove classifier 指定你支持python版本。如果你的代码不支持python3，你至少应该指定 Programming Language :: Python :: 2 :: only. 例如你同样需要指定哪个主版本，Programming Language :: Python :: 2.7 Have good test coverage 一旦你让你的代码支持python2早期的版本，你会想确保你的test suite足够覆盖你的代码。如果，你没有工具进行测试覆盖，coverage.py是个不错的选择。 Learn the differences between Python 2&3 当你准备好了代码和测试就可以开始支持python3了。 但要完全理解你的代码是如何改变的，你会想学习python2到python3的变化.通常比较好的方法是读python3每个版本的更新 What's New 和 Porting to Python3 .还有就是查看python未来项目 cheat sheet . Update your code 当你了解了python3&2不同之后，就可以更新你的代码了。有两个自动移植代码的工具可以选择：Modernize 和 Futurize.两个工具选择的依据是，你想让你的代码接近python3的程度。Futurize会尽力使Python 3语法同步到ython 2，如存在向后移植的bytes在Python 3这样的类型。 选好需要的工具之后，就可以开始更新代码了。你需要确保，更新之后的代码和之前的代码在功能实现是一致的。也就需要保证测试结果更新前后保持一致。尽管工具可以将大部分代码更新到支持python3，但仍然有一些不能更新，需要手动去更改，使代码完全支持python3.下面几种情况需要注意，有时调试时可能会忽略。 Division 在python3中，5/2 == 2.5而不是２；所有int之间的除法的结果都是float.这个变化实际上在2002年发布的python2.2中增加。一直鼓励用户在任何使用/和//的文件中增加\"from __future__ import division\" 或-Q标志。 如果你还没有这样做，那么你将需要通过你的代码，做两件事情： * 1.在文件中增加\"from __future__ import division\" * 2. 使用//进行地板除，/除则得到float 原因是/不能简单翻译成//,如果你的代码定义__truediv__方法而不是__floordiv__则会导致你的代码出错。 Text versus binary data 待补 Prevent compatibility regressions 待补 Check which dependencies block your transition 待补 Update your setup.py file to denote Python3 compatibility 待补 Use continuous integration to stay compatible_idioms 待补 Dropping Python2 support completely 待补","tags":"编程语言-Python","title":"Python-HOWTOS(一）"},{"url":"http://king32783784.github.io/2016/01/01/effective-python/","text":"确认python版本 目前两个版本活跃状态，python2和python3 python有很多流行的运行环境，如cpython jython ironpython以及 pypy 运行Python时，确保python是想用的版本 以后项目尽量使用python3 PEP8风格 编写python代码时，应该遵循PEP8风格指南 采用通用的代码风格，便于多人协作 一致的代码风格易于维护 bytes、str与Unicode的区别 Python3中，bytes是一种包含8位值的序列，str是一种包含Unicode字符的序列。开发时不能以>或+等操作符来混同操作bytes和str实例。 Python2中，str是一种包含8位值的序列，Unicode是一种包含Unicode字符的序列。如果 str只包含7位ASCII字符，可以通过想过操作符同时操作str和Unicode。 对于输入的数据进行操作之前，使用辅助函数来保证字符序列的类型与开发者的期望相符。 从文件中读取二进制数据或向其中写入二进制数据时，总应该以'rb'或'wb'等二进制模式来开启文件。 编写Python程序的时候，一定要把编码和解码操作放在解码最外围做。程序的核心部分分别使用Unicode字符类型（Python3中str，Python2中的unicode),而且不要对字符编码做任何假设。 由于字符类型有别，所以Python代码经常会出现两种常见的使用情景： 开发者需要原始8位值，这些8位值表示UTF-8格式来编码字符 开发者需要操作没有特定编码形式的Unicode字符。 编写两个helper函数以便在这种情况之间转换，使得转换后的输入数据符合预期。 python3中，需要编写接受str或bytes,并总是返回 str 的方法： def to_str(bytes_or_str): if isinstance(bytes_or_str, bytes): value = bytes_or_str.decode('utf-8') else: value = bytes_or_str retunr value 另外，需要编写接受str或bytes,总是返回bytes： def to_bytes(bytes_or_str): if isinstance(bytes_or_str, str): value = bytes_or_str.encode('utf-8') else: value = bytes_or_str return value Python2,需要编写接受str或Unicode，总是返回Unicode的方法： #python2 def to_unicode(unicode_or_str): if isinstance(unicode_or_str, str): value = unicode_or_str.decode('utf-8') else: value = unicode_or_str return value 编写接受str或Unicode，总是返回str的方法 def to_str(unicode_or_str): if isinstance(unicode_or_str, unicode): value = unicode_or_str.encode('unf-8') else: value = unicode_or_str return value python使用8位值与Unicode字符时，需要注意以下问题： python2中，如果str只包含7位ASCII，Unicode和str实例成了同一种类型。 可以用+操作符把这种str和Unicode连接 可以用等价与不等价操作符， 格式化字符串中，可以用\"%\"形式代表Unicode。 Python3中，如果通过内置的open函数获取了文件句柄，该句柄默认会采用UTF-8编码格式操作文件。而Python2中，文件默认编码格式为二进制格式。可能或出现问题。 例如，向文件中写入一些二进制数据。下面这种方法在Python2中可以正常运行，Python3不行 with open（'/tmp/random.bin', 'w') as f: f.write(os.urandom(10)) TypeError: must be str, not bytes Python3给open函数添加了名为encoding的新参数，而这个新参数的默认值却是\"utf-8\"。这样在文件句柄上进行read和write操作时，系统要求开发者必须传入包含Unicode字符的str实例，而不接受包含二进制的bytes实例。 为了解决这个问题，我们必须用二进制写入模式（'wb')来开启操作的文件。以下方式同时适用Python2和Python3: with open('/tmp/random.bin', 'wb') as f: f.write(os.urandom(10))","tags":"编程语言-Python","title":"Python-tips01"},{"url":"http://king32783784.github.io/2016/01/01/python/","text":"PyUnit简介 PyUnit是Python 2.1版本新增功能。 Python单元测试框架，又叫PyUnit。是JUnit的Python实现，是由Kent Beck和Erich Gamma共同开发的。同样，JUnit是Kent的Smalltalk测试框架的Java实现。PyUnit和JUnit都是各自怨言的标准测试框架。 PyUnit模块支持自动化测试，通用的setup和shutdown的代码，测试用例整合为测试集，还有独立的测试报告框架。PyUnit提供的类能够很容易的使以上特性应用于测试。PyUnit是借由以下概念支持单元测试的： 测试fixture 测试fixture是指运行测试前的准备工作和运行测试后的清理工作。例如，创建临时或代理数据库、目录，或者启动服务进程。 测试用例 测试用例是最小的测试单元，检查特定的输入会产生预期的结果。PyUnit提供一个测试用例几类TestCase，继承基类可以创建新的测试用例。 测试集 测试集是测试用例的集合，同时也可以是其他测试集的结合，或者是测试用例和测试集的混合集合。用于批量执行测试用例。 执行器 执行器用来执行测试用例，并且把测试结果呈现给用户。执行器可以使用图形界面，文本界面，甚至特殊值来显示测试结果。 测试用例和测试fixture通过TestCase和FunctionTestCase两个类来实现的。TestCase用来创建新的测试用例，而FunctionTestCase是用来把已有测试用例整合为PyUnit结构用例的（译者注：项目原来已经有测试用例了，后来想改用PyUnit测试框架，这时候就要用到FunctionTestCase了）。使用TestCase类创建新测试用例，需要覆盖setUp()和tearDown()方法，他们分别用来初始化fixture和清理fixture。而要使用FunctionTestCase类为已有函数创建测试用例，需要符合以下条件：我们不关心已有函数的测试结果，只关心正确的测试流程fixture初始化->执行测试步骤->测试固件清理。每个TestCase只能执行一个测试方法，所以最好每个测试用例有单独的测试fixture。 TestSuite类实现测试套件功能，可以整合单独的测试用例或者其他测试套件。执行测试套件，测试套件中所有的测试用例和子测试套件都会被执行。 执行器提供一个方法run()，该方法接受TestCase或者TestSuite对象最为参数，并且返回TestResult结果对象。PyUnit提供一个使用TextTestRunner执行器的例子，该例子汇报默认的标准错误流测试结果。想要更改其他环境的执行器（例如图形界面环境）并不需要派生自特定的类。 另请参阅： Module doctest Another test-support module with a very different flavor. unittest2: A backport of new unittest features for Python 2.4-2.6 Many new features were added to unittest in Python 2.7, including test discovery. unittest2 allows you to use these features with earlier versions of Python. Simple Smalltalk Testing: With Patterns Kent Beck's original paper on testing frameworks using the pattern shared by unittest. Nose and py.test Third-party unittest frameworks with a lighter-weight syntax for writing tests. For example, assert func(10) == 42. The Python Testing Tools Taxonomy An extensive list of Python testing tools including functional testing frameworks and mock object libraries. Testing in Python Mailing List A special-interest-group for discussion of testing, and testing tools, in Python. 简单例子 PyUnit模块提供了大量的工具来构造和运行测试，本部分的例子可以满足大部分用户的需求。 以下脚本是测试random模块的3个函数的例子： import random import unittest class TestSequenceFunctions ( unittest . TestCase ): def setUp ( self ): self . seq = range ( 10 ) def test_shuffle ( self ): # make sure the shuffied sequence does not lose any elements random . shuffle ( self . seq ) self . seq . sort () self . assertEqual ( self . seq , range ( 10 )) # should raise an exception for an immutable sequence self . assertRaise ( TypeError , random . shuffle , ( 1 , 2 , 3 )) def test_choice ( self ): element = random . choice ( self . seq ) self . assertTrue ( element in self . seq ) def test_sample ( self ): with self . assertRaise ( ValueError ): random . sample ( self . seq , 20 ) for element in random . sample ( self . seq , 5 ): self . assertTrue ( element in self . seq ) if __name__ == '__main__' : unittest . main () 通过继承unittest.TestCase类来创建测试用例，测试用例中３个独立的测试函数以\"test\"为开头命令。通过这种命名方式，执行器可以知道哪些方法是测试方法。 需要注意的是３个测试方法分别调用assertEqual()函数来检查预期结果；调用assertTure()函数来判断条件；调用assertRaises()函数来验证是否触发了预期的异常。这３个方法作为断言语句判断用例执行的正确性，以便执行器手机测试结果并产生测试报告。 如果定义setUp()方法，每个测试用例执行前都会执行setUp();同样的，如果定义的tearDown()方法，每个测试用例执行完后都会执行tearDown()方法。上面的例子，setup()方法用来为每个用例创建一个新序列。 例子的最后一段介绍了一种简单调用测试用例的方法－unittest.main().它为用例提供了命令行界面运行，脚本运行会输出以下内容： ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK 连续３个点\"...\"表示３个测试用例都运行通过，如果运行失败显示\"Ｆ\"，例如\".FF\"表示后２个用例运行失败。 有很多更易管理，输出信息更简洁，并且不在命令行运行的方法来替代unittest.main()方法运行测试用例。例如以下方法，替换例子的最后一行unittest.main(): suite = unittest.TestLoader().loadTestsFormTestCase(TestSequenceFunctions) unittest.TestTestRunner(verbosity=2).run(suite) 修改后的脚本如下： test_choice (__main__.TestSequenceFunctions) ... ok test_sample (__main__.TestSequenceFunctions) ... ok test_shuffle (__main__.TestSequenceFunctions) ... ok 下面是一个简短的例子用于测试3个字符方法： import unittest class TestStringMethods ( unittest . TestCase ): def test_upper ( self ): self . assertEqual ( 'foo' . upper (), 'FOO' ) def test_isupper ( self ): self . assertTure ( 'FOO' . isupper ()) self . assertFalse ( 'Foo' . isupper ()) def test_split ( self ): s = 'hello world' self . assertEqual ( s . split (), [ 'hello' , 'world' ]) # check that s.split fails when the separator is not a TestStringMethods with self . assertRaise ( TypeError ): s . split ( 2 ) if __name__ == '__main__' : unittest . main () 测试用例通过继承unittest.TestCase创建。测试用例中3个独立的测试函数以\"test\"为开头命名。通过使用这种命名方式，执行器可以知道哪些方法是测试方法。 3个测试方法同样调用assertEqual()函数来检查预期结果；调用assertTrue()函数来判断条件；调用assertRaises()函数来验证是否触发了预期的异常。这3个方法作为断言语句判断用例执行正确性，以便于执行器收集测试结果并产生测试报告。","tags":"编程语言-Python","title":"PyUnit(一）"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/13/autotest02/","text":"Local (Former Client) 主要内容 快速入门 client端控制文件 测试模块开发 如何添加测试到autotest 使用和开发job profilers linux发行版检测 API 参考 其他 快速入门 Autotest 客户端需要很少的依赖,需要安装python2.4或以上版本.推荐使用虚拟机或测试机验证,避免出现异常. 下载client端 git clone --recursive git://github.com/autotest/autotest.git cd autotest 测试例子 比如autotest中的sleeptest,sleeptest是一个简单的sleep几秒测试.可以从autotest目录启动(/usr/local/autotest/client): client/autotest-local --verbose run sleeptest 可以通过以下方式,进行任何独立测试: client/autotest-local run <testname> 还可以通过control文件启动测试: client/autotest-local client/tests/sleeptest/control 一些测试可能需要root权限,比如rtc测试.当提示结果为\"permission denied error\"时,意味着权限不足,你需要以root执行. 如果以root身份执行client端,后又切回到普通用户,一些重要的目录,可能是root用户的,再进行测试可能会出错.这时你可以删除这些目录: sudo rm -rf client/tmp sudo rm -rf client/results 在client/samples目录下面有一些测试例子,非常适合练习.kbuile_and_tests/control会下载一个内核,并且编译,而且会重启后进入该内核. 可以以root身份执行: client/autotest-loacl --verbose client/samples/kbuild_and_tests/control 注意,尽量在一个测试机或虚拟机执行,不然会丢失之前系统的启动设置. Top &#94; 上一篇 Autotest：Autotest-summary>>> 下一篇 Autotest：Autotest-client control>>>","tags":"自动化测试-Autotest","title":"Autotest-Local"},{"url":"http://king32783784.github.io/2015/08/12/Autotest01/","text":"Autotest是一个开源的自动化测试框架.设计目的是为了测试Linux内核,同样可以用来检查新的硬件,虚拟化测试以及linux平台用户空间程序.它遵循GPL协议,并有大量的开发组织成员,其中包括像谷歌,IBM,红帽等. Avocado,是Autotest开发组,开发的下一代的自动化测试框架.详细信息参考 Avocado ,后续有时间会再对Avocado进行介绍. 本专题主要介绍以下内容: * 基本信息 * 客户端介绍 * 服务端介绍 * 前端介绍 * 系统管理 * 调度模块 * 如何开发 本文主要介绍关于Autotest的一些基本信息.主要内容: * Autotest主要结构 Autotest项目主页: Autotest Github: Github Autotest主要结构 下图是Autotest框架简化图: Web接口和命令行接口 Web接口和命令行接口是相辅相成的方式去连接Autotest并创建job.这两则具有相同的功能,意在方便用户.你可以用这些接口做以下事情: * 管理jobs,如创建,监控,中止等 * 管理客户端 * 查看测试结果 前端会通过向mysql数据库中创建记录的方式将jobs插入服务端. 服务端 服务端主要包括3个部分: 一个Mysql数据库,该数据库保存了所有的job,客户端(测试物理机),用户,测试项目等信息 调度程序(monitor_db),从数据库中选择jobs 运行.它对数据库的操作,主要是为了启动autoserv进程去调用服务请求. 通常一台测试机一个调度进程 客户机端的jobs是异步的(设置客户端机变为可用) 服务器端的jobs是同步的(它启动前要等待所有客户端机) Autoserv: 服务端通过autoserv程序管理客户端,每个运行的job都会有一个autoserv进程.每个autoserv进程: 控制和监控一个或多个客户端 确认客户端是否工作正常,如果确认失败,会尝试修复. 管理job的执行 在开始测试前,更新客户端的autotest程序.(如新增了测试项) 另外,mysql数据库可用部署在不同的机器上进行调度,虽然有一定的调度负载,但每个可用管理几千个客户端.所以没必要部署在不同机器上. 客户端 启动一个job后,client端做了大部分的工作.它的调用方式有: 手动执行:通过client/autotest-local <control_file_name>命令启动 通过服务端调用 一个典型的工作流程如下: 简要说明 用户创建job(可以通过web端或命令行)或自动事件触发;将job信息记录插入前端数据库;调度器(monitor_db)将job匹配到空闲机器;调度器创建autoserv进程启动job;Autoserv确认客户端或修复;Autoserv在测试机器上安装或更新autotest客户端;Autoserv监控客户端状态,监视问题; 客户机器触发autotest客户端执行测试(已开发测试项目)-运行control文件-log模块记录测试信息-setup-执行测试-测试结果文件由autoserv回收;分析机器新的job;log结果信息处理; 结果目录 :按照一定格式结果目录 结果数据库 :一个简单的数据库保存每个测试的job信息 测试结果 性能指标等 随着前面的介绍,下图是更容易理解的基本框架图: 简要说明: Autotest通过 Web 前端或者命令行工具提交测试任务， Autotest Server 通过调度器将任务分发到不同的 Client（测试机）， Client 端任务执行完之后，再将结果返回到结果分析后端，Web 前端与命令行接口即可查看测试结果 . 主要构成部分： Local：在测试机Client上执行测试的引擎 Remote：从Server端推送测试代码到客户测试机，触发测试执行，监控测试状态，并且把测试结果从测试机反馈到服务器。 Scheduler：根据用户输入分配测试任务，为每个任务创建服务进程，存储结果到测试数据库 Frontends：允许用户运行作业并且方便地使测试结果可视化。 Top &#94; 下一篇 Autotest：Autotest-Local>>>","tags":"自动化测试-Autotest","title":"Autotest-summary"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/12/自动化测试/","text":"浏览器是系统下比较常用的软件，在linux系统比较常用的是firefox、chrome.如何评估浏览器的基础性能？有很多评测网站进行了这边的测试。 如 CSS acid3 v8test octane html5 dromaeo 等 考虑到每次测试都需要点击这些网站和取测试结果，决定采用selenium去实现自动测试。 测试代码如下： browser-run.py: ```python #encoding = utf-8 import logging import runtest import re import sys from subprocess import call from selenium import webdriver reload ( sys ) sys . setdefaultencoding ( 'utf8' ) # create logger with 'spam_application' logger = logging . getLogger ( 'browser-test' ) logger . setLevel ( logging . DEBUG ) # create file handler which logs even debug messages fh = logging . FileHandler ( 'browser.log' ) fh . setLevel ( logging . DEBUG ) # create console handler with a higher log level ch = logging . StreamHandler () ch . setLevel ( logging . DEBUG ) # create formatter and add it to the handlers formatter = logging . Formatter ( ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) fh . setFormatter ( formatter ) ch . setFormatter ( formatter ) # add the handlers to the logger logger . addHandler ( fh ) logger . addHandler ( ch ) css4 = { 'name' : 'css4' , 'url' : 'http://css4-selectors.com/browser-selector-test/' , 'click' : 'start-browser-selector-test' , 'result' : 'diagram' } #do_type2test acid3 = { 'name' : 'acid3' , 'url' : 'http://acid3.acidtests.org/' , 'result' : 'result' } v8test = { 'name' : 'v8test' , 'url' : 'http://chrome.360.cn/test/v8/run.html' , 'result' : 'status' } octane = { 'name' : 'octane' , 'url' : 'http://chrome.2345.com/labs/test/octanebenchmark.htm' , 'result' : 'main-banner' } #do_type3test html5 = { 'name' : 'html5' , 'url' : 'http://html5test.com/' , 'result' : '//*[@id= \\\" score \\\" ]/div[1]/h2/strong' } #do_type4test dromaeo = { 'name' : 'dromaeo' , 'url' : 'http://dromaeo.com/' , 'result' : '//*[@id= \\' timebar \\' ]/span/strong' , 'testxpath' : '//*[@id= \\\" tests \\\" ]/li[8]/a' , 'runid' : 'pause' , 'resultid' : 'left' } def result ( Initialresults ): p = re . compile ( r'\\d+' ) return p . findall ( Initialresults ) def chrome (): try : retcode = call ( \"which chromium-browser\" , shell = True ) if retcode > 0 : pass else : csstest = runtest . Do_type2test ( css4 ) cssresult = csstest . do_test ( webdriver . Chrome ()) print ( \"css4 result is %s \" % result ( cssresult )[ 3 ]) acidtest = runtest . Do_type1test ( acid3 ) acidresult = acidtest . do_test ( webdriver . Chrome ()) print ( \"acid3 result is %s \" % acidresult ) vtest = runtest . Do_type1test ( v8test ) vresult = vtest . do_test ( webdriver . Chrome ()) print ( \"V8test result is %s \" % vresult ) octanetest = runtest . Do_type1test ( octane ) octaneresult = octanetest . do_test ( webdriver . Chrome ()) print ( \"octane result is %s \" % octaneresult ) htmltest = runtest . Do_type3test ( html5 ) htmlresult = htmltest . do_test ( webdriver . Chrome ()) print ( \"html5test result is %s \" % htmlresult ) dromaeotest = runtest . Do_type4test ( dromaeo ) dromaeotestresult = dromaeotest . do_test ( webdriver . Chrome ()) print ( \"dromaeotest result is %s \" % dromaeotestresult ) print ( \"test finish\" ) except OSError as e : logger . ERROR ( \"Execution failed: %s \" % e ) def firefox (): try : retcode = call ( \"which firefox\" , shell = True ) if retcode > 0 : pass else : csstest = runtest . Do_type2test ( css4 ) cssresult = csstest . do_test ( webdriver . Firefox ()) print ( \"css4 result is %s \" % result ( cssresult )[ 3 ]) acidtest = runtest . Do_type1test ( acid3 ) acidresult = acidtest . do_test ( webdriver . Firefox ()) print ( \"acid3 result is %s \" % acidresult ) vtest = runtest . Do_type1test ( v8test ) vresult = vtest . do_test ( webdriver . Firefox ()) print ( \"V8test result is %s \" % vresult ) octanetest = runtest . Do_type1test ( octane ) octaneresult = octanetest . do_test ( webdriver . Firefox ()) print ( \"octane result is %s \" % octaneresult ) htmltest = runtest . Do_type3test ( html5 ) htmlresult = htmltest . do_test ( webdriver . Firefox ()) print ( \"html5test result is %s \" % htmlresult ) dromaeotest = runtest . Do_type4test ( dromaeo ) dromaeotestresult = dromaeotest . do_test ( webdriver . Firefox ()) print ( \"dromaeotest result is %s \" % dromaeotestresult ) print ( \"test finish\" ) except OSError as e : logger . ERROR ( \"Execution failed: %s \" % e ) if __name__ == \"__main__\" : chrome () firefox () runtest.py: import time import logging from selenium import webdriver from subprocess import call module_logger = logging . getLogger ( 'browser-test.runtest' ) def check_xpath ( testname = 'dromaetest' , checkxpath = \"//*[@id='tests']/li[3]/b/a\" ): '''check the xpath ready or not''' while True : try : drop = testname . find_element_by_xpath ( \" %s \" % checkxpath ) break except : module_logger . info ( \" %s is not ok\" % checkxpath ) def check_idon ( testname = 'dromaeotest' , checkid = 'pause' ): while True : try : drop = testname . find_element_by_id ( \" %s \" % checkid ) break except : time . sleep ( 1 ) def check_idoff ( testname = 'dromaeotest' , checkid = 'left' ): while True : try : drop = testname . find_element_by_id ( \" %s \" % checkid ) time . sleep ( 1 ) except : break class Do_type1test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type1test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 60 ) while True : try : drop = test . find_element_by_id ( self . cmds [ 'result' ]) break except : self . logger . info ( \"There are some errors about this test\" ) test . quit () exit () result = test . find_element_by_id ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type2test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type2test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) test . find_element_by_id ( self . cmds [ 'click' ]) . click () time . sleep ( 20 ) result = test . find_element_by_id ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type3test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type3test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 60 ) result = test . find_element_by_xpath ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type4test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type4test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 30 ) check_xpath ( testname = test , checkxpath = self . cmds [ 'testxpath' ]) test . find_element_by_xpath ( self . cmds [ 'testxpath' ]) . click () time . sleep ( 30 ) check_idon ( testname = test , checkid = self . cmds [ 'runid' ]) test . find_element_by_id ( self . cmds [ 'runid' ]) . click () check_idoff ( testname = test , checkid = self . cmds [ 'resultid' ]) result = test . find_element_by_xpath ( self . cmds [ 'result' ]) . text test . quit () ```","tags":"自动化测试-Selenium","title":"selenium-浏览器性能测试"},{"url":"http://king32783784.github.io/2014/10/10/linux/","text":"一、工具介绍 SPEC CPU 2006 benchmark是SPEC新一代的行业标准化的CPU测试基准套件。重点测试系统的处理器，内存子系统和编译器。这个基准测试套件包括的SPECint基准和SPECfp基准。 其中SPECint2006基准包含12个不同的基准测试和SPECfp2006年基准包含19个不同的基准测试。SPEC设计了这个套件提供了一个比较标准的计算密集型，高性能的跨硬件的CPU测试工具。在SPEC CPU 2006基准有几种不同的方法来衡量计算机性能。 一种方式是测量计算机完成单一任务的速度; 另一种方式吞吐量，容量或速率的测量。 说明：由于spec2006支持多种类型操作系统。以下安装、测试、移植等介绍均基于Unix 和其他的 Unix-like system如linux。Windows系统不在此范围内。 1.spec2006与spec2000的对比简要说明 2006年8月24日，标准性能评估公司（SPEC）宣布CPU2006将取代CPU2000。 Spec cpu基准测试被广泛的应用于工业界和学术界。新套件比cpu2000要大很多，而且将涵盖到CPU、存储器系统、编译器特别是C++编译器。Cpu2000只有1个关于C++的基准测试，CPU2006则含有7个相关套件，这其中包括了50W行c++代码，Fortran和C语言和之前一样有很好的覆盖。 2. Spec2000和spec20006具体的套件信息如下： 2.1 Spec int2000 12个整点测试项目 164.gzip C语言编写，很流行的数据压缩程序。使用Lempel-Ziv coding(LZ77)作为压缩算法。SPEC中的gzip除了读入集外没有其他文件I/O操作，所有压缩和解压都在主存中进行，方便测试CPU和存储子系统。 175.vpr C语言编写，FPGA中的电路定位和路由程序,用于计算机辅助电路设计领域。 176.gcc: C语言编写，C语言优化编译器。该GCC基于GCC 2.7.2.2版本，为摩托罗拉88100处理器生成机器码。 181.mcf: C语言编写，组合优化/单点轮换调度(Single-depot vehicle scheduling),派生自使用单站轮换调度的公共物流应用程序。 186.crafty： C语言编写，国际象棋游戏程序。这是一个在64位机上设计的高性能计算机国际象棋程序，在32位机上可以使用long long来表示该数据类型。主要是一个整点程序，大量的逻辑运算。通过配置，能生成不同的搜索集，可以对处理器的整点运算，转移预测和流水线等做测试。 197.parser: C语言编写，字处理程序。连接语法分析器(Link Grammar Parser)是一个基于连接语法的英语句法分析器。连接语法时英语语法的较早理论。给定一个句子，系统能给它赋予一个词法结构，这个结构是两个词之间被标记的连接。该分析器有大约60000个词表的字典。 252.eon： C++语言编写，计算机可视化。eon是一个基于概率的射线跟踪程序，基于Kajiya 1986 ACM SIGGRAPH会议的论文。它将一定数量的3D射线发射到一个3D多面体中，计算射线和多边形的交点，并通过计算入射光和交点生成新射线。最终的计算结果时一个能在照相机内看到的图片。程序中的计算需求和基本计算机图形学中介绍的传统确定性射线跟踪程序很相似，但是它有较少的存储一致性需求，因为很多在同一个位置生成的随机射线横切3D空间中完全不同的区域.输入：eon渲染一个150×150像素的一把椅子在房间前脚的图片。 253.perlbmk: C语言编写,Perl语言解释器。这是一个Perl v5.005_03版本的删减版，删除了很多操作系统相关的特性，并增加了一些第三方的模块，包括MD5 v1.7, MHonArc v2.3.3, IO-stringy v1.205,MailTools v1.11,TimeData v1.08。输入：由四个perl脚本组成，一个email-to-HTML 转换器，占用时间最长；一个spec CPU2000用来对比较输出的diff脚本，一个通过迭代算法寻找合格数字的脚本，一个用于测试伪随机数按照预定顺序生成的脚本。输出分别对应各个输入。 254.gap: C语言编写，群论，解释器中常用。它实现一个语言和库用于做群论计算。GAP是(Groups,Algorithms和Programming的缩写)。 255.vortex： C语言编写,单用户面向对象数据库中事务处理的benchmark。SPEC中的vortex来自完整面向对象数据库程序VORTEx的一个子集。输入和输入数据库的事务都会被转换成一个方案。 256.bzip2： C语言编写，压缩程序。基于Julian Seward的bzip2 v0.1，唯一的不同是SPEC中的bzip2除了输入外，无文件I/O。所有的压缩和解压都在内存中进行。输入，输出都和gzip的相似。 300.twolf： C语言实现，定位和路由模拟。twolf来自TimberWolfSC定位和全局路由，它被用于创建微处理器产品印刷电路布局的流程中，确定晶体管的位置和组内的全局连接。定位问题是一个排列，穷举法耗时太长，TimberWolfSC程序则使用模拟退火作为启发来找到较优解。 2.2 Spec int2000 12个整点测试项目 400.perlbench：C语言编写，同spec2000的253.perlbmk类似，是Perl V5.8.7版本的删减版，同样删除了一下操作系统特性有关的东西，增加了第三方的模块，如：SpamAssassin V2.61,Digest-MD5 v2.33,HTML-Parser v3.35,MHonArc V2.6.8,IO-stringy V1.205,MailTools V1.60，TimeDate V1.16。400.perlbench采用3个脚本进行增加负载或工作。1.主要的负载在于打开 垃圾邮件过滤软件SpamAssassin。采取的过滤方式是采用记分制，也就是说会根据我们所设定的标准来给予分数超过标准值的时候即判定为 SPAM（垃圾邮件），其余为非垃圾邮件。但对SpamAssassin软件做了很大程度的修改，避免一些I/0操作，并且没有使用贝叶斯过滤。2.是比较流行的email到HTML的转换器MHonArc 3.使用了spec2006的工具套件specdiff。 401.bzip2: C语言实现，同spec2000的256.bzip2类似,基于Julian Seward的bzip2 v1.03.唯一的不同是SPEC中的bzip2除了输入外，无文件I/O。所有的压缩和解压都在内存中进行。输入，输出都和gzip的相似。负载包括六个部分：两个小的JPEG图片、一个程序、一个tar包起的几个源程序文件、一个HTML文件、混合文件，包括压缩起来的高可压缩文件及不怎么可压缩的文件。测试分别使用了三个不同的压缩等级进行压缩和解压缩 403.gcc:C语言实现，同spec2000的176.gcc类似。该测试是基于gcc V3.2,为AMDCPU生成机器码。相比spec2000的176.gcc，该测试有更多的输入文件，因此测试压力会更大，负载来源于对9组C代码进行编译。 429.mcf:C语言实现，同时需要libm库支持，同spec2000的181.mcf类似，MCF是一个用于大型公共交通中的单站车辆调度的程序。但对输入文件做了一定的修改，由32位变成64位，用以兼容64位系统。并且增加了cache命中和程序的性能。相比spec2000的181.mcf来说，占用的内存由之前的100M-190M变为860M-1700M。 445.gobmk：C语言实现，同spec2000的186.crafty类似。不同的是这里是实现的围棋游戏。相比spec2000程序更复杂。 456.hmmer：C语言实现。HMMER是基于隐马尔可夫模型(profile HMMs)，用于生物序列分析工作。同Timed HMMer Search 类似。 458.sjeng：C语言实现。基于一种象棋游戏Sjeng11.2，属于人工智能的范畴。 462.libquantum:C语言实现（C99）。libquantum是模拟量子计算机的库文件，用来进行量子计算机应用的研究。 464.h264ref:C语言实现。一种视频压缩程序，基于H264AVC 9.3版，去除了I/O和平台相关的东西。 471.omnetpp:C++语言实现。OMNeT++，离散事件仿真。包括约8000台计算机和900个交换机/集线器，以及混合了各种从10Mb到1000Mb速率的大型CSMA/CD协议以太网络模拟。 473 astar：C++语言实现，实现了2D寻路算法A*的三种不同版本。 xalancbmk：C++语言实现，包含Xalan-C++ v1.8 mod、Xerces-C++ v2.5.0，实现了XML文档/XSL表到HTML文档的转换。 2.3 Spec fp2000 13个浮点测试项目 168 wupwise：Fortran 77语言实现，格点规范理论与威尔逊数值模拟对费米子格是夸克传播子的计算。输入文件wupwise.in包含几个创建该问题的参数，SEED:提供一个随机数 NITER：迭代次数KAPPA：参数表征矩阵M = I - KAPPA * D。输出文件wupwise.out,包含每次NITER迭代的校验值（EPS）和包含最终的EPSILON特征的结果。 171 swim：Fortran 77语言实现，气象学中的浅水模型。 172.mgrid ：Fortran 77语言实现，多重网格求解器：3D势场 173.applu： Fortran 77语言实现，抛物线/椭圆型偏微分方程 177.mesa：C语言实现 ，3D图形库。 178.galgel :Fortran 90语言实现，计算流体动力学 179.art :C，图像识别/神经网络 183.equake:C语言实现， 地震波传播模拟 187.facerec: Fortran 90语言实现，图像处理：人脸识别 189.lucas :Fortran 90语言实现，数论/素性测试 191.fma3d :Fortran 90语言实现，有限元模拟碰撞 200.sixtrack :Fortran 77语言实现，高能核物理加速器设计 301.apsi: Fortran 77语言实现，气象学中污染物分布 2.4 Spec fp2006 17个浮点测试项目 410.bwaves：Fortran 77语言实现，流体力学范畴。对三维瞬跨音速粘性流中冲击波的模拟计算 416.gamess：Fortran语言实现，量子化学范畴。采用GMAESS组件，包含 胞嘧啶分子、水和Cu2+离子、三唑离子等3种SCF自洽场计算。 433.milc：C语言实现，量子力学范畴，采用MILC组件，包含用来研究QCD量子色动力学、夸克及胶子的四维SU(3)格点规范理论的模。 434.zeusmp ：Fortran 77/REAL*8语言实现，属于计算流体力学范畴，ZEUS-MP程序，用来计算理想、非相对论条件下的流体力学和磁流体力学，434.zeusmp模拟计算了一个统一磁场中的3D冲击波。 435.gromacs ：C & Fortran语言实现，属于生物化学/分子力学范畴。GROMACS是一个分子力学计算套件，然而也可以用于非生物系统，435.gromacs模拟了在一个水和离子溶液中的蛋白质溶菌酶结构在各种实验手段如核磁共振的X光照射下的变化。 436.cactusADM：Fortran 90, ANSI C语言实现，物理中的广义相对论。来源于Cactus BenchADM。436.cactusADM对时空曲率由内部物质决定的爱因斯坦演化方程进行求解，爱因斯坦演化方程由10个标准ADM 3+1分解的二阶非线性偏微分方程组成。 437.leslie3d ：Fortran 90语言实现，属于流体力学范畴。 LESlie3d是用来计算湍流的计算流体力学程序，437.leslie3d计算了一个如燃油注入燃烧室的时间分层混合流体。 444.namd：C++语言实现。属于生物/分子学范畴。NAMD是一个大型生物分子系统并行计算程序，444.namd模拟了了92224个原子组成的A-I载脂蛋白 447.dealII：C++语言实现。进行有限元分析，w/Boost lib 、deal.II lib、deal.II是定位于自适应有限元及误差估计的C++库，447.dealII对非常系数的亥姆霍兹方程进行求解，它使用了基于二元加权误差估计生成最佳网格的自适应方法，该方程在3维得解。 450.soplex:C++语言实现。采用Plex v1.2.1程序，Plex使用单纯形算法解线性方程 453.povray：ISO C++ 语言实现。 POV-Ray POV-Ray是一个光线追踪渲染软件，453.povray渲染一幅1280x1024的反锯齿国际象棋棋盘图像 454.calculix：Fortran 90 & C语言实现，结构力学范畴。CalculiX是一个用于线性及非线性三位结构力学的有限元分析软件，454.calculix计算了一个高速旋转的压缩盘片在离心力的作用下的应力和变形情况 459.GemsFDTD：Fortran 90语言实现。属于电磁学范畴。 459.GemsFDTD使用FDTD（有限差分时域）方法求解三维时域中的麦克斯韦方程，计算了一个理想导体的雷达散射截面 465.tonto： Fortran 95实现。量子化学范畴Tonto是一个面向对象的量子化学程序包，465.tonto计算面向量子晶体学，它基于一个符合X光衍射实验数据的、约束的分子Hartree-Fock波函数 470.lbm ：ANSI C语言实现。 470.lbm使用LBM（格子波尔兹曼方法）模拟非压缩流体，它模拟了两种情况：类似活塞推动的剪切驱动流体和管道流体，测试包含了3000个步骤 481.wrf ：Fortran 90 & C语言实现。WRF v2.0.2 481.wrf基于WRF(Weather Research and Forecastin)模型，对NCAR的数据进行了计算，数据包括了UTC 2001.06.11到UTC 2001.06.12以三小时为间隔的数据 482.sphinx3：C语言实现。Sphinx-3一种语音识别软件。 二、工具安装 1.标准安装方式 $ mount -t iso9660 -o ro,exec /dev/cdrom /mnt $ cd /mnt $ ./install.sh 可以指定安装目录如： $./install.sh -d /home/cpu2006 安装过程中可能遇到以下提示： Installing FROM /Volumes/SPEC_CPU2006 Installing TO /home/cpu2006 Is this correct? (Please enter 'yes' or 'no') yes 2.通过安装完成的软件进行测试 先准备相关测试文件，如：cpu2006-20141030.tar。 解压文件： $ tar xf cpu2006-20141030.tar 进入安装目录： $ cd cpu2006v99/（根据实际路径） 导入测试工具： $. shrc 注意：输入时，圆点与shrc之间至少一个空格，该命令开始导入SPEC CPU2006程序。 修改测试文件绝对路径： $ bin /relocate 显示\"Top of SPEC benchmark tree is '/cpu2006v99'\" 3.运行测试 根据需求，进行参数选择，开始运行测试脚本： 例如：runspec -c linux-mipsel-gcc -i ref -n 3 all 命令参数说明： -c：读取测试配置文件，linux-mipsel-gcc位于SPEC CPU2000安装目录的config目录下，该文件可以根据实际信息进行修改。其编译选项不建议修改。 -i：输入测试数据集的大小，ref代表最大测试数据集，test代表最小测试数据集； -n：每个测试项目运行的次数，如果需要SPEC CPU2006自动计算测试分值，需要指定运行次数等于或大于3，即n>=3； all：SPEC CPU2006将运行基准测试程序中的所有测试项目。 出现以下信息，表明测试已经启动\" runspec v4283 - Copyright 1999-2006 Standard Performance Evaluation Corporation Using 'mipsel-linux' tools Reading MANIFEST... 17899 files Loading runspec modules............... Locating benchmarks...found 31 benchmarks in 13 benchsets. Locating output formats: ASCII, config, CSV, flags, html (DISABLED), mail, PDF, PostScript, raw, Screen, Submission Check Reading config file '/cpu2006v99/config/linux-mipsel-gcc.cfg' Benchmarks selected: 400.perlbench, 401.bzip2, 403.gcc, 429.mcf, 445.gobmk, 456.hmmer, 458.sjeng, 462.libquantum, 464.h264ref, 471.omnetpp, 473.astar, 483.xalancbmk, 999.specrand, 410.bwaves, 416.gamess, 433.milc, 434.zeusmp, 435.gromacs, 436.cactusADM, 437.leslie3d, 444.namd, 447.dealII, 450.soplex, 453.povray, 454.calculix, 459.GemsFDTD, 465.tonto, 470.lbm, 481.wrf, 482.sphinx3, 998.specrand Compiling Binaries up to date 400.perlbench ref base linux-mipsel-gcc default Up to date 401.bzip2 ref base linux-mipsel-gcc default Up to date 403.gcc ref base linux-mipsel-gcc default Up to date 429.mcf ref base linux-mipsel-gcc default …… 这组测试配置基本和spec2000类似，不同的是，spec2006在测试前，会把每个测试组件重新编译建立一次。所以在测试前，应确保此时的系统中包含以下编译器：g++、gcc、gfortran编译器。如果进行连续测试，则不必进行再次编译，可以加参数\"—nobuild\". 附config文件大体说明：斜体部分为文本内容 //为解释说明 ##################################################################### ignore_errors = yes tune = base ext = loongson.3a2000 output_format = asc, Screen, html reportable = 0 teeout = yes teerunout = yes hw_avail = Feb-2015 sw_avail = Feb-2015 license_num = company_name = Loongson prepared_by = Loongson tester_name = isoft test_date = July-2016 verbose = 9 default=default=default=default: ##################################################################### # # Compiler selection # ##################################################################### makeflags = -j 4 CC = mips64el-loongson-linux-gcc CXX = mips64el-loongson-linux-g++ FC = mips64el-loongson-linux-gfortran ## HW config hw_cpu_name = Loongson hw_model = 3A2000 hw_cpu_mhz = 1000 hw_fpu = Integrated hw_nchips = 1 hw_ncores = 4 hw_ncoresperchip= 4 hw_nthreads = 4 hw_ncpuorder = 1 hw_parallel = yes hw_pcache = 64KB I + 64KB D hw_scache = 4096KB(I + D) hw_memory = 2 x 4GB DDR1066 hw_vendor = Loongson ## SW config sw_os = iSoft sw_file = ext4 sw_state = runlevel 3 sw_compiler = gcc , g++ & gfortran 4.8 ##################################################################### # Optimization ##################################################################### ## Base is low opt default=default=default=default: # For this data model, -m32 needs to be here, as one of the lines below OPTIMIZE = -static -march=loongson3a PORTABILITY = COPTIMIZE = -flto -Ofast CXXOPTIMIZE = -flto -Ofast FOPTIMIZE = -flto -Ofast notes0100= C/C++ base flags: -flto -Ofast notes0110= Fortran base flags: -flto -Ofast ##################################################################### # 32/64 bit Portability Flags - all ##################################################################### default=base=default=default: notes25= default=peak=default=default: notes25= ##################################################################### # Portability Flags - INT ##################################################################### 400.perlbench=default=default=default: notes35 = 400.perlbench: -DSPEC_CPU_LINUX_IA32 CPORTABILITY= -DSPEC_CPU_LINUX_IA32 -fno-strict-aliasing #notes35 = 400.perlbench: -DSPEC_CPU_LINUX #CPORTABILITY= -DSPEC_CPU_LINUX -DSPEC_CPU_LITTLEENDIAN #COPTIMIZE = -O2 ...... 其他具体组件的编译信息不再一一说明，基本可以保持默认即可。 更多测试类型与方法参见下文。 4.测试结果收集与分析 测试结束后在result目录下，查看测试结果，测试结果一般以测试类型和测试次序进行区别，并且会按照整点和浮点进行划分。如果是按照正式reportable的模式进行测试的话，会出一份网页版的正式测试结果，参见下图： 非正式结果可以去asc或txt文档查看，格式例如下文： Base Base Base Peak Peak Peak Benchmarks Ref. Run Time Ratio Ref. Run Time Ratio -------------- ------ --------- --------- ------ --------- --------- 400.perlbench 9770 430 22.7 S 9770 339 28.8 S 400.perlbench 9770 429 22.8 * 9770 338 28.9 S 400.perlbench 9770 429 22.8 S 9770 339 28.8 * 401.bzip2 9650 559 17.3 * 9650 552 17.5 * 401.bzip2 9650 559 17.3 S 9650 553 17.5 S 401.bzip2 9650 560 17.2 S 9650 552 17.5 S 403.gcc 8050 374 21.5 S 8050 337 23.9 S 403.gcc 8050 367 22.0 * 8050 337 23.9 S 403.gcc 8050 366 22.0 S 8050 337 23.9 * 429.mcf 9120 187 48.9 S 9120 187 48.9 S 429.mcf 9120 188 48.6 * 9120 188 48.6 * 429.mcf 9120 211 43.2 S 9120 211 43.2 S 445.gobmk 10490 559 18.8 S 10490 542 19.4 S 445.gobmk 10490 559 18.8 S 10490 542 19.4 * 445.gobmk 10490 559 18.8 * 10490 541 19.4 S 456.hmmer 9330 213 43.8 S 9330 213 43.7 * 456.hmmer 9330 247 37.8 S 9330 214 43.6 S 456.hmmer 9330 214 43.5 * 9330 213 43.7 S 458.sjeng 12100 616 19.6 * 12100 574 21.1 * 458.sjeng 12100 617 19.6 S 12100 575 21.0 S 458.sjeng 12100 585 20.7 S 12100 574 21.1 S 462.libquantum 20720 14.2 1460 * 20720 14.2 1460 * 462.libquantum 20720 14.4 1440 S 20720 14.4 1440 S 462.libquantum 20720 13.5 1540 S 20720 13.5 1540 S 464.h264ref 22130 578 38.3 * 22130 527 42.0 S 464.h264ref 22130 579 38.2 S 22130 526 42.0 * 464.h264ref 22130 578 38.3 S 22130 526 42.0 S 471.omnetpp 6250 349 17.9 S 6250 288 21.7 * 471.omnetpp 6250 348 17.9 * 6250 288 21.7 S 471.omnetpp 6250 348 18.0 S 6250 289 21.7 S 473.astar 7020 313 22.4 S 7020 313 22.4 S 473.astar 7020 311 22.6 S 7020 311 22.6 S 473.astar 7020 311 22.6 * 7020 311 22.6 * 483.xalancbmk 6900 174 39.7 * 6900 170 40.7 S 483.xalancbmk 6900 174 39.6 S 6900 170 40.5 S 483.xalancbmk 6900 174 39.7 S 6900 170 40.6 * ============================================================================== 400.perlbench 9770 429 22.8 * 9770 339 28.8 * 401.bzip2 9650 559 17.3 * 9650 552 17.5 * 403.gcc 8050 367 22.0 * 8050 337 23.9 * 429.mcf 9120 188 48.6 * 9120 188 48.6 * 445.gobmk 10490 559 18.8 * 10490 542 19.4 * 456.hmmer 9330 214 43.5 * 9330 213 43.7 * 458.sjeng 12100 616 19.6 * 12100 574 21.1 * 462.libquantum 20720 14.2 1460 * 20720 14.2 1460 * 464.h264ref 22130 578 38.3 * 22130 526 42.0 * 471.omnetpp 6250 348 17.9 * 6250 288 21.7 * 473.astar 7020 311 22.6 * 7020 311 22.6 * 483.xalancbmk 6900 174 39.7 * 6900 170 40.6 * SPECint(R)_base2006 36.7 SPECint2006 39.1 Base Ratio为测试分值，该测试一般运行3遍取中值。整体结果为所有结果的几何平均值。 5. 举例说明SPEC CPU2006常用测试命令组合 1．runspec -c test.cfg -i test -I all 基于最小测试数据集快速执行所有的测试，测试过程中如果某个用例发生错误，则跳过错误用例，继续执行其他用例。 2．runspec -c test.cfg -i ref -n 3 -I all 基于最大测试数据集全面执行所有的测试，用于测试单核CPU，测试过程中如果某个用例发生错误，则跳过错误用例，继续执行其他用例。 3．runspec -c test.cfg –r ref –n 3 fp 基于最大测试数据集，只运行fp测试 4．runspec -c test.cfg –r ref –n 3 int 基于最大测试数据集，只运行int测试 5.runspec -c test.cfg -i ref 473.astar 基于最大测试数据集只执行473.astar单个测试。 6 runspec –c test.cfg –i ref --rate 4 int 基于最大数据测试集进行rate测试，运行4线程测试的分值 6.其他命令补充 --action build 创建测试项目 --action onlyrun 只是运行，不进行确认测试结果是否正确 --action report 标准测试 --action clean 清理已经建立的测试项目 模式很多，不再一一介绍。 --check_version 检查版本更新 --copies –c number 默认1 用来进行SPECrate run --help 显示帮助文档 --ignore_errors 忽略错误 ations number —n 测试次数，一次reportable测试，必须是3次 --iter—loose 未设置reportable测试 --output_format 输出文件格式 默认为html text 可以选择 all cfg test csv html mail pdf ps printer raw screen text 等多种方式。 --rate -r 进行SPECspeed测试可以指定copies数量运行。 --rebuild 重新编译测试文件 --tune tuning 默认是base 可以选择base, peak, or all ，Report 首先是base,其次是peak. 以上是比较常用的命令，一些不常用的命令不再介绍，可参考下文了解。 -a Same as --action --action action Do: build|buildsetup|clean|clobber|configpp| onlyrun|realclean|report|run|runsetup|scrub| setup|trash|validate --basepeak Copy base results to peak (use with --rawformat) --nobuild Do not attempt to build binaries -c Same as --config -C Same as --copies --check_version Check whether an updated version of CPU2006 is available --comment \"text\" Add a comment to the log and the stored configfile. --config file Set config file for runspec to use --copies Set the number of copies for a SPECrate run -D Same as --rebuild -d Same as --deletework --debug Same as --verbose --define SYMBOL[=VALUE] Define a config preprocessor macro --delay secs Add delay before and after benchmark invocation --deletework Force work directories to be rebuilt --dryrun Same as --fake --dry-run Same as --fake -e Same as --extension --ext Same as --extension --extension ext[,ext...] Set the extensions -F Same as --flagsurl --fake Show what commands would be executed. --fakereport Generate a report without compiling codes or doing a run. --fakereportable Generate a fake report as if \"--reportable\" were set. --[no]feedback Control whether builds use feedback directed optimization --flagupdate Same as --update --flagsupdate Same as --update --flagsurl url Location (url or filespec) where to find your flags file --getflags Same as --update --graph_auto Let the tools pick minimum and maximum for the graph --graph_min N Set the minimum for the graph --graph_max N Set the maximum for the graph -h Same as --help --help Print usage message --http_proxy Specify the proxy for internet access --http_timeout Timeout when attempting http access -I Same as --ignore_errors -i Same as --size --ignore_errors Continue with benchmark runs even if some fail --ignoreerror Same as --ignore_errors ...... 7.手动编译及跨平台移植方法（仅供参考） Spec2006包含的测试套件基本上与平台无关，因此理论上是可以直接进行跨平台进行测试。 Spec2006为了实现测试结果的准确及降低对平台的依赖，制作了自己的工具包。其中包括: specdiff（examines results to see if the correct answer was obtained）、specinvoke (invokes benchmarks for CPU2006)、specmake（GNU make ，Calling it \"specmake\" avoids possible conflicts with versions of make that may already be on your system. SPEC requires that published results use the versions of the tools that it supplies, so that if SPEC applies patches or extensions from time to time, all users run with a consistent tool set. Similar considerations apply to other tools in this list.)、specxz （The xz compression program）、specmd5sum（md5sum from GNU coreutils, with enhancements）、spectar（ GNU tar）、specperl（Perl）。Various Perl modules such as Algorithm::Diff, GD, HTML::Parser, PDF::API2, URI, XML::SAX, etc.。 编译工具：C99 编译器 C++编译器 如果是初始安装包，则需要解压源码包 # xz -dc install_archives/cpu2006.tar.xz | tar -xf - tools/src 建立工具包的命令如下： AIX (32-bit): CC=xlc CFLAGS='-O -qarch=ppc -D_LARGE_FILES -D_ILS_MACROS' PERLFLAGS=\"-Doptimize='-O' -Accflags='-D_LARGE_FILES'\" OBJECT_MODE=32 ./buildtools AIX (64-bit): CC=xlc CFLAGS='-O3 -qarch=ppc64 -q64 -D_ILS_MACROS' PERLFLAGS=\"-Doptimize='-O' -Aoptimize='-qarch=ppc64 -q64'\" OBJECT_MODE=64 ./buildtools HPUX: CC=\"/opt/ansic/bin/cc\" CFLAGS=\"-Ae +O2 +z -D_FILE_OFFSET_BITS=64 -AC99\" XZCFLAGS=-AC99 PERLFLAGS=\"-Doptimize=+O1 -Dlibpth=/usr/lib/hpux32 -Dldflags=-lm -Dcppstdin=cc -Acppstdin=-E -Acppstdin=-Aa -Acppstdin=-D__STDC_EXT__ -Acppstdin=-AC89\" ./buildtools IRIX: ulimit -s 128000; CFLAGS=\"-c99 -D_FILE_OFFSET_BITS=64\" MD5CFLAGS=\"-O2\" PERLFLAGS=\"-Doptimize=-O3 -Uloclib -Dlibpth=/usr/lib32\" XZFLAGS=\"--disable-assembler --disable-shared\" XZCFLAGS=\"-O1\" ./buildtools 建立完成之后，确认是否成功的方法： cd $ SPEC (Unix) . shrc 或 runspec -V 或specmake -v specxz -h specperl -v specdiff –h runspec -h specinvoke -h 工具编译完成之后，需要对工具进行打包 packagetools <archname> 如果自动化编译出现问题，可以手动编译每个测试工具。编译方法为进入对应的工具包，手动编译。 Top &#94;","tags":"性能测试","title":"Spec2006使用说明"},{"url":"http://king32783784.github.io/2014/09/15/linux/","text":"SPECJVM2008使用方法 1.工具介绍 SPECjvm2008 （Java Virtual Machine Benchmark）是一个评估JRE运行性能的基准测试套件。包含几个现实生活中的应用和专注于核心java功能的基准的测量基准套件。该套件侧重于JRE执行一个单一的应用程序；它反映了硬件处理器和内存子系统的性能，与文件系统I/O和网络I/O关系不大。SPECjvm2008负载模仿各种常见用途的应用计算。这些特征反映了这一基准适用于测量基本 Java 性能上种类繁多的客户端和服务器系统。 套件包含21个基准测试，其中每个基准测试均包含一个2分钟的热身测试和4分钟的正式测试。由于测试过程中程序并不中断基准测试的执行，所以测试时间至少为126分钟，根据Java性能的不同，测试时间会有所不同。关于21个基准测试的具体内容将在文档最后进行介绍。 官网： http://www.spec.org/jvm2008/ 2工具安装 2.1下载 下载SPECjvm2008测试套件： #wget ftp://ftp.spec.org/dist/osg/java/SPECjvm2008_1_01_setup.jar 2.2安装 #java -jar SPECjvm2008_1_01_setup.jar -i console 选择默认的内容进行安装，直至完成。默认的安装路径会是/SPECjvm2008 2.3调试 在/etc/profile中加入环境变量 JAVA_HOME=/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/ CLASSPATH=.： $ JAVA_HOME /lib/tools.jar：/lib.dt.jar PATH= $ JAVA_HOME /bin： $ PATH export JAVA_HOME CLASSPATH PATH 保存后，执行 source /etc/profile即可。 安装目录下有一个脚本，linux对应的是run-specjvm.sh，windows对应的是 run-specjvm.cmd 执行如下命令，用以测试安装或环境是否ok ./run-specjvm.sh startup.helloworld -ikv startup.helloworld 是测试helloworld程序的启动时间，选择这个测试用例是考虑到运行速度比较快。 -ikv的意思是跳过签名检查，那个过程有点慢。 2.4 配置 默认情况，我们只需要修改安装目录下 props/specjvm.properties 和 props/specjvm.reporter.properites 这两个配置文件就行了。 specjvm.properties主要负责对整个套件的运行进行调整。比如，指定需要运行的测试用例，测试迭代次数，每个用例跑完是否要GC等。 specjvm.reporter.properites主要用来丰富报表输出内容，一般是一些无法通过自动检测得到的环境信息。比如，主机的内存型号，cpu逻辑个数，主板提供商等。 官方对specjvm.properties的内容是遵循COC原则设计的。所以，我们只需要修改特定的参数就可以了。 下面是我测试时修改的一些参数。 specjvm.additional.properties.file=props/specjvm.reporter.properties // 指定报表配置文件路径 specjvm.benchmark.analyzer.names=HeapMemoryFreeAnalyzer HeapMemoryTotalAnalyzer // heap分析器 specjvm.home.dir=/home/admin/SPECjvm2008 // SPEC_HOME路径 specjvm.iteration.time=240s // 迭代时长 specjvm.startup.jvm_options=-Xms1024m -Xmx1024m -XX:+UseConcMarkSweepGC // JVM switches specjvm.reporter.properties这个配置文件就不多做介绍了，你甚至可以不做任何修改。 3 工具使用说明 3.1 命令及参数说明 通常的命令执行格式 java [<jvm options>] -jar SPECjvm2008.jar [<SPECjvm2008 options>] [<benchmark name> ...] 可用参数查询：java -jar SPECjvm2008.jar --help Arg Long arg Value Property name Description -h --help Show this help. --version Print SPECjvm2008 version and exit. -sv --showversion Print SPECjvm2008 version and continue. --base Run the base compliant run of SPECjvm2008 (default, unless jvm args are specified). --peak Run the peak compliant run of SPECjvm2008. --lagom Run the Lagom benchmark suite, a version, of SPECjvm2008 that uses a fixed workload. -pf --propfile string specjvm.propfile Use this properties file. -i --iterations int specjvm.miniter, specjvm.maxniter How many iterations to run. 'inf' means an infinite number. -mi --miniter int specjvm.miniter Minimum number of iterations. -ma --maxiter int specjvm.maxniter Maximum number of iterations. -it --iterationtime time specjvm.iteration.time How long one iteration should be. The time is specified as an integer, and assumed to be in seconds, or an integer with unit, for example 4m (4 minutes). Units available are ms, s, m and h. If the iteration time is too short, based on the warmup result, it will be adjusted to expect to finish at least 5 operations. -fit --forceIterationIime time specjvm.iteration.time, specjvm.iteration.time.forced As iteration time, but the time will not be adjusted based on the warmup result. -ja --jvmArgs string specjvm.startup.jvm_options JVM options used for startup subtests. -jl --jvmLauncher path specjvm.benchmark.startup.launcher JVM launcher used for startup subtests. -wt --warmuptime time specjvm.benchmark.warmup.time How long warmup time. The time format is the same as in iteration time. -ops --operations int specjvm.fixed.operations, specjvm.run.type How many operations each iteration will consist of. It will then be a fixed workload and iteration time is ignored. -bt --benchmarkThreads int specjvm.benchmark.threads How many benchmark threads to use. -r --reporter raw file name Invokes the reporter with given file(s). The benchmarks will not be run. -v --verbose specjvm.print.verbose, specjvm.print.progress Print verbose info (harness only). -pja --parseJvmArgs Parse jvm arguments info from command line, including heap settings (uses JMXBean info). This is not done by default. -coe --continueOnError specjvm.continue.on.error Continue to run suite, even if one test fails. -ict --ignoreCheckTest specjvm.run.initial.check Do not run check benchmark. -ikv --ignoreKitValidation specjvm.run.checksum.validation Do not run checksum validition of benchmark kit. -crf --createRawFile boolean specjvm.create.xml.report Whether to generate a raw file. -ctf --createTextFile boolean specjvm.create.txt.report Whether to generate text report. If raw is disabled, so is txt. -chf --createHtmlFile boolean specjvm.create.html.report Whether to generate html report. If raw is disabled, so is html. -xd --xmlDir path specjvm.benchmark.xml.validation.input.dir To set path to xml input files <benchmark(s)> specjvm.benchmarks Name of benchmark(s) to run. By default all submission benchmarks will be selected. 'all' means all sumission benchmarks will be run. See SPECjvm2008 workload names for all values. 3.2 基准测试用例介绍 SPECjvm2008的benchmarks测试用例列表如下： (单位 ops/m 每分钟操作数) Benchmark Name Description startup.helloworld 测试helloworld程序从运行开始到结束所需的时间 startup.compiler.compiler 普通java编译所需要的时间 startup.compiler.sunflow 编译sunflow图像渲染引擎所需要的时间 startup.compress 测试压缩程序，单次压缩所需的时间 startup.crypto.aes 测试AES/DES加密算法，单次加解密所需的时间 输入数据长度为 100 bytes , 713KB startup.crypto.rsa 测试RSA加密算法，单次加解密需要的时间 输入数据长度为 100 bytes, 16KB startup.crypto.signverify 测试单次使用MD5withRSA, SHA1withRSA, SHA1withDSA, SHA256withRSA来签名，识别所需要的时间。 输入数据长度为 1KB, 65KB, 1MB startup.mpegaudio 单次mpeg音频解码所需的时间 startup.scimark.fft 单次快速傅立叶变换所需的时间 startup.scimark.lu 单次LU分解所需的时间 startup.scimark.monte_carlo 单次运行蒙特卡罗算法所需的时间 startup.scimark.sor 单次运行jacobi逐次超松弛迭代法所需的时间 startup.scimark.sparse 单次稀疏矩阵乘积所需的时间 startup.serial 单次通过socket传输java序列化对象到对端反序列化完成所需的时间（基于jboss serialization benchmark） startup.sunflow 单次图片渲染处理所需的时间 startup.xml.transform 单次xml转换所需的时间，转换包括dom,sax,stream方式 startup.xml.validation 单次xml schema校验所需的时间 compiler.compiler 在规定时间内，多线程迭代测试普通java编译，得出 ops/m compiler.sunflow 在规定时间内，多线程迭代测试sunflow图像渲染，得出 ops/m compress 在规定时间内，多线程迭代测试压缩，得出 ops/m crypto.aes 在规定时间内，多线程迭代测试AES/DES加解密算法，得出 ops/m crypto.rsa 在规定时间内，多线程迭代测试RSA加解密算法，得出 ops/m crypto.signverify 在规定时间内，多线程迭代测试使用MD5withRSA, SHA1withRSA, SHA1withDSA, SHA256withRSA来签名，识别，得出 ops/m derby 在规定时间内，迭代测试数据库相关逻辑，包括数据库锁，BigDecimal计算等，最后得出 ops/m mpegaudio 在规定时间内，多线程迭代mpeg音频解码，得出 ops/m scimark.fft.large 在规定时间内，多线程迭代测试快速傅立叶变换，使用32M大数据集，最后得出 ops/m scimark.lu.large 在规定时间内，多线程迭代测试LU分解，使用32M大数据集，最后得出 ops/m scimark.sor.large 在规定时间内，多线程迭代测试jacobi逐次超松弛迭代法，使用32M大数据集，最后得出 ops/m scimark.sparse.large 在规定时间内，多线程迭代测试稀疏矩阵乘积，使用32M大数据集，最后得出 ops/m scimark.fft.small 在规定时间内，多线程迭代测试快速傅立叶变换，使用512K小数据集，最后得出 ops/m scimark.lu.small 在规定时间内，多线程迭代测试LU分解，使用512KB小数据集，最后得出 ops/m scimark.sor.small 在规定时间内，多线程迭代测试jacobi逐次超松弛迭代法，使用512KB小数据集，最后得出 ops/m scimark.sparse.small 在规定时间内，多线程迭代测试稀疏矩阵乘积，使用512KB小数据集，最后得出 ops/m scimark.monte_carlo 在规定时间内，多线程迭代测试蒙特卡罗算法，得出 ops/m serial 在规定时间内，多线程迭代测试通过socket传输java序列化对象到对端反序列化（基于jboss serialization benchmark），得出 ops/m sunflow 在规定时间内，利用sunflow多线程迭代测试图片渲染，得出 ops/m xml.transform 在规定时间内，多线程迭代测试xml转换，得出ops/m xml.validation 在规定时间内，多线程迭代测试xml schema验证，得出 ops/m 4执行基准测试 官方提供了三种基准测试方式，常用的有两种，一种是base，一种是peak，区别在于前者是不允许做任何vm参数调整。后者可以添加vm调优参数。 默认启动方式： java -jar SPECjvm2008.jar 此测试将完整的测试21个用例。 可以选择特定的用例进行测试 如：java -jar SPECjvm2008.jar startup.helloworld 根据需要可以进行vm参数调整，调整后需要使用-peak参数。 如：java -Xms256M -Xmx1024M -jar SPECjvm2008.jar -peak -ikv 5结果查看 测试结果默认的输出路径是安装目录的results 目录下。内部根据你执行测试套件的顺序，又分了不同的子文件夹。进入某个子文件夹，查看html格式的结果就行了。 6参考的URL 用户手册 运行和报告规范 http://www.spec.org/jvm2008/docs/RunRules.html 已知问题 http://www.spec.org/jvm2008/docs/KnownIssues.html 7 总结 1）如果选了base，又修改了vm options怎么办？ 套件在运行时，会给你警告。并且，在你的测试结果上会显示大大的一行Run is not compliant。另外，如果你想将测试结果提交官方，某些参数必须符合官方要求，否则同样是警告。 2）哪些参数有官方要求？ 默认配置文件props/specjvm.properties 里，注释了Permitted for的就是。 3）如何指定配置文件路径？ -pf指定配置文件路径，默认使用的是安装目录下的 props/specjvm.properties，（日志里会打印出使用文件的路径）","tags":"性能测试","title":"SpecJvm2008使用说明"},{"url":"http://king32783784.github.io/2014/09/12/ltp/","text":"Testing Linux, one syscall at a time. LTP是从SGI开始的,后由IBM 思科 富士通 SUSE Redhat等组织开发的.该工具的目标是建立一个测试套件用来验证linux的可靠性,健壮性及稳定性.LTP测试套件包含了linux内核及相关功能的工具. 本文主要介绍关于ltp的一些基本信息. LTP项目主页: ltp Github链接: ltp LTP是一个验证ltp内核功能和稳定性的测试集.用来支持linux开发过程中,通过更多的单元测试,减少bug的引入,降低bug对用户的影响.LTP并不是用来做benchmarking测试的,而是更专注与功能,问题回归及稳定性测试.LTP同样不是一个标准测试,标准测试有 LSB . 一 基本结构 LTP测试套件是由包含一个基本动作和一个确认基本动作工作是否正常的测试用例组成.这个测试用例通常的测试结果是PASS/FAIL.一个测试程序是包含一个或多个测试用例的可执行程序.测试程序包括相应的测试参数,这些参数包括内存测试容量,临时文件位置,网络测试类型等等.Test tags 是用于匹配测试程序和一组命令行参数.Test tags是测试集的基础. 1.编写测试 编写一个测试用例比大多数想象的更容易.任何一个你编写用于验证内核功能的代码都可以用来形成一个用例. 测试退出约定 通常一个简单的判断一个测试用例执行结果的方式就是程序的返回值.如果你的测试程序没有得到一个预期结果或错误结果,程序退出是需要返回一个非零值,如exit1, 同样如果程序得到预期的结果,需要返回0,exit(0).一些测试驱动需要去收集这些返回值.如果一个测试程序包含多个测试用例,你不知道那个出错了,但你会知道程序出错了. 格式化输出 一个简单方式处理测试结果就是每个测试用例都输出一个标准格式的输出结果.这个格式需要是测试人员和分析工具都能理解的格式,当测试结果都按一个标准格式输出时工具就能够分析测试结果. 测试工具 LTP目前没有一个最终的测试工具.我们选择了一个简单的解决方式ltp-pan. Ltp-pan是一个简单的测试驱动程序,它可以跟踪孤儿进程和抓取测试的输出信息.它工作方式是读取一个包括test tags和命令行列表的文件并执行.默认的ltp-pan会随机的从列表中选择命令执行,并等待其结束.可以通过选择多个命令行执行多个测试,在一定时间执行多个测试并且缓冲多个测试结果.这样Ltp-pan可以营造出复杂的测试环境.Ltp-pan使用一个活动文件,通常叫做zoo文件来保存哪些测试在运行.这个文件包括pid,tag以及命令行的一部分.当启动ltp-pan,它本身变成了自己的一个标签.当一个测试标签退出,ltp-pan会第一个字符加#的方式重写.这个活动文件可以在多个ltp-pan实例中共享,所以当系统崩溃时,你可以通过查看一个文件,了解哪个用例造成的. 一个Ltp-pan文件包括一个测试tag列表.格式如下: testtag testprogram -o one -p two other command line options # This is a comment. It is a good idea to describe the test # tags in your ltp-pan file. Tests programs can have different # behaviors depending on the command line options so it is # helpful to describe what each test tag is meant to verify or # provoke. # Some more test cases mm01 mmap001 -m 10000 # 40 Mb mmap() test. # Creates a 10000 page mmap, touches all of the map, sync's # it, and munmap()s it. mm03 mmap001 -i 0 -I 1 -m 100 # repetitive mmapping test. # Creates a one page map repetitively for one minute. dup02 dup02 # Negative test for dup(2) with bad fd kill09 kill09 # Basic test for kill(2) fs-suite01 ltp-pan -e -a fs-suite01.zoo -n fs-suite01 -f runtest/fs 测试例子 运行一个测试基本方式是: $ ltp-pan -a ltp.zoo -n tutor sleep 4 <<< test_start>>> tag = cmdln stime = 971450564 cmdline = \"sleep 4\" contacts = \"\" analysis = exit initiation_status = \"ok\" <<< test_output>>> <<< execution_status>>> duration = 103341903 termination_type = exited termination_id = 0 corefile = no cutime = 0 cstime = 0 <<< test_end>>> $ cat ltp.zoo #9357,tutor,pan/ltp-pan -a ltp.zoo -n tutor sleep 4 #9358,cmdln,sleep 4 $ 如何实现的: 这个例子展示ltp-pan两个参数,一个活动文件,一个test tag. \"sleep 4\"测试程序及ltp-pan要执行的参数.这个测试会得到标记\"cmdln\"。 LTP-run将随机运行一个测试，最终被cmdln，因为指定了唯一测试. 在活动文件,ltp.zoo,ltp-pan写入pid,testlog,运行测试部分命令行.当test tag运行完成,ltp-pan会标记一个\"#\",代表它可以执行.这时,你能看到cmdln和tutor,如果测试机挡住,你可以读这些文件查找哪个测试导致的. 同时运行一个测试多次. $ ltp-pan -a ltp.zoo -n tutor -x 3 -s 3 -O /tmp sleep 1 <<< test_start>>> tag = cmdln stime = 971465653 cmdline = \"sleep 1\" contacts = \"\" analysis = exit initiation_status = \"ok\" <<< test_output>>> <<< execution_status>>> duration = 103326814 termination_type = exited termination_id = 0 corefile = no cutime = 1 cstime = 0 <<< test_end>>> <<< test_start>>> tag = cmdln stime = 971465653 cmdline = \"sleep 1\" contacts = \"\" analysis = exit initiation_status = \"ok\" <<< test_output>>> <<< execution_status>>> duration = 103326814 termination_type = exited termination_id = 0 corefile = no cutime = 0 cstime = 1 <<< test_end>>> <<< test_start>>> tag = cmdln stime = 971465653 cmdline = \"sleep 1\" contacts = \"\" analysis = exit initiation_status = \"ok\" <<< test_output>>> <<< execution_status>>> duration = 103326814 termination_type = exited termination_id = 0 corefile = no cutime = 0 cstime = 0 <<< test_end>>> 如何工作的? 在这个例子中运行了另一个命令行,但是测试执行了3遍(-s 3)并且保持了3个test tags在同一时间执行(-x 3). -O 参数是指定临时文件保存目录,并且为每个缓冲结果设定标签.可以看到cmdln运行了3次.如果 -O 没有指定,则3次结果被混合,就没有意义了. Scanner Ltp-scanner 是一个测试结果分析工具,它可以理解rts风格的输出.最终生成一个汇总结果显示哪个用例pass,哪个用例fail. 测试流程参见下图: 二.LTP文件结构 从 http://ltp.sourceforge.net/下载LTP测试源码包 LTP的目录结构基本上分为文档目录（doc）、测试驱动程序目录（pan）、测试脚本目录（testscripts）、测试用例库（testcase）、测试命令文件目录（runtest）、头文件目录（include）、库目录（lib）等。 * Doc：该目录是说明文件和帮助文档的所在地，这个目录中对LTP的内容和每个工具都有详细的说明。 * Pan：该目录存储的是LTP测试套件的测试驱动程序pan。 * Testscripts：该目录中存储的是可执行的测试脚本，不同方面的测试脚本的集合。 * Testcase：该目录存储了所有LTP测试套件中所使用的测试用例的源码。 * Runtest：该目录中的每个文件都是要执行的测试用例的命令集合，每个文件针对测试的不同方面。 * Include：LTP测试套件的头文件目录，定义了LTP自身的数据结构和函数结构。 * Lib：LTP测试套件运行时自身需要的库文件，定义了LTP自身的各种函数。 各个文件结构之间的联系： ---->testscripts中ltpstress.sh ---->runtest(stress.part1,stress.part2,stress.part3) ---->pan后台运行 ---->最终运行Testcase中的各个测试案例 其中runtest中 stree.part1,stree.part2,stree.part3中的测试命令或脚本 如 mmstress；来源于testcase/bin 中mmstress；而testcase/bin 中mmstress 可执行脚本或命令来源于/testcase中如 kernel,network, pounder21, commands 等源代码编译生成的， mmstress:kernel/mem/mtest05/mmstress.c stress.part n 中测试命令如何看？ 这些命令文件包含测试用例的tag和带有参数的测使用里，格式如下： #tag test case test1 test1 -l 10 mtest01 mtest01 -m 20 fork01 fork01 三.LTP测试方法 测试方法有两个的阶段：一个是\"初始测试\"，一个是\"压力测试\"。 初始测试是开始测试的必要条件。初始测试包括 LTP 测试套件在硬件和操作系统上成功运转，这些硬件和操作系统将用于可靠性运转。LTP 测试套件包附带的驱动程序脚本 runalltest.sh 用于验证内核。这个脚本串行地运行一组成包的测试，并报告全部结果。也可以选择同时并行地运行几个实例。默认地，这个脚本执行： * 文件系统压力测试。 * 硬盘 I/O 测试。 * 内存管理压力测试。 * IPC 压力测试。 * SCHED测试。 * 命令功能的验证测试。 * 系统调用功能的验证测试。 压力测试可以验证产品在系统高使用率时的健壮性。作为 runalltest.sh 的补充，特别设计了一个名为 ltpstress.sh 的测试场景，在使用网络与内存管理的同时并行地运行大范围的内核组件，并在测试系统上生成高压力负荷。ltpstress.sh 也是 LTP 测试套件的一部分。这个脚本并行地运行相似的测试用例，串行地运行不同的测试用例，这样做是为了避免由于同时访问同一资源或者互相干扰而引起的间歇性故障。默认地，这个脚本执行： * NFS 压力测试。 * 内存管理压力测试。 * 文件系统压力测试。 * 数学 (浮点) 测试。 * 多线程压力测试。 * 硬盘 I/O 测试。 * IPC (pipeio, semaphore) 测试。 * 系统调用功能的验证测试。 * 网络压力测试。 四.测试组合的选择 所选择的测试的组合必须给系统的资源带来足够的压力。Linux 内核的四个主要方面可以影响系统的 响应和执行时间： CPU：用于在机器的 CPU（s）上处理数据的时间。 Memory：用于自真实存储器中读写数据的时间。 I/O：用于自磁盘存储器读写数据的时间。 Networking：用于自网络读写数据的时间。 系统资源利用率评价阶段通常需要多次尝试才能得到合适的测试组合，并得到期望水平的利用率。在这个评价过程中，sar 工具也应该在运行。在评价运行的结论中，您应该收集并评价所有四种资源的利用率水平。 具体的测试组合修改方法。 修改方法一： runtest中 stress.part1,stress.part2,stress.part3。 如修改stress.part1中有这样一个测试mem02，根据阅读testcases/kernel/mem/mem／mem02.c 源代码，可将他修改为mem02 -m 15,意思是测试15m内存。 同样的也可以在 stress.part1,stress.part2,stress.part3 中添加、删除一些测试， 如我们测试时就把 stress.part3中关于swap交换分区的去掉 #swapoff01 swapoff01 #swapoff02 swapoff02 #swapon01 swapon01 #swapon02 swapon02 #swapon03 swapon03 修改方法二： 前面提到的初始测试或者压力测试都是测试的默认的，如果想测试其他的或者自己的测试案例，需要修改testcase的 Makefile,因为通过它的Makefile可以看到 SUBDIRS = ls */Makefile | sed \"s/Makefile//g\" | grep -v open | grep -v pounder | grep -v DOTS | grep -v kdump | grep -v realtime sed 's//:/ /g' :想把文本中的冒号替换成空格 grep -v:显示所有与指定模式不匹配的行 也就是说open,pounder,DOTS,kdump,realtime没有测试，当然你可以选上或者，添加上自己的测试案例。 五.工具介绍 Gcov,lcove： 分析代码覆盖率 sar: 帮助我们掌握系统资源的使用情况，特别是内存和CPU 的使用情况， 是UNIX系统使用者应该掌握的工具之一 在我们的测试中，sar工具每 10 秒(当然时间间隔可以修改)钟截取一次系统利用率的快照，并保存到结果文件。 针对sar生成的sar.data使用方法： sar -u sar.data //查看cpu使用情况 sar -r sar.data //看看memory,swap使用情况 …………………… Top: 跟sar差不多的功能，这里我们就用sar 了。 六、其他 什么是稳定性和可靠性？ 稳定性反映的是系统不会出现异常情况；可靠性反映的是系统能够保持正常运行而不受外界影响的能力。 系统的稳定性和可靠性通常以连续运转时间和系统的可靠运行时间来度量。 什么是压力测试？ 压力测试是一种破坏性的测试，即系统在非正常的、超负荷的条件下的运行情况 。用来评估在超越最大负载的情况下系统将如何运行，是系统在正常的情况下对某种负载强度的承受能力的考验 。 为什么要进行压力测试？ 通常我们用压力测试来判断系统的稳定性和可靠性。 Top &#94;","tags":"自动化测试-LTP","title":"Linux Test Project(一)"},{"url":"http://king32783784.github.io/2014/03/01/stablity/","text":"为了验证操作系统启动的稳定性，需要进行500次启动测试，便写了脚本实现。 脚本如下： HOME=`pwd` sleep 15 desktop_x86_4x() { if [ ! -f /etc/reboot.sh ];then cp -rf $ HOME /reboot.sh /etc/ fi if grep \"reboot.sh\" /etc/profile > /dev/null; then break; else echo \"/bin/sh /etc/reboot.sh &\" >> /etc/profile fi if id rebootuser > /dev/null 2>&1; then break else useradd rebootuser passwd rebootuser << TEST abc123 abc123 TEST echo \"[Autologin]\" >> /etc/sddm.conf echo \"Session=plasma.desktop\" >> /etc/sddm.conf echo \"User=rebootuser\" >> /etc/sddm.conf fi } if id rebootuser > /dev/null 2>&1; then break else desktop_x86_4x fi if [ ! -f /etc/tmpbash ];then echo $ 1 >> /etc/tmpbash fi if [ ! -f /home/rebootuser/reboot.log ]; then echo \"Total= $ 1 , Times=0 , start at `date`\" >> /home/rebootuser/reboot.log chmod 777 /home/rebootuser/reboot.log fi times=`cat /etc/tmpbash` n=`cat /home/rebootuser/reboot.log | awk -F, ' { print $ 2}' | awk -F= ' { print $ 2}' | tail -1` if (( $ n < $ times ));then N= $(($ n + 1 )) echo \" Total= $ times , Times= $ N , reboot at `date`\" >> /home/rebootuser/reboot.log sleep 60 reboot else rm /etc/reboot.sh sed -i ' $ d ' /etc/profile fi","tags":"Linux","title":"Reboot test脚本"},{"url":"http://king32783784.github.io/2013/08/29/pmon/","text":"启动过程： PMON2000 MIPS Initializing. Standby... /*CPU Initializing*/ 0xbfe00190 : 00008062f0f8f0f0 CPU CLK SEL : 00000002 CPU clk frequency = SYSCLK x 0x00000020 / 1 /×CPU的频率×/ MEM CLK SEL : 00000003 DDR clk frequency = MEMCLK x 0x00000021 / 3 /*DDR的频率×/ CPU 1 READ TEST... CPU 1 READ TEST OK./×CPU 读测试×/ HT0 frequency reconfig /×总线时钟重新设置×/ Fix L1xbar illegal access at NODE 0 Fix L1xbar illegal access at NODE 1 /×修复节点的一级缓存×/ Fix L2xbar in NODE 0 Fix L2xbar in NODE 1 /×修复节点的二级缓存×/ Init tlb... /×初始化TLB×/ Init htpcitlb.../×初始化PCI总线TLB×/ godson2 caches found /×初始化缓存×/ Jump to 9fc /×跳转到9fc / scache init done /×chache 初始化完成 / Start Init Memory, wait a while...... NODE 0 MEMORY CONFIG BEGIN/*开始初始化内存，首先是节点0的内存×/ Open SMBUS controller/*开启SMBUS控制器×/ Probing DDR MC1 SLOT: / 侦测 DDR控制器MC1 插槽 / Probe MC1 slot 0. /*侦测到MC1 slot0 内存颗粒×/ Probe MC1 slot 1. NO DIMM in this slot. /×MC1 slot 1 没有内存颗粒×/ Probing DDR MC0 SLOT: Probe MC0 slot 0. Probe MC0 slot 1. NO DIMM in this slot./×MC0同MC1*/ s1 = 0xf0a10400__f0a10400 /* new s1 = 0xf0a10400__f0a10400 Disable cpu buffered read /*关闭CPU缓存读×/ Disable read buffer Enable register space of MEMORY /×设置内存寄存器模块使能×/ The MC param is: 00000100 00000100 00000001 00010001 ... /×写入内存参数×/ Disable register space of MEMORY / 关闭内存的寄存器模块 / NODE ID:00000000 Lock Scache Node x--9800?01000000000~4K... Lock Scache Done. Start ARB Leveling.... / 启动ARB训练 / Start Write Leveling. Wait a while... Min value: 0x0000000000000000 Max value: 0x4e46443c44484e50 Cal Mid value: 0x120a0800080c1214 /×写入练习×/ Start read leveling.. Level slice: 0x00000007 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000808 RDLVL_DELAYP_GD_MAX: 0x00003a3c RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003a3a This Slice level success, use first value. /*这一级片训练成功，采用第一个值×/ Level slice: 0x00000006 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000808 RDLVL_DELAYP_GD_MAX: 0x00003a3a RDLVL_DELAYN_GD_MIN: 0x00000808 RDLVL_DELAYN_GD_MAX: 0x00003c3c This Slice level success, use second value. /*这一级片训练成功，采用第二个值×/ Level slice: 0x00000005 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000808 RDLVL_DELAYP_GD_MAX: 0x00003a3a RDLVL_DELAYN_GD_MIN: 0x00000808 RDLVL_DELAYN_GD_MAX: 0x00003c3c This Slice level success, use second value. /*这一级片训练成功，采用第二个值×/ Level slice: 0x00000004 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000808 RDLVL_DELAYP_GD_MAX: 0x00003a3a RDLVL_DELAYN_GD_MIN: 0x00000808 RDLVL_DELAYN_GD_MAX: 0x00003c3c This Slice level success, use second value. /*这一级片训练成功，采用第二个值×/ Level slice: 0x00000003 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000404 RDLVL_DELAYP_GD_MAX: 0x00003c3c RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003c3c This Slice level success, use second value. /*这一级片训练成功，采用第二个值×/ Level slice: 0x00000002 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000404 RDLVL_DELAYP_GD_MAX: 0x00003e3e RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003e3e This Slice level success, use second value. /*这一级片训练成功，采用第二个值×/ Level slice: 0x00000001 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000404 RDLVL_DELAYP_GD_MAX: 0x00003e3e RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003c3c This Slice level success, use second value. /*这一级片训练成功，采用第二个值×/ Level slice: 0x00000000 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000404 RDLVL_DELAYP_GD_MAX: 0x00003e3e RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003c3c This Slice level success, use second value. /*这一级片训练成功，采用第二个值×/ ARB Leveling Finished./ ARB训练完成，MC设置如下： / After ARB level. The MC configuration is: ... 00000c2d 00000c2d Unlock Scache Node x--9800?01000000000~4K... Unlock Scache Done. Disable register space of MEMORY MC0 Config DONE Enable register space of MEMORY The MC param is: 00000100 00000100 00000000 00000000 ... Disable register space of MEMORY NODE ID:00000000 Lock Scache Node x--9800?01000000000~4K... Lock Scache Done. Start ARB Leveling.... Start Write Leveling. Wait a while... Wrlvl Error: This Byte Window not found. Failed byte is byte: 00000006 Try another pad compensation. Start Write Leveling. Wait a while... Wrlvl Error: This Byte Window not found. Failed byte is byte: 00000006 Try another pad compensation. Start Write Leveling. Wait a while... Wrlvl Error: This Byte Window not found. Failed byte is byte: 00000006 Try another pad compensation. Write level failed. Write default value(0x30). /*写训练失败×/ Start read leveling.. Level slice: 0x00000007 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000404 RDLVL_DELAYP_GD_MAX: 0x0000383a RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003c3c This Slice level success, use first value. Level slice: 0x00000006 Wait a while... RDLVL_FAIL_MARK: 0x00000003 RDLVL_GATE_CFG: 0x00000000 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00000000 RDLVL_DELAYP_GD_MIN: 0x00000000 RDLVL_DELAYP_GD_MAX: 0x00000000 RDLVL_DELAYN_GD_MIN: 0x00000000 RDLVL_DELAYN_GD_MAX: 0x00000000 Try another pad compensation. ERROR: This Slice level failed, write default value. /×读训练失败×/ Level slice: 0x00000005 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00001c1c RDLVL_DELAYP_GD_MIN: 0x00000808 RDLVL_DELAYP_GD_MAX: 0x00003a3a RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003e3e This Slice level success, use second value. Level slice: 0x00000004 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00001818 RDLVL_DELAYP_GD_MIN: 0x00000808 RDLVL_DELAYP_GD_MAX: 0x00003a3a RDLVL_DELAYN_GD_MIN: 0x00000808 RDLVL_DELAYN_GD_MAX: 0x00003c3c This Slice level success, use second value. Level slice: 0x00000003 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00001a1a RDLVL_DELAYP_GD_MIN: 0x00000808 RDLVL_DELAYP_GD_MAX: 0x00003e3e RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003e3e This Slice level success, use second value. Level slice: 0x00000002 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00001e1e RDLVL_DELAYP_GD_MIN: 0x00000404 RDLVL_DELAYP_GD_MAX: 0x00003e3e RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003c3c This Slice level success, use second value. Level slice: 0x00000001 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002020 RDLVL_DELAYP_GD_MIN: 0x00000404 RDLVL_DELAYP_GD_MAX: 0x00004040 RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003e3e This Slice level success, use second value. Level slice: 0x00000000 Wait a while... RDLVL_FAIL_MARK: 0x00000000 RDLVL_GATE_CFG: 0x00000101 RDLVL_GATE_GD_MIN: 0x00000000 RDLVL_GATE_GD_MAX: 0x00002222 RDLVL_DELAYP_GD_MIN: 0x00000404 RDLVL_DELAYP_GD_MAX: 0x00003c3c RDLVL_DELAYN_GD_MIN: 0x00000404 RDLVL_DELAYN_GD_MAX: 0x00003e3e This Slice level success, use second value. ERROR!!!: ARB Leveling Fail /*内存训练失败×/ RW Diff 0x0010000000000000 RD Diff 0x0010000000000000 Unlock Scache Node x--9800?01000000000~4K... Unlock Scache Done. Disable register space of MEMORY MC1 Config DONE msize = 0x00000008 !!!MEM is at NO_INTERLEAVE mode. If this is not the expected setting, please check whether the two MC_MEMSIZE is equal DDR space open : 0x00000000 - 0x0FFFFFFF PCI space open: 0x80000000 - 0x8FFFFFFF MC0 space open : 0x80000000 - 0xFFFFFFFF MC1 space open : 0x100000000 - 0x17FFFFFFF DDR space open : 0x080000000 - 0x17FFFFFFF Full PCI space opened as cpu. NODE 1 MEMORY CONFIG BEGIN /节点1 开始内存训练×/ Open SMBUS controller Probing DDR MC1 SLOT: Probe MC1 slot 0. Probe MC1 slot 1. NO DIMM in this slot. Probing DDR MC0 SLOT: Probe MC0 slot 0. Probe MC0 slot 1. NO DIMM in this slot. s1 = 0xf0a10400__f0a10401 new s1 = 0xf0a10400__f0a10401 Disable cpu buffered read Disable read buffer MC1 Config DONE msize = 0x00000800 !!!MEM is at NO_INTERLEAVE mode. If this is not the expected setting, /×内存未启用交错模式×/ please check whether the two MC_MEMSIZE is equal DDR space open : 0x00000000 - 0x0FFFFFFF PCI space open: 0x80000000 - 0x8FFFFFFF MC0 space open : 0x80000000 - 0xFFFFFFFF MC1 space open : 0x100000000 - 0x17FFFFFFF DDR space open : 0x080000000 - 0x17FFFFFFF Full PCI space opened as cpu. system msize = 0x00000808 system s3 = 0x0003030f76543210 Init Memory done. store DIMM info of MC0 store DIMM info of MC1 32 bit PCI space translate to 64 bit HT space Waiting HyperTransport bus to be up.> 00110020 HT RX DMA address ENABLE HT RX DMA address ENABLE done 1 HT RX DMA address ENABLE done 2 Setting HyperTransport Controller to be 8-bit width 00110020 Setting HyperTransport Controller to be 800Mhz 80258523 SET HT as HOST 2001000820010008 Setting HyperTransport Southbridge to be 8-bit width 00110020 Setting HyperTransport Southbridge to be 800M 1c750060 Setting Watch Dog to make a WARM RESET Watch dog Enable Watch dog decode enable 00000000 Watch dog control value 00000000 00000000 Set Watch dog control value Waiting HyperTransport bus to be down.> 00110010 Waiting HyperTransport bus to be up.>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b=>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b= 00110020 Setting HyperTransport Southbridge back to be 8-bit width and 200Mhz for next RESET 1c750560 Checking HyperTransport bus CRC error bit. Checking HyperTransport SouthBridge CRC error bit. Done Read HT Channel priority 00904321 ======This is cww's world:1 enable rs780 dev8... test GPPSB Enabled GPPSB success... sb700 lpc init... set boottimerdisable enable lpc controller enable port 80 LPC decode Decode port 0x3f8-0x3ff Decode port 0x60-0x66 SuperIO RTC ======This is cww's world:2 ======X1 core0 map windows: 900000003ff02000: 0000000018000000 900000003ff02008: 00000e0000000000 900000003ff02010: 0000000000000000 900000003ff02018: 0000000040000000 900000003ff02020: 000000001e000000 900000003ff02028: 00000c0000000000 900000003ff02030: 0000200000000000 900000003ff02038: 000000fdfe000000 900000003ff02040: fffffffffc000000 900000003ff02048: ffffff0000000000 900000003ff02050: 0000000000000000 900000003ff02058: ffffffffc0000000 900000003ff02060: ffffffffff000000 900000003ff02068: 00000c0000000000 900000003ff02070: 0000200000000000 900000003ff02078: 000000fffe000000 900000003ff02080: 00000efdfc0000f7 900000003ff02088: 00000e00000000f7 900000003ff02090: 0000000000000000 900000003ff02098: 00000e00400000f7 900000003ff020a0: 00000e00000000f7 900000003ff020a8: 00000c00000000f7 900000003ff020b0: 00002000000000f7 900000003ff020b8: 000000fdfe0000f7 ======X2 cpu map windows: 900000003ff00000: 000000001fc00000 900000003ff00008: 0000000010000000 900000003ff00010: 0000000000000000 900000003ff00018: 0000000000000000 900000003ff00020: 0000000080000000 900000003ff00028: 0000000100000000 900000003ff00030: 0000000000000000 900000003ff00038: 0000000000000000 900000003ff00040: fffffffffff00000 900000003ff00048: fffffffff0000000 900000003ff00050: fffffffff0000000 900000003ff00058: 0000000000000000 900000003ff00060: ffffffff80000000 900000003ff00068: ffffffff80000000 900000003ff00070: 0000000000000000 900000003ff00078: 0000000000000000 900000003ff00080: 000000001fc000f2 900000003ff00088: 0000000010000082 900000003ff00090: 00000000000000f0 900000003ff00098: 0000000000000000 900000003ff000a0: 00000000000000f0 900000003ff000a8: 00000000000000f1 900000003ff000b0: 0000000000000000 900000003ff000b8: 0000000000000000 ======X2 pci map windows: 900000003ff00100: 0000000080000000 900000003ff00108: 0000000000000000 900000003ff00110: 0000000080000000 900000003ff00118: 0000000080000000 900000003ff00120: 0000000080000000 900000003ff00128: 0000000100000000 900000003ff00130: 0000000000000000 900000003ff00138: 0000000000000000 900000003ff00140: ffffffff80000000 900000003ff00148: 0000000000000000 900000003ff00150: fffffffff0000000 900000003ff00158: 0000000000000000 900000003ff00160: ffffffff80000000 900000003ff00168: ffffffff80000000 900000003ff00170: 0000000000000000 900000003ff00178: 0000000000000000 900000003ff00180: 0000000000000000 900000003ff00188: 0000000000000000 900000003ff00190: 00000000000000f0 900000003ff00198: 0000000000000000 900000003ff001a0: 00000000000000f0 900000003ff001a8: 00000000000000f1 900000003ff001b0: 0000000000000000 900000003ff001b8: 0000000000000000 ======read HT config reg: 90000efdfb000000: 0000000000000000 90000efdfb000060: 0080fff0c0000000 90000efdfb000068: 00008000c0000000 90000efdfb000070: 0000000000000000 ======X1 core0 map windows: 900010003ff02000: 0000000000000000 900010003ff02008: 0000000000000000 900010003ff02010: 0000000000000000 900010003ff02018: 0000000000000000 900010003ff02020: 0000000000000000 900010003ff02028: 00001c0000000000 900010003ff02030: 0000200000000000 900010003ff02038: 00000efdfe000000 900010003ff02040: 0000000000000000 900010003ff02048: 0000000000000000 900010003ff02050: 0000000000000000 900010003ff02058: 0000000000000000 900010003ff02060: 0000000000000000 900010003ff02068: 00001c0000000000 900010003ff02070: 0000200000000000 900010003ff02078: 0000fffffe000000 900010003ff02080: 0000000000000000 900010003ff02088: 0000000000000000 900010003ff02090: 0000000000000000 900010003ff02098: 0000000000000000 900010003ff020a0: 0000000000000000 900010003ff020a8: 00001c00000000f7 900010003ff020b0: 00002000000000f7 900010003ff020b8: 000000fdfe0000f6 ======X2 cpu map windows: 900010003ff00000: 0000000000000000 900010003ff00008: 0000100010000000 900010003ff00010: 0000100000000000 900010003ff00018: 0000000000000000 900010003ff00020: 0000100080000000 900010003ff00028: 0000100100000000 900010003ff00030: 0000000000000000 900010003ff00038: 0000000000000000 900010003ff00040: fffffffff0000000 900010003ff00048: fffffffff0000000 900010003ff00050: fffffffff0000000 900010003ff00058: 0000000000000000 900010003ff00060: ffffffff80000000 900010003ff00068: ffffffff80000000 900010003ff00070: 0000000000000000 900010003ff00078: 0000000000000000 900010003ff00080: 0000000000000000 900010003ff00088: 0000000010000082 900010003ff00090: 00000000000000f0 900010003ff00098: 0000000000000000 900010003ff000a0: 00000000000000f0 900010003ff000a8: 00000000000000f1 900010003ff000b0: 0000000000000000 900010003ff000b8: 0000000000000000 ======X2 pci map windows: 900010003ff00100: 0000000080000000 900010003ff00108: 0000000000000000 900010003ff00110: 0000100080000000 900010003ff00118: 0000000080000000 900010003ff00120: 0000100080000000 900010003ff00128: 0000100100000000 900010003ff00130: 0000000000000000 900010003ff00138: 0000000000000000 900010003ff00140: ffffffff80000000 900010003ff00148: 0000000000000000 900010003ff00150: fffffffff0000000 900010003ff00158: 0000000000000000 900010003ff00160: ffffffff80000000 900010003ff00168: ffffffff80000000 900010003ff00170: 0000000000000000 900010003ff00178: 0000000000000000 900010003ff00180: 0000000000000000 900010003ff00188: 0000000000000000 900010003ff00190: 00000000000000f0 900010003ff00198: 0000000000000000 900010003ff001a0: 00000000000000f0 900010003ff001a8: 00000000000000f1 900010003ff001b0: 0000000000000000 900010003ff001b8: 0000000000000000 ======read HT config reg: 90001efdfb000000: 0000000000000000 90001efdfb000060: 0080fff0c0000000 90001efdfb000068: 00008000c0000000 90001efdfb000070: 0000000000000000 spd_info_store begain. spd_info_store done. Copy PMON to execute location... start = 0x81000000 s0 = 0x3ec00000 81000000 81010000 81020000 81030000 81040000 81050000 81060000 81070000 81080000 81090000 810a0000 810b0000 copy text section done. Copy PMON to execute location done. sp=80ffc000 Uncompressing Bios..................................................................................OK,Booting Bios memorysize_high_n1 0xf0000000 FREQ RTC: 12-15-03 08:40:12 FREI cpu fre 799980000 DONE DEVI ENVI MAPV in envinit nvram=bfc00000 NVRAM@bfcfd800 STDV 80100000: memory between 82fff000-83000000 is already been allocated,heap is already above this point SBDD rs780_early_setup sb700_early_setup rs780_before_pci_fixup sb700_before_pci_fixup rs780_enable sb700_enable disable bus0 device pcie bridges disable OHCI and EHCI controller enable OHCI controller P12PCIH PCIH pcie-slot device: vendor:ffff product:ffff PCIS PCIR PCIW vga_dev =:0 pcie_dev :0 vga_dev ==:82fff348 vga_dev =:82fff348 pcie_dev :0 vga_dev ==:82fff348 sb700_after_pci_fixup NETI RTCL PCID VGAI memorysize=b000000,base=82efe4f0,sysMem=82eee4e8,vram=be0a0000 in setup_int_vect!done!USE inter-graphic device: vendor:1002, device=0x:9615 vgarom romaddress:0x8014a940 Rom base addr: 8014a940 VGA bios found rom size is 59k PCI data structure at offset 1c0 video bios address: c7f00000 lock vga starting bios emu... ax=0,bx=0,cx=0,dx=0 just before emu done ax(0x128) bios emu done vesa_mode : 0x0 ax 4f02 bx 4114 run_bios_int,intno=10,ret=1 VESA VESA FB init complete. fbaddress 0x40000000 ioaddress 0x48000000 fbaddress = c0000000 begin fb_init cfb_console init,fb=c0000000 CONSOLE_SIZE 960000 after fb_init in configure mainbus0 (root) localbus0 at mainbus0 loopdev0 at mainbus0pcibr0 at mainbus0 pci0 at pcibr0 bus 0 ppb0 at pci0 dev 1 function 0 vendor/product: 0x1022/0x9602 (bridge, PCI) pci1 at ppb0 bus 1 vendor/product: 0x1002/0x9615 (display, VGA) at pci1 dev 5 function 0 not configured ppb1 at pci0 dev 2 function 0 vendor/product: 0x1022/0x9603 (bridge, PCI) pci2 at ppb1 bus 2 ppb2 at pci0 dev 3 function 0 vendor/product: 0x1022/0x960b (bridge, PCI) pci3 at ppb2 bus 3 ppb3 at pci0 dev 4 function 0 vendor/product: 0x1022/0x9604 (bridge, PCI) pci4 at ppb3 bus 4 ppb4 at pci0 dev 9 function 0 vendor/product: 0x1022/0x9608 (bridge, PCI) pci5 at ppb4 bus 5 em0 at pci5 dev 0 function 0 vendor/product: 0x8086/0x10d3 (network, ethernet)ent->driver_data is 0x3 em_probe done! generic poll, address 00:23:90:10:96:93 in if attach ppb5 at pci0 dev 10 function 0 vendor/product: 0x1022/0x9609 (bridge, PCI) pci6 at ppb5 bus 6 em1 at pci6 dev 0 function 0 vendor/product: 0x8086/0x10d3 (network, ethernet)ent->driver_data is 0x3 em_probe done! generic poll, address 00:23:90:10:20:59 in if attach pciide0 at pci0 dev 17 function 0 vendor/product: 0x1002/0x4390 (mass storage, IDE): DMA, (partial support), ch 0 cfg to native-PCI, ch 1 cfg to native-PCI pciide0: using generic poll for native-PCI interrupt wd0 at pciide0 channel 0 drive 0: wd0: can use 16-bit, PIO mode 4, DMA mode 2 wd0: 16-sector PIO, LBA, 131071MB, 16383 cyl, 16 head, 63 sec, 268435455 sectors wd1 at pciide0 channel 1 drive 0: wd1: can use 16-bit, PIO mode 4, DMA mode 2 wd1: 16-sector PIO, LBA, 131071MB, 16383 cyl, 16 head, 63 sec, 268435455 sectors pciide0:0:0: using DMA data transfers pciide0:1:0: using DMA data transfers ohci0 at pci0 dev 18 function 0 vendor/product: 0x1002/0x4397 (serialbus, USB)usb base addr : 0xc8708000, bus_base is : 0xc0000000 OHCI revision: 0x00000110 RH: a: 0x02000b03 b: 0x00000000 early period(0x0) OHCI 8b01f000 initialized ok drive at ohci0 devnum 1, Product OHCI Root Hub not configured ohci1 at pci0 dev 18 function 1 vendor/product: 0x1002/0x4398 (serialbus, USB)usb base addr : 0xc8707000, bus_base is : 0xc0000000 OHCI revision: 0x00000110 RH: a: 0x02000b03 b: 0x00000000 early period(0x0) OHCI 8b026c00 initialized ok drive at ohci1 devnum 3, Product Wired Keyboard 600 not configured Read Capacity returns: 0xff17ef00, 0x20000 Capacity = 0xef1800, blocksz = 0x200 usb0 at ohci1 devnum 4, Product OnlyDisk drive at ohci1 devnum 2, Product OHCI Root Hub not configured vendor/product: 0x1002/0x4396 (serialbus, USB) at pci0 dev 18 function 2 not configured vendor/product: 0x1002/0x4397 (serialbus, USB) at pci0 dev 19 function 0 not configured vendor/product: 0x1002/0x4398 (serialbus, USB) at pci0 dev 19 function 1 not configured vendor/product: 0x1002/0x4396 (serialbus, USB) at pci0 dev 19 function 2 not configured vendor/product: 0x1002/0x4385 (serialbus, subclass: 0x05) at pci0 dev 20 function 0 not configured pciide1 at pci0 dev 20 function 1 vendor/product: 0x1002/0x439c (mass storage, IDE): DMA, (partial support), ch 0 cfg to compat, ch 1 cfg to compat vendor/product: 0x1002/0x4383 (multimedia, subclass: 0x03) at pci0 dev 20 function 2 not configured vendor/product: 0x1002/0x439d (bridge, ISA) at pci0 dev 20 function 3 not configured ppb6 at pci0 dev 20 function 4 vendor/product: 0x1002/0x4384 (bridge, PCI) pci7 at ppb6 bus 7 vendor/product: 0x1002/0x4399 (serialbus, USB) at pci0 dev 20 function 5 not configured out configure Self test cmd failed,ignored! KBD_TEST cmd failed,ignored! Keyboard succesfully initialized. Press to set BIOS,waiting for 3 seconds here..... devconfig done. -----------------godson3a_smbus_fixup--------------- set smbus reg (0xbe) :1212 (usb intr map) set smbus reg (0xaf) :1c (sata intr map) SB700 interrupt PIC set begin, set pic_5 pass set pic_5 pass set pic_6 pass set pic_5 pass set pic_5 pass set pic_a pass set pic_9 pass set pic_5 pass PIC control bit: 00007d37 original int mode: 0x00000000 <1> now int mode: 0x00000078 waiting.... <1> now int mode: 0x00007878 SB700 interrupt PIC set done SB700 device interrupt route begin rte0 fixup: em0 ---------------> int5 SB700 device route em0: int5 SB700 device route em1: int6 godson3a_sata_fixup: sata ---------------> int5 -----------------tset sata------------------ sata pci_config 0x40 (14) godson3a_sata: fix sata mode==:5 godson3a_ide_fixup: fix ide mode godson3a fixup: usb ------> int6 godson3a fixup: usb ------> int6 godson3a fixup: usb ------> int6 godson3a fixup: usb ------> int6 godson3a fixup: usb ------> int6 godson3a fixup: usb ------> int6 godson3a fixup: usb ------> int6 godson3a fixup: usb ------> int6 godson3a fixup: VGA ------> int6 godson3a fixup: VGA ------> int6 05:00:00 interrupt line : Error 06:00:00 interrupt line : Error ifinit done. domaininit done. init_proc.... HSTI SYMI SBDE [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ [[ [[[[[[[[[ [[[[[ [[[[ [[[[[ [[[[[ [[[[[ [[[[[ [[[[ [[[[[ [[ [[ [[[[[[[[ [[[[ [[[ [[[[ [[[ [[[[ [[[[ [[[[ [[[ [[[[ [[[ [[[[ [[[ [[[[ [[ [[ [[[[[[[[ [[[[[[ [[[ [[[[[[ [[[ [ [[[ [[[ [[[[[[[[[[[[ [[[[[[[ [[[[[[ [[[ [ [[[ [[ [[ [[[[[[[[ [[[[[[ [[[ [[[[[[ [[[ [[ [[ [[[ [[[ [[[[[[[ [[[[ [[[[[[ [[[ [[ [[ [[ [[ [[[[[[[[ [[[[[[ [[[ [[[[[[ [[[ [[[ [ [[[ [[[[[ [[[[[[[[[[ [[[ [[[[[[ [[[ [[[ [ [[ [[ [[[[[[[[ [[[[ [[[ [[[[ [[[ [[[[ [[[ [[[[ [[[ [[[ [[[[ [[[[ [[[ [[[[ [[ [[ [[[[ [[[[[ [[[[ [[[[[ [[[[ [[[[[ [[[[[[ [[[[ [[[[[ [[ [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[2011 Loongson][[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ Configuration [Bonito,EL,NET,SCSI,IDE] Version: PMON2013 V3.1R052B0053D0201 (Bonito) #1: Fri Feb 1 09:22:13 CST 2013 commit 39e53a7fafbe17ff77b63e61c49f1794f1907570 Author: Chen Xinke chenxinke@ict.ac.cn Date: Sun Jan 27 15:20:17 2013 +0800 . Supported loaders [txt, srec, elf, bin] Supported filesystems [net, fat, fs, disk, iso9660, socket, tty, ram] This software may be redistributed under the BSD copyright. Copyright 2000-2002, Opsycon AB, Sweden. Copyright 2005, ICT CAS. CPU GODSON3 @ 799.98 MHz/ Bus @ 275 MHz Memory size 8192 MB . Primary Instruction cache size 64kb (32 line, 4 way) Primary Data cache size 64kb (32 line, 4 way) Secondary cache size 4096kb BEV1 BEV0 BEV in SR set to zero. Token is correct! flag is 0x0003030f76543210 Store MC info of Node 0 MC 0 Now enable ddr config windows Now Read out DDR parameter from DDR MC0 controler after DDR training Read out DDR MC0 config Done. Programming flash 8000b888:5c8 into bfc0d000 Disable all space write protection of 49LF008A. Erasing FLASH block 13 \b\b\b\b\b\b|\b Done. Enable all space write protection of 49LF008A. Programming FLASH. Disable all space write protection of 49LF008A. \b/\b Done. Enable all space write protection of 49LF008A. Verifying FLASH. \b No Errors found. Store MC info of Node 0 MC 1 Now enable ddr config windows Now Read out DDR parameter from DDR MC1 controler after DDR training Read out DDR MC1 config Done. Programming flash 8000b888:5c8 into bfc0e000 Disable all space write protection of 49LF008A. Erasing FLASH block 14 \b\b\b\b\b\b Done. Enable all space write protection of 49LF008A. Programming FLASH. Disable all space write protection of 49LF008A. \b-\b\\\b Done. Enable all space write protection of 49LF008A. Verifying FLASH. \b No Errors found. Store MC info of Node 1 MC 0 Now enable ddr config windows Now Read out DDR parameter from DDR MC0 controler after DDR training Read out DDR MC0 config Done. Programming flash 8000b888:5c8 into bfc0f000 Disable all space write protection of 49LF008A. Erasing FLASH block 15 \b\b\b\b\b\b Done. Enable all space write protection of 49LF008A. Programming FLASH. Disable all space write protection of 49LF008A. \b|\b Done. Enable all space write protection of 49LF008A. Verifying FLASH. \b/\b No Errors found. Store MC info of Node 1 MC 1 Now enable ddr config windows Now Read out DDR parameter from DDR MC1 controler after DDR training Read out DDR MC1 config Done. Programming flash 8000b888:5c8 into bfc10000 Disable all space write protection of 49LF008A. Erasing FLASH block 16 \b\b\b\b\b\b Done. Enable all space write protection of 49LF008A. Programming FLASH. Disable all space write protection of 49LF008A. \b-\b Done. Enable all space write protection of 49LF008A. Verifying FLASH. \b No Errors found. There is no 1 linux partion we can't locate root directory in super block! usage: bl -d cdrom/ide boot_config_file \b\\\b|usage: bl -d cdrom/ide boot_config_file usage: bl -d cdrom/ide boot_config_file Now booting the LoongsonLinuxSystem Loading file: /dev/fs/ext2@wd0/boot/vmlinux20130419.numa (elf) (elf) 0x80300000/11711552 \b + 0x80e2b440/17428768(z) \b + 19271 syms \b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/\b-\b\\\b|\b/ Entry address is 80305bf0 Boot with parameters: console=tty root=/dev/sda1 /home/TMP/wanghongmei/28/pmon-loongson3/pmon/common/env.c:length of boot_param is 00000090 ac = 00000003, nsp @ 8a7fff00, env @ 8a7fff30, en @ 801453d0 vsp = 08xffffffff8a7fff10, ssp @ 08xffffffff8a7fff30 board_name:Loongson-3A-780E-2w-V1.02-demo ---0x80142730 10 Shutdown:0x80074b68 reset:0x80074cb4 zero at v0 v1 a0 a1 a2 a3 00000000 00000000 00000000 00000000 00000003 8a7fff00 8a7fff30 801453d0 t0 t1 t2 t3 t4 t5 t6 t7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 s0 s1 s2 s3 s4 s5 s6 s7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 t8 t9 k0 k1 gp sp s8 ra 00000000 00000000 00000000 00000000 00000000 8a7ffee0 00000000 800aa3f0 CP0_Config3: CP0 16.3 (0xa0) CP0_PageGrain: CP0 5.1 (0x20000000) Caller cpu 0 NUMA: Discovered 8 cpus on 2 nodes Debug: node_id:0, mem_type:1, mem_start:0x1000000, mem_size:0xf0 MB start_pfn:0x0, end_pfn:0x4000, num_physpages:0x4000 Debug: node_id:0, mem_type:2, mem_start:0x90000000, mem_size:0xf00 MB start_pfn:0x24000, end_pfn:0x60000, num_physpages:0x40000 smbios_addr : 0xfffe000 node0's addrspace_offset is 0x0 node0's start_pfn is 0x0, end_pfn is 0x60000, freepfn is 0x7b3 Debug: node_id:0, mem_type:3, mem_start:0xfffe000, mem_size:0x0 MB Mengxf: total_memsize :0x1000 MB Debug: node_id:1, mem_type:1, mem_start:0x1000000, mem_size:0xf0 MB start_pfn:0x40000000, end_pfn:0x40004000, num_physpages:0x44000 Debug: node_id:1, mem_type:2, mem_start:0x90000000, mem_size:0xf00 MB start_pfn:0x40024000, end_pfn:0x40060000, num_physpages:0x80000 node1's addrspace_offset is 0x100000000000 node1's start_pfn is 0x40000000, end_pfn is 0x40060000, freepfn is 0x40000000 Mengxf: total_memsize :0x1000 MB NUMA: set cpumask cpu 0 on node 0 NUMA: set cpumask cpu 1 on node 0 NUMA: set cpumask cpu 2 on node 0 NUMA: set cpumask cpu 3 on node 0 NUMA: set cpumask cpu 4 on node 1 NUMA: set cpumask cpu 5 on node 1 NUMA: set cpumask cpu 6 on node 1 NUMA: set cpumask cpu 7 on node 1 SET HT_DMA CACHED [ 0.000000] Linux version 2.6.36.3+ (git@ubuntu) (gcc version 4.4.0 (GCC) ) #18 SMP Fri Apr 19 15:23:35 CST 2013 [ 0.000000] shutdown:0xffffffff80074b68 reset:0xffffffff80074cb4 [ 0.000000] vbios locate in ffffffff8014a940 [ 0.000000] Version:1 PMON_Version_V3.1R052B0053D0201 [ 0.000000] Board name:Loongson-3A-780E-2w-V1.02-demo ffffffff80142730 10 [ 0.000000] Board type:0(RS780E) [ 0.000000] cpu_clock:799980000, cputye:2, nr_cpus:8, ccnuma_smp:65536,single_double_way:131072 [ 0.000000] lp:ffffffff8a7fff58, irq_source:ffffffff80142698, offset:-174840000, ht_int_bit:1000000,ht_enable:d17b [ 0.000000] pci_mem_start:40000000, pci_mem_end:7fffffff [ 0.000000] Caller cpu 0 [ 0.000000] NUMA: Discovered 8 cpus on 2 nodes [ 0.000000] bootconsole [early0] enabled [ 0.000000] CPU revision is: 00006305 (ICT Loongson-3A5) [ 0.000000] FPU revision is: 00770501 [ 0.000000] Checking for the multiply/shift bug... no. [ 0.000000] Checking for the daddiu bug... no. [ 0.000000] Determined physical RAM map: [ 0.000000] Initrd not found or empty - disabling initrd [ 0.000000] swiotlb:restricted 32bit dma! [ 0.000000] SWIOTLB: swiotlbsize = 0x4000000 [ 0.000000] Placing 64MB software IO TLB between 98000000026dc000 - 98000000066dc000 [ 0.000000] software IO TLB at phys 0x26dc000 - 0x66dc000 [ 0.000000] Zone PFN ranges: [ 0.000000] DMA32 0x00000000 -> 0x00040000 [ 0.000000] Normal 0x00040000 -> 0x40060000 [ 0.000000] Movable zone start PFN for each node [ 0.000000] early_node_map[4] active PFN ranges [ 0.000000] 0: 0x00000000 -> 0x00004000 [ 0.000000] 0: 0x00024000 -> 0x00060000 [ 0.000000] 1: 0x40000000 -> 0x40004000 [ 0.000000] 1: 0x40024000 -> 0x40060000 [ 0.000000] sizhiying--nr_node_ids:2,highest:3 FILE:mm/page_alloc.c,func:setup_nr_node_ids [ 0.000000] Detected 7 available secondary CPU(s) [ 0.000000] PERCPU: Embedded 3 pages/cpu @9800000006758000 s13376 r8192 d27584 u65536 [ 0.000000] pcpu-alloc: s13376 r8192 d27584 u65536 alloc=4*16384 [ 0.000000] pcpu-alloc: [0] 0 [0] 1 [0] 2 [0] 3 [0] 4 [0] 5 [0] 6 [0] 7 [ 0.000000] Built 2 zonelists in Zone order, mobility grouping on. Total pages: 521600 [ 0.000000] Policy zone: Normal [ 0.000000] Kernel command line: console=tty root=/dev/sda1 [ 0.000000] PID hash table entries: 4096 (order: 1, 32768 bytes) [ 0.000000] c0_config1 = fffffffffee37193 [ 0.000000] Primary instruction cache 64kB, VIPT, 4-way, linesize 32 bytes. [ 0.000000] Primary data cache 64kB, 4-way, VIPT, no aliases, linesize 32 bytes [ 0.000000] c0_config2 = ffffffff80001743 [ 0.000000] Unified secondary cache 4096kB 4-way, linesize 32 bytes, waybit=0. total ram pages initialed 0 [ 0.000000] BUG: Bad page state in process swapper pfn:007b7 [ 0.000000] page:980000010001b008 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] free_hot_cold_page+0x5c/0x250 [ 0.000000] [ ] free_all_bootmem_core+0x154/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] Disabling lock debugging due to kernel taint [ 0.000000] BUG: Bad page state in process swapper pfn:007b8 [ 0.000000] page:980000010001b040 count:0 mapcount:-1048576 mapping:(null) index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] free_hot_cold_page+0x5c/0x250 [ 0.000000] [ ] free_all_bootmem_core+0x154/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:6bdb6db6e00007b9 [ 0.000000] page:980000010001b078 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x10000000000000() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] free_hot_cold_page+0x5c/0x250 [ 0.000000] [ ] free_all_bootmem_core+0x154/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:6bdb6db6e00007ba [ 0.000000] page:980000010001b0b0 count:0 mapcount:-15663104 mapping:(null) index:0x0 [ 0.000000] page flags: 0x10000000000000() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] free_hot_cold_page+0x5c/0x250 [ 0.000000] [ ] free_all_bootmem_core+0x154/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007bb [ 0.000000] page:980000010001b0e8 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] free_hot_cold_page+0x5c/0x250 [ 0.000000] [ ] free_all_bootmem_core+0x154/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007bd [ 0.000000] page:980000010001b158 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] free_hot_cold_page+0x5c/0x250 [ 0.000000] [ ] free_all_bootmem_core+0x154/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007be [ 0.000000] page:980000010001b190 count:0 mapcount:0 mapping:0010000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] free_hot_cold_page+0x5c/0x250 [ 0.000000] [ ] free_all_bootmem_core+0x154/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:6bdb6db6e00007bf [ 0.000000] page:980000010001b1c8 count:0 mapcount:-15663104 mapping:(null) index:0x0 [ 0.000000] page flags: 0xff000000000000() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] free_hot_cold_page+0x5c/0x250 [ 0.000000] [ ] free_all_bootmem_core+0x154/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:6bdb6db6e00007c0 [ 0.000000] page:980000010001b200 count:0 mapcount:0 mapping:00ff000000000000 index:0x0 [ 0.000000] page flags: 0xff000000000000() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007c2 [ 0.000000] page:980000010001b270 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007c3 [ 0.000000] page:980000010001b2a8 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007c4 [ 0.000000] page:980000010001b2e0 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007c6 [ 0.000000] page:980000010001b350 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007c7 [ 0.000000] page:980000010001b388 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007c8 [ 0.000000] page:980000010001b3c0 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007ca [ 0.000000] page:980000010001b430 count:0 mapcount:0 mapping:0010000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007cb [ 0.000000] page:980000010001b468 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007cc [ 0.000000] page:980000010001b4a0 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007ce [ 0.000000] page:980000010001b510 count:0 mapcount:0 mapping:0010000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007cf [ 0.000000] page:980000010001b548 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007d0 [ 0.000000] page:980000010001b580 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007d2 [ 0.000000] page:980000010001b5f0 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007d3 [ 0.000000] page:980000010001b628 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007d4 [ 0.000000] page:980000010001b660 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007d6 [ 0.000000] page:980000010001b6d0 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007d7 [ 0.000000] page:980000010001b708 count:0 mapcount:-1048576 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007d8 [ 0.000000] page:980000010001b740 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007da [ 0.000000] page:980000010001b7b0 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007db [ 0.000000] page:980000010001b7e8 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007dc [ 0.000000] page:980000010001b820 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007de [ 0.000000] page:980000010001b890 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007df [ 0.000000] page:980000010001b8c8 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007e0 [ 0.000000] page:980000010001b900 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007e2 [ 0.000000] page:980000010001b970 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007e3 [ 0.000000] page:980000010001b9a8 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007e4 [ 0.000000] page:980000010001b9e0 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007e6 [ 0.000000] page:980000010001ba50 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007e7 [ 0.000000] page:980000010001ba88 count:0 mapcount:-1048576 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007e8 [ 0.000000] page:980000010001bac0 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007ea [ 0.000000] page:980000010001bb30 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007eb [ 0.000000] page:980000010001bb68 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007ec [ 0.000000] page:980000010001bba0 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007ee [ 0.000000] page:980000010001bc10 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007ef [ 0.000000] page:980000010001bc48 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007f0 [ 0.000000] page:980000010001bc80 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007f2 [ 0.000000] page:980000010001bcf0 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007f3 [ 0.000000] page:980000010001bd28 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007f4 [ 0.000000] page:980000010001bd60 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007f6 [ 0.000000] page:980000010001bdd0 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007f7 [ 0.000000] page:980000010001be08 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007f8 [ 0.000000] page:980000010001be40 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007fa [ 0.000000] page:980000010001beb0 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007fb [ 0.000000] page:980000010001bee8 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007fc [ 0.000000] page:980000010001bf20 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007fe [ 0.000000] page:980000010001bf90 count:0 mapcount:0 mapping:00ff000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:007ff [ 0.000000] page:980000010001bfc8 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:00800 [ 0.000000] page:980000010001c000 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:00802 [ 0.000000] page:980000010001c070 count:0 mapcount:0 mapping:0010000000000000 index:0x10000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:00803 [ 0.000000] page:980000010001c0a8 count:0 mapcount:0 mapping:00ff000000000000 index:0xff000000000000 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] BUG: Bad page state in process swapper pfn:00804 [ 0.000000] page:980000010001c0e0 count:0 mapcount:-1048576 mapping:(null) index:0x0 [ 0.000000] page flags: 0x0() [ 0.000000] Call Trace: [ 0.000000] [ ] dump_stack+0x8/0x34 [ 0.000000] [ ] bad_page+0x10c/0x138 [ 0.000000] [ ] free_pages_prepare+0xa8/0x100 [ 0.000000] [ ] __free_pages_ok+0x38/0x17c [ 0.000000] [ ] free_all_bootmem_core+0x12c/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] Unhandled kernel unaligned access[#1]: [ 0.000000] Cpu 0 [ 0.000000] $ 0 : 0000000000000000 00000000140000e0 0000000000000000 0000000000000000 [ 0.000000] $ 4 : 0000000000000000 ffffffff80cf3c50 0000000000000002 0000000000000001 [ 0.000000] $ 8 : 0000000000000040 0000000000000003 0000000000000001 0000000000000006 [ 0.000000] $12 : 00000000140000e0 000000001000001e ffffffff80e30560 0000000000000000 [ 0.000000] $16 : 0000000000000000 ffffffffdc690008 001af6daee9e5e08 ffffffff80e30540 [ 0.000000] $20 : 0000000000000000 00001fffffffffff 0000000000021400 0000000000000009 [ 0.000000] $24 : 0000000000000000 ffffffff8032382c [ 0.000000] $28 : ffffffff80cf0000 ffffffff80cf3c20 00000000000215f8 ffffffff80300400 [ 0.000000] Hi : 0000000000000000 [ 0.000000] Lo : 0000000000000003 [ 0.000000] epc : ffffffff8032bacc do_ade+0x1cc/0x594 [ 0.000000] Tainted: G B [ 0.000000] ra : ffffffff80300400 ret_from_exception+0x0/0x24 [ 0.000000] Status: 140000e2 KX SX UX KERNEL EXL [ 0.000000] Cause : 40008010 [ 0.000000] BadVA : 001af6daee9e5e0f [ 0.000000] PrId : 00006305 (ICT Loongson-3A5) [ 0.000000] Modules linked in: [ 0.000000] Process swapper (pid: 0, threadinfo=ffffffff80cf0000, task=ffffffff80d015c0, tls=0000000000000000) [ 0.000000] Stack : 00000000140000e0 ffffffff80cf3bef 98000001000215f8 0010000000000000 [ 0.000000] 0000000000060000 ffffffff80300400 0000000000000000 00000000140000e0 [ 0.000000] 0000000000000000 001af6daee9e5e00 001af6db6db80000 0000000000000000 [ 0.000000] 0000000000000002 0000000000000001 0000000000000040 0000000000000003 [ 0.000000] 0000000000000001 0000000000000006 9800000100021540 98000001000215b0 [ 0.000000] ffffffff80e30560 0000000000000000 98000001000215f8 0010000000000000 [ 0.000000] 0000000000060000 ffffffff80e30540 0000000000000000 00001fffffffffff [ 0.000000] 0000000000021400 0000000000000009 0000000000000000 ffffffff8032382c [ 0.000000] 0000000000000001 98000001000215c0 ffffffff80cf0000 ffffffff80cf3d80 [ 0.000000] 00000000000215f8 ffffffff803a5f10 00000000140000e2 0000000000000000 [ 0.000000] ... [ 0.000000] Call Trace: [ 0.000000] [ ] do_ade+0x1cc/0x594 [ 0.000000] [ ] ret_from_exception+0x0/0x24 [ 0.000000] [ ] get_pageblock_flags_group+0x74/0xd0 [ 0.000000] [ ] free_hot_cold_page+0x74/0x250 [ 0.000000] [ ] free_all_bootmem_core+0x154/0x2ac [ 0.000000] [ ] mem_init+0xac/0x1b0 [ 0.000000] [ ] start_kernel+0x190/0x468 [ 0.000000] [ 0.000000] [ 0.000000] Code: 00431024 144000c6 00000000 <6a430007> 6e430000 24020000 0060902d 144000b0 00a0202d [ 0.000000] Kernel panic - not syncing: Attempted to kill the idle task!","tags":"其他","title":"PMON启动信息详解"},{"url":"http://king32783784.github.io/2013/08/01/Makefile/","text":"一 概述 什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和 professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。 因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。 makefile带来的好处就是——\"自动化编译\"，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。 现在讲述如何写 makefile的文章比较少，这是我想写这篇文章的原因。当然，不同厂商的make各不相同，也有不同的语法，但其本质都是在\"文件依赖性\"上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。 在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。 关于程序的编译和链接 在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。 编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。 链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫\"库文件\"（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。 总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File. 好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。 Makefile介绍 make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。 首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感性认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是： 1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。 2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。 3）如果这个工程的头文件被改变了，那么我们需要编译引用了这个头文件的所有C文件，并链接目标程序。 只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 二、Makefile的规则 在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。 target ... : prerequisites ... command ... ... target 也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的\"伪目标\"章节中会有叙述。 prerequisites 就是，要生成那个target所需要的文件或是目标。 command 也就是make需要执行的命令。（任意的Shell命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是 Makefile的规则。也就是Makefile中最核心的内容。 说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：） 三、一个示例 正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。 edit : main . o kbd . o command . o display . o insert . o search . o files . o utils . o cc - o edit main . o kbd . o command . o display . o insert . o search . o files . o utils . o main . o : main . c defs . h cc - c main . c kbd . o : kbd . c defs . h command . h cc - c kbd . c command . o : command . c defs . h command . h cc - c command . c display . o : display . c defs . h buffer . h cc - c display . c insert . o : insert . c defs . h buffer . h cc - c insert . c search . o : search . c defs . h buffer . h cc - c search . c files . o : files . c defs . h buffer . h command . h cc - c files . c utils . o : utils . c defs . h cc - c utils . c clean : rm edit main . o kbd . o command . o display . o insert . o search . o files . o utils . o 换行可使用反斜杠（\\）。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为\"Makefile\"或\"makefile\"的文件中，然后在该目录下直接输入命令\"make\"就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下\"make clean\"就可以了。 在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。 在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。 这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。 四、make是如何工作的 在默认的方式下，也就是我们只输入make命令。那么： 1、make会在当前目录下找名字叫\"Makefile\"或\"makefile\"的文件。 2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到\"edit\"这个文件，并把这个文件作为最终的目标文件。 3、如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。 4、如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程） 5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。 通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——\"make clean\"，以此来清除所有的目标文件，以便重编译。 于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。 而如果我们改变了\"command.h\"，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。 五、makefile中使用变量 在上面的例子中，先让我们看看edit的规则： edit : main . o kbd . o command . o display . o insert . o search . o files . o utils . o cc - o edit main . o kbd . o command . o display . o insert . o search . o files . o utils . o 我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在 clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成 C语言中的宏可能会更好。 比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义： objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o 于是，我们就可以很方便地在我们的makefile中以\"$(objects)\"的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子： objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o edit : $(objects) cc -o edit $(objects) main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.c defs.h command.h cc -c command.c display.o : display.c defs.h buffer.h cc -c display.c insert.o : insert.c defs.h buffer.h cc -c insert.c search.o : search.c defs.h buffer.h cc -c search.c files.o : files.c defs.h buffer.h command.h cc -c files.c utils.o : utils.c defs.h cc -c utils.c clean : rm edit $(objects) 于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。 关于变量更多的话题，我会在后续给你一一道来。 六、让make自动推导 GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。 只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。 objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o edit : $(objects) cc -o edit $(objects) main.o : defs.h kbd.o : defs.h command.h command.o : defs.h command.h display.o : defs.h buffer.h insert.o : defs.h buffer.h search.o : defs.h buffer.h files.o : defs.h buffer.h command.h utils.o : defs.h .PHONY : clean clean : rm edit $(objects) 这种方法，也就是make的\"隐晦规则\"。上面文件内容中，\".PHONY\"表示，clean是个伪目标文件。 关于更为详细的\"隐晦规则\"和\"伪目标文件\"，我会在后续给你一一道来。 七、另类风格的makefile 即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。 objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o edit : $(objects) cc -o edit $(objects) $(objects) : defs.h kbd.o command.o files.o : command.h display.o insert.o search.o files.o : buffer.h .PHONY : clean clean : rm edit $(objects) 这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。 八、清空目标文件的规则 每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个\"修养\"（呵呵，还记得我的《编程修养》吗）。一般的风格都是： clean : rm edit $ ( objects ) 更为稳健的做法是： .PHONY : clean clean : - rm edit $ ( objects ) 前面说过，.PHONY意思表示clean是一个\"伪目标\"，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——\"clean从来都是放在文件的最后\"。 上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。 九、Makefile总述 1、Makefile里有什么 Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。 3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用\"#\"字符，这个就像C/C++中的\"//\"一样。如果你要在你的Makefile中使用\"#\"字符，可以用反斜框进行转义，如：\"#\"。 最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。 2、Makefile的文件名 默认的情况下，make命令会在当前目录下按顺序找寻文件名为\"GNUmakefile\"、\"makefile\"、\"Makefile\"的文件，找到了解释这个文件。在这三个文件名中，最好使用\"Makefile\"这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 \"GNUmakefile\"，这个文件是GNU的make识别的。有另外一些make只对全小写的\"makefile\"文件名敏感，但是基本上来说，大多数的make都支持\"makefile\"和\"Makefile\"这两种默认文件名。 当然，你可以使用别的文件名来书写Makefile，比如：\"Make.Linux\"，\"Make.Solaris\"，\"Make.AIX\"等，如果要指定特定的Makefile，你可以使用make的\"- f\"和\"--file\"参数，如：make -f Make.Linux或make --file Make.AIX。 3、引用其它的Makefile 在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是： include <filename> filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符） 在 include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和 可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和 f.mk，那么，下面的语句： include foo.make *.mk $(bar) 等价于： include foo.make a.mk b.mk c.mk e.mk f.mk make 命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 1、如果make执行时，有\"-I\"或\"--include-dir\"参数，那么make就会在这个参数所指定的目录下去寻找。 2、如果目录 /include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。 如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在 include前加一个减号\"-\"。如： -include <filename> 其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。 4、环境变量 MAKEFILES 如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的 Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的\"目标\"不会起作用，如果环境变量中定义的文件发现错误，make也会不理。 但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的 Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。 5、make的工作方式 GNU的make工作时的执行步骤入下：（想来其它的make也是类似） 1、读入所有的Makefile。 2、读入被include的其它Makefile。 3、初始化文件中的变量。 4、推导隐晦规则，并分析所有规则。 5、为所有的目标文件创建依赖关系链。 6、根据依赖关系，决定哪些目标要重新生成。 7、执行生成命令。 1-5 步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。 当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。 十、书写规则 规则包含两个部分，一个是依赖关系，一个是生成目标的方法。 在 Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让 make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。 好了，还是让我们来看一看如何书写规则。 1、规则举例 foo.o : foo.c defs.h # foo模块 cc -c -g foo.c 看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令\"cc -c -g foo.c\"（以Tab键开头）。这个规则告诉我们两件事： 1、文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。 2、如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件） 2、规则的语法 targets : prerequisites command ... 或是这样： targets : prerequisites ; command command ... targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。 command是命令行，如果其不与\"target吐舌rerequisites\"在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是\"过时的\"，被认为是需要重生成的。这个在前面已经讲过了。 如果命令太长，你可以使用反斜框（‘\\'）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。 一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。 3、在规则中使用通配符 如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：\"*\"，\"?\"和\"[...]\"。这是和Unix的B-Shell是相同的。 波浪号（\"~\"）字符在文件名中也有比较特殊的用途。如果是\"~/test\"，这就表示当前用户的$HOME目录下的test目录。而\"~hchen /test\"则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS 下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量\"HOME\"而定。 通配符代替了你一系列的文件，如\" .c\"表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：\" \"，那么可以用转义字符\"\\\"，如\"*\"来表示真实的\"*\"字符，而不是任意长度的字符串。 好吧，还是先来看几个例子吧： clean : rm - f *. o 上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。 print: *.c lpr -p $? touch print 上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的\"$?\"是一个自动化变量，我会在后面给你讲述。 objects = *.o 上面这个例子，表示了，通符同样可以用在变量中。并不是说[ .o]会展开，不！objects的值就是\" .o\"。Makefile中的变量其实就是 C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样： objects := $(wildcard *.o) 这种用法由关键字\"wildcard\"指出，关于Makefile的关键字，我们将在后面讨论。 4、文件搜寻 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。 Makefile文件中的特殊变量\"VPATH\"就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。 VPATH = src:../headers 上面的的定义指定两个目录，\"src\"和\"../headers\"，make会按照这个顺序进行搜索。目录由\"冒号\"分隔。（当然，当前目录永远是最高优先搜索的地方） 另一个设置文件搜索路径的方法是使用make的\"vpath\"关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个 VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种： 1、vpath 为符合模式 的文件指定搜索目录 。 2、vpath 清除符合模式 的文件的搜索目录。 3、vpath清除所有已被设置好了的文件搜索目录。 vapth 使用方法中的 需要包含\"%\"字符。\"%\"的意思是匹配零或若干字符，例如，\"%.h\"表示所有以\".h\"结尾的文件。 指定了要搜索的文件集，而 则指定了 的文件集的搜索的目录。例如： vpath %.h ../headers 该语句表示，要求make在\"../headers\"目录下搜索所有以\".h\"结尾的文件。（如果某文件在当前目录没有找到的话）我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的 ，或是被重复了的 ，那么，make会按照vpath语句的先后顺序来执行搜索。如： vpath %.c foo vpath % blish vpath %.c bar 其表示\".c\"结尾的文件，先在\"foo\"目录，然后是\"blish\"，最后是\"bar\"目录。 vpath %.c foo:bar vpath % blish 而上面的语句则表示\".c\"结尾的文件，先在\"foo\"目录，然后是\"bar\"目录，最后才是\"blish\"目录。 5、伪目标 最早先的一个例子中，我们提到过一个\"clean\"的目标，这是一个\"伪目标\"： clean : rm *. o temp 正像我们前面例子中的\"clean\"一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的\"目标\"以备完整地重编译而用。（以\"make clean\"来使用该目标）因为，我们并不生成\"clean\"这个文件。\"伪目标\"并不是一个文件，只是一个标签，由于\"伪目标\"不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个\"目标\"才能让其生效。当然，\"伪目标\"的取名不能和文件名重名，不然其就失去了\"伪目标\"的意义了。 当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记\".PHONY\"来显示地指明一个目标是\"伪目标\"，向make说明，不管是否有这个文件，这个目标就是\"伪目标\"。 .PHONY : clean 只要有这个声明，不管是否有\"clean\"文件，要运行\"clean\"这个目标，只有\"make clean\"这样。于是整个过程可以这样写： .PHONY: clean clean: rm *. o temp 伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为\"默认目标\"，只要将其放在第一个。一个示例就是，如果你的 Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用\"伪目标\"这个特性： all : prog1 prog2 prog3 . PHONY : all prog1 : prog1 . o utils . o cc - o prog1 prog1 . o utils . o prog2 : prog2 . o cc - o prog2 prog2 . o prog3 : prog3 . o sort . o utils . o cc - o prog3 prog3 . o sort . o utils . o 我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个\"all\"的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如\"all\"这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。 \".PHONY : all\"声明了\"all\"这个目标为\"伪目标\"。 随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子： .PHONY: cleanall cleanobj cleandiff cleanall : cleanobj cleandiff rm program cleanobj : rm *. o cleandiff : rm *. diff \"make clean\"将清除所有要被清除的文件。\"cleanobj\"和\"cleandiff\"这两个伪目标有点像\"子程序\"的意思。我们可以输入\"make cleanall\"和\"make cleanobj\"和\"make cleandiff\"命令来达到清除不同种类文件的目的。 6、多目标 Makefile 的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量\"$@\"（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。 bigoutput littleoutput : text.g generate text.g -$(subst output,,$@) > $@ 上述规则等价于： bigoutput : text . g generate text . g - big > bigoutput littleoutput : text . g generate text . g - little > littleoutput 其中，- \\((subst output,,\\) @)中的\" \\(\"表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，\"\\) @\"表示目标的集合，就像一个数组，\"$@\"依次取出目标，并执于命令。 7、静态模式 静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法： <targets ...>: <target-pattern>: <prereq-patterns ...> <commands> ... targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。 target-parrtern是指明了targets的模式，也就是的目标集模式。 prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。 这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的 定义成\"%.o\"，意思是我们的 集合中都是以\".o\"结尾的，而如果我们的 定义成\"%.c\"，意思是对 所形成的目标集进行二次定义，其计算方法是，取 模式中的\"%\"（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。 所以，我们的\"目标模式\"或是\"依赖模式\"中都应该有\"%\"这个字符，如果你的文件名中有\"%\"那么你可以使用反斜杠\"\\\"进行转义，来标明真实的\"%\"字符。 看一个例子： objects = foo.o bar.o all : $( objects ) $(objects) : %. o : %. c $( CC ) -c $( CFLAGS ) $< -o $@ 上面的例子中，指明了我们的目标从 \\(object中获取，\"%.o\"表明要所有以\".o\"结尾的目标，也就是\"foo.o bar.o\"，也就是变量\\) object集合的模式，而依赖模式\"%.c\"则取模式\"%.o\"的\"%\"，也就是\"foo bar\"，并为其加下\".c\"的后缀，于是，我们的依赖目标就是\"foo.c bar.c\"。而命令中的\" \\(<\"和\"\\) @\"则是自动化变量，\" \\(<\"表示所有的依赖目标集（也就是\"foo.c bar.c\"），\"\\) @\"表示目标集（也就是\"foo.o bar.o\"）。于是，上面的规则展开后等价于下面的规则： foo.o : foo . c $( CC ) -c $( CFLAGS ) foo.c -o foo.o bar.o : bar . c $( CC ) -c $( CFLAGS ) bar.c -o bar.o 试想，如果我们的\"%.o\"有几百个，那种我们只要用这种很简单的\"静态模式规则\"就可以写完一堆规则，实在是太有效率了。\"静态模式规则\"的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子： files = foo.elc bar.o lose.o $(filter %.o,$(files)) : %. o : %. c $( CC ) -c $( CFLAGS ) $< -o $@ $(filter %.elc,$(files)) : %. elc : %. el emacs -f batch-byte-compile $< $( filter %. o , $ ( files ) )表示调用Makefile的filter函数，过滤\"$filter\"集，只要其中模式为\"%.o\"的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。 8、自动生成依赖性 在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句\"#include \"defs.h\"\"，那么我们的依赖关系应该是： main.o : main.c defs.h 但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个\"-M\"的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令： cc -M main.c 其输出是： main.o : main.c defs.h 于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用\"-MM\"参数，不然，\"-M\"参数会把一些标准库的头文件也包含进来。 gcc -M main.c的输出是： main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \\ /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \\ /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \\ /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \\ /usr/include/bits/sched.h /usr/include/libio.h \\ /usr/include/_G_config.h /usr/include/wchar.h \\ /usr/include/bits/wchar.h /usr/include/gconv.h \\ /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \\ /usr/include/bits/stdio_lim.h gcc -MM main.c的输出则是： main.o: main.c defs.h 那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile 自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个\"name.c\"的文件都生成一个\"name.d\"的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。 于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。 这里，我们给出了一个模式规则来产生[.d]文件： %.d: %.c @ set - e ; rm - f $ @; \\ $ ( CC ) - M $ ( CPPFLAGS ) $ < > $ @. $$$$ ; \\ sed 's,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g' < $ @. $$$$ > $ @; \\ rm - f $ @. $$$$ 这个规则的意思是，所有的[.d]文件依赖于[.c]文件，\"rm -f \\(@\"的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件\"\\) <\"，也就是[.c]文件生成依赖文件，\" \\(@\"表示模式 \"%.d\"文件，如果有一个C文件是name.c，那么\"%\"就是\"name\"，\"\\) \\($\\) \"意为一个随机编号，第二行生成的文件有可能是 \"name.d.12345\"，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。 总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系： main.o : main.c defs.h 转成： main.o main.d : main.c defs.h 于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个 [.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用 Makefile的\"include\"命令，来引入别的Makefile文件（前面讲过），例如： sources = foo.c bar.c include $(sources:.c=.d) 上述语句中的\" \\((sources:.c=.d)\"中的\".c=.d\"的意思是做一个替换，把变量\\) (sources)所有[.c]的字串都替换成 [.d]，关于这个\"替换\"的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。 十一、书写命令 每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。 我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被\"/bin/sh\"——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，\"#\"是注释符，很像C/C++中的\"//\"，其后的本行字符都被注释。 1、显示命令 通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用\"@\"字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如： @echo 正在编译XXX模块...... 当make执行时，会输出\"正在编译XXX模块......\"字串，但不会输出命令，如果没有\"@\"，那么，make将输出： echo 正在编译XXX模块...... 正在编译XXX模块...... 如果make执行时，带入make参数\"-n\"或\"--just-print\"，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。 而make参数\"-s\"或\"--slient\"则是全面禁止命令的显示。 2、命令执行 当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如： 示例一： exec : cd /home/ hchen pwd 示例二： exec : cd /home/ hchen ; pwd 当我们执行\"make exec\"时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出\"/home/hchen\"。 make 一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS- DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如\".exe\"、\".com\"、\".bat\"、\".sh\"等后缀。 3、命令出错 每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。 有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。 为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号\"-\"（在Tab键之后），标记为不管命令出不出错都认为是成功的。如： clean: -rm -f *.o 还有一个全局的办法是，给make加上\"-i\"或是\"--ignore-errors\"参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以\".IGNORE\"作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。 还有一个要提一下的make的参数的是\"-k\"或是\"--keep-going\"，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。 4、嵌套执行make 在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。 例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写： subsystem : cd subdir && $ ( MAKE ) 其等价于： subsystem : $( MAKE ) -C subdir 定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入\"subdir\"目录，然后执行make命令。 我们把这个Makefile叫做\"总控Makefile\"，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了\"-e\"参数。 如果你要传递变量到下级Makefile中，那么你可以使用这样的声明： export <variable ...> 如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明： unexport <variable ...> 如： 示例一： export variable = value 其等价于： variable = value export variable 其等价于： export variable := value 其等价于： variable := value export variable 示例二： export variable += value 其等价于： variable += value export variable 如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。 需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行\"总控Makefile\"时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。 但是make命令中的有几个参数并不往下传递，它们是\"-C\",\"-f\",\"-h\"\"-o\"和\"-W\"（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来： subsystem : cd subdir && $ ( MAKE ) MAKEFLAGS = 如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有\"-t\",\"-n\",和\"-q\"参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。 还有一个在\"嵌套执行\"中比较有用的参数，\"-w\"或是\"--print-directory\"会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是\"/home/hchen/gnu/make\"，如果我们使用\"make -w\"来执行，那么当进入该目录时，我们会看到： make : Entering directory ` /home/hchen/gnu/ make ' . 而在完成下层make后离开目录时，我们会看到： make : Leaving directory ` /home/hchen/gnu/ make ' 当你使用\"-C\"参数来指定make下层Makefile时，\"-w\"会被自动打开的。如果参数中有\"-s\"（\"--slient\"）或是\"--no-print-directory\"，那么，\"-w\"总是失效的。 5、定义命令包 如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以\"define\"开始，以\"endef\"结束，如： define run-yacc yacc $(firstword $&#94;) mv y.tab.c $@ endef 这里，\"run-yacc\"是这个命令包的名字，其不要和Makefile中的变量重名。在\"define\"和\"endef\"中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成\"y.tab.c\"的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。 foo.c : foo.y $(run-yacc) 我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包\"run-yacc\"中的\" \\(&#94;\"就是\"foo.y\"，\"\\) @\"就是\"foo.c\"（有关这种以 \"$\"开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。 十二、使用变量 在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在\"目标\"，\"依赖目标\"，\"命令\"或是 Makefile的其它部分中。 变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有\":\"、\"#\"、\"=\"或是空字符（空格、回车等）。变量是大小写敏感的，\"foo\"、\"Foo\"和\"FOO\"是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。 有一些变量是很奇怪字串，如\" \\(<\"、\"\\) @\"等，这些是自动化变量，我会在后面介绍。 1、变量的基础 变量在声明时需要给予初值，而在使用时，需要给在变量名前加上\" \\(\"符号，但最好用小括号\"（）\"或是大括号\"{}\"把变量给包括起来。如果你要使用真实的\"\\) \"字符，那么你需要用\"$$\"来表示。 变量可以使用在许多地方，如规则中的\"目标\"、\"依赖\"、\"命令\"以及新的变量中。先看一个例子： objects = program.o foo.o utils.o program : $(objects) cc -o program $(objects) $(objects) : defs.h 变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如： foo = c prog.o : prog.$(foo) $(foo)$(foo) -$(foo) prog.$(foo) 展开后得到： prog.o : prog.c cc -c prog.c 当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个\"替代\"的原理。 另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。 2、变量中的变量 在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。 先看第一种方式，也就是简单的使用\"=\"号，在\"=\"左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如： foo = $(bar) bar = $(ugh) ugh = Huh? all: echo $(foo) 我们执行\"make all\"将会打出变量 \\((foo)的值是\"Huh?\"（ $(foo)的值是\\) (bar)， \\((bar)的值是\\) (ugh)，$(ugh)的值是\"Huh?\"）可见，变量是可以使用后面的变量来定义的。 这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面 来定义，如： CFLAGS = $(include_dirs) –O include_dirs = -Ifoo –Ibar 当\"CFLAGS\"在命令中被展开时，会是\"-Ifoo -Ibar -O\"。但这种形式也有不好的地方，那就是递归定义，如： CFLAGS = $( CFLAGS ) –O 或： A = $( B ) B = $( A ) 这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数\"wildcard\"和\"shell\"发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。 为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是\":=\"操作符，如： x := foo y := $(x) bar x := later 其等价于： y := foo bar x := later 值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样： y := $(x) bar x := foo 那么，y的值是\"bar\"，而不是\"foo bar\"。 上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量\"MAKELEVEL\"的使用： ifeq (0, ${ MAKELEVEL } ) cur-dir := $(shell pwd) whoami := $(shell whoami) host-type := $(shell arch) MAKE := ${ MAKE } host-type= ${ host - type } whoami= ${ whoami } endif 关于条件表达式和函数，我们在后面再说，对于系统变量\"MAKELEVEL\"，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的\"嵌套使用make\"），那么，这个变量会记录了我们的当前Makefile的调用层数。 下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来： nullstring := space := $(nullstring) # end of the line nullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用\"#\"注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于\"#\"的使用，注释符\"#\"的这种特性值得我们注意，如果我们这样定义一个变量： dir := /foo/bar # directory to put the frobs in dir这个变量的值是\"/foo/bar\"，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——\"$(dir)/file\"那么就完蛋了。 还有一个比较有用的操作符是\"?=\"，先看示例： FOO ?= bar 其含义是，如果FOO没有被定义过，那么变量FOO的值就是\"bar\"，如果FOO先前被定义过，那么这条语将什么也不做，其等价于： ifeq ($(origin FOO), undefined) FOO = bar endif 3、变量高级用法 这里介绍两种变量的高级使用方法，第一种是变量值的替换。 我们可以替换变量中的共有的部分，其格式是\" \\((var:a=b)\"或是\"\\) \"，其意思是，把变量\"var\"中所有以\"a\"字串\"结尾\"的\"a\"替换成\"b\"字串。这里的\"结尾\"意思是\"空格\"或是\"结束符\"。 还是看一个示例吧： foo := a.o b.o c.o bar := $(foo:.o=.c) 这个示例中，我们先定义了一个\" \\((foo)\"变量，而第二行的意思是把\"\\) (foo)\"中所有以\".o\"字串\"结尾\"全部替换成\".c\"，所以我们的\"$(bar)\"的值就是\"a.c b.c c.c\"。 另外一种变量替换的技术是以\"静态模式\"（参见前面章节）定义的，如： foo := a.o b.o c.o bar := $(foo:%.o=%.c) 这依赖于被替换字串中的有相同的模式，模式中必须包含一个\"%\"字符，这个例子同样让$(bar)变量的值为\"a.c b.c c.c\"。 第二种高级用法是——\"把变量的值再当成变量\"。先看一个例子： x = y y = z a := $($(x)) 在这个例子中， \\((x)的值是\"y\"，所以\\) ( \\((x))就是\\) (y)，于是 \\((a)的值就是\"z\"。（注意，是\"x=y\"，而不是\"x=\\) (y)\"） 我们还可以使用更多的层次： x = y y = z z = u a := $($($(x))) 这里的$(a)的值是\"u\"，相关的推导留给读者自己去做吧。 让我们再复杂一点，使用上\"在变量定义中使用变量\"的第一个方式，来看一个例子： x = $(y) y = z z = Hello a := $($(x)) 这里的 \\((\\) (x))被替换成了 \\((\\) (y))，因为 \\((y)值是\"z\"，所以，最终结果是：a:=\\) (z)，也就是\"Hello\"。 再复杂一点，我们再加上函数： x = variable1 variable2 := Hello y = $(subst 1,2,$(x)) z = y a := $($($(z))) 这个例子中，\" \\((\\) ( \\((z)))\"扩展为\"\\) ( \\((y))\"，而其再次被扩展为\"\\) ( \\((subst 1,2,\\) (x)))\"。 \\((x)的值是\"variable1\"，subst函数把\"variable1\"中的所有\"1\"字串替换成\"2\"字串，于是，\"variable1\"变成\"variable2\"，再取其值，所以，最终，\\) (a)的值就是$(variable2)的值—— \"Hello\"。（喔，好不容易） 在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值： first_second = Hello a = first b = second all = $($ a_ $ b ) 这里的\" \\(a_\\) b\"组成了\"first_second\"，于是，$(all)的值就是\"Hello\"。 再来看看结合第一种技术的例子： a_objects := a.o b.o c.o 1_objects := 1.o 2.o 3.o sources := $($(a1)_objects:.o=.c) 这个例子中，如果 \\((a1)的值是\"a\"的话，那么，\\) (sources)的值就是\"a.c b.c c.c\"；如果 \\((a1)的值是\"1\"，那么\\) (sources)的值是\"1.c 2.c 3.c\"。 再来看一个这种技术和\"函数\"与\"条件语句\"一同使用的例子： ifdef do_sort func := sort else func := strip endif bar := a d b g q c foo := $($(func) $(bar)) 这个示例中，如果定义了\"do_sort\"，那么：foo := \\((sort a d b g q c)，于是\\) (foo)的值就是\"a b c d g q\"，而如果没有定义\"do_sort\"，那么：foo := $(sort a d b g q c)，调用的就是strip函数。 当然，\"把变量的值再当成变量\"这种技术，同样可以用在操作符的左边： dir = foo $(dir)_sources := $(wildcard $(dir)/*.c) define $(dir)_print lpr $($(dir)_sources) endef 这个例子中定义了三个变量：\"dir\"，\"foo_sources\"和\"foo_print\"。 4、追加变量值 我们可以使用\"+=\"操作符给变量追加值，如： objects = main.o foo.o bar.o utils.o objects += another.o 于是，我们的$(objects)值变成：\"main.o foo.o bar.o utils.o another.o\"（another.o被追加进去了） 使用\"+=\"操作符，可以模拟为下面的这种例子： objects = main.o foo.o bar.o utils.o objects := $(objects) another.o 所不同的是，用\"+=\"更为简洁。 如果变量之前没有定义过，那么，\"+=\"会自动变成\"=\"，如果前面有变量定义，那么\"+=\"会继承于前次操作的赋值符。如果前一次的是\":=\"，那么\"+=\"会以\":=\"作为其赋值符，如： variable := value variable += more 等价于： variable := value variable := $(variable) more 但如果是这种情况： variable = value variable += more 由于前次的赋值符是\"=\"，所以\"+=\"也会以\"=\"来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。 5、override 指示符 如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用\"override\"指示符。其语法是： override <variable> = <value> override <variable> := <value> 当然，你还可以追加： override <variable> += <more text> 对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如： override define foo bar endef 6、多行变量 还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过\"命令包\"的技术就是利用这个关键字）。 define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和\"=\"操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。 下面的这个示例展示了define的用法： define two-lines echo foo echo $(bar) endef 7、环境变量 make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了\"-e\"参数，那么，系统环境变量将覆盖Makefile中定义的变量） 因此，如果我们在环境变量中设置了\"CFLAGS\"环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像\"全局变量\"和\"局部变量\"的特性。 当make嵌套调用时（参见前面的\"嵌套调用\"章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节） 当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。 8、目标变量 前面我们所讲的在Makefile中定义的变量都是\"全局变量\"，在整个文件，我们都可以访问这些变量。当然，\"自动化变量\"除外，如\"$<\"等这种类量的自动化变量就属于\"规则型变量\"，这种变量的值依赖于规则的目标和依赖目标的定义。 当然，我样同样可以为某个目标设置局部变量，这种变量被称为\"Target-specific Variable\"，它可以和\"全局变量\"同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。 其语法是： <target ...> : <variable-assignment> <target ...> : overide <variable-assignment> <variable-assignment>可以是前面讲过的各种赋值表达式，如\"=\"、\":=\"、\"+=\"或是\"？=\"。第二个语法是针对于make命令行带入的变量，或是系统环境变量。 这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如： prog : CFLAGS = - g prog : prog . o foo . o bar . o $ ( CC ) $ ( CFLAGS ) prog . o foo . o bar . o prog . o : prog . c $ ( CC ) $ ( CFLAGS ) prog . c foo . o : foo . c $ ( CC ) $ ( CFLAGS ) foo . c bar . o : bar . c $ ( CC ) $ ( CFLAGS ) bar . c 在这个示例中，不管全局的 \\((CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），\\) (CFLAGS)的值都是\"-g\"。 9、模式变量 在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种\"模式\"，可以把变量定义在符合这种模式的所有目标上。 我们知道，make的\"模式\"一般是至少含有一个\"%\"的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量： %.o : CFLAGS = -O 同样，模式变量的语法和\"目标变量\"一样： <pattern ...> : <variable-assignment> <pattern ...> : override <variable-assignment> override同样是针对于系统环境传入的变量，或是make命令行指定的变量。 十三、使用条件判断 使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以 是比较变量的值，或是比较变量和常量的值。 1示例 下面的例子，判断$(CC)变量是否\"gcc\"，如果是的话，则使用GNU函数编译目标。 libs_for_gcc = -lgnu normal_libs = foo : $( objects ) ifeq ($(CC),gcc) $( CC ) -o foo $( objects ) $( libs_for_gcc ) else $( CC ) -o foo $( objects ) $( normal_libs ) endif 可见，在上面示例的这个规则中，目标\"foo\"可以根据变量\"$(CC)\"值来选取不同的函数库来编译程序。 我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。 当我们的变量$(CC)值是\"gcc\"时，目标foo的规则是： foo : $( objects ) $( CC ) -o foo $( objects ) $( libs_for_gcc ) 而当我们的变量$(CC)值不是\"gcc\"时（比如\"cc\"），目标foo的规则是： foo : $( objects ) $( CC ) -o foo $( objects ) $( normal_libs ) 当然，我们还可以把上面的那个例子写得更简洁一些： libs_for_gcc = -lgnu normal_libs = ifeq ($(CC),gcc) libs = $( libs_for_gcc ) else libs = $( normal_libs ) endif foo : $( objects ) $( CC ) -o foo $( objects ) $( libs ) 2、语法 条件表达式的语法为： <conditional-directive> <text-if-true> endif 以及： <conditional-directive> <text-if-true> else <text-if-false> endif 其中 表示条件关键字，如\"ifeq\"。这个关键字有四个。 第一个是我们前面所见过的\"ifeq\" ifeq (<arg1>, <arg2> ) ifeq '<arg1>' '<arg2>' ifeq \"<arg1>\" \"<arg2>\" ifeq \"<arg1>\" '<arg2>' ifeq '<arg1>' \"<arg2>\" 比较参数\"arg1\"和\"arg2\"的值是否相同。当然，参数中我们还可以使用make的函数。如： ifeq ($(strip $(foo)),) <text-if-empty> endif 这个示例中使用了\"strip\"函数，如果这个函数的返回值是空（Empty），那么 就生效。 第二个条件关键字是\"ifneq\"。语法是： ifneq (<arg1>, <arg2> ) ifneq '<arg1>' '<arg2>' ifneq \"<arg1>\" \"<arg2>\" ifneq \"<arg1>\" '<arg2>' ifneq '<arg1>' \"<arg2>\" 其比较参数\"arg1\"和\"arg2\"的值是否相同，如果不同，则为真。和\"ifeq\"类似。 第三个条件关键字是\"ifdef\"。语法是： ifdef <variable-name> 如果变量 的值非空，那到表达式为真。否则，表达式为假。当然， 同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子： 示例一： bar = foo = $(bar) ifdef foo frobozz = yes else frobozz = no endif 示例二： foo = ifdef foo frobozz = yes else frobozz = no endif 第一个例子中，\"$(frobozz)\"值是\"yes\"，第二个则是\"no\"。 第四个条件关键字是\"ifndef\"。其语法是： ifndef <variable-name> 这个我就不多说了，和\"ifdef\"是相反的意思。 在 这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符\"#\"同样也是安全的。\"else\"和\"endif\"也一样，只要不是以[Tab]键开始就行了。 特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如\"$@\"等）放入条件表达式中，因为自动化变量是在运行时才有的。 而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。 十四、使用函数 在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。 1、函数的调用语法 函数调用，很像变量的使用，也是以\"$\"来标识的，其语法如下： $(<function> <arguments> ) 或是 ${ < function > < arguments > } 这里， 就是函数名，make支持的函数不多。 是函数的参数，参数间以逗号\",\"分隔，而函数名和参数之间以\"空格\"分隔。函数调用以\" \\(\"开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用\"\\) (subst a,b, \\((x))\"这样的形式，而不是\"\\) (subst a,b,${x})\"的形式。因为统一会更清楚，也会减少一些不必要的麻烦。 还是来看一个示例： comma:= , empty:= space:= $(empty) $(empty) foo:= a b c bar:= $(subst $(space),$(comma),$(foo)) 在这个示例中， \\((comma)的值是一个逗号。\\) (space)使用了 \\((empty)定义了一个空格，\\) (foo)的值是\"a b c\"， \\((bar)的定义用，调用了函数\"subst\"，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把\\) (foo)中的空格替换成逗号，所以$(bar)的值是\"a,b,c\"。 2、字符串处理函数 $(subst <from>,<to>,<text> ) 名称：字符串替换函数——subst。 功能：把字串 中的 字符串替换成 。 返回：函数返回被替换过后的字符串。 示例：$(subst ee,EE,feet on the street)，把\"feet on the street\"中的\"ee\"替换成\"EE\"，返回结果是\"fEEt on the strEEt\"。 $(patsubst <pattern>,<replacement>,<text> ) 名称：模式字符串替换函数——patsubst。 功能：查找 中的单词（单词以\"空格\"、\"Tab\"或\"回车\"\"换行\"分隔）是否符合模式 ，如果匹配的话，则以 替换。这里， 可以包括通配符\"%\"，表示任意长度的字串。如果 中也包含\"%\"，那么， 中的这个\"%\"将是 中的那个\"%\"所代表的字串。（可以用\"\\\"来转义，以\"\\%\"来表示真实含义的\"%\"字符） 返回：函数返回被替换过后的字符串。 示例：$(patsubst %.c,%.o,x.c.c bar.c)把字串\"x.c.c bar.c\"符合模式[%.c]的单词替换成[%.o]，返回结果是\"x.c.o bar.o\" 备注：这和我们前面\"变量章节\"说过的相关知识有点相似。如： \"$(var:<pattern>=<replacement> )\"相当于\"$(patsubst <pattern>,<replacement>,$(var))\"，而\"$(var: <suffix>=<replacement> )\"则相当于\"$(patsubst %<suffix>,%<replacement>,$(var))\"。 例如有：objects = foo.o bar.o baz.o，那么，\" \\((objects:.o=.c)\"和\"\\) (patsubst %.o,%.c,$(objects))\"是一样的。 $(strip <string> ) 名称：去空格函数——strip。 功能：去掉 字串中开头和结尾的空字符。 返回：返回被去掉空格的字符串值。 示例：$(strip a b c )把字串\"a b c \"去到开头和结尾的空格，结果是\"a b c\"。 $(findstring <find>,<in> ) 名称：查找字符串函数——findstring。 功能：在字串 中查找 字串。 返回：如果找到，那么返回 ，否则返回空字符串。 示例： \\((findstring a,a b c)返回\"a\"字符串，\\) (findstring a,b c)返回\"\"字符串（空字符串） $(filter <pattern...>,<text> ) 名称：过滤函数——filter。 功能：以 模式过滤 字符串中的单词，保留符合模式 的单词。可以有多个模式。 返回：返回符合模式 的字串。 示例： sources := foo.c bar.c baz.s ugh.h foo: $(sources) cc $(filter %.c %.s,$(sources)) -o foo $(filter %.c %.s,$(sources))返回的值是\"foo.c bar.c baz.s\"。 $(filter-out <pattern...>,<text> ) 名称：反过滤函数——filter-out。 功能：以 模式过滤 字符串中的单词，去除符合模式 的单词。可以有多个模式。 返回：返回不符合模式 的字串。 示例： objects=main1.o foo.o main2.o bar.o mains=main1.o main2.o $(filter-out $(mains),$(objects)) 返回值是\"foo.o bar.o\"。 $(sort <list> ) 名称：排序函数——sort。 功能：给字符串 中的单词排序（升序）。 返回：返回排序后的字符串。 示例：$(sort foo bar lose)返回\"bar foo lose\" 。 备注：sort函数会去掉 中相同的单词。 $(word <n>,<text> ) 名称：取单词函数——word。 功能：取字符串 中第 个单词。（从一开始） 返回：返回字符串 中第 个单词。如果 比 中的单词数要大，那么返回空字符串。 示例：$(word 2, foo bar baz)返回值是\"bar\"。 $(wordlist <s>,<e>,<text> ) 名称：取单词串函数——wordlist。 功能：从字符串 中取从 开始到 的单词串。 和 是一个数字。 返回：返回字符串 中从 到 的单词字串。如果 比 中的单词数要大，那么返回空字符串。如果 大于 的单词数，那么返回从 开始，到 结束的单词串。 示例： $(wordlist 2, 3, foo bar baz)返回值是\"bar baz\"。 $(words <text> ) 名称：单词个数统计函数——words。 功能：统计 中字符串中的单词个数。 返回：返回 中的单词数。 示例：$(words, foo bar baz)返回值是\"3\"。 备注：如果我们要取 中最后的一个单词，我们可以这样：$(word $(words ), )。 $(firstword <text> ) 名称：首单词函数——firstword。 功能：取字符串 中的第一个单词。 返回：返回字符串 的第一个单词。 示例：$(firstword foo bar)返回值是\"foo\"。 备注：这个函数可以用word函数来实现：$(word 1, )。 以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用\"VPATH\"变量来指定\"依赖文件\"的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如： override CFLAGS += $(patsubst %,-I%,$(subst : , , $( VPATH ) )) 如果我们的\" \\((VPATH)\"值是\"src:../headers\"，那么\"\\) (patsubst %,-I%, \\((subst :, ,\\) (VPATH)))\"将返回\"-Isrc -I../headers\"，这正是cc或gcc搜索头文件路径的参数。 3、文件名操作函数 下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。 $(dir <names...> ) 名称：取目录函数——dir。 功能：从文件名序列 中取出目录部分。目录部分是指最后一个反斜杠（\"/\"）之前的部分。如果没有反斜杠，那么返回\"./\"。 返回：返回文件名序列 的目录部分。 示例： $(dir src/foo.c hacks)返回值是\"src/ ./\"。 $(notdir <names...> ) 名称：取文件函数——notdir。 功能：从文件名序列 中取出非目录部分。非目录部分是指最后一个反斜杠（\"/\"）之后的部分。 返回：返回文件名序列 的非目录部分。 示例： $(notdir src/foo.c hacks)返回值是\"foo.c hacks\"。 $(suffix <names...> ) 名称：取后缀函数——suffix。 功能：从文件名序列 中取出各个文件名的后缀。 返回：返回文件名序列 的后缀序列，如果文件没有后缀，则返回空字串。 示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是\".c .c\"。 $(basename <names...> ) 名称：取前缀函数——basename。 功能：从文件名序列 中取出各个文件名的前缀部分。 返回：返回文件名序列 的前缀序列，如果文件没有前缀，则返回空字串。 示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是\"src/foo src-1.0/bar hacks\"。 $(addsuffix <suffix>,<names...> ) 名称：加后缀函数——addsuffix。 功能：把后缀 加到 中的每个单词后面。 返回：返回加过后缀的文件名序列。 示例：$(addsuffix .c,foo bar)返回值是\"foo.c bar.c\"。 $(addprefix <prefix>,<names...> ) 名称：加前缀函数——addprefix。 功能：把前缀 加到 中的每个单词后面。 返回：返回加过前缀的文件名序列。 示例：$(addprefix src/,foo bar)返回值是\"src/foo src/bar\"。 $(join <list1>,<list2> ) 名称：连接函数——join。 功能：把 中的单词对应地加到 的单词后面。如果 的单词个数要比 的多，那么， 中的多出来的单词将保持原样。如果 的单词个数要比 多，那么， 多出来的单词将被复制到 中。 返回：返回连接过后的字符串。 示例：$(join aaa bbb , 111 222 333)返回值是\"aaa111 bbb222 333\"。 4、foreach 函数 foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是： $(foreach <var>,<list>,<text> ) 这个函数的意思是，把参数 中的单词逐一取出放到参数 所指定的变量中，然后再执行 所包含的表达式。每一次 会返回一个字符串，循环过程中， 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。 所以， 最好是一个变量名， 可以是一个表达式，而 中一般会使用 这个参数来依次枚举 中的单词。举个例子： names := a b c d files := $(foreach n,$(names),$(n).o) 上面的例子中， \\((name)中的单词会被挨个取出，并存到变量\"n\"中，\"\\) (n).o\"每次根据\" \\((n)\"计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，\\) (files)的值是\"a.o b.o c.o d.o\"。 注意，foreach中的 参数是一个临时的局部变量，foreach函数执行完后，参数 的变量将不在作用，其作用域只在foreach函数当中。 5、if 函数 if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是： $(if <condition>,<then-part> ) 或是 $(if <condition>,<then-part>,<else-part> ) 可见，if函数可以包含\"else\"部分，或是不含。即if函数的参数可以是两个，也可以是三个。 参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是， 会被计算，否则 会被计算。 而if函数的返回值是，如果 为真（非空字符串），那个 会是整个函数的返回值，如果 为假（空字符串），那么 会是整个函数的返回值，此时如果 没有被定义，那么，整个函数返回空字串。 所以， 和 只会有一个被计算。 6、call函数 call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是： $(call <expression>,<parm1>,<parm2>,<parm3>...) 当 make执行这个函数时， 参数中的变量，如 \\((1)，\\) (2)，$(3)等，会被参数 ， ， 依次取代。而 的返回值就是 call函数的返回值。例如： reverse = $(1) $(2) foo = $(call reverse,a,b) 那么，foo的值就是\"a b\"。当然，参数的次序是可以自定义的，不一定是顺序的，如： reverse = $(2) $(1) foo = $(call reverse,a,b) 此时的foo的值就是\"b a\"。 7、origin函数 origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是： $(origin <variable> ) 注意， 是变量的名字，不应该是引用。所以你最好不要在 中使用\"$\"字符。Origin函数会以其返回值来告诉你这个变量的\"出生情况\"，下面，是origin函数的返回值: \"undefined\" 如果 从来没有定义过，origin函数返回这个值\"undefined\"。 \"default\" 如果 是一个默认的定义，比如\"CC\"这个变量，这种变量我们将在后面讲述。 \"environment\" 如果 是一个环境变量，并且当Makefile被执行时，\"-e\"参数没有被打开。 \"file\" 如果 这个变量被定义在Makefile中。 \"command line\" 如果 这个变量是被命令行定义的。 \"override\" 如果 是被override指示符重新定义的。 \"automatic\" 如果 是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。 这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量\"bletch\"，而我们的环境中也有一个环境变量\"bletch\"，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写： ifdef bletch ifeq \"$(origin bletch)\" \"environment\" bletch = barf, gag, etc. endif endif 当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。 8、shell函数 shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号\"`\"是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如： contents := $(shell cat foo) files := $(shell echo *.c) 注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。 9、控制make的函数 make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。 $(error <text ...> ) 产生一个致命的错误， 是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如： 示例一： ifdef ERROR_001 $(error error is $(ERROR_001)) endif 示例二： ERR = $( error found an error! ) .PHONY : err err : ; $( ERR ) 示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。 $(warning <text ...> ) 这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。 十五、make的运行 一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。 1、make的退出码 make命令执行后有三个退出码： 0 —— 表示成功执行。 1 —— 如果make运行时出现任何错误，其返回1。 2 —— 如果你使用了make的\"-q\"选项，并且make使得一些目标不需要更新，那么返回2。 Make的相关参数我们会在后续章节中讲述。 2、指定Makefile 前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——\"GNUmakefile\"、\"makefile\"和\"Makefile\"。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。 当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的\"-f\"或是\"--file\"参数（\"-- makefile\"参数也行）。例如，我们有个makefile的名字是\"hchen.mk\"，那么，我们可以这样来让make来执行这个文件： make –f hchen.mk 如果在make的命令行是，你不只一次地使用了\"-f\"参数，那么，所有指定的makefile将会被连在一起传递给make执行。 3、指定目标 一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的\"make clean\"形式） 任何在makefile中的目标都可以被指定成终极目标，但是除了以\"- \"打头，或是包含了\"=\"的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。 有一个make的环境变量叫\"MAKECMDGOALS\"，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子： sources = foo.c bar.c ifneq ( $(MAKECMDGOALS),clean) include $(sources:.c=.d) endif 基于上面的这个例子，只要我们输入的命令不是\"make clean\"，那么makefile会自动包含\"foo.d\"和\"bar.d\"这两个makefile。 使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子： .PHONY: all all: prog1 prog2 prog3 prog4 从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——\"prog1\"，\"prog2\"，\"prog3\"和\"prog4\"，我们可以使用\"make all\"命令来编译所有的目标（如果把all置成第一个目标，那么只需执行\"make\"），我们也可以使用\"make prog2\"来单独编译目标\"prog2\"。 即然make可以指定所有makefile中的目标，那么也包括\"伪目标\"，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。 \"all\" 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。 \"clean\" 这个伪目标功能是删除所有被make创建的文件。 \"install\" 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。 \"print\" 这个伪目标的功能是例出改变过的源文件。 \"tar\" 这个伪目标功能是把源程序打包备份。也就是一个tar文件。 \"dist\" 这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。 \"TAGS\" 这个伪目标功能是更新所有的目标，以备完整地重编译使用。 \"check\"和\"test\" 这两个伪目标一般用来测试makefile的流程。 当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。 4、检查规则 有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数： \"-n\" \"--just-print\" \"--dry-run\" \"--recon\" 不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。 \"-t\" \"--touch\" 这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。 \"-q\" \"--question\" 这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。 \"-W \" \"--what-if= \" \"--assume-new= \" \"--new-file= \" 这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和\"-n\"参数一同使用，来查看这个依赖文件所发生的规则命令。 另外一个很有意思的用法是结合\"-p\"和\"-v\"来输出makefile被执行时的信息（这个将在后面讲述）。 5、make的参数 下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。 \"-b\" \"-m\" 这两个参数的作用是忽略和其它版本make的兼容性。 \"-B\" \"--always-make\" 认为所有的目标都需要更新（重编译）。 \"-C \" \"--directory= \" 指定读取makefile的目录。如果有多个\"-C\"参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：\"make –C ~hchen/test –C prog\"等价于\"make –C ~hchen/test/prog\"。 \"—debug[= ]\" 输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是 的取值： a —— 也就是all，输出所有的调试信息。（会非常的多） b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。 v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。 i —— 也就是implicit，输出所以的隐含规则。 j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。 m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。 \"-d\" 相当于\"--debug=a\"。 \"-e\" \"--environment-overrides\" 指明环境变量的值覆盖makefile中定义的变量的值。 \"-f= \" \"--file= \" \"--makefile= \" 指定需要执行的makefile。 \"-h\" \"--help\" 显示帮助信息。 \"-i\" \"--ignore-errors\" 在执行时忽略所有的错误。 \"-I \" \"--include-dir= \" 指定一个被包含makefile的搜索目标。可以使用多个\"-I\"参数来指定多个目录。 \"-j [ ]\" \"--jobs[= ]\" 指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的\"-j\"参数，那么仅最后一个\"-j\"才是有效的。（注意这个参数在MS-DOS中是无用的） \"-k\" \"--keep-going\" 出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。 \"-l \" \"--load-average[=<load]\" \"—max-load[= ]\" 指定make运行命令的负载。 \"-n\" \"--just-print\" \"--dry-run\" \"--recon\" 仅输出执行过程中的命令序列，但并不执行。 \"-o \" \"--old-file= \" \"--assume-old= \" 不重新生成的指定的 ，即使这个目标的依赖文件新于它。 \"-p\" \"--print-data-base\" 输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用\"make -qp\"命令。如果你想查看执行makefile前的预设变量和规则，你可以使用\"make –p –f /dev/null\"。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。 \"-q\" \"--question\" 不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。 \"-r\" \"--no-builtin-rules\" 禁止make使用任何隐含规则。 \"-R\" \"--no-builtin-variabes\" 禁止make使用任何作用于变量上的隐含规则。 \"-s\" \"--silent\" \"--quiet\" 在命令运行时不输出命令的输出。 \"-S\" \"--no-keep-going\" \"--stop\" 取消\"-k\"选项的作用。因为有些时候，make的选项是从环境变量\"MAKEFLAGS\"中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的\"-k\"选项失效。 \"-t\" \"--touch\" 相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。 \"-v\" \"--version\" 输出make程序的版本、版权等关于make的信息。 \"-w\" \"--print-directory\" 输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。 \"--no-print-directory\" 禁止\"-w\"选项。 \"-W \" \"--what-if= \" \"--new-file= \" \"--assume-file= \" 假定目标 需要更新，如果和\"-n\"选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有\"-n\"那么就像运行UNIX的\"touch\"命令一样，使得 的修改时间为当前时间。 \"--warn-undefined-variables\" 只要make发现有未定义的变量，那么就输出警告信息。 十六、隐含规则 在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的\"隐含的\"，早先约定了的，不需要我们再写出来的规则。 \"隐含规则\"也就是一种惯例，make会按照这种\"惯例\"心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。 \"隐含规则\"会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量\"CFLAGS\"可以控制编译时的编译器参数。 我们还可以通过\"模式规则\"的方式写下自己的隐含规则。用\"后缀规则\"来定义隐含规则会有许多的限制。使用\"模式规则\"会更回得智能和清楚，但\"后缀规则\"可以用来保证我们Makefile的兼容性。我们了解了\"隐含规则\"，可以让其为我们更好的服务，也会让我们知道一些\"约定俗成\"了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候\"隐含规则\"也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。 1、使用隐含规则 如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile： foo : foo.o bar.o cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS) 我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的\"隐含规则\"功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。 make 会在自己的\"隐含规则\"库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令\"cc –c $(CFLAGS) [.c]\"来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则： foo.o : foo.c cc –c foo.c $(CFLAGS) bar.o : bar.c cc –c bar.c $(CFLAGS) 因为，这已经是\"约定\"好了的事了，make和我们约定好了用C编译器\"cc\"生成[.o]文件的规则，这就是隐含规则。 当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。 还有，在make的\"隐含规则库\"中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）： foo.o : foo.p 依赖文件\"foo.p\"（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了\"foo.c\"文件，那么我们的隐含规则一样会生效，并会通过 \"foo.c\"调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出\"依赖规则\"，而不写命令。 2、隐含规则一览 这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数\"-r\"或\"--no-builtin-rules\"选项来取消所有的预设置的隐含规则。 当然，即使是我们指定了\"-r\"参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了\"后缀规则\"来定义的，所以，只要隐含规则中有\"后缀列表 \"（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。 还是先来看一看常用的隐含规则吧。 1、编译C程序的隐含规则。 \" .o\"的目标的依赖目标会自动推导为\" .c\"，并且其生成命令是\"$(CC) –c $(CPPFLAGS) $(CFLAGS)\" 2、编译C++程序的隐含规则。 \" .o\" 的目标的依赖目标会自动推导为\" .cc\"或是\" .C\"，并且其生成命令是\"$(CXX) –c $(CPPFLAGS) $(CFLAGS)\"。（建议使用\".cc\"作为C++源文件的后缀，而不是\".C\"） 3、编译Pascal程序的隐含规则。 \" .o\"的目标的依赖目标会自动推导为\" .p\"，并且其生成命令是\"$(PC) –c $(PFLAGS)\"。 4、编译Fortran/Ratfor程序的隐含规则。 \" .o\"的目标的依赖目标会自动推导为\" .r\"或\" .F\"或\" .f\"，并且其生成命令是: \".f\" \"$(FC) –c $(FFLAGS)\" \".F\" \"$(FC) –c $(FFLAGS) $(CPPFLAGS)\" \".f\" \"$(FC) –c $(FFLAGS) $(RFLAGS)\" 5、预处理Fortran/Ratfor程序的隐含规则。 \" .f\"的目标的依赖目标会自动推导为\" .r\"或\" .F\"。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是： \".F\" \"$(FC) –F $(CPPFLAGS) $(FFLAGS)\" \".r\" \"$(FC) –F $(FFLAGS) $(RFLAGS)\" 6、编译Modula-2程序的隐含规则。 \" .sym\" 的目标的依赖目标会自动推导为\" .def\"，并且其生成命令是：\" \\((M2C) $(M2FLAGS) $(DEFFLAGS)\"。\"<n.o>\" 的目标的依赖目标会自动推导为\"<n>.mod\"，并且其生成命令是：\"\\) (M2C) $(M2FLAGS) $(MODFLAGS)\"。 7、汇编和汇编预处理的隐含规则。 \" .o\" 的目标的依赖目标会自动推导为\" .s\"，默认使用编译品\"as\"，并且其生成命令是：\" \\((AS) $(ASFLAGS)\"。\"<n>.s\" 的目标的依赖目标会自动推导为\"<n>.S\"，默认使用C预编译器\"cpp\"，并且其生成命令是：\"\\) (AS) $(ASFLAGS)\"。 8、链接Object文件的隐含规则。 \" \" 目标依赖于\" .o\"，通过运行C的编译器来运行链接程序生成（一般是\"ld\"），其生成命令是：\"$(CC) $(LDFLAGS) .o $(LOADLIBES) $(LDLIBS)\"。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则： x : y.o z.o 并且\"x.c\"、\"y.c\"和\"z.c\"都存在时，隐含规则将执行如下命令： cc -c x.c -o x.o cc -c y.c -o y.o cc -c z.c -o z.o cc x.o y.o z.o -o x rm -f x.o rm -f y.o rm -f z.o 如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。 9、Yacc C程序时的隐含规则。 \" .c\"的依赖文件被自动推导为\"n.y\"（Yacc生成的文件），其生成命令是：\"$(YACC) $(YFALGS)\"。（\"Yacc\"是一个语法分析器，关于其细节请查看相关资料） 10、Lex C程序时的隐含规则。 \" .c\"的依赖文件被自动推导为\"n.l\"（Lex生成的文件），其生成命令是：\"$(LEX) $(LFALGS)\"。（关于\"Lex\"的细节请查看相关资料） 11、Lex Ratfor程序时的隐含规则。 \" .r\"的依赖文件被自动推导为\"n.l\"（Lex生成的文件），其生成命令是：\"$(LEX) $(LFALGS)\"。 12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。 \" .ln\" （lint生成的文件）的依赖文件被自动推导为\"n.c\"，其生成命令是：\"$(LINT) $(LINTFALGS) $(CPPFLAGS) -i\"。对于\" .y\"和\" .l\"也是同样的规则。 3、隐含规则使用的变量 在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的\"-R\"或\"--no– builtin-variables\"参数来取消你所定义的变量对隐含规则的作用。例如，第一条隐含规则——编译C程序的隐含规则的命令是\" \\((CC) –c $(CFLAGS) $(CPPFLAGS)\"。Make默认的编译命令是\"cc\"，如果你把变量\"\\) (CC)\"重定义成\"gcc\"，把变量\"$(CFLAGS)\"重定义成 \"-g\"，那么，隐含规则中的命令全部会以\"gcc –c -g $(CPPFLAGS)\"的样子来执行了。 我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如\"CC\"；一种是参数相的关，如\"CFLAGS\"。下面是所有隐含规则中会用到的变量： 3.1、关于命令的变量。 AR 函数库打包程序。默认命令是\"ar\"。 AS 汇编语言编译程序。默认命令是\"as\"。 CC C语言编译程序。默认命令是\"cc\"。 CXX C++语言编译程序。默认命令是\"g++\"。 CO 从 RCS文件中扩展文件程序。默认命令是\"co\"。 CPP C程序的预处理器（输出是标准输出设备）。默认命令是\"$(CC) –E\"。 FC Fortran 和 Ratfor 的编译器和预处理程序。默认命令是\"f77\"。 GET 从SCCS文件中扩展文件的程序。默认命令是\"get\"。 LEX Lex方法分析器程序（针对于C或Ratfor）。默认命令是\"lex\"。 PC Pascal语言编译程序。默认命令是\"pc\"。 YACC Yacc文法分析器（针对于C程序）。默认命令是\"yacc\"。 YACCR Yacc文法分析器（针对于Ratfor程序）。默认命令是\"yacc –r\"。 MAKEINFO 转换Texinfo源文件（.texi）到Info文件程序。默认命令是\"makeinfo\"。 TEX 从TeX源文件创建TeX DVI文件的程序。默认命令是\"tex\"。 TEXI2DVI 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是\"texi2dvi\"。 WEAVE 转换Web到TeX的程序。默认命令是\"weave\"。 CWEAVE 转换C Web 到 TeX的程序。默认命令是\"cweave\"。 TANGLE 转换Web到Pascal语言的程序。默认命令是\"tangle\"。 CTANGLE 转换C Web 到 C。默认命令是\"ctangle\"。 RM 删除文件命令。默认命令是\"rm –f\"。 3.2、关于命令参数的变量 下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。 ARFLAGS 函数库打包程序AR命令的参数。默认值是\"rv\"。 ASFLAGS 汇编语言编译器参数。（当明显地调用\".s\"或\".S\"文件时）。 CFLAGS C语言编译器参数。 CXXFLAGS C++语言编译器参数。 COFLAGS RCS命令参数。 CPPFLAGS C预处理器参数。（ C 和 Fortran 编译器也会用到）。 FFLAGS Fortran语言编译器参数。 GFLAGS SCCS \"get\"程序参数。 LDFLAGS 链接器参数。（如：\"ld\"） LFLAGS Lex文法分析器参数。 PFLAGS Pascal语言编译器参数。 RFLAGS Ratfor 程序的Fortran 编译器参数。 YFLAGS Yacc文法分析器参数。 4、隐含规则链 有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做\"隐含规则链\"。 在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。 我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？ 在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以\"rm -f\"删除。 通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标\".INTERMEDIATE\"来强制声明。（如：.INTERMEDIATE ： mid ） 你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标\".SECONDARY\"来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标\".PRECIOUS\"的依赖目标，以保存被隐含规则所生成的中间文件。 在\"隐含规则链\"中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。 Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件\"foo.c\"生成目标程序\"foo\"，按道理，make会编译生成中间文件\"foo.o\"，然后链接成\"foo\"，但在实际情况下，这一动作可以被一条\"cc\"的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。 5、定义模式规则 你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有\"%\"字符。\"%\"的意思是表示一个或多个任意字符。在依赖目标中同样可以使用\"%\"，只是依赖目标中的\"%\"的取值，取决于其目标。 有一点需要注意的是，\"%\"的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的\"%\"则发生在运行时。 1、模式规则介绍 模式规则中，至少在规则的目标定义中要包含\"%\"，否则，就是一般的规则。目标中的\"%\"定义表示对文件名的匹配，\"%\"表示长度任意的非空字符串。例如：\"%.c\"表示以\".c\"结尾的文件名（文件名的长度至少为3），而\"s.%.c\"则表示以\"s.\"开头，\".c\"结尾的文件名（文件名的长度至少为 5）。 如果\"%\"定义在目标中，那么，目标中的\"%\"的值决定了依赖目标中的\"%\"的值，也就是说，目标中的模式的\"%\"决定了依赖目标中\"%\"的样子。例如有一个模式规则如下： %.o : %.c ; 其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是\"a.o b.o\"，那么\"%c\"就是\"a.c b.c\"。 一旦依赖目标中的\"%\"模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。 2、模式规则示例 下面这个例子表示了，把所有的[.c]文件都编译成[.o]文件。 %.o : %.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@ 其中，\" \\(@\"表示所有的目标的挨个值，\"\\) <\"表示了所有依赖目标的挨个值。这些奇怪的变量我们叫\"自动化变量\"，后面会详细讲述。 下面的这个例子中有两个目标是模式的： %.tab.c %.tab.h: %.y bison -d $< 这条规则告诉make把所有的[.y]文件都以\"bison -d .y\"执行，然后生成\" .tab.c\"和\" .tab.h\"文件。（其中，\" \" 表示一个任意字符串）。如果我们的执行程序\"foo\"依赖于文件\"parse.tab.o\"和\"scan.o\"，并且文件\"scan.o\"依赖于文件\"parse.tab.h\"，如果\"parse.y\"文件被更新了，那么根据上述的规则，\"bison -d parse.y\"就会被执行一次，于是，\"parse.tab.o\"和\"scan.o\"的依赖文件就齐了。（假设，\"parse.tab.o\" 由\"parse.tab.c\"生成，和\"scan.o\"由\"scan.c\"生成，而\"foo\"由\"parse.tab.o\"和\"scan.o\"链接生成，而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足） 3、自动化变量 在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。 自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。 下面是所有的自动化变量及其说明： \\(@表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，\"\\) @\"就是匹配于目标中模式定义的集合。 \\(%仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是\"foo.a(bar.o)\"，那么，\"\\) %\"就是\"bar.o\"，\"$@\"就是\"foo.a\"。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。 \\(<依赖目标中的第一个目标名字。如果依赖目标是以模式（即\"%\"）定义的，那么\"\\) <\"将是符 合模式的一系列的文件集。注意，其是一个一个取出来的。 $?所有比目标新的依赖目标的集合。以空格分隔。 $&#94;所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。 \\(+这个变量很像\"\\) &#94;\"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。 \\(*这个变量表示目标模式中\"%\"及其之前的部分。如果目标是\"dir/a.foo.b\"，并且目标的模式是\"a.%.b\"，那么，\"\\) \"的值就是\"dir /a.foo\"。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么\" \\(*\"也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么\"\\) \"就是除了后缀的那一部分。例如：如果目标是\"foo.c\"，因为\".c\"是make所能识别的后缀名，所以，\" \\(*\"的值就是\"foo\"。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用\"\\) \"，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么\"$ \"就是空值。 当你希望只对更新过的依赖文件进行操作时，\"$?\"在显式规则中很有用，例如，假设有一个函数库文件叫\"lib\"，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是： lib : foo.o bar.o lose.o win.o ar r lib $? 在上述所列出来的自动量变量中。四个变量（ \\(@、\\) <、 \\(%、\\) *）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上\"D\"或\"F\"字样。这是GNU make中老版本的特性，在新版本中，我们使用函数\"dir\"或\"notdir\"就可以做到了。\"D\"的含义就是Directory，就是目录，\"F\"的含义就是File，就是文件。 下面是对于上面的七个变量分别加上\"D\"或是\"F\"的含义： \\((@D)表示\"\\) @\"的目录部分（不以斜杠作为结尾），如果\" \\(@\"值是\"dir/foo.o\"，那么\"\\) (@D)\"就是\"dir\"，而如果\"$@\"中没有包含斜杠的话，其值就是\".\"（当前目录）。 \\((@F)表示\"\\) @\"的文件部分，如果\" \\(@\"值是\"dir/foo.o\"，那么\"\\) (@F)\"就是\"foo.o\"，\" \\((@F)\"相当于函数\"\\) (notdir $@)\"。 \" \\((*D)\"\"\\) ( F)\"和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，\" \\((*D)\"返回\"dir\"，而\"\\) ( F)\"返回\"foo\" \" \\((%D)\"\"\\) (%F)\"分别表示了函数包文件成员的目录部分和文件部分。这对于形同\"archive(member)\"形式的目标中的\"member\"中包含了不同的目录很有用。 \" \\((<D)\"\"\\) (<F)\"分别表示依赖文件的目录部分和文件部分。 \" \\((&#94;D)\"\"\\) (&#94;F)\"分别表示所有依赖文件的目录部分和文件部分。（无相同的） \" \\((+D)\"\"\\) (+F)\"分别表示所有依赖文件的目录部分和文件部分。（可以有相同的） \" \\((?D)\"\"\\) (?F)\"分别表示被更新的依赖文件的目录部分和文件部分。 最后想提醒一下的是，对于\" \\(<\"，为了避免产生不必要的麻烦，我们最好给\\) 后面的那个特定字符都加上圆括号，比如，\" \\((< )\"就要比\"\\) <\"要好一些。 还得要注意的是，这些变量只使用在规则的命令中，而且一般都是\"显式规则\"和\"静态模式规则\"（参见前面\"书写规则\"一章）。其在隐含规则中并没有意义。 4、模式的匹配 一般来说，一个目标的模式有一个有前缀或是后缀的\"%\"，或是没有前后缀，直接就是一个\"%\"。因为\"%\"代表一个或多个字符，所以在定义好了的模式中，我们把\"%\"所匹配的内容叫做\"茎\"，例如\"%.c\"所匹配的文件\"test.c\"中\"test\"就是\"茎\"。因为在目标和依赖目标中同时有\"%\"时，依赖目标的\"茎\"会传给目标，当做目标中的\"茎\"。 当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行\"茎\"的传递时，我们需要知道这个步骤。例如有一个模式\"e%t\"，文件\"src/eat\" 匹配于该模式，于是\"src/a\"就是其\"茎\"，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式\"c%r\"，那么，目标就是\"src/car\"。（\"茎\"被传递） 5、重载内建隐含规则 你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如： %.o : %.c $ ( CC ) - c $ ( CPPFLAGS ) $ ( CFLAGS ) - D $ ( date ) 你可以取消内建的隐含规则，只要不在后面写命令就行。如： %.o : %.s 同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。 6、老式风格的\"后缀规则\" 后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：\"双后缀\"和\"单后缀\"。 双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如\".c.o\"相当于\"%o : %c\"。单后缀规则只定义一个后缀，也就是源文件的后缀。如\".c\"相当于\"% : %.c\"。 后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：\".c\"和\".o\"都是make所知道。因而，如果你定义了一个规则是\".c.o\"那么其就是双后缀规则，意义就是\".c\" 是源文件的后缀，\".o\"是目标文件的后缀。如下示例： .c.o: $ ( CC ) - c $ ( CFLAGS ) $ ( CPPFLAGS ) - o $@ $ < 后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如： .c.o: foo.h $ ( CC ) - c $ ( CFLAGS ) $ ( CPPFLAGS ) - o $@ $ < 这个例子，就是说，文件\".c.o\"依赖于文件\"foo.h\"，而不是我们想要的这样： %.o: %.c foo.h $ ( CC ) - c $ ( CFLAGS ) $ ( CPPFLAGS ) - o $ @ $ < 后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。 而要让make知道一些特定的后缀，我们可以使用伪目标\".SUFFIXES\"来定义或是删除，如： .SUFFIXES: .hack .win 把后缀.hack和.win加入后缀列表中的末尾。 .SUFFIXES: # 删除默认的后缀 .SUFFIXES: .c .o .h # 定义自己的后缀 先清除默认后缀，后定义自己的后缀列表。 make的参数\"-r\"或\"-no-builtin-rules\"也会使用得默认的后缀列表为空。而变量\"SUFFIXE\"被用来定义默认的后缀列表，你可以用\".SUFFIXES\"来改变后缀列表，但请不要改变变量\"SUFFIXE\"的值。 7、隐含规则搜索算法 比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是\"archive(member)\"的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把\"member\"当作T来搜索。 1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是\"src/foo.o\"，那么，D就是\"src/\"，N就是\"foo.o\"） 2、创建所有匹配于T或是N的模式规则列表。 3、如果在模式规则列表中有匹配所有文件的模式，如\"%\"，那么从列表中移除其它的模式。 4、移除列表中没有命令的规则。 5、对于第一个在列表中的模式规则： *1）推导其\"茎\"S，S应该是T或是N匹配于模式中\"%\"非空的部分。 *2）计算依赖文件。把依赖文件中的\"%\"都替换成\"茎\"S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。 *3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫\"理当存在\"） *4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。 6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则： *1）如果规则是终止规则，那就忽略它，继续下一条模式规则。 *2）计算依赖文件。（同第5步） *3）测试所有的依赖文件是否存在或是理当存在。 *4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。 *5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。 7、如果没有隐含规则可以使用，查看\".DEFAULT\"规则，如果有，采用，把\".DEFAULT\"的命令给T使用。 一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。 十七、使用make更新函数库文件 函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令\"ar\"来完成打包工作。 1、函数库文件的成员 一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成： archive(member) 这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了\"ar\"命令来服务的。如： foolib(hack.o) : hack.o ar cr foolib hack.o 如果要指定多个member，那就以空格分开，如： foolib(hack.o kludge.o) 其等价于： foolib(hack.o) foolib(kludge.o) 你还可以使用Shell的文件通配符来定义，如： foolib(*.o) 3、函数库成员的隐含规则 当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是\"a(m)\"形式的，其会把目标变成\"(m)\"。于是，如果我们的成员是\"%.o\" 的模式定义，并且如果我们使用\"make foo.a(bar.o)\"的形式调用Makefile时，隐含规则会去找\"bar.o\"的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下： cc -c bar.c -o bar.o ar r foo.a bar.o rm -f bar.o 还有一个变量要注意的是\"$%\"，这是专属函数库文件的自动化变量，有关其说明请参见\"自动化变量\"一节。 3、函数库文件的后缀规则 你可以使用\"后缀规则\"和\"隐含规则\"来生成函数库打包文件，如： .c.a: $ ( CC ) $ ( CFLAGS ) $ ( CPPFLAGS ) - c $ < - o $ *. o $ ( AR ) r $@ $ *. o $ ( RM ) $ *. o 其等效于： (%.o) : %. c $( CC ) $( CFLAGS ) $( CPPFLAGS ) -c $< -o $* .o $( AR ) r $@ $* .o $( RM ) $* .o 4、注意事项 在进行函数库打包文件生成时，请小心使用make的并行机制（\"-j\"参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。 但就目前而言，你还是应该不要尽量不要使用\"-j\"参数。 最后，我还想介绍一下make程序的设计开发者。 首当其冲的是： Richard Stallman开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页： Richard Stallman 。 第二位是：Roland McGrath个人主页是： Roland McGrath ，下面是他的一些事迹： 1） 合作编写了并维护GNU make。 2） 和Thomas Bushnell一同编写了GNU Hurd。 3） 编写并维护着GNU C library。 4） 合作编写并维护着部分的GNU Emacs。 在此，向这两位开源项目的斗士致以最真切的敬意。 Top &#94; if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"linux","title":"Makefile中文手册"},{"url":"http://king32783784.github.io/2013/07/01/sort/","text":"1.快速排序 对于一个给定的数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集， 一个子集的所有元素都小于该元素，另一个子集的元素都大于或等于该元素， 对两个子集递归执行这一过程，当某个子集中的元素小于二时， 这个子集就不需要再次排序，终止递归。 2.代码实现及测试 void qsort ( int v [], int left , int right ) { int i , last ; void swap ( int v [], int i , int j ); if ( left >= right ) return ; swap ( v , left ,( left + right ) / 2 ); //将中点的元素作为比较元素，放到整个数组的最左边 last = left ; for ( i = left + 1 ; i <= right ; i ++ ) if ( v [ i ] < v [ left ]) swap ( v , ++ last , i ); swap ( v , left , last ); //last位置放的将是比较元素，左边全是比它小的元素 qsort ( v , left , last - 1 ); //对子集1进行递归调用 qsort ( v , last + 1 , right ); //对子集2进行递归调用 } void swap ( int v [], int i , int j ) { int temp ; temp = v [ i ]; v [ i ] = v [ j ]; v [ j ] = temp ; } main () { int k = 0 ; int test [] = { 3 , 2 , 6 , 4 , 5 , 9 , 11 , 7 , 16 , 8 }; qsort ( test , 0 , 9 ); for ( k = 0 ; k < 10 ; k ++ ) { printf ( \"%d,\" , test [ k ]); } } Top &#94;","tags":"算法","title":"快速排序"},{"url":"http://king32783784.github.io/2013/06/12/linpack/","text":"一 工具介绍 Linpack现在在国际上已经成为最流行的用于测试高性能计算机系统浮点性能的benchmark。通过利用高性能计算机，用高斯消元法求解N元一次稠密线性代数方程组的测试，评价高性能计算机的浮点性能。HPL是针对现代并行计算机提出的测试方式。用户在不修改任意测试程序的基础上，可以调节问题规模大小N(矩阵大小)、使用到的CPU数目、使用各种优化方法等来执行该测试程序，以获取最佳的性能。HPL采用高斯消元法求解线性方程组。当求解问题规模为N时，浮点运算次数为(2/3 * N&#94;3－2 N&#94;2)。因此，只要给出问题规模N，测得系统计算时间T，峰值=计算量(2/3 * N&#94;3－2 N&#94;2)/计算时间T，测试结果以浮点运算每秒（Flops）给出。 实测浮点峰值是指Linpack测试值，也就是说在这台机器上运行Linpack测试程序，通过各种调优方法得到的最优的测试结果。实际上在实际程序运行过程中，几乎不可能达到实测浮点峰值，更不用说达到理论浮点峰值了。这两个值只是作为衡量机器性能的一个指标，用来表明机器处理能力的一个标尺和潜能的度量。 HPL作为一个基准测试程序在HPC领域取得了巨大的成功。它对趋势进行了准确的预测，积累的优化技巧对于提高实际应用的性能发挥了重要的作用。但是，随着应用的发展，它与实际应用之间的相关性在逐渐降低，需要寻找替代者。但并不支持淘汰HPL。HPL提供给我们的历史经验数据相当的宝贵，并且HPL促进了HPC应用范围的扩大，这些重要作用都决定了HPL不会被淘汰。HPCG将会作为TOP500排名一个可供选择的基准测试，就像Green500排名一样，重新排名HPC系统。HPCG最诱人的地方就是它包含在实际应用中广泛使用的关键的通讯和计算模式，而且足够简单。HPCG不仅具有实际的数值意义，而且非常容易被大家理解和接受。我们将会在现有和即将出现的平台上，针对实际的应用程序，完成HPCG的验证和校验。验证和校验过程将会提高HPCG的质量，使之逐渐成为一个被大家广泛认可的基准测试程序。 二 编译安装 １.mpich2+GotoBLAS2+hpl 1.1 mpich安装 普华服务器版本iSoftServerOS3.0_x86-64_Build4 #wget http://www.mpich.org/static/downloads/1.0.8/mpich2-1.0.8.tar.gz #tar zxf mpich2-1.0.8.tar.gz #cd mpich2-1.0.8 # ./configure # make # make install 普华桌面版本iSoftClientOS3.0SP1 # vi /etc/pacman.d/mirrorlist 添加SigLevel = Never\"一行 修改地址\"Server = http://ftp.isoft.zhcn.cc/ \\(repo/os/\\) arch\" #pacman -Rdd gcc-multilib #pacman -Sy gcc-fortran #wget http://www.mpich.org/static/downloads/1.0.8/mpich2-1.0.8.tar.gz #tar zxf mpich2-1.0.8.tar.gz #cd mpich2-1.0.8 # ./configure # make # make install 1.2 GotoBlas 2安装 # wget https://www.tacc.utexas.edu/documents/1084364/1087496/GotoBLAS2-1.13.tar.gz/b58aeb8c-9d8d-4ec2-b5f1-5a5843b4d47b # make TARGET=NEHALEM For PPC # vi cpuid_power.c if (!strncasecmp(p, \"POWER6\", 6)) return CPUTYPE_POWER6; POWER6改为POWER8 POWER6与POWER8存在差异，部分参数可能需要调整 安装过程中需要lapack-3.1.1.tgz，如果测试机没有外网，请手动下载后放到 $ HOME 目录 # make TARGET=POWER BINARY=64 1.3 HPL安装 #wget http://www.netlib.org/benchmark/hpl/hpl-2.1.tar.gz #tar -zxf hpl-2.1.tar.gz #cd cd hpl-2.1 #cp ./setup/Make.Linux_PII_FBLAS ./Make.goto #vi Make.goto 修改Make.goto文件 以下斜体部分是Make.goto文件的内容，//后为解释部分。 \" ARCH = goto //名字需和Make.goto的尾缀名字一致 TOPdir = /home/linpack-x86/hpl-2.1 //hpl源码所在目录 MPdir = /home/linpack-x86/mpich2-1.0.8 //mpich2源码所在目录 LAdir = $( HOME ) /Bench/GotoBLAS2 // GotoBlas源码的目录 LAlib = $( LAdir ) /libgoto2.a // GotoBlas静态库 CC = /usr/bin/mpicc //mpicc的绝对路径 LINKER = /usr/bin/mpif77 //mpif77绝对路径 \" #make arch=Goto 2.openmpi+BLAS+hpl 2.1 Openmpi安装 #wget http://www.open-mpi.org/software/ompi/v1.7/downloads/openmpi-1.7.2.tar.bz2 #tar xf openmpi-1.7.2.tar.bz2 # ./configure --prefix=/shared/openmpi/openmpi-1.7.2 --enable-orterun-prefix-by-default # make #make install 2.2 BLAS # wget http://www.netlib.org/lapack/lapack-3.4.2.tgz #tar zxf lapack-3.4.2.tgz #cd lapack-3.4.2 #cp INSTALL/make.inc.gfortran ./make.inc #make blaslib 2.3 HPL wget http://www.netlib.org/benchmark/hpl/hpl.tgz #tar zxf hpl.tgz #cd hpl-2.1 #cp setup/Make.Linux_PII_FBLAS ./Make.ompi17 修改Make.ompi17 注：部分绝对路径根据实际环境做相应调整 \"--- setup/Make.Linux_PII_FBLAS +++ Make.ompi17 @@ -64 +64 @@ -ARCH = Linux_PII_FBLAS +ARCH = ompi17 @@ -70 +70 @@ -TOPdir = $(HOME)/hpl +TOPdir = /home/testtool-gcc-ppc/hpc-mpi/lapack-3.4.2/hpl-2.1 @@ -84 +84 @@ -MPdir = /usr/local/mpi +MPdir = /shared/openmpi/openmpi-1.7.2/ @@ -86 +86 @@ -MPlib = $(MPdir)/lib/libmpich.a +MPlib = @@ -95 +95 @@ -LAdir = $(HOME)/netlib/ARCHIVES/Linux_PII +LAdir =/home/testtool-gcc-ppc/hpc-mpi/lapack-3.4.2 @@ -97 +97 @@ -LAlib = $(LAdir)/libf77blas.a $(LAdir)/libatlas.a +LAlib = $(LAdir)/librefblas.a @@ -169 +169 @@ -CC = /usr/bin/gcc +CC = /shared/openmpi/openmpi-1.7.2/bin/mpicc @@ -176 +176 @@ -LINKER = /usr/bin/g77 +LINKER = /shared/openmpi/openmpi-1.7.2/bin/mpif90 \" #make arch=ompi17 注意： 1.运行时可能会出现找到mpi库的问题，请将mpi库移动到/lib64或修改程序库搜索路径。 2.如果Openmpi启动失败，可以采用mpich2+BLAS+hpl进行编译测试。 三.测试执行 1.测试调优参数 测试参数保存在HPL.out文件，修改参数时，直接修改HPL.out文件。HPL文件内容如下，注：斜体部分为文本内容，//号为解释部分 HPL.out output file name (if any) //输出文件名，同下一行一起设定 6 device out (6=stdout,7=stderr,file) //6标准输出，7标准错误输出，file可以设定为保存至特定文件，文件名上一行设定 4 # of problems sizes (N)//选择测试规模的数量 29 30 34 35 Ns //计算规模的大小,一般规模越大，得出的结果越优，但规模越大，占用的内存也就越大，对系统造成的影响也越明显。所以，一般根据实际物理内存大小进行计算：N*N*8=内存总量*0.8 1 # of NBs //分块矩阵的数量 1 2 3 4 NBs //分块矩阵的大小，HPL采用分块矩阵的算法。分块的大小对性能有很大的影响，NB的选择和软硬件许多因素密切相关。NB值的选择主要是通过实际测试得到最优值，一般在256以下，NB × 8最好为 Cache line的倍数。 0 PMAP process mapping (0=Row-,1=Column-major) //选择处理器阵列是列的排列方式还是按行的排列方式。按列的排列方式适用于节点数较多、每个节点内CPU数较少的系统；而按行的排列方式适用于节点数较少、每个节点内CPU数较多系统。在机群系统上，按列的排列方式的性能远好于按行的排列方式。 1 # of process grids (P x Q) //选择测试线程类型的数量 1 1 4 Ps 1 4 1 Qs //二维处理器网格（P × Q），P × Q = 系统CPU数 = 进程数。P≤Q，一般来说，P的值尽量取得小一点，因为列向通信量（通信次数和通信数据量）要远大于横向通信（和实际CPU物理阵列有关）。P = 2n，即P最好选择2的幂。HPL中，L分解的列向通信采用二元交换法（Binary Exchange），当列向处理器个数P为2的幂时，性能最优。例如，当系统进程数为4的时候，P × Q选择为1 × 4的效果要比选择2 × 2好一些。 这主要取决于CPU物理互联网络。在集群测试中，P × Q 系统CPU总核数 16.0 threshold //测试的精度，保持默认即可 1 # of panel fact //选PFACTS算法的方式，可以进行试验进行选择 0 1 2 PFACTs (0=left, 1=Crout, 2=Right)// 用PFACTs算法对nn列作消元 2 # of recursive stopping criterium //选择NBMINS的值，递归L分解 2 4 NBMINs (>= 1) //设定NBMINS的值，一般推荐2、4、8 1 # of panels in recursion //选择NDIVS的值 2 NDIVs //设定NDIVS的值 1 # of recursive panel fact. //选择PFACTs算法 0 1 2 RFACTs (0=left, 1=Crout, 2=Right) 1 # of broadcast //选择L的横向广播方式 0 BCASTs (0=1rg,1=1rM,2=2rg,3=2rM,4=Lng,5=LnM) // HPL提供六种广播方式。其中前四种适合于快速网络；后两种采用将数据切割后传送的方式，主要适合于速度较慢的 网络。前四种算法，分别采用单环/双环、第一列处理器不优先/优先。 01234567t=0t=1t=2t=3t=4t=5t=6t=70)Increasing-ring:单环,不优先01234567t=0,1t= 2t=3t=4t=5t=6t=71)Increasing-ring(M):单环,优先01234567t=0,1t=1t=2t=3t=2t=3t= 4t=52)Increasing-2-ring:双环,不优先01234567t=0,1,2t=2t=3t=3t=4t=5t=63) Increasing-2-ring(M):双环,优先。对于系统规模较小、处理器数（进程数）较少的系统来说，这四个选择对性能影响很小。对于横向处理器数Q较大的网络来来说，选择双环可以减少横向通信宽度，较小横向通信延迟。另外，第一列处理器优先算法也可以确保下一次L分解的尽早开始。在小规模系统中，一般选择0或1；对于大规模系统，一般选3 1 # of lookahead depth //选择横向通信的通信深度 0 DEPTHs (>=0) // DEPTHs＝0表明将L一次性广播出去，也就是将整个L分解完成以后在一次性广播； DEPTHs＝1表示将L分两次广播；依此类推.小规模系统中，DEPTHs一般选择1或2；对于大规模系统，选择2～5之间 2 SWAP (0=bin-exch,1=long,2=mix) 64 swapping threshold // U的广播为列向广播，HPL共提供了三种U的广播算法：二元交换（Binary Exchange）法、Long法和二者混合法。SWAP=\"0\"，采用二元交换法；SWAP=\"1\"，采用Long法；SWAP=\"2\"，采用混合法。二元交换法的通信开销为㏒2P×（Latency＋NB×LocQ（N）/Bandwith），适用于通信量较小的情况；Long法的通信开销为（㏒2P＋ P－1）×Latency＋K×NB×LocQ（N）/Bandwith，适用于通信量较大的情况。其中P为列向处理器数，Latency为网络延迟， Bandwith为网络带宽，K为常数，其经验值约为2.4。LocQ（N）＝NB×NN为通信量，NN随着求解过程的进行逐步减少。由于NN在求解过程中在不断的变化，为了充分发挥两种算法的优势，HPL提供了混合法，当NN≤swapping threshold（第27行指定）时，采用二元交换；否则采用Long法。一般来说，我们选择混合法，阈值可通过公式求得一个大概值。对于小规模系统来说，此值性能影响不大，采用其缺省值即可。 0 L1 in (0=transposed,1=no-transposed) form //选择L的数据存放方式 0 U in (0=transposed,1=no-transposed) form //选择U的数据存放格式。C语言矩阵在内存是按行存放的，Fortran语言是按列存放的。由于HPL采用C语言书写，而调用的BLAS库有可能采用C语言，也有可能采用Fortran语言编写。若选择\"transposed\"，则采用按列存放，否则按行存放。可以根据实际测试进行选择。 1 Equilibration (0=no,1=yes) //选择是否回代，默认即可 8 memory alignment in double (> 0) // 内存分配中作地址对齐,根据实际测试结果选择 2.单核单线程 #cd /home/linpack-x86/hpl-2.1/bin/goto #vi HPL.dat 设置PQ值为1x1 物理内存为8G，设置规模大小为28800 其余值可以保持默认，测试时，可以根据实际物理平台，进行试验，进行选择。 #./xhpl 3.多核多线程 # echo secretword=abc123 > /etc/mpd.conf #chmod 600 /etc/mpd.conf #mpd& 注：普华服务器系统 iSoftServerOS3 . 0 _x86 - 64 _Build4 启动 mpd 时会出现以下提示： \" / usr / local / bin / mpdlib . py : 8 : DeprecationWarning : The popen2 module is deprecated . Use the subprocess module . import sys , os , signal , popen2 , socket , select , inspect / usr / local / bin / mpdlib . py : 15 : DeprecationWarning : the md5 module is deprecated ; use hashlib instead from md5 import new as md5new\" 应该为python版本问题造成，可以降低python版本或忽略该问题。 CPU实际的物理核数为4.修改hpl文件中的PQ值为1x4 #mpirun -np 4 ./xhpl 4.大页模式测试 #umount /mnt #mount -t hugetlbfs none /mnt #echo 3 > /proc/sys/vm/drop_caches #cat /proc/meminfo | grep Hugepagesize // iSoftServerOS3.0_x86-64_Build4的单页大小为2048KB #echo 3276> /proc/sys/vm/nr_hugepages //实际物理内存为8G，大页面数量应该为8Gx0.8x1024/2=3276 # echo secretword=abc123 > /etc/mpd.conf #chmod 600 /etc/mpd.conf #mpd& CPU实际的物理核数为4.修改hpl文件中的PQ值为1x4 修改规模大小：N N 8=3276 2 1024 1024 0.8 N设定为26112 #mpirun -np 4 ./xhpl 注：此处调用的xhpl，需对hpl代码进行修改，使其调用hugpage 5.集群测试 #echo secretword=abc123 > /etc/mpd.conf #chmod 600 /etc/mpd.conf 注：每个Node都必须添加该文件，并且正确设置该文件的权限 下面以2个节点进行测试说明。 设定每个节点的名字 临时修改hostname方法： 设定主节点为node0 #hostname node0 设定第1个次节点为node1 #hostname node1 永久修改hostname方法： iSoftServerOS3.0_x86-64_Build4 平台 # vi /etc/sysconfig/network 修改HOSTNAME=node0 iSoftClientOS3.0 SP1 平台 # vi /etc/hostname 输入 node0 设置主机名与ip地址映射 #vi /etc/hosts 主节点node0 添加如下： \"192.168.32.165 node0 192.168.32.171 node1\" Node1添加如下： \"192.168.32.165 node0 192.168.32.171 node1\" 设置免密码登录 #ssh-keygen -t rsa 连续点击enter键 将主节点node0的公钥文件复制到集群的node1节点上： #scp /root/.ssh/id_rsa.pub root@node1:/root 登录到节点node1上，将主节点的公钥信息追加到/root/.ssh/authorized_keys文件中，并设置authorized_keys的权限，顺序执行以下两条命令： [root@node1 ~]#cat id_rsa.pub >> .ssh/authorized_keys [root@node1 ~]#chmod 600 .ssh/authorized_keys Node1，方法同步骤（1）-（3），即在每个节点上都生成一对公私密钥，并且将各自的公钥信息追加到主节点的/root/.ssh/authorized_keys文件中。 设置完成后验证一下节点之间是否可以实现无密码登录 #ssh root@node1 无需输入密码，可以直接登录。 将主节点node0系统中的hpl文件复制到其他节点相同目录位置 [root@node0 home]#scp -r linpack-x86 root@node1:/home/ 在主节点的hpl目录下新建mpd.hosts文件 内容如下： \"node1 node2\" 分别在各节点启动mpd #mpd & 主节点启动集群系统 [root@node0 goto]#mpdboot -n 2 -f mpd.hosts 运行测试 2个节点总核数为8，PQ值设定为8*1 规模大小以集群总内存进行计算，设定为29184 注:如果内存不一致，一般以最小内存的倍数进行计算 [root@node0 goto]#mpiexec -n 8 ./xhpl 注意确保网络连通，如果出现网络断开，则测试失败。 4.测试结果分析 测试结果的常见输出信息如下： ================================================================================ HPLinpack 2.1 -- High-Performance Linpack benchmark -- October 26, 2012 Written by A. Petitet and R. Clint Whaley, Innovative Computing Laboratory, UTK Modified by Piotr Luszczek, Innovative Computing Laboratory, UTK Modified by Julien Langou, University of Colorado Denver ================================================================================ An explanation of the input/output parameters follows: T/V : Wall time / encoded variant. N : The order of the coefficient matrix A. NB : The partitioning blocking factor. P : The number of process rows. Q : The number of process columns. Time : Time in seconds to solve the linear system. Gflops : Rate of execution for solving the linear system. The following parameter values will be used: N : 17280 NB : 256 PMAP : Row-major process mapping P : 1 Q : 1 PFACT : Left NBMIN : 2 NDIV : 2 RFACT : Left BCAST : 1ring DEPTH : 0 SWAP : Mix (threshold = 64) L1 : transposed form U : transposed form EQUIL : yes ALIGN : 8 double precision words -------------------------------------------------------------------------------- - The matrix A is randomly generated for each test. - The following scaled residual check will be computed: ||Ax-b||_oo / ( eps * ( || x ||_oo * || A ||_oo + || b ||_oo ) * N ) - The relative machine precision (eps) is taken to be 1.110223e-16 - Computational tests pass if scaled residuals are less than 16.0 ================================================================================ T/V N NB P Q Time Gflops -------------------------------------------------------------------------------- WR00L2L2 17280 256 1 1 75.77 4.541e+01 //测试结果 HPL_pdgesv() start time Sun Jan 4 09:33:11 2015 HPL_pdgesv() end time Sun Jan 4 09:34:27 2015 -------------------------------------------------------------------------------- ||Ax-b||_oo/(eps*(||A||_oo*||x||_oo+||b||_oo)*N)= 0.0050103 ...... PASSED ================================================================================ Finished 1 tests with the following results: 1 tests completed and passed residual checks, 0 tests completed and failed residual checks, 0 tests skipped because of illegal input values. -------------------------------------------------------------------------------- End of Tests. ================================================================================ 其中4.541e+01Gflops为测试结果，表示Linpack测试浮点值为45.41 Gflops 由此可以计算该系统的效率。以此次测试为例： 该平台所用CPU为 Intel(R) Core(TM) i5-2400 CPU @ 3.10GHz 为4核CPU。 INTELcore系列CPU每个时钟周期执行浮点运算的次数一般为8次，CPU的主频为3.1G。可以计算得出该CPU的理论浮点值为 3.1 4 8=99.2G 所以该平台的系统的效率为45.41/99.2约45.8%。 附1HPCG（高性能共轭梯度基准测试） 普通编译 #wget http://www.hpcg-benchmark.org/downloads/hpcg-2.4.tar.gz #tar zxf hpcg-2.4.tar.gz #cd hpcg-2.4 #make arch=GCC_OMP #cd bin hpcg.dat 保持默认即可 #./xhpcg 多核编译 #wget http://www.mpich.org/static/downloads/3.1.3/mpich-3.1.3.tar.gz #tar zxf mpich-3.1.3.tar.gz #cd mpich-3.1.3 #./configure #make #make install #wget http://www.hpcg-benchmark.org/downloads/hpcg-2.4.tar.gz #tar zxf hpcg-2.4.tar.gz #cd hpcg-2.4 #make arch=Linux_MPI #cd bin/ #echo secretword=abc123 > /etc/mpd.conf #chmod 600 /etc/mpd.conf #mpd& hpcg.dat 保持默认即可。 #mpirun -np 2 ./xhpcg 附2. Intel MPI 和 已编译好的linpack测试 解压缩 tar –zxvf l_mpi_p_3.2.011.tgz 创建安装目录 mkdir /Clusterr/intelmpi ,拷贝license 到解压缩的目录中 执行 ./install.sh root@mng l_mpi_p_3.1.038]# ./install.sh 安装完intel mpi后，使用intel编译好的linpack测试包 将l_lpk_p_10.0.2.010.tgz解压缩 tar –zxvf l_lpk_p_10.0.2.010.tgz 测试方法同上面。 Top &#94; if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"性能测试","title":"高性能计算机系统浮点性能测试"},{"url":"http://king32783784.github.io/2013/05/27/C/","text":"先看代码， minprintf #include<stdarg.h> /*minprintf:minimal printf with variable argument list */ void minprintf(char *fmt,...) { va_list ap; /*points to unnamed arg in turn */ char *p, *sval; int ival; double dval; va_start(ap,fmt); /*make ap point to 1st unamed arg*/ for (p = fmt; *p; p++) { if (*p != '%') { putchar(*p); continue; } switch(*++p) { case 'd': ival = va_arg(ap ,int); printf(\"%d\", ival); break; case 'f': ival = va_arg(ap ,double); printf(\"%f\", ival); break; case 's': for(sval = va_arg(ap,char *);*sval;sval ++) putchar(*sval); break; default: putchar(*p); break; } } va_end(ap) ; /*clean up when done*/ } 在C语言中，没有函数重载。所以要想实现不定数目的函数参数，变得比较复杂。了解这个问题，涉及到标准头文件 几个宏定义，va_start和va_end 等。在此之前，先看一下C语言中传递函数的参数时的用法和原理： 1.在c中，当我们无法列出传递函数的所有实参的类型和数目时，，可以用省略号指定参数列表。 void foo(...); void foo(parm_list,..); 这就是C中一种传参的形式，多用于变长参数表。 2.函数参数传递的原理 函数参数是以数据结构：栈的形式存取，从右至左入栈。这跟栈的机制有关。 参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数时，从最后一个开始入栈。因此栈底的高地址，栈顶低地址。void func(int x,float y,char z),在函数调用的时候，是参char z先进栈，然后是 floaty,intx,出的时候顺序是相反的。理论上说，如果我们找到任意变量的地址，并知道其他变量的类型，便可以通过移动位置（指针移位运算，找到其他的输入变量。 下面看几个宏定义 typedef char* va_list; void va_start(va_list ap, prev_param):/ANSI version*/ type va_arg(va_list ao,type); void va_end(va_list ap); va_list是一个字符指针，可以理解为当前参数的一个指针，取参必须通过这个指针进行。 1在调用参数表之前，定义一个va_list类型的变量（假设va_list类型变量被定义为ap）； 2然后应该对ap进行初始化，让它指向可变参数列表的第一个参数，是通过va_start实现的，第一个参数是ap本身，第二个参数是在变参表前面紧挨着的一个变量，即\"...\"之前的那个参数。 3 获取参数，调用va_arg,他的第一个参数是ap，第二个参数是获取的参数的指定类型，然后返回这个指定类型的值，并且把ap指向参数的下一个变量位置 4 获取所有参加之后，我们有必要将ap指针关掉，调用va_end ，他是将ap指向为空，应该养成取完参数之后，关闭指针的习惯，一般情况下，vstart 和 vend 同时出现。 如下面的小例子 #include <stdio.h> void fun ( int a ,..) { int * temp = & a ; temp ++ ; for ( int i = 0 ; i < a ; ++ i ) { printf ( \"%d\" , * temp ); temp ++ ; } } int main () { int a = 1 , int b = 2 ; int c = 3 ; int d = 4 ; fun ( 4 , a , b , c , d ); return 0 ; } 获取省略号指定的参数 在函数体声明一个va_list，然后用va_start函数获取参数列表中的参数,使用完毕后调用va_end（）结束，例如： void TestFun(char *pszDest, int DestLen, const char* pszFormat,...) { va_list args; va_start(args,pszFormat); //\"一定要\"...\"之前的那个参数 _vsnprintf(pszDest,Destlen,pszFormat,args); va_end(args); } 5.如何使用参数个数可变的函数, #include <stdio.h> #include <string.h> #include <stdarg.h> /*注意函数原型声明,至少有一个确定的参数,后面跟省略号*/ int demo ( char ,...) void main ( void ) { demo ( \"DEMO\" , \"This\" , \"is\" , \"a\" , \"demo!\" , \" \" ); } int demo ( char msg ,...) { /*定义保存函数参数的结构*/ va_list argp ; int argno = 0 ; char para ; /*argp 指向第一个可选参数,msg是最后一个确定的参数*/ va_start ( argp , msg ); { while ( 1 ) { para = va_arg ( argp , char ); if ( strcmp ( para , \" \" ) == 0 ) break ; printf ( \"Parameter #%d is :%s \\n \" , argno , para ); argno ++ ; } va_end ( argp ) retrun 0 ; } 6 回过头来看一下一开始那个程序. minprintf函数用来遍历printf函数的参数表,它的参数为printf函数中参数的指针 指针ap 用来实现遍历函数的参数列表.在函数运行中ap会先后指向参数表中的每一个参数. va_start(ap,fmt).ap指向省略中的第一个参数.fmt指向最后一个函数参数表中有名参数.即开始时ap指向的参数的前一个参数. for(p =fmt; p;p++),p初始为 fmt ,即指向ap前一个参数,通过对p的循环实现ap指针遍历省略的参数表. 就有了下面的switch,来讨论可能出现的参数. 最后通过va_end(ap),将ap指向NULL.避免出现异常.注意:，应该养成，关闭指针的习惯. Top &#94;","tags":"编程语言-C","title":"通过printf函数简单实现解析不定参数表"},{"url":"http://king32783784.github.io/2011/08/15/C/","text":"1.简单的宏定义 #define MAXTIME 1000 简单的MATIME定义好了，它代表1000，如果在程序中写： if(i<MAXTIME){...} 编译器在处理这个代码之前会对MAXTIME进行替换为1000。 宏定义类同于简单的文本替换，而不是变量。 2.define的\"函数定义\" define可以像函数那样接受一些参数，如下： #define max(x,y)(x)>(y)?(x):(y); 这个定义将返回两个数中最大的，而且这个函数没有经过类型检查，好像函数模板，但没有模板安全。存在隐患： #define Add(a,b) a+b; 如果代数式 c Add(a,b) d,本意为a+b然后去和c、d相乘，而define只是一个简单替换，式子反而变为了： c a + b d ,忽略了运算规则。 #define pin(int*); pin a,b; 本来是想定义a，b都是int型指针，而一替换变成了 int*a,b; 3.宏的单行定义 #define A(x) T_##x #define B (x)#@x #define C (x)#x 我们假设x=1,则有： A(1): T_1 B(1): '1' C(1): \"1\" 3.define的多行定义 define可以替换多行的代码，例如MFC中的宏定义 #define MACRO(arg1, arg2) do{/ /*declarations*/ stmt1;/ stmt2;/ }while(0) /*(no trailing;)*/ 每行换行时加上换行符\"/\" 4.条件编译 在大规模的开发中，define最重要的功能就是条件编译。也就是本文的用法。 #ifdef UCLINU ... ... #endif 编译时，可以通过#define设置编译环境 5如何定义宏，取消宏 //定义宏 #define [MarcoName] [Macro Value] //取消宏 #undef [MacroName] //普通宏 #define PI(3.14] //带参数的宏 #define max(a,b)((a)>(b)?(a),(b)) 加括号是个好习惯哦 6.头文件(.h)可以被头文件或C文件包含 重复包含（重复定义） 由于头文件包含可以嵌套，那么C文件就有可能包含多次同一个头文件，就可能出现重复定义的问题的。 通过条件编译开关来避免重复包含（重复定义） 例如 #ifndef headerfileXXX #define headerfileXXX … //文件内容 … #endif 7.define命令的一些高级用法 define中的三个特殊符号\"#\" \"##\" \"#@\"，前面提到过但未解释。 #define Conn(x,y) x##y x##y 表示什么？ 表示x连接y, int n = Conn(123, 456); //表示n=123456 相信你已经猜到了 char* str = Conn(\"asdf\", \"adf\"); //表示str = \"asdfadf\" #define ToChar(x) #@x @x，就是给x加上单引号，返回一个const char: char a = ToChar(1) //a='1' x, 就是加双引号. 下面看一下宏定义常用用法： 防止头文件被重复包含： #ifdef BODYDEF_H #define BODYDEF_H ... #endif 得到指定地址上的一个字节或字： #define MEM_B( x ) ( *( (byte *) (x) ) ) #define MEM_W( x ) ( *( (word *) (x) ) ) 得到一个field在结构体(struct)中的偏移量 #define OFFSETOF( type, field ) ( (size_t) &(( type *) 0)-> field ) 得到一个结构体中field所占用的字节数 #define FSIZ( type, field ) sizeof( ((type *) 0)->field ) 得到一个变量的地址（word宽度） #define B_PTR( var ) ( (byte *) (void *) &(var) ) #define W_PTR( var ) ( (word *) (void *) &(var) ) 将一个字母转换为大写 #define UPCASE( c ) ( ((c) >= ''a'' && (c) <= ''z'') ? ((c) - 0x20) : (c) ) 判断字符是不是10进值的数字 #define DECCHK( c ) ((c) >= ''0'' && (c) <= ''9'') 判断字符是不是16进值的数字 #define HEXCHK( c ) ( ((c) >= ''0'' && (c) <= ''9'') ||((c) >= ''A'' && (c) <= ''F'') ||((c) >= ''a'' && (c) <= ''f'') ) 防止溢出的一个方法 #define INC_SAT( val ) (val = ((val)+1 > (val)) ? (val)+1 : (val)) 返回数组元素的个数 #define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) ) 使用一些宏跟踪调试 在调试时，我们可以设置__DEBUG宏，也可以再Makefile中使用-D编译选项设置， [cpp] view plain copy print? #define __DEBUG 使用方法为， [ cpp ] view plain copy print ? #ifdef __DEBUG printf ( \"%s\" , ...); #endif 另外，ANSI C标准中有几个标准预定义宏，前面几个（func...STDC）常用于printf(sprintf)等语句中： __func__：在源代码中插入当前所在函数名； __LINE__：在源代码中插入当前源代码行号； __FILE__：在源文件中插入当前源文件名； __DATE__：在源文件中插入当前的编译日期 __TIME__：在源文件中插入当前编译时间； __STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1； __cplusplus：当编写C++程序时该标识符被定义。 其中__cplusplus常用于头文件中，格式如下： [ cpp ] view plain copy print ? #ifndef _ZX_FUNC_H #define _ZX_FUNC_H #ifdef __cplusplus extern \"C\" { #endif /* functions */ char * strdup ( const char * s ); #ifdef __cplusplus } #endif #endif extern\"C\"表示将其中的代码按照C编译方法编译，目的是实现C++与C语言的调用。 C编译与C++编译的区别是：C会将上面strdup编译成_STRDUP符号，而C++会编译成_STRDUP_CHAR，这也是C++为什么能实现函数重载的原因。extern只能出现在C++文件中，一般如上面的方式置于头文件中。 要在C中调用C++代码，需要在C代码中的函数或变量声明为extern类型，在C++中将函数或变量用extern \"C\"修饰。 简单数学计算（绝对值，三角函数等） [cpp] view plain copy print? #define ABS( a ) ( ((a)>0) ? (a) : (-(a)) ) define 一个复杂语句 比如交换a,b的值， [cpp] view plain copy print? #define(a,b) do { \\ int t = 0; t = a; \\ a = b; \\ b = t; \\ } while(0) define的这些高级用法在Linux内核源代码很多处出现，可阅读参考内核源代码。","tags":"编程语言-C","title":"C-宏定义"},{"url":"http://king32783784.github.io/2011/07/11/C/","text":"结构体声明 例如： struct Student { char name[20]; char sex; int age; char addr[40]; } / 定义一个Student 类型的student变量 / struct Student student; 定义结构体的时候每次都要写struct显得比较繁琐，可以用typedef来方便声明。这样就可以想int、char一样定义结构体类型了。比如： typedef struct _TEST_T { int i; char c[10]; }TEST_T; 初始化 1.初始化的就是定义一个结构体变量，并且给它赋值比如： TEST_T gst = {1, \"12345\"}; /*可以初始化，设置i为1，c为一个字符串.*/ TEST_T gst = {1}; /*初始化个数少于实际个数时，只初始化前面的成员。*/ TEST_T gst = {.c=\"12345\"}; /*有选择的初始化成员。*/ 2、复合字面量。 gst = (TEST_T){122, \"1256\"}; /*这是一个赋值语句，也可以作为初始化。可以出现在程序的任何地方。*/ 当然也可以使用复合字面量来初始化： gst = (TEST_T){.i=122, .c=\"123\"}; 3、结构体数组 可以用多个大括号括起来： TEST_T gst[10] = \\{\\{\\},\\{\\},\\{\\},\\{\\}\\} 也可以初始化其中的一个元素： TEST_T gst[10] = {[2]={}, [3]={}} 也可以使用复合字面量： TEST_T gst[10] = {[2].i=0, [3].i={}} 为什么要初始化 1、对局部变量初始化可以防止随机值产生的危害。 2、对全局变量初始化可以告诉编译器，这是一个定义，而不是一个声明。（如果两个c中有相同的全局变量定义，且没有初始化，编译器会认为第二个是声明而不是定义。） 声明和定义的区别在于是否分配内存进行存储。","tags":"编程语言-C","title":"C-结构体声明"},{"url":"http://king32783784.github.io/2011/01/01/cmds/","text":"Linux常用命令备忘 1.查找大于100M的文件 find / -type f -size +100M 2.换行符替换为空格 sed ':label;N;s/\\n/ /;t label' 3.在文本指定行首加空格 :10,20 s/&#94;/ /g 在第10行知第20行每行前面加四个空格，用于缩进。 Top &#94;","tags":"Linux","title":"常用shell命令"},{"url":"http://king32783784.github.io/2009/10/12/UNIX/","text":"信号 我们运行如下命令，可看到Linux支持的信号列表： $ kill -l1 ) SIGHUP 2 ) SIGINT 3 ) SIGQUIT 4 ) SIGILL 5 ) SIGTRAP 6 ) SIGABRT 7 ) SIGBUS 8 ) SIGFPE 9 ) SIGKILL 10 ) SIGUSR1 11 ) SIGSEGV 12 ) SIGUSR213 ) SIGPIPE 14 ) SIGALRM 15 ) SIGTERM 17 ) SIGCHLD18 ) SIGCONT 19 ) SIGSTOP 20 ) SIGTSTP 21 ) SIGTTIN22 ) SIGTTOU 23 ) SIGURG 24 ) SIGXCPU 25 ) SIGXFSZ26 ) SIGVTALRM 27 ) SIGPROF 28 ) SIGWINCH 29 ) SIGIO30 ) SIGPWR 31 ) SIGSYS 34 ) SIGRTMIN 35 ) SIGRTMIN+136 ) SIGRTMIN+2 37 ) SIGRTMIN+3 38 ) SIGRTMIN+4 39 ) SIGRTMIN+540 ) SIGRTMIN+6 41 ) SIGRTMIN+7 42 ) SIGRTMIN+8 43 ) SIGRTMIN+944 ) SIGRTMIN+10 45 ) SIGRTMIN+11 46 ) SIGRTMIN+12 47 ) SIGRTMIN+1348 ) SIGRTMIN+14 49 ) SIGRTMIN+15 50 ) SIGRTMAX-14 51 ) SIGRTMAX-1352 ) SIGRTMAX-12 53 ) SIGRTMAX-11 54 ) SIGRTMAX-10 55 ) SIGRTMAX-956 ) SIGRTMAX-8 57 ) SIGRTMAX-7 58 ) SIGRTMAX-6 59 ) SIGRTMAX-560 ) SIGRTMAX-4 61 ) SIGRTMAX-3 62 ) SIGRTMAX-2 63 ) SIGRTMAX-164 ) SIGRTMAX 列表中，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。 下面我们对编号小于SIGRTMIN的信号进行说明。 1) SIGHUP 本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。 登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程 序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP 信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽 略它，这样就算退出了Linux登录，wget也能继续下载。 此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。 2) SIGINT 程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。 3) SIGQUIT 和SIGINT类似, 但由QUIT字符(通常是Ctrl-)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。 4) SIGILL 执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。 5) SIGTRAP 由断点指令或其它trap指令产生. 由debugger使用。 6) SIGABRT 调用abort函数生成的信号。 7) SIGBUS 非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。 8) SIGFPE 在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。 9) SIGKILL 用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。 10) SIGUSR1 留给用户使用 11) SIGSEGV 试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据. 12) SIGUSR2 留给用户使用 13) SIGPIPE 管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。 14) SIGALRM 时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号. 15) SIGTERM 程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。 17) SIGCHLD 子进程结束时, 父进程会收到这个信号。 如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核 进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或 者父进程先终止，这时子进程的终止自动由init进程来接管)。 18) SIGCONT 让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符 19) SIGSTOP 停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略. 20) SIGTSTP 停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号 21) SIGTTIN 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行. 22) SIGTTOU 类似于SIGTTIN, 但在写终端(或修改终端模式)时收到. 23) SIGURG 有\"紧急\"数据或out-of-band数据到达socket时产生. 24) SIGXCPU 超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。 25) SIGXFSZ 当进程企图扩大文件以至于超过文件大小资源限制。 26) SIGVTALRM 虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间. 27) SIGPROF 类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间. 28) SIGWINCH 窗口大小改变时发出. 29) SIGIO 文件描述符准备就绪, 可以开始进行输入/输出操作. 30) SIGPWR Power failure 31) SIGSYS 非法的系统调用。 在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP 不能恢复至默认动作的信号有：SIGILL,SIGTRAP 默认会导致进程流产的信号有：SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGIOT,SIGQUIT,SIGSEGV,SIGTRAP,SIGXCPU,SIGXFSZ 默认会导致进程退出的信号有：SIGALRM,SIGHUP,SIGINT,SIGKILL,SIGPIPE,SIGPOLL,SIGPROF,SIGSYS,SIGTERM,SIGUSR1,SIGUSR2,SIGVTALRM 默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU 默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH 此外，SIGIO在SVR4是退出，在4.3BSD中是忽略；SIGCONT在进程挂起时是继续，否则是忽略，不能被阻塞 可靠信号与不可靠信号测试: #include <stdio.h> #include <signal.h> static volatile int signum = 0 ; void sigme ( int signo ) { printf ( \"signal received:%d \\n \" , signum ++ ); sleep ( 3 ); } int main () { signal ( SIGUSR1 , sigme ); /*signal(SIGRTMIN, sigme);*/ while ( 1 ); return 0 ; } 在3秒内向这个程序发送SIGUSR1，只有第一个被接收到，而SIGRTMIN则不会有这样的问题。","tags":"unix环境编程","title":"信号"},{"url":"http://king32783784.github.io/2009/10/10/UNIX/","text":"一、追加至一个文件 一个进程，将数据添加到一个文件尾端。早期不支持open的O_APPEND选项。所有程序被编写成下列形式 if (lseek(fd, 0L, 2 ) < 0) /* position to EOF*/ err_sys(\"lseek error\"); if (write(fd, buf, 100) != 100) /* and write */ err_sys(\"write error\"); 单个进程而言，可以正常工作，但若有多个进程同事使用这种方法将数据添加到同一文件，则会产生问题。 UNIX系统提供了一种方法使这种操作成为原子操作。该方法是在打开文件时设置O_APPEND标志。使内核每次对这种文件进行写之前，都将当前偏移量设置到该文件的尾端处，每次写之前就不在需要调用lseek。 二、pread和 pwrite函数 原型如下： #include ＜unistd.h> ssize_t pread (int filedes, void *buf, size_t nbytes, off_t offset); 返回值：读到的字节数，若已到文件结尾则返回0，若出错则返回-1 ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset); 若成功，返回已写的字节数，若出错则返回-1 调用pread相当于顺序调用lseek和read,但是pread与这种顺序调用存在区别 调用pread时，无法中断其定位和读写作。 不能更新文件指针 三、创建一个文件 当用open进行打开文件时，如果该文件已经存在，open将失败。检查文件是否存在和创建该文件这两个操作是作为一个原子操作执行的。如果没有这个原子操作，需要用下面程序段。 if((fd = open(pathname, O_WRONLY)) < 0 ) { if （errno == ENOENT) { if ((fd = creat(pathname, mode)) < 0) err_sys(\"creat error\"); } else { err_sys(\"open error\"); } } 如果在open和creat之间，另一个进程创建了该文件，那么就会引起问题。例如，若在这两个函数调用之间，另一个进程创建了该文件，并且写进了一些数据。然后，原先的进程执行这段程序的creat。刚由另一个进程写上去的数据就会被擦除。这样两则合并为一个原子操作，就不会发生该问题。 一般而言，原子操作，指的是由多步组成的操作，如果操作原子地执行，那么执行完所有步骤，要么不执行，不可能只执行一部分。 Top &#94;","tags":"unix环境编程","title":"原子操作"},{"url":"http://king32783784.github.io/2009/10/01/排序/","text":"（一）算法讲解 原始的算法实现在最坏的情况下需要进行O(n2)的比较和交换。V. Pratt的书[1] 对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。 一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 然后我们对每列进行排序： 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序： 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 排序之后变为： 10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94 最后以1步长进行排序（此时就是简单的插入排序了）。 步长串行 步长的选择是希尔排序的重要部分。只要最终步长为1任何步长串行都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。 Donald Shell 最初建议步长选择为\\frac{n}{2}并且对步长取半直到步长达到 1。虽然这样取可以比\\mathcal{O}(n&#94;2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。 可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。 步长串行 最坏情况下复杂度 {n/2&#94;i} \\mathcal{O}(n&#94;2) 2&#94;k - 1 \\mathcal{O}(n&#94;{3/2}) 2&#94;i 3&#94;j \\mathcal{O}( n\\log&#94;2 n ) 已知的最好步长串行是由Sedgewick提出的 (1, 5, 19, 41, 109,...)，该串行的项来自 9 * 4&#94;i - 9 * 2&#94;i + 1 和 4&#94;i - 3 * 2&#94;i + 1 这两个算式[1].这项研究也表明\"比较在希尔排序中是最主要的操作，而不是交换。\"用这样步长串行的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。 另一个在大数组中表现优异的步长串行是(斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列)：（1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713, …）[2] 伪代码 input : an array a of length n with array elements numbered 0 to n ? 1 inc ← round ( n / 2 ) while inc > 0 do : for i = inc .. n ? 1 do : temp ← a [ i ] j ← i while j ≥ inc and a [ j ? inc ] > temp do : a [ j ] ← a [ j ? inc ] j ← j ? inc a [ j ] ← temp inc ← round ( inc / 2.2 ) （二）代码示例 （1）C示例代码 #include <stdio.h> int main () { const int n = 5 ; int i , j , temp ; int gap = 0 ; int a [] = { 5 , 4 , 3 , 2 , 1 }; while ( gap <= n ) { gap = gap * 3 + 1 ; } while ( gap > 0 ) { for ( i = gap ; i < n ; i ++ ) { j = i - gap ; temp = a [ i ]; while (( j >= 0 ) && ( a [ j ] > temp )) { a [ j + gap ] = a [ j ]; j = j - gap ; } a [ j + gap ] = temp ; } gap = ( gap - 1 ) / 3 ; } } （2）C++示例代码 void shellsort ( int * data , size_t size ) { for ( int gap = size / 2 ; gap > 0 ; gap /= 2 ) for ( int i = gap ; i < size ; ++ i ) { int key = data [ i ]; int j = 0 ; for ( j = i - gap ; j >= 0 && data [ j ] > key ; j -= gap ) { data [ j + gap ] = data [ j ]; } data [ j + gap ] = key ; } } （3）Java中的示例代码 static void shellsort ( int [] a , int n ) { int temp ; for ( int i = n ; i = 0 ) { if ( a [ j ]< a [ j - n ]) { temp = a [ j ]; a [ j ]= a [ j - n ]; a [ j - n ]= temp ; } j = j - n ; } } Top &#94;","tags":"算法","title":"排序-希尔排序法"},{"url":"http://king32783784.github.io/2016/11/13/python/","text":"pyqt是对Qt的封装。Ｑt是面向对象的图形用户界面库，可以在多个操作系统上使用。 PyQt基本操作 基本的界面： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/env python #*-* coding=utf-8 *-* import sys from PyQt4 import QtCore , QtGui # 导入PyQt模块 class MyWindow ( QtGui . QMainWindow ): # 通过继承QtGui.QMainWindow创建类 def __init__ ( self ): # 初始化方法 QtGui . QMainWindow . __init__ ( self ) # 调用父类的初始化方法 self . setWindowTitle ( \"pyQt\" ) # 设置窗口标题 self . resize ( 400 , 600 ) # 设置窗口大小 app = QtGui . QApplication ( sys . argv ) # 创建QApplication对象 mywindow = MyWindow () # 创建MyWindow对象 mywindow . show () # 显示窗口 app . exec_ () # 进入消息循环 运行效果： 添加一个标签： PyQt提供了丰富的组件进行GUI编程，可以方便的使用组件，并使用信号/插槽进行组件的通信，处理组件事件。 使用QtGui.QLabel可以创建标签。使用setText方法可以设置标签的文字。使用setTextFormat可以设置中文字的格式。当创建标签后使用QMainWindow 的setCentralWidget方法将标签添加到窗口中。常见的方法： setPicture():设置标签中的图片 setText():设置标签中的文字 setTextFormat:设置标签文字的格式 setAlignment:设置标签中文本的对齐方式 下面将创建一个标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #! /usr/bin/env python # *-* coding=utf-8 *-* import sys from PyQt4 import QtCore , QtGui class Window ( QtGui . QMainWindow ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) set . resize ( 400 , 600 ) #添加标签 label = QtGui . QLabel ( \"start test\" ) # 创建标签 label . setAlignment ( QtCore . Qt . AlignCenter ) # 设置标签文字的对齐样式 self . setCentralWidget ( label ) # 向窗口添加标签 app = QtGui . QApplicatin ( sys . argv ) demo = Window () demo . show () app . exec_ () 运行效果： 布局组件和空白项 布局组件 在窗口中使用setCentralWidget只能添加一个组件。如果想添加多个组件，可以使用布局组件。空白项用于占位，配合布局组件更好的控制界面。 布局组件：主要用于控制内部组件的大小、位置等。布局组件可以包含其他的组件，也可以嵌套其他的布局组件。 常见的布局组件： QLayout: 基本的布局组件，只能被继承 QHBoxLayout: 横向Box布局组件 QVBoxLayout: 竖向Box布局组件 QGridLayout: Grid布局组件 布局组件共有的方法： addWidget():添加组件 addLayout():添加其他布局组件 下面是一个使用布局组件布置标签的例子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/env python # *-* coding=utf-8 *-* import sys from PyQt4 import QtCore , QtGui class Window ( QtGui . QWidget ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb-i\" ) self . resize ( 500 , 600 ） label1 = QtGui . QLabel ( \"sysbench\" ) # 创建标签 label2 = QtGui . QLabel ( \"iozone\" ) label3 = QtGui . QLabel ( \"lmbench\" ) label4 = QtGui . QLabel ( \"netperf\" ) label5 = QtGui . QLabel ( \"pingpong\" ) label6 = QtGui . QLabel ( \"unixbench\" ) gridLayout = QtGui . QGridLayout () # 创建网格布局组件 gridLayout . addWidget ( label1 , 0 , 0 ) # 向布局中添加标签，第１行第一列 gridLayout . addWidget ( label2 , 0 , 1 ) gridLayout . addWidget ( label3 , 0 , 2 ) gridLayout . addWidget ( label4 , 1 , 0 ) gridLayout . addWidget ( label5 , 1 , 1 ) gridLayout . addWidget ( label6 , 1 , 2 ) self . setLayout ( gridLayout ) ＃ 设置布局组件 # 添加水平布局 # hBoxLayout1 = QtGui.QHBoxLayout() # 创建横向布局组件 # hBoxLayout1.addWidget(label1) # hBoxLayout1.addWidget(label2) # hBoxLayout1.addWidget(label3) # hBoxLayout1.addWidget(label4) # hBoxLayout1.addWidget(label5) # hBoxLayout1.addWidget(label6) # self.setLayout( hBoxLayout1) # 添加垂直布局 # vBoxLayout = QtGui.QVBoxLayout() # 创建垂直布局组件 # vBoxLayout.addWidget(label1) # vBoxLayout.addWidget(label2) # vBoxLayout.addWidget(label3) # vBoxLayout.addWidget(label4) # vBoxLayout.addWidget(label5) # vBoxLayout.addWidget(label6) # self.setLayout(vBoxLayout) app = QtGui . QApplication ( sys . argv ) demo = Window () demo . show () app . exec_ () 运行效果： 空白项 PyQt中的空白项可以占据位置，这样就可以更好的布置其他的组件。使用QtGui.QSpaerItem创建空白项，可以使用宽度和高度进行设置。 使用布局组件的addItem方法将其添加到布局组件中。 下面看一个例子： #!/usr/bin/env python # - - coding:utf-8 - - import sys from PyQt4 import QtCore , QtGui class MyWindow ( QtGui . QWidget ): def __init__ ( self ): QtGui . QWidget . __init__ ( self ) self . setWindowTitle ( 'test' ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 spacer1 = QtGui . QSpacerItem ( 300 , 40 ) # 创建空白项 spacer2 = QtGui . QSpacerItem ( 300 , 40 ) label = QtGui . QLabel ( 'Label' , self ) # 创建标签 label . setAlignment ( QtCore . Qt . AlignCenter ) #设置标签文本样式 gridlayout . addItem ( spacer1 , 0 , 0 ) # 添加空白项 gridlayout . addWidget ( label , 1 , 0 ) # 添加标签 gridlayout . addItem ( spacer2 , 2 , 0 ) self . setLayout ( gridlayout ) # 向窗口中添加布局组件 app = QtGui . QApplication ( sys . argv ) mywindow = MyWindow () mywindow . show () app . exec_ () 运行效果： 按钮基本使用 使用PyQt中的QtGui.QPushButton可以创建按钮。在PyQt中按钮事件是以信号/插槽的形式进行的，将按钮事件绑定到类的方法上。 创建按钮 当使用QtGui.QPushButton创建按钮后可以使用一下几种方法设置按钮的样式、属性等。 setDefault():将按钮设置为默认按钮 setFlat(): 将按钮设置为平坦模式 setMenu(): 设置按钮关联的菜单。 menu(): 获得按钮关联的菜单 下面例子创建两个按钮 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/usr/bin/env python # *-* coding=utf-8 *-* import sys from PyQt4 import QtGui , QtCore class Window ( QtGui . QWidget ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb-i\" ) self . resize ( 400 , 600 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 button1 = QtGui . QPushButton ( \"spec2000\" ) # 生成button1 gridlayout . addWidget ( button1 , 0 , 0 , 1 , 3 ) # 添加button1 button2 = QtGui . QPushButton ( \"iozone\" ) button2 . setFlat ( True ) gridlayout . addWidget ( button2 , 1 , 1 , 1 , 3 ) self . setLayout ( gridlayout ) # 向窗口中添加布局组件 app = QtGui . QApplication ( sys . argv ) demo = Window () demo . show () app . exec_ () 运行效果 信号和信号槽 Qt中的组件使用信号和信号槽的形式来进行通信。Qt的组件中有很多预定义的信号，当事件触发时，组件发出对应的信号。信号被发送给信号槽进行处理。信号槽是处理特定信号的函数。在PyQt同样，需要使用组件的connect方法将组件信号绑定到其处理插槽上。connect方法的原型如下： connect(QObject, SIGNAL(), SLOT(), Qt.ConnectionType) 参数含义如下： QObject: 发送信号的组件 SIGNAL(): 组件发送的信号 SLOT(): 信号槽函数 Qt.ConnectionType: 可选参数，连接类型 下面的例子使用connect方法将按钮的\"clicked()\"信号连接到事件处理信息槽的函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/usr/bin/env python # -*- coding:utf-8 -*- import sys from PyQt4 import QtCore , QtGui class MyWindow ( QtGui . QWidget ): def __init__ ( self ): QtGui . QWidget . __init__ ( self ) self . setWindowTitle ( 'test' ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 self . button1 = QtGui . QPushButton ( 'Button1' ) gridlayout . addWidget ( self . button1 , 1 , 1 , 1 , 3 ) self . button2 = QtGui . QPushButton ( 'Button2' ) gridlayout . addWidget ( self . button2 , 2 , 2 ) self . setLayout ( gridlayout ) # 向窗口添加布局组件 self . connect ( self . button1 , # button1事件 QtCore . SIGNAL ( 'clicked()' ), # clicked()信号 self . OnButton1 ) # 信号处理函数 self . connect ( self . button2 , # button2事件 QtCore . SIGNAL ( 'clicked()' ), # clicked()信号 self . OnButton2 ) # 信号处理函数 def OnButton1 ( self ): self . button1 . setText ( 'clicked' ) print ( \"button1 is cliecked\" ) def OnButton2 ( self ): self . button2 . setText ( 'clicked' ) print ( \"button2 is cliecked\" ) app = QtGui . QApplication ( sys . argv ) mywindow = MyWindow () mywindow . show () app . exec_ () 运行效果如下：","tags":"Python-pyqt","title":"pyqt基本操作"},{"url":"http://king32783784.github.io/2016/01/01/python/","text":"PyUnit简介 PyUnit是Python 2.1版本新增功能。 Python单元测试框架，又叫PyUnit。是JUnit的Python实现，是由Kent Beck和Erich Gamma共同开发的。同样，JUnit是Kent的Smalltalk测试框架的Java实现。PyUnit和JUnit都是各自怨言的标准测试框架。 PyUnit模块支持自动化测试，通用的setup和shutdown的代码，测试用例整合为测试集，还有独立的测试报告框架。PyUnit提供的类能够很容易的使以上特性应用于测试。PyUnit是借由以下概念支持单元测试的： 测试fixture 测试fixture是指运行测试前的准备工作和运行测试后的清理工作。例如，创建临时或代理数据库、目录，或者启动服务进程。 测试用例 测试用例是最小的测试单元，检查特定的输入会产生预期的结果。PyUnit提供一个测试用例几类TestCase，继承基类可以创建新的测试用例。 测试集 测试集是测试用例的集合，同时也可以是其他测试集的结合，或者是测试用例和测试集的混合集合。用于批量执行测试用例。 执行器 执行器用来执行测试用例，并且把测试结果呈现给用户。执行器可以使用图形界面，文本界面，甚至特殊值来显示测试结果。 测试用例和测试fixture通过TestCase和FunctionTestCase两个类来实现的。TestCase用来创建新的测试用例，而FunctionTestCase是用来把已有测试用例整合为PyUnit结构用例的（译者注：项目原来已经有测试用例了，后来想改用PyUnit测试框架，这时候就要用到FunctionTestCase了）。使用TestCase类创建新测试用例，需要覆盖setUp()和tearDown()方法，他们分别用来初始化fixture和清理fixture。而要使用FunctionTestCase类为已有函数创建测试用例，需要符合以下条件：我们不关心已有函数的测试结果，只关心正确的测试流程fixture初始化->执行测试步骤->测试固件清理。每个TestCase只能执行一个测试方法，所以最好每个测试用例有单独的测试fixture。 TestSuite类实现测试套件功能，可以整合单独的测试用例或者其他测试套件。执行测试套件，测试套件中所有的测试用例和子测试套件都会被执行。 执行器提供一个方法run()，该方法接受TestCase或者TestSuite对象最为参数，并且返回TestResult结果对象。PyUnit提供一个使用TextTestRunner执行器的例子，该例子汇报默认的标准错误流测试结果。想要更改其他环境的执行器（例如图形界面环境）并不需要派生自特定的类。 另请参阅： Module doctest Another test-support module with a very different flavor. unittest2: A backport of new unittest features for Python 2.4-2.6 Many new features were added to unittest in Python 2.7, including test discovery. unittest2 allows you to use these features with earlier versions of Python. Simple Smalltalk Testing: With Patterns Kent Beck's original paper on testing frameworks using the pattern shared by unittest. Nose and py.test Third-party unittest frameworks with a lighter-weight syntax for writing tests. For example, assert func(10) == 42. The Python Testing Tools Taxonomy An extensive list of Python testing tools including functional testing frameworks and mock object libraries. Testing in Python Mailing List A special-interest-group for discussion of testing, and testing tools, in Python. 简单例子 PyUnit模块提供了大量的工具来构造和运行测试，本部分的例子可以满足大部分用户的需求。 以下脚本是测试random模块的3个函数的例子： import random import unittest class TestSequenceFunctions ( unittest . TestCase ): def setUp ( self ): self . seq = range ( 10 ) def test_shuffle ( self ): # make sure the shuffied sequence does not lose any elements random . shuffle ( self . seq ) self . seq . sort () self . assertEqual ( self . seq , range ( 10 )) # should raise an exception for an immutable sequence self . assertRaise ( TypeError , random . shuffle , ( 1 , 2 , 3 )) def test_choice ( self ): element = random . choice ( self . seq ) self . assertTrue ( element in self . seq ) def test_sample ( self ): with self . assertRaise ( ValueError ): random . sample ( self . seq , 20 ) for element in random . sample ( self . seq , 5 ): self . assertTrue ( element in self . seq ) if __name__ == '__main__' : unittest . main () 通过继承unittest.TestCase类来创建测试用例，测试用例中３个独立的测试函数以\"test\"为开头命令。通过这种命名方式，执行器可以知道哪些方法是测试方法。 需要注意的是３个测试方法分别调用assertEqual()函数来检查预期结果；调用assertTure()函数来判断条件；调用assertRaises()函数来验证是否触发了预期的异常。这３个方法作为断言语句判断用例执行的正确性，以便执行器手机测试结果并产生测试报告。 如果定义setUp()方法，每个测试用例执行前都会执行setUp();同样的，如果定义的tearDown()方法，每个测试用例执行完后都会执行tearDown()方法。上面的例子，setup()方法用来为每个用例创建一个新序列。 例子的最后一段介绍了一种简单调用测试用例的方法－unittest.main().它为用例提供了命令行界面运行，脚本运行会输出以下内容： ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK 连续３个点\"...\"表示３个测试用例都运行通过，如果运行失败显示\"Ｆ\"，例如\".FF\"表示后２个用例运行失败。 有很多更易管理，输出信息更简洁，并且不在命令行运行的方法来替代unittest.main()方法运行测试用例。例如以下方法，替换例子的最后一行unittest.main(): suite = unittest.TestLoader().loadTestsFormTestCase(TestSequenceFunctions) unittest.TestTestRunner(verbosity=2).run(suite) 修改后的脚本如下： test_choice (__main__.TestSequenceFunctions) ... ok test_sample (__main__.TestSequenceFunctions) ... ok test_shuffle (__main__.TestSequenceFunctions) ... ok 下面是一个简短的例子用于测试3个字符方法： import unittest class TestStringMethods ( unittest . TestCase ): def test_upper ( self ): self . assertEqual ( 'foo' . upper (), 'FOO' ) def test_isupper ( self ): self . assertTure ( 'FOO' . isupper ()) self . assertFalse ( 'Foo' . isupper ()) def test_split ( self ): s = 'hello world' self . assertEqual ( s . split (), [ 'hello' , 'world' ]) # check that s.split fails when the separator is not a TestStringMethods with self . assertRaise ( TypeError ): s . split ( 2 ) if __name__ == '__main__' : unittest . main () 测试用例通过继承unittest.TestCase创建。测试用例中3个独立的测试函数以\"test\"为开头命名。通过使用这种命名方式，执行器可以知道哪些方法是测试方法。 3个测试方法同样调用assertEqual()函数来检查预期结果；调用assertTrue()函数来判断条件；调用assertRaises()函数来验证是否触发了预期的异常。这3个方法作为断言语句判断用例执行正确性，以便于执行器收集测试结果并产生测试报告。","tags":"编程语言-Python","title":"PyUnit(一）"},{"url":"http://king32783784.github.io/2016/01/01/python/","text":"PyUnit简介 PyUnit是Python 2.1版本新增功能。 Python单元测试框架，又叫PyUnit。是JUnit的Python实现，是由Kent Beck和Erich Gamma共同开发的。同样，JUnit是Kent的Smalltalk测试框架的Java实现。PyUnit和JUnit都是各自怨言的标准测试框架。 PyUnit模块支持自动化测试，通用的setup和shutdown的代码，测试用例整合为测试集，还有独立的测试报告框架。PyUnit提供的类能够很容易的使以上特性应用于测试。PyUnit是借由以下概念支持单元测试的： 测试fixture 测试fixture是指运行测试前的准备工作和运行测试后的清理工作。例如，创建临时或代理数据库、目录，或者启动服务进程。 测试用例 测试用例是最小的测试单元，检查特定的输入会产生预期的结果。PyUnit提供一个测试用例几类TestCase，继承基类可以创建新的测试用例。 测试集 测试集是测试用例的集合，同时也可以是其他测试集的结合，或者是测试用例和测试集的混合集合。用于批量执行测试用例。 执行器 执行器用来执行测试用例，并且把测试结果呈现给用户。执行器可以使用图形界面，文本界面，甚至特殊值来显示测试结果。 测试用例和测试fixture通过TestCase和FunctionTestCase两个类来实现的。TestCase用来创建新的测试用例，而FunctionTestCase是用来把已有测试用例整合为PyUnit结构用例的（译者注：项目原来已经有测试用例了，后来想改用PyUnit测试框架，这时候就要用到FunctionTestCase了）。使用TestCase类创建新测试用例，需要覆盖setUp()和tearDown()方法，他们分别用来初始化fixture和清理fixture。而要使用FunctionTestCase类为已有函数创建测试用例，需要符合以下条件：我们不关心已有函数的测试结果，只关心正确的测试流程fixture初始化->执行测试步骤->测试固件清理。每个TestCase只能执行一个测试方法，所以最好每个测试用例有单独的测试fixture。 TestSuite类实现测试套件功能，可以整合单独的测试用例或者其他测试套件。执行测试套件，测试套件中所有的测试用例和子测试套件都会被执行。 执行器提供一个方法run()，该方法接受TestCase或者TestSuite对象最为参数，并且返回TestResult结果对象。PyUnit提供一个使用TextTestRunner执行器的例子，该例子汇报默认的标准错误流测试结果。想要更改其他环境的执行器（例如图形界面环境）并不需要派生自特定的类。 另请参阅： Module doctest Another test-support module with a very different flavor. unittest2: A backport of new unittest features for Python 2.4-2.6 Many new features were added to unittest in Python 2.7, including test discovery. unittest2 allows you to use these features with earlier versions of Python. Simple Smalltalk Testing: With Patterns Kent Beck's original paper on testing frameworks using the pattern shared by unittest. Nose and py.test Third-party unittest frameworks with a lighter-weight syntax for writing tests. For example, assert func(10) == 42. The Python Testing Tools Taxonomy An extensive list of Python testing tools including functional testing frameworks and mock object libraries. Testing in Python Mailing List A special-interest-group for discussion of testing, and testing tools, in Python. 简单例子 PyUnit模块提供了大量的工具来构造和运行测试，本部分的例子可以满足大部分用户的需求。 以下脚本是测试random模块的3个函数的例子： import random import unittest class TestSequenceFunctions ( unittest . TestCase ): def setUp ( self ): self . seq = range ( 10 ) def test_shuffle ( self ): # make sure the shuffied sequence does not lose any elements random . shuffle ( self . seq ) self . seq . sort () self . assertEqual ( self . seq , range ( 10 )) # should raise an exception for an immutable sequence self . assertRaise ( TypeError , random . shuffle , ( 1 , 2 , 3 )) def test_choice ( self ): element = random . choice ( self . seq ) self . assertTrue ( element in self . seq ) def test_sample ( self ): with self . assertRaise ( ValueError ): random . sample ( self . seq , 20 ) for element in random . sample ( self . seq , 5 ): self . assertTrue ( element in self . seq ) if __name__ == '__main__' : unittest . main () 通过继承unittest.TestCase类来创建测试用例，测试用例中３个独立的测试函数以\"test\"为开头命令。通过这种命名方式，执行器可以知道哪些方法是测试方法。 需要注意的是３个测试方法分别调用assertEqual()函数来检查预期结果；调用assertTure()函数来判断条件；调用assertRaises()函数来验证是否触发了预期的异常。这３个方法作为断言语句判断用例执行的正确性，以便执行器手机测试结果并产生测试报告。 如果定义setUp()方法，每个测试用例执行前都会执行setUp();同样的，如果定义的tearDown()方法，每个测试用例执行完后都会执行tearDown()方法。上面的例子，setup()方法用来为每个用例创建一个新序列。 例子的最后一段介绍了一种简单调用测试用例的方法－unittest.main().它为用例提供了命令行界面运行，脚本运行会输出以下内容： ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK 连续３个点\"...\"表示３个测试用例都运行通过，如果运行失败显示\"Ｆ\"，例如\".FF\"表示后２个用例运行失败。 有很多更易管理，输出信息更简洁，并且不在命令行运行的方法来替代unittest.main()方法运行测试用例。例如以下方法，替换例子的最后一行unittest.main(): suite = unittest.TestLoader().loadTestsFormTestCase(TestSequenceFunctions) unittest.TestTestRunner(verbosity=2).run(suite) 修改后的脚本如下： test_choice (__main__.TestSequenceFunctions) ... ok test_sample (__main__.TestSequenceFunctions) ... ok test_shuffle (__main__.TestSequenceFunctions) ... ok 下面是一个简短的例子用于测试3个字符方法： import unittest class TestStringMethods ( unittest . TestCase ): def test_upper ( self ): self . assertEqual ( 'foo' . upper (), 'FOO' ) def test_isupper ( self ): self . assertTure ( 'FOO' . isupper ()) self . assertFalse ( 'Foo' . isupper ()) def test_split ( self ): s = 'hello world' self . assertEqual ( s . split (), [ 'hello' , 'world' ]) # check that s.split fails when the separator is not a TestStringMethods with self . assertRaise ( TypeError ): s . split ( 2 ) if __name__ == '__main__' : unittest . main () 测试用例通过继承unittest.TestCase创建。测试用例中3个独立的测试函数以\"test\"为开头命名。通过使用这种命名方式，执行器可以知道哪些方法是测试方法。 3个测试方法同样调用assertEqual()函数来检查预期结果；调用assertTrue()函数来判断条件；调用assertRaises()函数来验证是否触发了预期的异常。这3个方法作为断言语句判断用例执行正确性，以便于执行器收集测试结果并产生测试报告。","tags":"编程语言-Python","title":"PyUnit(一）"},{"url":"http://king32783784.github.io/2016/11/15/python/","text":"对话框 PyQT提供基本的消息框和标准对话框。在PyQt也可以根据需要创建自定义的对话框。 使用PyQt提供的类和方法可以创建和使用消息框、标准对话框等。标准对话框包含基本的打开，关闭，字体选择对话框和颜色选择对话框等。 消息框 使用QtGui.QMessageBox类中的方法可以创建简单的消息框，用于向用户传递信息。QtGui.QMessageBox类中包含一下方法： about():创建关于消息框 aboutQt(): 创建关于Qt消息框 critical(): 创建错误处理对话框 infomation(): 创建信息消息框 question(): 创建询问消息框 warning(): 创建警告消息框 以下是示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #!/usr/bin/env python #*-* coding=utf-8 *-* import sys from PyQt4 import QtGui , QtCore class MyWindow ( QtGui . QWidget ): def __init__ ( self ): super ( MyWindow , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 self . label = QtGui . QLabel ( 'MessBox example' ) gridlayout . addWidget ( self . label , 1 , 3 , 1 , 3 ) #添加标签 self . button1 = QtGui . QPushButton ( \"About\" ) # 生成button1 gridlayout . addWidget ( self . button1 , 2 , 1 ) # 添加button到布局组件 self . button2 = QtGui . QPushButton ( \"AboutQt\" ) # 生成button2 gridlayout . addWidget ( self . button2 , 2 , 2 ) self . button3 = QtGui . QPushButton ( \"Critical\" ) gridlayout . addWidget ( self . button3 , 2 , 3 ) self . button4 = QtGui . QPushButton ( \"Info\" ) gridlayout . addWidget ( self . button4 , 2 , 4 ) self . button5 = QtGui . QPushButton ( \"Question\" ) gridlayout . addWidget ( self . button5 , 2 , 5 ) self . button6 = QtGui . QPushButton ( \"warning\" ) gridlayout . addWidget ( self . button6 , 2 , 6 ) spacer = QtGui . QSpacerItem ( 200 , 80 ) gridlayout . addItem ( spacer , 3 , 1 , 1 , 5 ) self . setLayout ( gridlayout ) # 向窗口中添加布局组件 self . connect ( self . button1 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton1 ) # button1事件 self . connect ( self . button2 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton2 ) self . connect ( self . button3 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton3 ) self . connect ( self . button4 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton4 ) self . connect ( self . button5 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton5 ) self . connect ( self . button6 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton6 ) def Onbutton1 ( self ): # button1插槽函数 self . button1 . setText ( 'clicked' ) QtGui . QMessageBox . about ( self , 'pyQt' , 'About' ) # 创建About消息框 def Onbutton2 ( self ): self . button2 . setText ( 'clicked' ) QtGui . QMessageBox . aboutQt ( self , \"PyQt\" ) def Onbutton3 ( self ): self . button3 . setText ( 'clicked' ) r = QtGui . QMessageBox . critical ( self , \"PyQt\" , \"Critical\" , QtGui . QMessageBox . Abort , QtGui . QMessageBox . Retry , QtGui . QMessageBox . Ignore ) if r == QtGui . QMessageBox . Abort : self . setWindowTitle ( \"Abort\" ) elif r == QtGui . QMessageBox . Retry : self . setWindowTitle ( \"Retry\" ) else : self . setWindowTitle ( \"Ignore\" ) def Onbutton4 ( self ): self . button4 . setText ( 'clicked' ) QtGui . QMessageBox . information ( self , \"Pyqt\" , \"information\" ) def Onbutton5 ( self ): self . button5 . setText ( 'clicked' ) r = QtGui . QMessageBox . question ( self , \"PyQt\" , \"Question\" , QtGui . QMessageBox . Yes , QtGui . QMessageBox . No , QtGui . QMessageBox . Cancel ) def Onbutton6 ( self ): self . button6 . setText ( 'clicked' ) r = QtGui . QMessageBox . warning ( self , \"PyQT\" , 'warning' , QtGui . QMessageBox . Yes , QtGui . QMessageBox . No ) app = QtGui . QApplication ( sys . argv ) win = MyWindow () win . show () app . exec_ () 运行效果： 标准对话框 PyQt使用QtGui.QFileDialog提供的方法可以创建文件打开、关闭对话框。使用QtGui.QFontDialog可以创建文章选择对话框，使用QtGui.QColorDialog可以创建颜色选择对话框。 其中QtGui.QFileDialog: getExistingDirectory(): 创建选取路径对话框 getOpenFileName(): 创建打开文件对话框 getOpenFileNames(): 创建打开文件对话框，可以同时打开多个文件 getSaveFileNmae(): 创建保存文件对话框 对于QtGui.QFontDialog,静态方法只有getFont,创建字体选择对话框。QtGui.QColorDialog，可以使用getColor创建颜色选择对话框。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/usr/bin/env python #*-* coding=utf-8 *-* import sys from PyQt4 import QtGui , QtCore class MyWindow ( QtGui . QWidget ): def __init__ ( self ): super ( MyWindow , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () self . label = QtGui . QLabel ( 'StandarDialog example' ) gridlayout . addWidget ( self . label , 1 , 2 ) self . button1 = QtGui . QPushButton ( \"File\" ) # 生成button1 gridlayout . addWidget ( self . button1 , 2 , 1 ) self . button2 = QtGui . QPushButton ( \"Font\" ) # 生成button2 gridlayout . addWidget ( self . button2 , 2 , 2 ) self . button3 = QtGui . QPushButton ( \"Color\" ) gridlayout . addWidget ( self . button3 , 2 , 3 ) spacer = QtGui . QSpacerItem ( 200 , 80 ) gridlayout . addItem ( spacer , 3 , 1 , 1 , 3 ) self . setLayout ( gridlayout ) # 向窗口添加布局组件 self . connect ( self . button1 , QtCore . SIGNAL ( 'clicked()' ), self . OnButton1 ) self . connect ( self . button2 , QtCore . SIGNAL ( 'clicked()' ), self . OnButton2 ) self . connect ( self . button3 , QtCore . SIGNAL ( 'clicked()' ), self . OnButton3 ) def OnButton1 ( self ): self . button1 . setText ( 'clicked' ) filename = QtGui . QFileDialog . getOpenFileName ( self , 'Open' ) # 创建文件打开对话框 if not filename . isEmpty (): self . label . setText ( filename ) def OnButton2 ( self ): self . button2 . setText ( 'clicked' ) font , ok = QtGui . QFontDialog . getFont () # 创建字体选择对话框 if ok : self . label . setText ( font . key ()) def OnButton3 ( self ): self . button3 . setText ( 'clicked' ) color = QtGui . QColorDialog . getColor () # 创建颜色选择对话框 if color . isValid (): self . label . setText ( color . name ()) app = QtGui . QApplication ( sys . argv ) win = MyWindow () win . show () app . exec_ () 运行效果： 自定义对话框 通过继承QtGui.QDialog类可以创建自定义的对话框。所创建的对话框和窗口一样，可以向其添加组件。使用connect方法响应组件时间。 自定义对话框例子： #coding=utf-8 import sys from PyQt4 import QtGui , QtCore class MyDialog ( QtGui . QDialog ): def __init__ ( self ): super ( MyDialog , self ) . __init__ () self . gridlayout = QtGui . QGridLayout () self . label = QtGui . QLabel ( \"Input:\" ) self . gridlayout . addWidget ( self . label , 0 , 0 ) self . textField = QtGui . QLineEdit () # 创建单行文本框 self . gridlayout . addWidget ( self . textField , 0 , 1 ) # 添加文本框到布局组件 self . okButton = QtGui . QPushButton ( \"OK\" ) # 创建OK按钮 self . gridlayout . addWidget ( self . okButton , 1 , 0 ) #添加按钮到布局组件 self . cancelButton = QtGui . QPushButton ( \"Cancel\" ) # 创建cancel按钮 self . gridlayout . addWidget ( self . cancelButton , 1 , 1 ) self . setLayout ( self . gridlayout ) self . connect ( self . okButton , QtCore . SIGNAL ( 'clicked()' ), self . OnOk ) self . connect ( self . cancelButton , QtCore . SIGNAL ( 'clicked()' ), self . OnCancel ) def OnOk ( self ): self . text = self . textField . text () # 获取文本框中的内容 self . done ( 1 ) # 结束对话框返回１ def OnCancel ( self ): self . done ( 0 ) class Window ( QtGui . QWidget ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb-i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () self . creatDialogButton = QtGui . QPushButton ( \"Create a new Dialog\" ) #生成button gridlayout . addWidget ( self . creatDialogButton , 1 , 1 ) self . setLayout ( gridlayout ) self . connect ( self . creatDialogButton , QtCore . SIGNAL ( 'clicked()' ), self . OnButton ) def OnButton ( self ): dialog = MyDialog () r = dialog . exec_ () if r : self . creatDialogButton . setText ( dialog . text ) app = QtGui . QApplication ( sys . argv ) win = Window () win . show () app . exec_ () 运行效果： 资源文件 Qt中资源文件是以'.ui'为后缀的文件。Qt提供Qt Designer用于创建资源文件。使用Qt Designer创建的资源文件可以在pyqt中使用。使用资源文件可以简化界面设计，也可以将界面和代码分离，提高程序的可维护性。 示例 #coding=utf-8 import sys from PyQt4 import QtGui , QtCore , uic class MyDialog ( QtGui . QDialog ): def __init__ ( self ): QtGui . QDialog . __init__ ( self ) uic . loadUi ( \"res.ui\" , self ) # 载入资源文件 class MyWindow ( QtGui . QWidget ): def __init__ ( self ): super ( MyWindow , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 self . button = QtGui . QPushButton ( \"CreateDialog\" ) # 生成button1 gridlayout . addWidget ( self . button , 1 , 1 ) self . setLayout ( gridlayout ) self . connect ( self . button , QtCore . SIGNAL ( 'clicked()' ), self . OnButton ) def OnButton ( self ): dialog = MyDialog () r = dialog . exec_ (); if r : self . button . setText ( dialog . lineEdit . text ()) app = QtGui . QApplication ( sys . argv ) demo = MyWindow () demo . show () app . exec_ ()","tags":"Python-pyqt","title":"pyqt基本操作(三）"},{"url":"http://king32783784.github.io/2015/01/12/自动化测试/","text":"浏览器是系统下比较常用的软件，在linux系统比较常用的是firefox、chrome.如何评估浏览器的基础性能？有很多评测网站进行了这边的测试。 如 CSS acid3 v8test octane html5 dromaeo 等 考虑到每次测试都需要点击这些网站和取测试结果，决定采用selenium去实现自动测试。 测试代码如下： browser-run.py: ```python #encoding = utf-8 import logging import runtest import re import sys from subprocess import call from selenium import webdriver reload ( sys ) sys . setdefaultencoding ( 'utf8' ) # create logger with 'spam_application' logger = logging . getLogger ( 'browser-test' ) logger . setLevel ( logging . DEBUG ) # create file handler which logs even debug messages fh = logging . FileHandler ( 'browser.log' ) fh . setLevel ( logging . DEBUG ) # create console handler with a higher log level ch = logging . StreamHandler () ch . setLevel ( logging . DEBUG ) # create formatter and add it to the handlers formatter = logging . Formatter ( ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) fh . setFormatter ( formatter ) ch . setFormatter ( formatter ) # add the handlers to the logger logger . addHandler ( fh ) logger . addHandler ( ch ) css4 = { 'name' : 'css4' , 'url' : 'http://css4-selectors.com/browser-selector-test/' , 'click' : 'start-browser-selector-test' , 'result' : 'diagram' } #do_type2test acid3 = { 'name' : 'acid3' , 'url' : 'http://acid3.acidtests.org/' , 'result' : 'result' } v8test = { 'name' : 'v8test' , 'url' : 'http://chrome.360.cn/test/v8/run.html' , 'result' : 'status' } octane = { 'name' : 'octane' , 'url' : 'http://chrome.2345.com/labs/test/octanebenchmark.htm' , 'result' : 'main-banner' } #do_type3test html5 = { 'name' : 'html5' , 'url' : 'http://html5test.com/' , 'result' : '//*[@id= \\\" score \\\" ]/div[1]/h2/strong' } #do_type4test dromaeo = { 'name' : 'dromaeo' , 'url' : 'http://dromaeo.com/' , 'result' : '//*[@id= \\' timebar \\' ]/span/strong' , 'testxpath' : '//*[@id= \\\" tests \\\" ]/li[8]/a' , 'runid' : 'pause' , 'resultid' : 'left' } def result ( Initialresults ): p = re . compile ( r'\\d+' ) return p . findall ( Initialresults ) def chrome (): try : retcode = call ( \"which chromium-browser\" , shell = True ) if retcode > 0 : pass else : csstest = runtest . Do_type2test ( css4 ) cssresult = csstest . do_test ( webdriver . Chrome ()) print ( \"css4 result is %s \" % result ( cssresult )[ 3 ]) acidtest = runtest . Do_type1test ( acid3 ) acidresult = acidtest . do_test ( webdriver . Chrome ()) print ( \"acid3 result is %s \" % acidresult ) vtest = runtest . Do_type1test ( v8test ) vresult = vtest . do_test ( webdriver . Chrome ()) print ( \"V8test result is %s \" % vresult ) octanetest = runtest . Do_type1test ( octane ) octaneresult = octanetest . do_test ( webdriver . Chrome ()) print ( \"octane result is %s \" % octaneresult ) htmltest = runtest . Do_type3test ( html5 ) htmlresult = htmltest . do_test ( webdriver . Chrome ()) print ( \"html5test result is %s \" % htmlresult ) dromaeotest = runtest . Do_type4test ( dromaeo ) dromaeotestresult = dromaeotest . do_test ( webdriver . Chrome ()) print ( \"dromaeotest result is %s \" % dromaeotestresult ) print ( \"test finish\" ) except OSError as e : logger . ERROR ( \"Execution failed: %s \" % e ) def firefox (): try : retcode = call ( \"which firefox\" , shell = True ) if retcode > 0 : pass else : csstest = runtest . Do_type2test ( css4 ) cssresult = csstest . do_test ( webdriver . Firefox ()) print ( \"css4 result is %s \" % result ( cssresult )[ 3 ]) acidtest = runtest . Do_type1test ( acid3 ) acidresult = acidtest . do_test ( webdriver . Firefox ()) print ( \"acid3 result is %s \" % acidresult ) vtest = runtest . Do_type1test ( v8test ) vresult = vtest . do_test ( webdriver . Firefox ()) print ( \"V8test result is %s \" % vresult ) octanetest = runtest . Do_type1test ( octane ) octaneresult = octanetest . do_test ( webdriver . Firefox ()) print ( \"octane result is %s \" % octaneresult ) htmltest = runtest . Do_type3test ( html5 ) htmlresult = htmltest . do_test ( webdriver . Firefox ()) print ( \"html5test result is %s \" % htmlresult ) dromaeotest = runtest . Do_type4test ( dromaeo ) dromaeotestresult = dromaeotest . do_test ( webdriver . Firefox ()) print ( \"dromaeotest result is %s \" % dromaeotestresult ) print ( \"test finish\" ) except OSError as e : logger . ERROR ( \"Execution failed: %s \" % e ) if __name__ == \"__main__\" : chrome () firefox () runtest.py: import time import logging from selenium import webdriver from subprocess import call module_logger = logging . getLogger ( 'browser-test.runtest' ) def check_xpath ( testname = 'dromaetest' , checkxpath = \"//*[@id='tests']/li[3]/b/a\" ): '''check the xpath ready or not''' while True : try : drop = testname . find_element_by_xpath ( \" %s \" % checkxpath ) break except : module_logger . info ( \" %s is not ok\" % checkxpath ) def check_idon ( testname = 'dromaeotest' , checkid = 'pause' ): while True : try : drop = testname . find_element_by_id ( \" %s \" % checkid ) break except : time . sleep ( 1 ) def check_idoff ( testname = 'dromaeotest' , checkid = 'left' ): while True : try : drop = testname . find_element_by_id ( \" %s \" % checkid ) time . sleep ( 1 ) except : break class Do_type1test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type1test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 60 ) while True : try : drop = test . find_element_by_id ( self . cmds [ 'result' ]) break except : self . logger . info ( \"There are some errors about this test\" ) test . quit () exit () result = test . find_element_by_id ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type2test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type2test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) test . find_element_by_id ( self . cmds [ 'click' ]) . click () time . sleep ( 20 ) result = test . find_element_by_id ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type3test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type3test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 60 ) result = test . find_element_by_xpath ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type4test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type4test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 30 ) check_xpath ( testname = test , checkxpath = self . cmds [ 'testxpath' ]) test . find_element_by_xpath ( self . cmds [ 'testxpath' ]) . click () time . sleep ( 30 ) check_idon ( testname = test , checkid = self . cmds [ 'runid' ]) test . find_element_by_id ( self . cmds [ 'runid' ]) . click () check_idoff ( testname = test , checkid = self . cmds [ 'resultid' ]) result = test . find_element_by_xpath ( self . cmds [ 'result' ]) . text test . quit () ```","tags":"自动化测试-Selenium","title":"selenium-浏览器性能测试"},{"url":"http://king32783784.github.io/2016/11/01/自动化测试/","text":"Avocado 用户指南 内容： 关于Avocado 入门 安装Avocado 使用Avocado 写一个简单测试 运行一个较复杂的测试 第一个测试失败时中断测试job 结合外部runner运行测试 测试调试 编写Avocado测试 基本例子 保存测试生成的数据（自定义） 访问测试参数 使用multplex文件 高级日志功能 unittest.TestCase 继承 Setup和cleanup方法 运行第三方测试集 获取资源文件 测试输出检查和输出记录模式 Avocado Testlog，stdout和stderr模块 独立进程中运行Avocado测试 设置测试超时 测试标签 Python unitest 兼容测试和警告 简单测试的环境变量 简单测试的BASH扩展 Wrap up 结果格式 人性化测试结果 机器可读的结果 一次多种结果 Exit Codes 实现其他结果格式 配置 配置文件的解析顺序 插件设置文件 解析订单概述 测试中使用值的优先级 设置插件 Avocado数据目录 测试发现 测试载入的顺序 日志系统 UI调整 存储用户日志 分页器 测试变种－Mux Mux内部 Mux API 节点 键和值 变体 分辨顺序 插入文件 复合文件 高级YAML标记 !include !using !remove_node !remove_value !mux 完整示例 Job重放 Job对比 运行远程测试 远程Host运行测试 虚拟机上运行测试 Docker容器上运行测试 环境变量 使用GDB调试 透明执行可执行文件 avocado.uitls.gdb APIs 封装测试执行文件 用法 警告 插件系统 插件列表 制作插件 高级主题和维护 参考指南 job,test和identifiers 测试类型 测试状态 库和APIs 测试解析 结果规格 job前后脚本 job清理 Avocado 开发tips 中断测试 In tree utils Line-profiler 使用Eclipse远程debug 在Eclipase中使用Trello avocado发布 删除版本号 应当注意哪些项目库 所有库的标记 构建rpms 包命名 上传包到仓库 书写发行注记 发送电子邮件到avocado-devel和其他地方 API参考 测试APIs 工具APIs 内部(核心)APIs 外部(插件)APIs Avocado 发行注记 发行注记 关于Avocado Avocado 是一套帮助自动化测试工具和库。 可以把它称作为测试框架。内部测试是通过python编写的，并且遵从unittest模式，但是它也可以将执行任何外部可执行文件作为测试。 组成部分： 一个可以引导执行测试的Test runner。这些测试可以是选择任意语言编写的测试，或则通过python编写，并使用可用的库。这两种情况，你都可以获取自动日志和系统信息收集功能。 提供一个帮助你通过一种concise,yet expressive 和 powerful的方式编写测试。你可以通过后面 库和API 章节了解更多这方面的信息。 插件，可以扩展和增加框架的功能 Avocado尽可能尝试遵守标准的Python测试技术。 使用Avocado API编写的测试是从unittest类派生，而添加了适合于功能和性能测试的其他方法。 测试运行器旨在帮助人们运行测试，同时提供各种系统和日志记录工具。 接下来的专题，会按照本文的目录详细介绍Avocado Top &#94; 下一篇 Avocado-入门","tags":"自动化测试-Avocado","title":"Avocado User's Guide"},{"url":"http://king32783784.github.io/2016/11/03/自动化测试/","text":"1.Avocado 安装 1.1 通过包安装 像 Fedora 可以通过rpm包进行安装，其他通过RPM管理的发行版需要自己制作相关包。Avocado同样支持DEP包的安装可以在contrib/packages/debian找到。 Fedora 首先通过下面的命令获取仓库配置文件。 sudo curl https://repos-avocadoproject.rhcloud.com/static/avocado-fedora.repo -o /etc/yum.repos.d/avocado.repo 检查是否有了Avocodo和Avocado-lts的仓库配置： sudo dnf repolist avocado avocado-lts ... repo id repo name status avocado Avocado 50 avocado-lts Avocado LTS (Long Term Stability) disabled Avocao了解更多的LTS信息，参考 Avocado Long Term Stability 接下来，可以进行avocado安装啦： sudo dnf install avocado 另外还有两个包需要安装： avocado-examples: 包含测试例子和示例文件 avocado-plugins-output-html: HTML job 报告的插件 RHEL7 如果要运行在红帽商业版或CentOS上，需要进行下面设置： # If not already, enable epel (for RHEL7 it's following cmd) sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm # Add avocado repository and install avocado sudo curl https://repos-avocadoproject.rhcloud.com/static/avocado-el.repo -o /etc/yum.repos.d/avocado.repo sudo yum install avocado 同fedora一样，需要安装以下包： avocado-examples: 包含测试例子和示例文件 avocado-plugins-output-html: HTML job 报告的插件 OpenSUSE Avocado同样支持，执行运行以下命令即可： sudo zypper install avocado 1.2 源码安装 首先确保系统有基本的编译环境，如fedora： sudo yum install -y git gcc python-devel python-pip libvirt-devel libyaml-devel redhat-rpm-config xz-devel 然后，获取源码： git clone git://github.com/avocado-framework/avocado.git cd avocado sudo make requirements sudo python setup.py install 注意，python和pip需要2.7.x版本。如果安装出现问题，需要指明python2.7 和 pip2.7. Avocodo可能需要一些插件： cd optional_plugins/html sudo python setup.py install 安装python依赖工具 avocado可以通过pip安装。 pip install avocado-framework 注意：只有基本的avocado基本的test runner安装，导入插件时可能会失败，需要根据不同的系统安装不同的依赖。 如果想安装全部插件，需要执行以下命令： pip install -r https://raw.githubusercontent.com/avocado-framework/avocado/master/requirements.txt 2. Avocado使用 首先 要使用命令行工具test runner,用来运行你的测试和收集测试结果。 2.1 运行测试 可以运行avocado加 run子命令，后面跟一个测试，例如： $ avocado run /bin/true JOB ID : 381b849a62784228d2fd208d929cc49f310412dc JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.39-381b849a/job.log TESTS : 1 ( 1/1 ) /bin/true: PASS ( 0.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.01 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.39-381b849a/html/results.html 可以看到，我们把/bin/true作为一个测试运行，并记录了测试过程。这是一个简单的例子，这是支持测试的一种类型。 Test Types 了解更多的测试类型。 注意： 尽管可以通过 avocao run \\(test1 $test3... 运行多个测试，但可以导致崩溃。一个安全的方式为： avocodo run --\\) argument1 --$argument2 -- $test1 $test2. 后面所有内容都会当做位置参数。 2.2 列出测试项 有两种方式覆盖这些测试。可以通过--dry-run 参数模拟： avocado run / bin/true -- dry-run JOB ID : 0000000000000000000000000000000000000000 JOB LOG : / tmp/avocado-dry-runSeWniM/job-2015-10-16T15 . 46 - 0000000 / job . log TESTS : 1 ( 1 / 1 ) / bin/true : SKIP RESULTS : PASS 0 | ERROR 0 | FAIL 0 | SKIP 1 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.00 s JOB HTML : / tmp/avocado-dry-runSeWniM/job-2015-10-16T15 . 46 - 0000000 / html/results . html 另一个方式是使用list参数列出支持的测试参数。如： $ avocado list INSTRUMENTED /usr/share/avocado/tests/abort.py INSTRUMENTED /usr/share/avocado/tests/datadir.py INSTRUMENTED /usr/share/avocado/tests/doublefail.py INSTRUMENTED /usr/share/avocado/tests/doublefree.py INSTRUMENTED /usr/share/avocado/tests/errortest.py INSTRUMENTED /usr/share/avocado/tests/failtest.py INSTRUMENTED /usr/share/avocado/tests/fiotest.py INSTRUMENTED /usr/share/avocado/tests/gdbtest.py INSTRUMENTED /usr/share/avocado/tests/gendata.py INSTRUMENTED /usr/share/avocado/tests/linuxbuild.py INSTRUMENTED /usr/share/avocado/tests/multiplextest.py INSTRUMENTED /usr/share/avocado/tests/passtest.py INSTRUMENTED /usr/share/avocado/tests/sleeptenmin.py INSTRUMENTED /usr/share/avocado/tests/sleeptest.py INSTRUMENTED /usr/share/avocado/tests/synctest.py INSTRUMENTED /usr/share/avocado/tests/timeouttest.py INSTRUMENTED /usr/share/avocado/tests/trinity.py INSTRUMENTED /usr/share/avocado/tests/warntest.py INSTRUMENTED /usr/share/avocado/tests/whiteboard.py ... 这些测试文件被Avocodo视为包含在INSTRUMENTED测试。 我们可以只列出可执行shell脚本： $ avocado list | grep &#94;SIMPLE SIMPLE /usr/share/avocado/tests/env_variables.sh SIMPLE /usr/share/avocado/tests/output_check.sh SIMPLE /usr/share/avocado/tests/simplewarning.sh SIMPLE /usr/share/avocado/tests/failtest.sh SIMPLE /usr/share/avocado/tests/passtest.sh 如前面说的那样，SIMPLE表示这些文件是一些简单的可执行的测试。 可以通过--verbose 或 -V,列出avocado中不是测试的文件。 $ avocado list examples/gdb-prerun-scripts/ -V Type file NOT_A_TEST examples/gdb-prerun-scripts/README NOT_A_TEST examples/gdb-prerun-scripts/pass-sigusr1 SIMPLE: 0 INSTRUMENTED: 0 MISSING: 0 NOT_A_TEST: 2 3.编写一个简单的测试 下面是一个 simple 测试的简单示例： $ echo '#!/bin/bash' > /tmp/simple_test.sh $ echo 'exit 0 ' >> /tmp/simple_test.sh $ chmod +x /tmp/simple_test.sh 注意，我们给这个文件增加了执行权限，它会被avocado当做一个simple test. 4.运行一个较复杂的测试 你 可以以任意顺序执行任意数量的测试，而且可以混合不同类型的测试： $ avocado run failtest.py sleeptest.py synctest.py failtest.py synctest.py /tmp/simple_test.sh JOB ID : 86911e49b5f2c36caeea41307cee4fecdcdfa121 JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.42-86911e49/job.log TESTS : 6 ( 1/6 ) failtest.py:FailTest.test: FAIL ( 0.00 s ) ( 2/6 ) sleeptest.py:SleepTest.test: PASS ( 1.00 s ) ( 3/6 ) synctest.py:SyncTest.test: PASS ( 2.43 s ) ( 4/6 ) failtest.py:FailTest.test: FAIL ( 0.00 s ) ( 5/6 ) synctest.py:SyncTest.test: PASS ( 2.44 s ) ( 6/6 ) /bin/true: PASS ( 0.00 s ) ( 6/6 ) /tmp/simple_test.sh.1: PASS ( 0.02 s ) RESULTS : PASS 2 | ERROR 2 | FAIL 2 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 5.88 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.42-86911e49/html/results.html 5.出现fail后中断测试 Avocado run 命令包含 --failfast on 参数，当出现错误是会退出测试： $ avocado run --failfast on /bin/true /bin/false /bin/true /bin/true JOB ID : eaf51b8c7d6be966bdf5562c9611b1ec2db3f68a JOB LOG : $HOME /avocado/job-results/job-2016-07-19T09.43-eaf51b8/job.log TESTS : 4 ( 1/4 ) /bin/true: PASS ( 0.01 s ) ( 2/4 ) /bin/false: FAIL ( 0.01 s ) Interrupting job ( failfast ) . RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 2 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.02 s JOB HTML : /home/apahim/avocado/job-results/job-2016-07-19T09.43-eaf51b8/html/results.html 6.通过外部Runner 运行测试 大 部软件都存在自己的测试集。通常包括一个定制的runner,它可以找到并运行自己的测试。 Avocado能支持运行这些测试，而且可以支持生成不同格式的结果，收集系统信息以及这些测试（Avocado的sysinfo功能）等等。 大部分方式如下： $ avocado run --external -runner=/path/to/external_runner foo bar baz 这个例子，avocado会产生foo bar baz的测试结果。实际结果将来源于执行 /path/to/external_runner foo /path/to/external_runner bar和/path/to/external_runner baz 另一种方式展示这一特性，就是思考\"外部runner\"可以是解释器和可以解释执行任何测试。UNIXshell,/bin/sh就可以被当做外部执行引擎，而且shell脚本就可以当成它的测试： $ echo \"exit 0\" > /tmp/pass $ echo \"exit 1\" > /tmp/fail $ avocado run --external-runner = /bin/sh /tmp/pass /tmp/fail JOB ID : 4a2a1d259690cc7b226e33facdde4f628ab30741 JOB LOG : /home/<user>/avocado/job-results/job-<date>-<shortid>/job.log TESTS : 2 ( 1/2 ) /tmp/pass: PASS ( 0.01 s ) ( 2/2 ) /tmp/fail: FAIL ( 0.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.01 s JOB HTML : /home/<user>/avocado/job-results/job-<date>-<shortid>/html/results.html 这个例子很明显，可以通过给/tmp/pass和/tmp/fail ，shell\"shebangs\"（＃！/ bin / sh）来实现，使它们可执行（chmod + x / tmp / pass / tmp / ，并将其作为\"简单\"测试运行。 下面看另一个例子： $ avocado run --external-runner = /bin/curl http://local-avocado-server:9405/jobs/ \\ http://remote-avocado-server:9405/jobs/ JOB ID : 56016a1ffffaba02492fdbd5662ac0b958f51e11 JOB LOG : /home/<user>/avocado/job-results/job-<date>-<shortid>/job.log TESTS : 2 ( 1/2 ) http://local-avocado-server:9405/jobs/: PASS ( 0.02 s ) ( 2/2 ) http://remote-avocado-server:9405/jobs/: FAIL ( 3.02 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 3.04 s JOB HTML : /home/<user>/avocado/job-results/job-<date>-<shortid>/html/results.html 这个例子是把\"/bin/curl\"当做\"external test runner\". 7. 测试调试 当 开发一个新的测试时，经常做的就是查看一个测试job的运行日志。 为了实现这个目的， 可以通过 avocado --show test run ... 或 avocado run --show-job-log ... 例如： $ avocado --show test run examples/tests/sleeptest.py ... Job ID: f9ea1742134e5352dec82335af584d1f151d4b85 START 1-sleeptest.py:SleepTest.test PARAMS (key=timeout, path=*, default=None) => None PARAMS (key=sleep_length, path=*, default=1) => 1 Sleeping for 1.00 seconds PASS 1-sleeptest.py:SleepTest.test Test results available in $ HOME /avocado/job-results/job-2015-06-02T10.45-f9ea174 UI输出被抑制，只显示作业日志，这使得它成为测试开发和调试的有用功能。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"自动化测试-Avocado","title":"Avocado-入门"},{"url":"http://king32783784.github.io/2015/01/12/自动化测试/","text":"浏览器是系统下比较常用的软件，在linux系统比较常用的是firefox、chrome.如何评估浏览器的基础性能？有很多评测网站进行了这边的测试。 如 CSS acid3 v8test octane html5 dromaeo 等 考虑到每次测试都需要点击这些网站和取测试结果，决定采用selenium去实现自动测试。 测试代码如下： browser-run.py: ```python #encoding = utf-8 import logging import runtest import re import sys from subprocess import call from selenium import webdriver reload ( sys ) sys . setdefaultencoding ( 'utf8' ) # create logger with 'spam_application' logger = logging . getLogger ( 'browser-test' ) logger . setLevel ( logging . DEBUG ) # create file handler which logs even debug messages fh = logging . FileHandler ( 'browser.log' ) fh . setLevel ( logging . DEBUG ) # create console handler with a higher log level ch = logging . StreamHandler () ch . setLevel ( logging . DEBUG ) # create formatter and add it to the handlers formatter = logging . Formatter ( ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) fh . setFormatter ( formatter ) ch . setFormatter ( formatter ) # add the handlers to the logger logger . addHandler ( fh ) logger . addHandler ( ch ) css4 = { 'name' : 'css4' , 'url' : 'http://css4-selectors.com/browser-selector-test/' , 'click' : 'start-browser-selector-test' , 'result' : 'diagram' } #do_type2test acid3 = { 'name' : 'acid3' , 'url' : 'http://acid3.acidtests.org/' , 'result' : 'result' } v8test = { 'name' : 'v8test' , 'url' : 'http://chrome.360.cn/test/v8/run.html' , 'result' : 'status' } octane = { 'name' : 'octane' , 'url' : 'http://chrome.2345.com/labs/test/octanebenchmark.htm' , 'result' : 'main-banner' } #do_type3test html5 = { 'name' : 'html5' , 'url' : 'http://html5test.com/' , 'result' : '//*[@id= \\\" score \\\" ]/div[1]/h2/strong' } #do_type4test dromaeo = { 'name' : 'dromaeo' , 'url' : 'http://dromaeo.com/' , 'result' : '//*[@id= \\' timebar \\' ]/span/strong' , 'testxpath' : '//*[@id= \\\" tests \\\" ]/li[8]/a' , 'runid' : 'pause' , 'resultid' : 'left' } def result ( Initialresults ): p = re . compile ( r'\\d+' ) return p . findall ( Initialresults ) def chrome (): try : retcode = call ( \"which chromium-browser\" , shell = True ) if retcode > 0 : pass else : csstest = runtest . Do_type2test ( css4 ) cssresult = csstest . do_test ( webdriver . Chrome ()) print ( \"css4 result is %s \" % result ( cssresult )[ 3 ]) acidtest = runtest . Do_type1test ( acid3 ) acidresult = acidtest . do_test ( webdriver . Chrome ()) print ( \"acid3 result is %s \" % acidresult ) vtest = runtest . Do_type1test ( v8test ) vresult = vtest . do_test ( webdriver . Chrome ()) print ( \"V8test result is %s \" % vresult ) octanetest = runtest . Do_type1test ( octane ) octaneresult = octanetest . do_test ( webdriver . Chrome ()) print ( \"octane result is %s \" % octaneresult ) htmltest = runtest . Do_type3test ( html5 ) htmlresult = htmltest . do_test ( webdriver . Chrome ()) print ( \"html5test result is %s \" % htmlresult ) dromaeotest = runtest . Do_type4test ( dromaeo ) dromaeotestresult = dromaeotest . do_test ( webdriver . Chrome ()) print ( \"dromaeotest result is %s \" % dromaeotestresult ) print ( \"test finish\" ) except OSError as e : logger . ERROR ( \"Execution failed: %s \" % e ) def firefox (): try : retcode = call ( \"which firefox\" , shell = True ) if retcode > 0 : pass else : csstest = runtest . Do_type2test ( css4 ) cssresult = csstest . do_test ( webdriver . Firefox ()) print ( \"css4 result is %s \" % result ( cssresult )[ 3 ]) acidtest = runtest . Do_type1test ( acid3 ) acidresult = acidtest . do_test ( webdriver . Firefox ()) print ( \"acid3 result is %s \" % acidresult ) vtest = runtest . Do_type1test ( v8test ) vresult = vtest . do_test ( webdriver . Firefox ()) print ( \"V8test result is %s \" % vresult ) octanetest = runtest . Do_type1test ( octane ) octaneresult = octanetest . do_test ( webdriver . Firefox ()) print ( \"octane result is %s \" % octaneresult ) htmltest = runtest . Do_type3test ( html5 ) htmlresult = htmltest . do_test ( webdriver . Firefox ()) print ( \"html5test result is %s \" % htmlresult ) dromaeotest = runtest . Do_type4test ( dromaeo ) dromaeotestresult = dromaeotest . do_test ( webdriver . Firefox ()) print ( \"dromaeotest result is %s \" % dromaeotestresult ) print ( \"test finish\" ) except OSError as e : logger . ERROR ( \"Execution failed: %s \" % e ) if __name__ == \"__main__\" : chrome () firefox () runtest.py: import time import logging from selenium import webdriver from subprocess import call module_logger = logging . getLogger ( 'browser-test.runtest' ) def check_xpath ( testname = 'dromaetest' , checkxpath = \"//*[@id='tests']/li[3]/b/a\" ): '''check the xpath ready or not''' while True : try : drop = testname . find_element_by_xpath ( \" %s \" % checkxpath ) break except : module_logger . info ( \" %s is not ok\" % checkxpath ) def check_idon ( testname = 'dromaeotest' , checkid = 'pause' ): while True : try : drop = testname . find_element_by_id ( \" %s \" % checkid ) break except : time . sleep ( 1 ) def check_idoff ( testname = 'dromaeotest' , checkid = 'left' ): while True : try : drop = testname . find_element_by_id ( \" %s \" % checkid ) time . sleep ( 1 ) except : break class Do_type1test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type1test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 60 ) while True : try : drop = test . find_element_by_id ( self . cmds [ 'result' ]) break except : self . logger . info ( \"There are some errors about this test\" ) test . quit () exit () result = test . find_element_by_id ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type2test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type2test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) test . find_element_by_id ( self . cmds [ 'click' ]) . click () time . sleep ( 20 ) result = test . find_element_by_id ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type3test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type3test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 60 ) result = test . find_element_by_xpath ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type4test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type4test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 30 ) check_xpath ( testname = test , checkxpath = self . cmds [ 'testxpath' ]) test . find_element_by_xpath ( self . cmds [ 'testxpath' ]) . click () time . sleep ( 30 ) check_idon ( testname = test , checkid = self . cmds [ 'runid' ]) test . find_element_by_id ( self . cmds [ 'runid' ]) . click () check_idoff ( testname = test , checkid = self . cmds [ 'resultid' ]) result = test . find_element_by_xpath ( self . cmds [ 'result' ]) . text test . quit () ```","tags":"自动化测试-Selenium","title":"selenium-浏览器性能测试"},{"url":"http://king32783784.github.io/2016/11/01/自动化测试/","text":"Avocado 用户指南 内容： 关于Avocado 入门 安装Avocado 使用Avocado 写一个简单测试 运行一个较复杂的测试 第一个测试失败时中断测试job 结合外部runner运行测试 测试调试 编写Avocado测试 基本例子 保存测试生成的数据（自定义） 访问测试参数 使用multplex文件 高级日志功能 unittest.TestCase 继承 Setup和cleanup方法 运行第三方测试集 获取资源文件 测试输出检查和输出记录模式 Avocado Testlog，stdout和stderr模块 独立进程中运行Avocado测试 设置测试超时 测试标签 Python unitest 兼容测试和警告 简单测试的环境变量 简单测试的BASH扩展 Wrap up 结果格式 人性化测试结果 机器可读的结果 一次多种结果 Exit Codes 实现其他结果格式 配置 配置文件的解析顺序 插件设置文件 解析订单概述 测试中使用值的优先级 设置插件 Avocado数据目录 测试发现 测试载入的顺序 日志系统 UI调整 存储用户日志 分页器 测试变种－Mux Mux内部 Mux API 节点 键和值 变体 分辨顺序 插入文件 复合文件 高级YAML标记 !include !using !remove_node !remove_value !mux 完整示例 Job重放 Job对比 运行远程测试 远程Host运行测试 虚拟机上运行测试 Docker容器上运行测试 环境变量 使用GDB调试 透明执行可执行文件 avocado.uitls.gdb APIs 封装测试执行文件 用法 警告 插件系统 插件列表 制作插件 高级主题和维护 参考指南 job,test和identifiers 测试类型 测试状态 库和APIs 测试解析 结果规格 job前后脚本 job清理 Avocado 开发tips 中断测试 In tree utils Line-profiler 使用Eclipse远程debug 在Eclipase中使用Trello avocado发布 删除版本号 应当注意哪些项目库 所有库的标记 构建rpms 包命名 上传包到仓库 书写发行注记 发送电子邮件到avocado-devel和其他地方 API参考 测试APIs 工具APIs 内部(核心)APIs 外部(插件)APIs Avocado 发行注记 发行注记 关于Avocado Avocado 是一套帮助自动化测试工具和库。 可以把它称作为测试框架。内部测试是通过python编写的，并且遵从unittest模式，但是它也可以将执行任何外部可执行文件作为测试。 组成部分： 一个可以引导执行测试的Test runner。这些测试可以是选择任意语言编写的测试，或则通过python编写，并使用可用的库。这两种情况，你都可以获取自动日志和系统信息收集功能。 提供一个帮助你通过一种concise,yet expressive 和 powerful的方式编写测试。你可以通过后面 库和API 章节了解更多这方面的信息。 插件，可以扩展和增加框架的功能 Avocado尽可能尝试遵守标准的Python测试技术。 使用Avocado API编写的测试是从unittest类派生，而添加了适合于功能和性能测试的其他方法。 测试运行器旨在帮助人们运行测试，同时提供各种系统和日志记录工具。 接下来的专题，会按照本文的目录详细介绍Avocado Top &#94; 下一篇 Avocado-入门","tags":"自动化测试-Avocado","title":"Avocado User's Guide"},{"url":"http://king32783784.github.io/2016/11/12/自动化测试/","text":"编写Avocado测试 现在我们开始使用python编写Avocado测试，测试继承于avocado.Test. 基本例子 创建一个时间测试，sleeptest,测试非常简单，只是sleep一会： import time from avocado import Test class SleepTest ( Test ): def test ( self ): sleep_length = self . params . get ( 'sleep_length' , default = 1 ) self . log . debug ( \"Sleep for %.2f seconds\" , sleep_length ) time sleep ( sleep_length ) 这是为avocado编写的一个简单示例，可以使用其他power API编写。 从上面的例子可以看出，avocado测试从avocado.Test继承的test方法入手。 多个测试和命名约定 可以在一个类中存在多个测试。 要想做多个测试，只需要在命名方法前加test,例如test_foo,test_bar等。建议遵守这个命名风格，就像 PEP8 Function Names . 对于class名称，可以任意命名，当最好还是遵从CamelCase命名，参考PEP8 中 Class Names 方便属性 测试类提供了一定数量的方便属性： 为测试添加测试log,可以使用self.log.可以定义log debug,info,error和warning信息。 参数解析系统，可以访问self.parms使用。可以在后面的Test variants - Mux文章查看更多信息。 保存生成的数据 每个测试都提供一个所谓的whiteboard,可以通过self.whiteboard访问。Witeboard是一个可以自动保存到测试结果（可以支持的output格式）字符串。你同样可以选择保存二进制数据到whiteboard,但你需要先进行编码转换（base64). 基于上面的sleeptest，假设想保存sleep_length用于其他脚本或数据分析工具： def test(self): sleep_length = self.params.get('sleep_length', default=1) self.log.debug(\"Sleeping for %.2f second\", sleep_length) time.sleep(sleep_length) slef.writeboard = \"%.2f\" % sleep_length whiteboard可以并应当接收由可用的测试结果插件生成的文件。Result.json文件已经为每个测试包含了whiteboard.此外，会用一个命名为whiteboard的文件保存和results.json相同级别的信息（也许你想使用与你定制的脚本配套的结果处理工具，该文件会保存白板内容的原始副本）。 访问测试参数 每个测试都有一组可以通过self.params.get($name, $path=None, $default=None)访问的参数.Avocado会从Multiplex 配置文件中发现所有参数并填充到self.params.比如上面的例子，sleeptest的multiplex文件： sleeptest : type : \"builtin\" length : ! Mux short : sleep_length : 0.5 medium : sleep_length : 1 long : sleep_length : 5 当我们用avocado run $test --mux-yaml $file.yaml运行这个例子，3个variants会执行并且内容会插入/run的命名空间。每个variant包含变量的\"type\"和\"sleep_length\"。要获取有效值，需要名称（\"sleep_length)和path。需要选择路径 ,在这个例子：/run/sleeptest/length/ 或sleeptest/ ,取决于如何设置。 默认的参数是可选的，但是要处理好这部分。可能有人运行你的测试时选择不同的参数或没有参数，它仍然能够很好的运行。 所以关于如何访问\"sleep_length\"的完整示例： self.params.get(\"sleep_length\", \"/*/sleeptest/*\", 1) 还有一种更简单的方式。它用于定义解析顺序，简单的查询可以简单的指定路径： self.params.get(\"sleep_length\", None, 1) self.params.get(\"sleep_length\", '*', 1) self.params.get(\"sleep_length\", default=1) 应该避免参数冲突（不同的匹配值应该指定不同的路径）。如果不能这样（例如使用复合yaml文件）可以通过 --mux-path进行默认路径的修改。它将对参数和操作通过路径进行一个接一个的切片。当第一个切片匹配后会返回，不再尝试其他切片。虽然相对查询只匹配来自--mux-path的切片。 有很多方式使用paths分离存在冲突的params或只是使查询更清晰。通常tests中使用\"*\"就足够了，namespacing不是必须的，但是有助于高级用法更清晰简单。 关于路径的考虑基本是从用户角度。更多信息参考 The variants-Mux 使用multplex文件 Ａvocado可以使用multplex文件提供params和生成generation来运行sleeptest: $ avocado run sleeptest.py --mux-yaml examples/tests/sleeptest.py.date/sleeptest.yaml JOB ID : d565e8dec576d6040f894841f32a836c751f968f JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.44-d565e8de/job.log TESTS : 3 ( 1/3 ) sleeptest.py:SleepTest.test ; 1: PASS ( 0.50 s ) ( 2/3 ) sleeptest.py:SleepTest.test ; 2: PASS ( 1.00 s ) ( 3/3 ) sleeptest.py:SleepTest.test ; 3: PASS ( 5.00 s ) RESULTS : PASS 3 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 6.50 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.44-d565e8de/html/results.html The --mux-yaml accepts either only \\(FILE_LOCATION or $INJECT_TO:\\) FILE_LOCATION. As explained in Test variants - Mux without any path the content gets injected into /run in order to be in the default relative path location. The \\(INJECT_TO can be either relative path, then it's injected into /run/\\) INJECT_TO location, or absolute path (starting with '/'), then it's injected directly into the specified path and it's up to the test/framework developer to get the value from this location (using path or adding the path to mux-path). To understand the difference execute those commands: $ avocado multiplex -t -m examples/tests/sleeptest.py.data/sleeptest.yaml $ avocado multiplex -t -m duration:examples/tests/sleeptest.py.data/sleeptest.yaml $ avocado multiplex -t -m /my/location:examples/tests/sleeptest.pt.data/sleeptest.yaml 注意，因为multiplex文件为sleeptest指定了所有参数，所以不能将ID留空： $ scripts/avocado run --mux-yaml examples/tests/sleeptest/sleeptest.yaml Empty test ID. A test path or alias must be provided 可以使用同一个multiplex文件启动多个测试： $avocado run sleeptest . py synctest . py -- mux-yaml examples/tests/sleeptest . py . data/sleeptest . yaml JOB ID : cd20fc8d1714da6d4791c19322374686da68c45c JOB LOG : $HOME/avocado/job-results/job-2016-05-04T09 . 25 - cd20fc8/job . log TESTS : 8 ( 1 / 8 ) sleeptest . py : SleepTest . test;1 : PASS ( 0.50 s ) ( 2 / 8 ) sleeptest . py : SleepTest . test;2 : PASS ( 1.00 s ) ( 3 / 8 ) sleeptest . py : SleepTest . test;3 : PASS ( 5.01 s ) ( 4 / 8 ) sleeptest . py : SleepTest . test;4 : PASS ( 10.00 s ) ( 5 / 8 ) synctest . py : SyncTest . test;1 : PASS ( 2.38 s ) ( 6 / 8 ) synctest . py : SyncTest . test;2 : PASS ( 2.47 s ) ( 7 / 8 ) synctest . py : SyncTest . test;3 : PASS ( 2.46 s ) ( 8 / 8 ) synctest . py : SyncTest . test;4 : PASS ( 2.45 s ) RESULTS : PASS 8 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 26.26 s JOB HTML : $HOME/avocado/job-results/job-2016-05-04T09 . 25 - cd20fc8/html/results . html 高级日志功能 Avocado 在测试的同时提供高级日志功能。这些可以和标准python API库组合。 一个常见的例子是需要在更长或更复杂的测试中遵循具体的进展。 让我们看一个非常简单的测试示例，但在单个测试中有一个多个明确的阶段： import logging import time from avocado import Test progress_log = logging . getLogger ( \"progress\" class Plant ( Test ): def test_plant_organic ( self ): rows = self . params . get ( \"rows\" , default = 3 ) #Preparing soil for row in range ( rows ): progress_log . info ( \" %s : Preparing soil on row %s \" , self . name , row ) # Letting soil rest progress_log . info ( \" %s : letting soil rest before throwing seeds\" , self . name ) time . sleep ( 2 ) # Throwing seeds for row in range ( rows ): progress_log . info ( \" %s : throwing seeds on row %s \" , self . name , row ) # Let them grow progress_log . info ( \" %s : waiting for Avocados to grow\" , self . name ) time . sleep ( 5 ) # Harvest them for row in range ( rows ): progress_log . info ( \" %s : harvesting organic avocados on row %s \" , self . name , row ) 这时，可以请求avocaod显示你的日志流，独占或则加入其他内建流： $ avocado --show app, progress run plant.py 结果类似于： JOB ID : af786f86db530bff26cd6a92c36e99bedcdca95b JOB LOG : / home/cleber/avocado/job-results/job-2016-03-18T10 . 29 - af786f8/job . log TESTS : 1 ( 1 / 1 ) plant . py : Plant . test_plant_organic : progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 0 progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 1 progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 2 progress : 1 - plant . py : Plant . test_plant_organic : letting soil rest before throwing seeds - progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 0 progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 1 progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 2 progress : 1 - plant . py : Plant . test_plant_organic : waiting for Avocados to grow \\progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 0 progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 1 progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 2 PASS ( 7.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 7.01 s JOB HTML : / home/cleber/avocado/job-results/job-2016-03-18T10 . 29 - af786f8/html/results . html 自定义的progress流和app输出混合在一起，可能不太适合。如果想让progress流输入到一个独立文件，这样会清晰。 $ avocado run plant.py --store-loggin-stream progress 这样，除了所有其他日志文件通常生成，会有另一个名为日志文件progress.INFO在作业结果目录。 在测试运行期间，可以观察进度： $ tail -f ~/avocado/job-results/latest/progress.INFO 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 0 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 1 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 2 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: letting soil rest before throwing seeds 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 0 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 1 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 2 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: waiting for Avocados to grow 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 0 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 1 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 2 同一个progress日志记录器，可以在多个测试方法和在多个测试模块一起使用。 在给出的示例中，测试名称用于给出额外的上下文。 <未完待续> if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"自动化测试-Avocado","title":"Avocado-编写Avocado测试"},{"url":"http://king32783784.github.io/2015/01/12/自动化测试/","text":"浏览器是系统下比较常用的软件，在linux系统比较常用的是firefox、chrome.如何评估浏览器的基础性能？有很多评测网站进行了这边的测试。 如 CSS acid3 v8test octane html5 dromaeo 等 考虑到每次测试都需要点击这些网站和取测试结果，决定采用selenium去实现自动测试。 测试代码如下： browser-run.py: ```python #encoding = utf-8 import logging import runtest import re import sys from subprocess import call from selenium import webdriver reload ( sys ) sys . setdefaultencoding ( 'utf8' ) # create logger with 'spam_application' logger = logging . getLogger ( 'browser-test' ) logger . setLevel ( logging . DEBUG ) # create file handler which logs even debug messages fh = logging . FileHandler ( 'browser.log' ) fh . setLevel ( logging . DEBUG ) # create console handler with a higher log level ch = logging . StreamHandler () ch . setLevel ( logging . DEBUG ) # create formatter and add it to the handlers formatter = logging . Formatter ( ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) fh . setFormatter ( formatter ) ch . setFormatter ( formatter ) # add the handlers to the logger logger . addHandler ( fh ) logger . addHandler ( ch ) css4 = { 'name' : 'css4' , 'url' : 'http://css4-selectors.com/browser-selector-test/' , 'click' : 'start-browser-selector-test' , 'result' : 'diagram' } #do_type2test acid3 = { 'name' : 'acid3' , 'url' : 'http://acid3.acidtests.org/' , 'result' : 'result' } v8test = { 'name' : 'v8test' , 'url' : 'http://chrome.360.cn/test/v8/run.html' , 'result' : 'status' } octane = { 'name' : 'octane' , 'url' : 'http://chrome.2345.com/labs/test/octanebenchmark.htm' , 'result' : 'main-banner' } #do_type3test html5 = { 'name' : 'html5' , 'url' : 'http://html5test.com/' , 'result' : '//*[@id= \\\" score \\\" ]/div[1]/h2/strong' } #do_type4test dromaeo = { 'name' : 'dromaeo' , 'url' : 'http://dromaeo.com/' , 'result' : '//*[@id= \\' timebar \\' ]/span/strong' , 'testxpath' : '//*[@id= \\\" tests \\\" ]/li[8]/a' , 'runid' : 'pause' , 'resultid' : 'left' } def result ( Initialresults ): p = re . compile ( r'\\d+' ) return p . findall ( Initialresults ) def chrome (): try : retcode = call ( \"which chromium-browser\" , shell = True ) if retcode > 0 : pass else : csstest = runtest . Do_type2test ( css4 ) cssresult = csstest . do_test ( webdriver . Chrome ()) print ( \"css4 result is %s \" % result ( cssresult )[ 3 ]) acidtest = runtest . Do_type1test ( acid3 ) acidresult = acidtest . do_test ( webdriver . Chrome ()) print ( \"acid3 result is %s \" % acidresult ) vtest = runtest . Do_type1test ( v8test ) vresult = vtest . do_test ( webdriver . Chrome ()) print ( \"V8test result is %s \" % vresult ) octanetest = runtest . Do_type1test ( octane ) octaneresult = octanetest . do_test ( webdriver . Chrome ()) print ( \"octane result is %s \" % octaneresult ) htmltest = runtest . Do_type3test ( html5 ) htmlresult = htmltest . do_test ( webdriver . Chrome ()) print ( \"html5test result is %s \" % htmlresult ) dromaeotest = runtest . Do_type4test ( dromaeo ) dromaeotestresult = dromaeotest . do_test ( webdriver . Chrome ()) print ( \"dromaeotest result is %s \" % dromaeotestresult ) print ( \"test finish\" ) except OSError as e : logger . ERROR ( \"Execution failed: %s \" % e ) def firefox (): try : retcode = call ( \"which firefox\" , shell = True ) if retcode > 0 : pass else : csstest = runtest . Do_type2test ( css4 ) cssresult = csstest . do_test ( webdriver . Firefox ()) print ( \"css4 result is %s \" % result ( cssresult )[ 3 ]) acidtest = runtest . Do_type1test ( acid3 ) acidresult = acidtest . do_test ( webdriver . Firefox ()) print ( \"acid3 result is %s \" % acidresult ) vtest = runtest . Do_type1test ( v8test ) vresult = vtest . do_test ( webdriver . Firefox ()) print ( \"V8test result is %s \" % vresult ) octanetest = runtest . Do_type1test ( octane ) octaneresult = octanetest . do_test ( webdriver . Firefox ()) print ( \"octane result is %s \" % octaneresult ) htmltest = runtest . Do_type3test ( html5 ) htmlresult = htmltest . do_test ( webdriver . Firefox ()) print ( \"html5test result is %s \" % htmlresult ) dromaeotest = runtest . Do_type4test ( dromaeo ) dromaeotestresult = dromaeotest . do_test ( webdriver . Firefox ()) print ( \"dromaeotest result is %s \" % dromaeotestresult ) print ( \"test finish\" ) except OSError as e : logger . ERROR ( \"Execution failed: %s \" % e ) if __name__ == \"__main__\" : chrome () firefox () runtest.py: import time import logging from selenium import webdriver from subprocess import call module_logger = logging . getLogger ( 'browser-test.runtest' ) def check_xpath ( testname = 'dromaetest' , checkxpath = \"//*[@id='tests']/li[3]/b/a\" ): '''check the xpath ready or not''' while True : try : drop = testname . find_element_by_xpath ( \" %s \" % checkxpath ) break except : module_logger . info ( \" %s is not ok\" % checkxpath ) def check_idon ( testname = 'dromaeotest' , checkid = 'pause' ): while True : try : drop = testname . find_element_by_id ( \" %s \" % checkid ) break except : time . sleep ( 1 ) def check_idoff ( testname = 'dromaeotest' , checkid = 'left' ): while True : try : drop = testname . find_element_by_id ( \" %s \" % checkid ) time . sleep ( 1 ) except : break class Do_type1test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type1test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 60 ) while True : try : drop = test . find_element_by_id ( self . cmds [ 'result' ]) break except : self . logger . info ( \"There are some errors about this test\" ) test . quit () exit () result = test . find_element_by_id ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type2test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type2test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) test . find_element_by_id ( self . cmds [ 'click' ]) . click () time . sleep ( 20 ) result = test . find_element_by_id ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type3test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type3test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 60 ) result = test . find_element_by_xpath ( self . cmds [ 'result' ]) . text test . quit () return result class Do_type4test ( object ): def __init__ ( self , testcmds ): self . logger = logging . getLogger ( 'browser-test.runtest.Do_type4test' ) self . cmds = testcmds self . logger . info ( \" %s test startting \" % self . cmds [ 'name' ]) def do_test ( self , test ): test . get ( self . cmds [ 'url' ]) time . sleep ( 30 ) check_xpath ( testname = test , checkxpath = self . cmds [ 'testxpath' ]) test . find_element_by_xpath ( self . cmds [ 'testxpath' ]) . click () time . sleep ( 30 ) check_idon ( testname = test , checkid = self . cmds [ 'runid' ]) test . find_element_by_id ( self . cmds [ 'runid' ]) . click () check_idoff ( testname = test , checkid = self . cmds [ 'resultid' ]) result = test . find_element_by_xpath ( self . cmds [ 'result' ]) . text test . quit () ```","tags":"自动化测试-Selenium","title":"selenium-浏览器性能测试"},{"url":"http://king32783784.github.io/2016/11/12/自动化测试/","text":"编写Avocado测试 现在我们开始使用python编写Avocado测试，测试继承于avocado.Test. 基本例子 创建一个时间测试，sleeptest,测试非常简单，只是sleep一会： import time from avocado import Test class SleepTest ( Test ): def test ( self ): sleep_length = self . params . get ( 'sleep_length' , default = 1 ) self . log . debug ( \"Sleep for %.2f seconds\" , sleep_length ) time sleep ( sleep_length ) 这是为avocado编写的一个简单示例，可以使用其他power API编写。 从上面的例子可以看出，avocado测试从avocado.Test继承的test方法入手。 多个测试和命名约定 可以在一个类中存在多个测试。 要想做多个测试，只需要在命名方法前加test,例如test_foo,test_bar等。建议遵守这个命名风格，就像 PEP8 Function Names . 对于class名称，可以任意命名，当最好还是遵从CamelCase命名，参考PEP8 中 Class Names 方便属性 测试类提供了一定数量的方便属性： 为测试添加测试log,可以使用self.log.可以定义log debug,info,error和warning信息。 参数解析系统，可以访问self.parms使用。可以在后面的Test variants - Mux文章查看更多信息。 保存生成的数据 每个测试都提供一个所谓的whiteboard,可以通过self.whiteboard访问。Witeboard是一个可以自动保存到测试结果（可以支持的output格式）字符串。你同样可以选择保存二进制数据到whiteboard,但你需要先进行编码转换（base64). 基于上面的sleeptest，假设想保存sleep_length用于其他脚本或数据分析工具： def test(self): sleep_length = self.params.get('sleep_length', default=1) self.log.debug(\"Sleeping for %.2f second\", sleep_length) time.sleep(sleep_length) slef.writeboard = \"%.2f\" % sleep_length whiteboard可以并应当接收由可用的测试结果插件生成的文件。Result.json文件已经为每个测试包含了whiteboard.此外，会用一个命名为whiteboard的文件保存和results.json相同级别的信息（也许你想使用与你定制的脚本配套的结果处理工具，该文件会保存白板内容的原始副本）。 访问测试参数 每个测试都有一组可以通过self.params.get($name, $path=None, $default=None)访问的参数.Avocado会从Multiplex 配置文件中发现所有参数并填充到self.params.比如上面的例子，sleeptest的multiplex文件： sleeptest : type : \"builtin\" length : ! Mux short : sleep_length : 0.5 medium : sleep_length : 1 long : sleep_length : 5 当我们用avocado run $test --mux-yaml $file.yaml运行这个例子，3个variants会执行并且内容会插入/run的命名空间。每个variant包含变量的\"type\"和\"sleep_length\"。要获取有效值，需要名称（\"sleep_length)和path。需要选择路径 ,在这个例子：/run/sleeptest/length/ 或sleeptest/ ,取决于如何设置。 默认的参数是可选的，但是要处理好这部分。可能有人运行你的测试时选择不同的参数或没有参数，它仍然能够很好的运行。 所以关于如何访问\"sleep_length\"的完整示例： self.params.get(\"sleep_length\", \"/*/sleeptest/*\", 1) 还有一种更简单的方式。它用于定义解析顺序，简单的查询可以简单的指定路径： self.params.get(\"sleep_length\", None, 1) self.params.get(\"sleep_length\", '*', 1) self.params.get(\"sleep_length\", default=1) 应该避免参数冲突（不同的匹配值应该指定不同的路径）。如果不能这样（例如使用复合yaml文件）可以通过 --mux-path进行默认路径的修改。它将对参数和操作通过路径进行一个接一个的切片。当第一个切片匹配后会返回，不再尝试其他切片。虽然相对查询只匹配来自--mux-path的切片。 有很多方式使用paths分离存在冲突的params或只是使查询更清晰。通常tests中使用\"*\"就足够了，namespacing不是必须的，但是有助于高级用法更清晰简单。 关于路径的考虑基本是从用户角度。更多信息参考 The variants-Mux 使用multplex文件 Ａvocado可以使用multplex文件提供params和生成generation来运行sleeptest: $ avocado run sleeptest.py --mux-yaml examples/tests/sleeptest.py.date/sleeptest.yaml JOB ID : d565e8dec576d6040f894841f32a836c751f968f JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.44-d565e8de/job.log TESTS : 3 ( 1/3 ) sleeptest.py:SleepTest.test ; 1: PASS ( 0.50 s ) ( 2/3 ) sleeptest.py:SleepTest.test ; 2: PASS ( 1.00 s ) ( 3/3 ) sleeptest.py:SleepTest.test ; 3: PASS ( 5.00 s ) RESULTS : PASS 3 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 6.50 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.44-d565e8de/html/results.html The --mux-yaml accepts either only \\(FILE_LOCATION or $INJECT_TO:\\) FILE_LOCATION. As explained in Test variants - Mux without any path the content gets injected into /run in order to be in the default relative path location. The \\(INJECT_TO can be either relative path, then it's injected into /run/\\) INJECT_TO location, or absolute path (starting with '/'), then it's injected directly into the specified path and it's up to the test/framework developer to get the value from this location (using path or adding the path to mux-path). To understand the difference execute those commands: $ avocado multiplex -t -m examples/tests/sleeptest.py.data/sleeptest.yaml $ avocado multiplex -t -m duration:examples/tests/sleeptest.py.data/sleeptest.yaml $ avocado multiplex -t -m /my/location:examples/tests/sleeptest.pt.data/sleeptest.yaml 注意，因为multiplex文件为sleeptest指定了所有参数，所以不能将ID留空： $ scripts/avocado run --mux-yaml examples/tests/sleeptest/sleeptest.yaml Empty test ID. A test path or alias must be provided 可以使用同一个multiplex文件启动多个测试： $avocado run sleeptest . py synctest . py -- mux-yaml examples/tests/sleeptest . py . data/sleeptest . yaml JOB ID : cd20fc8d1714da6d4791c19322374686da68c45c JOB LOG : $HOME/avocado/job-results/job-2016-05-04T09 . 25 - cd20fc8/job . log TESTS : 8 ( 1 / 8 ) sleeptest . py : SleepTest . test;1 : PASS ( 0.50 s ) ( 2 / 8 ) sleeptest . py : SleepTest . test;2 : PASS ( 1.00 s ) ( 3 / 8 ) sleeptest . py : SleepTest . test;3 : PASS ( 5.01 s ) ( 4 / 8 ) sleeptest . py : SleepTest . test;4 : PASS ( 10.00 s ) ( 5 / 8 ) synctest . py : SyncTest . test;1 : PASS ( 2.38 s ) ( 6 / 8 ) synctest . py : SyncTest . test;2 : PASS ( 2.47 s ) ( 7 / 8 ) synctest . py : SyncTest . test;3 : PASS ( 2.46 s ) ( 8 / 8 ) synctest . py : SyncTest . test;4 : PASS ( 2.45 s ) RESULTS : PASS 8 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 26.26 s JOB HTML : $HOME/avocado/job-results/job-2016-05-04T09 . 25 - cd20fc8/html/results . html 高级日志功能 Avocado 在测试的同时提供高级日志功能。这些可以和标准python API库组合。 一个常见的例子是需要在更长或更复杂的测试中遵循具体的进展。 让我们看一个非常简单的测试示例，但在单个测试中有一个多个明确的阶段： import logging import time from avocado import Test progress_log = logging . getLogger ( \"progress\" class Plant ( Test ): def test_plant_organic ( self ): rows = self . params . get ( \"rows\" , default = 3 ) #Preparing soil for row in range ( rows ): progress_log . info ( \" %s : Preparing soil on row %s \" , self . name , row ) # Letting soil rest progress_log . info ( \" %s : letting soil rest before throwing seeds\" , self . name ) time . sleep ( 2 ) # Throwing seeds for row in range ( rows ): progress_log . info ( \" %s : throwing seeds on row %s \" , self . name , row ) # Let them grow progress_log . info ( \" %s : waiting for Avocados to grow\" , self . name ) time . sleep ( 5 ) # Harvest them for row in range ( rows ): progress_log . info ( \" %s : harvesting organic avocados on row %s \" , self . name , row ) 这时，可以请求avocaod显示你的日志流，独占或则加入其他内建流： $ avocado --show app, progress run plant.py 结果类似于： JOB ID : af786f86db530bff26cd6a92c36e99bedcdca95b JOB LOG : / home/cleber/avocado/job-results/job-2016-03-18T10 . 29 - af786f8/job . log TESTS : 1 ( 1 / 1 ) plant . py : Plant . test_plant_organic : progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 0 progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 1 progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 2 progress : 1 - plant . py : Plant . test_plant_organic : letting soil rest before throwing seeds - progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 0 progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 1 progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 2 progress : 1 - plant . py : Plant . test_plant_organic : waiting for Avocados to grow \\progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 0 progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 1 progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 2 PASS ( 7.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 7.01 s JOB HTML : / home/cleber/avocado/job-results/job-2016-03-18T10 . 29 - af786f8/html/results . html 自定义的progress流和app输出混合在一起，可能不太适合。如果想让progress流输入到一个独立文件，这样会清晰。 $ avocado run plant.py --store-loggin-stream progress 这样，除了所有其他日志文件通常生成，会有另一个名为日志文件progress.INFO在作业结果目录。 在测试运行期间，可以观察进度： $ tail -f ~/avocado/job-results/latest/progress.INFO 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 0 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 1 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 2 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: letting soil rest before throwing seeds 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 0 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 1 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 2 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: waiting for Avocados to grow 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 0 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 1 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 2 同一个progress日志记录器，可以在多个测试方法和在多个测试模块一起使用。 在给出的示例中，测试名称用于给出额外的上下文。 <未完待续> if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"自动化测试-Avocado","title":"Avocado-编写Avocado测试"},{"url":"http://king32783784.github.io/2016/11/03/自动化测试/","text":"1.Avocado 安装 1.1 通过包安装 像 Fedora 可以通过rpm包进行安装，其他通过RPM管理的发行版需要自己制作相关包。Avocado同样支持DEP包的安装可以在contrib/packages/debian找到。 Fedora 首先通过下面的命令获取仓库配置文件。 sudo curl https://repos-avocadoproject.rhcloud.com/static/avocado-fedora.repo -o /etc/yum.repos.d/avocado.repo 检查是否有了Avocodo和Avocado-lts的仓库配置： sudo dnf repolist avocado avocado-lts ... repo id repo name status avocado Avocado 50 avocado-lts Avocado LTS (Long Term Stability) disabled Avocao了解更多的LTS信息，参考 Avocado Long Term Stability 接下来，可以进行avocado安装啦： sudo dnf install avocado 另外还有两个包需要安装： avocado-examples: 包含测试例子和示例文件 avocado-plugins-output-html: HTML job 报告的插件 RHEL7 如果要运行在红帽商业版或CentOS上，需要进行下面设置： # If not already, enable epel (for RHEL7 it's following cmd) sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm # Add avocado repository and install avocado sudo curl https://repos-avocadoproject.rhcloud.com/static/avocado-el.repo -o /etc/yum.repos.d/avocado.repo sudo yum install avocado 同fedora一样，需要安装以下包： avocado-examples: 包含测试例子和示例文件 avocado-plugins-output-html: HTML job 报告的插件 OpenSUSE Avocado同样支持，执行运行以下命令即可： sudo zypper install avocado 1.2 源码安装 首先确保系统有基本的编译环境，如fedora： sudo yum install -y git gcc python-devel python-pip libvirt-devel libyaml-devel redhat-rpm-config xz-devel 然后，获取源码： git clone git://github.com/avocado-framework/avocado.git cd avocado sudo make requirements sudo python setup.py install 注意，python和pip需要2.7.x版本。如果安装出现问题，需要指明python2.7 和 pip2.7. Avocodo可能需要一些插件： cd optional_plugins/html sudo python setup.py install 安装python依赖工具 avocado可以通过pip安装。 pip install avocado-framework 注意：只有基本的avocado基本的test runner安装，导入插件时可能会失败，需要根据不同的系统安装不同的依赖。 如果想安装全部插件，需要执行以下命令： pip install -r https://raw.githubusercontent.com/avocado-framework/avocado/master/requirements.txt 2. Avocado使用 首先 要使用命令行工具test runner,用来运行你的测试和收集测试结果。 2.1 运行测试 可以运行avocado加 run子命令，后面跟一个测试，例如： $ avocado run /bin/true JOB ID : 381b849a62784228d2fd208d929cc49f310412dc JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.39-381b849a/job.log TESTS : 1 ( 1/1 ) /bin/true: PASS ( 0.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.01 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.39-381b849a/html/results.html 可以看到，我们把/bin/true作为一个测试运行，并记录了测试过程。这是一个简单的例子，这是支持测试的一种类型。 Test Types 了解更多的测试类型。 注意： 尽管可以通过 avocao run \\(test1 $test3... 运行多个测试，但可以导致崩溃。一个安全的方式为： avocodo run --\\) argument1 --$argument2 -- $test1 $test2. 后面所有内容都会当做位置参数。 2.2 列出测试项 有两种方式覆盖这些测试。可以通过--dry-run 参数模拟： avocado run / bin/true -- dry-run JOB ID : 0000000000000000000000000000000000000000 JOB LOG : / tmp/avocado-dry-runSeWniM/job-2015-10-16T15 . 46 - 0000000 / job . log TESTS : 1 ( 1 / 1 ) / bin/true : SKIP RESULTS : PASS 0 | ERROR 0 | FAIL 0 | SKIP 1 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.00 s JOB HTML : / tmp/avocado-dry-runSeWniM/job-2015-10-16T15 . 46 - 0000000 / html/results . html 另一个方式是使用list参数列出支持的测试参数。如： $ avocado list INSTRUMENTED /usr/share/avocado/tests/abort.py INSTRUMENTED /usr/share/avocado/tests/datadir.py INSTRUMENTED /usr/share/avocado/tests/doublefail.py INSTRUMENTED /usr/share/avocado/tests/doublefree.py INSTRUMENTED /usr/share/avocado/tests/errortest.py INSTRUMENTED /usr/share/avocado/tests/failtest.py INSTRUMENTED /usr/share/avocado/tests/fiotest.py INSTRUMENTED /usr/share/avocado/tests/gdbtest.py INSTRUMENTED /usr/share/avocado/tests/gendata.py INSTRUMENTED /usr/share/avocado/tests/linuxbuild.py INSTRUMENTED /usr/share/avocado/tests/multiplextest.py INSTRUMENTED /usr/share/avocado/tests/passtest.py INSTRUMENTED /usr/share/avocado/tests/sleeptenmin.py INSTRUMENTED /usr/share/avocado/tests/sleeptest.py INSTRUMENTED /usr/share/avocado/tests/synctest.py INSTRUMENTED /usr/share/avocado/tests/timeouttest.py INSTRUMENTED /usr/share/avocado/tests/trinity.py INSTRUMENTED /usr/share/avocado/tests/warntest.py INSTRUMENTED /usr/share/avocado/tests/whiteboard.py ... 这些测试文件被Avocodo视为包含在INSTRUMENTED测试。 我们可以只列出可执行shell脚本： $ avocado list | grep &#94;SIMPLE SIMPLE /usr/share/avocado/tests/env_variables.sh SIMPLE /usr/share/avocado/tests/output_check.sh SIMPLE /usr/share/avocado/tests/simplewarning.sh SIMPLE /usr/share/avocado/tests/failtest.sh SIMPLE /usr/share/avocado/tests/passtest.sh 如前面说的那样，SIMPLE表示这些文件是一些简单的可执行的测试。 可以通过--verbose 或 -V,列出avocado中不是测试的文件。 $ avocado list examples/gdb-prerun-scripts/ -V Type file NOT_A_TEST examples/gdb-prerun-scripts/README NOT_A_TEST examples/gdb-prerun-scripts/pass-sigusr1 SIMPLE: 0 INSTRUMENTED: 0 MISSING: 0 NOT_A_TEST: 2 3.编写一个简单的测试 下面是一个 simple 测试的简单示例： $ echo '#!/bin/bash' > /tmp/simple_test.sh $ echo 'exit 0 ' >> /tmp/simple_test.sh $ chmod +x /tmp/simple_test.sh 注意，我们给这个文件增加了执行权限，它会被avocado当做一个simple test. 4.运行一个较复杂的测试 你 可以以任意顺序执行任意数量的测试，而且可以混合不同类型的测试： $ avocado run failtest.py sleeptest.py synctest.py failtest.py synctest.py /tmp/simple_test.sh JOB ID : 86911e49b5f2c36caeea41307cee4fecdcdfa121 JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.42-86911e49/job.log TESTS : 6 ( 1/6 ) failtest.py:FailTest.test: FAIL ( 0.00 s ) ( 2/6 ) sleeptest.py:SleepTest.test: PASS ( 1.00 s ) ( 3/6 ) synctest.py:SyncTest.test: PASS ( 2.43 s ) ( 4/6 ) failtest.py:FailTest.test: FAIL ( 0.00 s ) ( 5/6 ) synctest.py:SyncTest.test: PASS ( 2.44 s ) ( 6/6 ) /bin/true: PASS ( 0.00 s ) ( 6/6 ) /tmp/simple_test.sh.1: PASS ( 0.02 s ) RESULTS : PASS 2 | ERROR 2 | FAIL 2 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 5.88 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.42-86911e49/html/results.html 5.出现fail后中断测试 Avocado run 命令包含 --failfast on 参数，当出现错误是会退出测试： $ avocado run --failfast on /bin/true /bin/false /bin/true /bin/true JOB ID : eaf51b8c7d6be966bdf5562c9611b1ec2db3f68a JOB LOG : $HOME /avocado/job-results/job-2016-07-19T09.43-eaf51b8/job.log TESTS : 4 ( 1/4 ) /bin/true: PASS ( 0.01 s ) ( 2/4 ) /bin/false: FAIL ( 0.01 s ) Interrupting job ( failfast ) . RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 2 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.02 s JOB HTML : /home/apahim/avocado/job-results/job-2016-07-19T09.43-eaf51b8/html/results.html 6.通过外部Runner 运行测试 大 部软件都存在自己的测试集。通常包括一个定制的runner,它可以找到并运行自己的测试。 Avocado能支持运行这些测试，而且可以支持生成不同格式的结果，收集系统信息以及这些测试（Avocado的sysinfo功能）等等。 大部分方式如下： $ avocado run --external -runner=/path/to/external_runner foo bar baz 这个例子，avocado会产生foo bar baz的测试结果。实际结果将来源于执行 /path/to/external_runner foo /path/to/external_runner bar和/path/to/external_runner baz 另一种方式展示这一特性，就是思考\"外部runner\"可以是解释器和可以解释执行任何测试。UNIXshell,/bin/sh就可以被当做外部执行引擎，而且shell脚本就可以当成它的测试： $ echo \"exit 0\" > /tmp/pass $ echo \"exit 1\" > /tmp/fail $ avocado run --external-runner = /bin/sh /tmp/pass /tmp/fail JOB ID : 4a2a1d259690cc7b226e33facdde4f628ab30741 JOB LOG : /home/<user>/avocado/job-results/job-<date>-<shortid>/job.log TESTS : 2 ( 1/2 ) /tmp/pass: PASS ( 0.01 s ) ( 2/2 ) /tmp/fail: FAIL ( 0.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.01 s JOB HTML : /home/<user>/avocado/job-results/job-<date>-<shortid>/html/results.html 这个例子很明显，可以通过给/tmp/pass和/tmp/fail ，shell\"shebangs\"（＃！/ bin / sh）来实现，使它们可执行（chmod + x / tmp / pass / tmp / ，并将其作为\"简单\"测试运行。 下面看另一个例子： $ avocado run --external-runner = /bin/curl http://local-avocado-server:9405/jobs/ \\ http://remote-avocado-server:9405/jobs/ JOB ID : 56016a1ffffaba02492fdbd5662ac0b958f51e11 JOB LOG : /home/<user>/avocado/job-results/job-<date>-<shortid>/job.log TESTS : 2 ( 1/2 ) http://local-avocado-server:9405/jobs/: PASS ( 0.02 s ) ( 2/2 ) http://remote-avocado-server:9405/jobs/: FAIL ( 3.02 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 3.04 s JOB HTML : /home/<user>/avocado/job-results/job-<date>-<shortid>/html/results.html 这个例子是把\"/bin/curl\"当做\"external test runner\". 7. 测试调试 当 开发一个新的测试时，经常做的就是查看一个测试job的运行日志。 为了实现这个目的， 可以通过 avocado --show test run ... 或 avocado run --show-job-log ... 例如： $ avocado --show test run examples/tests/sleeptest.py ... Job ID: f9ea1742134e5352dec82335af584d1f151d4b85 START 1-sleeptest.py:SleepTest.test PARAMS (key=timeout, path=*, default=None) => None PARAMS (key=sleep_length, path=*, default=1) => 1 Sleeping for 1.00 seconds PASS 1-sleeptest.py:SleepTest.test Test results available in $ HOME /avocado/job-results/job-2015-06-02T10.45-f9ea174 UI输出被抑制，只显示作业日志，这使得它成为测试开发和调试的有用功能。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"自动化测试-Avocado","title":"Avocado-入门"},{"url":"http://king32783784.github.io/2016/08/11/Docker/","text":"时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New \"Old Stuff\"。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。 当然，文章的风格一定会尊重时下的\"流行\"——我们再也没有整块整块的时间去看书去专研，而我们只有看微博微信那样的碎片时间（那怕我们有整块的时间，也被那些在手机上的APP碎片化了）。所以，这些文章的风格必然坚持\"马桶风格\"（希望简单到占用你拉一泡屎就时间，而且你还不用动脑子，并能学到些东西） 废话少说，我们开始。先从Linux Namespace开始。 简介 Linux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。 举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程 看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID namespace中的进程无法看到彼此） Linux Namespace 有如下种类，官方文档在这里 《Namespace in Operation》 分类 系统调用参数 相关内核版本 Mount namespaces CLONE_NEWNS Linux 2.4.19 UTS namespaces CLONE_NEWUTS Linux 2.6.19 IPC namespaces CLONE_NEWIPC Linux 2.6.19 PID namespaces CLONE_NEWPID Linux 2.6.24 Network namespaces CLONE_NEWNET 始于Linux 2.6.24 完成于 Linux 2.6.29 User namespaces CLONE_NEWUSER 始于 Linux 2.6.23 完成于 Linux 3.8 主要是三个系统调用 clone() – 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。 unshare() – 使某进程脱离某个namespace setns() – 把某进程加入到某个namespace unshare() 和 setns() 都比较简单，大家可以自己man，我这里不说了。 下面还是让我们来看一些示例（以下的测试程序最好在Linux 内核为3.8以上的版本中运行，我用的是ubuntu 14.04）。 clone()系统调用 首先，我们来看一下一个最简单的clone()系统调用的示例，（后面，我们的程序都会基于这个程序做修改）： ```c #define _GNU_SOURCE #include #include #include #include #include #include /* 定义一个给 clone 用的栈，栈大小1M */ # define STACK_SIZE ( 1024 * 1024 ) static char container_stack [ STACK_SIZE ]; char * const container_args [] = { \"/bin/bash\" , NULL }; int container_main ( void * arg ) { printf ( \"Container - inside the container!\\n\" ) ; /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */ execv ( container_args [ 0 ] , container_args ) ; printf ( \"Something's wrong!\\n\" ) ; return 1 ; } int main () { printf ( \"Parent - start a container!\\n\" ) ; /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针， 因为栈是反着的） */ int container_pid = clone ( container_main , container_stack + STACK_SIZE , SIGCHLD , NULL ) ; /* 等待子进程结束 */ waitpid ( container_pid , NULL , 0 ) ; printf ( \"Parent - container stopped!\\n\" ) ; return 0 ; } 从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。 下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。 #### UTS Namespace 下面的代码，我略去了上面那些头文件和数据结构的定义，只有最重要的部分。 ```c int container_main(void* arg) { printf(\"Container - inside the container!\\n\"); sethostname(\"container\",10); /* 设置hostname */ execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent - start a container!\\n\"); int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */ waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container。 hchen@ubuntu:~$ sudo ./uts Parent - start a container! Container - inside the container! root@container:~# hostname container root@container:~# uname -n container IPC Namespace IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。 要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了。 int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL); 首先，我们先创建一个IPC的Queue（如下所示，全局的Queue ID是0） hchen@ubuntu:~$ ipcmk -Q Message queue id: 0 hchen@ubuntu:~$ ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 0xd0d56eb2 0 hchen 644 0 0 如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC Queue。 hchen@ubuntu:~$ sudo ./uts Parent - start a container! Container - inside the container! root@container:~# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 0xd0d56eb2 0 hchen 644 0 0 但是，如果我们运行加上了CLONE_NEWIPC的程序，我们就会下面的结果： root@ubuntu:~$ sudo./ipc Parent - start a container! Container - inside the container! root@container:~/linux_namespace# ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 我们可以看到IPC已经被隔离了。 PID Namespace 我们继续修改上面的程序： int container_main(void* arg) { /* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */ printf(\"Container [%5d] - inside the container!\\n\", getpid()); sethostname(\"container\",10); execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent [%5d] - start a container!\\n\", getpid()); /*启用PID namespace - CLONE_NEWPID*/ int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, NULL); waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 运行结果如下（我们可以看到，子进程的pid是1了）： hchen@ubuntu:~$ sudo ./pid Parent [ 3474] - start a container! Container [ 1] - inside the container! root@container:~# echo $$ 1 你可能会问，PID为1有个毛用啊？我们知道，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。 但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。 所以，我们还需要对文件系统进行隔离。 Mount Namespace 下面的例程中，我们在启用了mount namespace并在子进程中重新mount了/proc文件系统。 int container_main(void* arg) { printf(\"Container [%5d] - inside the container!\\n\", getpid()); sethostname(\"container\",10); /* 重新mount proc文件系统到 /proc下 */ system(\"mount -t proc proc /proc\"); execv(container_args[0], container_args); printf(\"Something's wrong!\\n\"); return 1; } int main() { printf(\"Parent [%5d] - start a container!\\n\", getpid()); /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */ int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL); waitpid(container_pid, NULL, 0); printf(\"Parent - container stopped!\\n\"); return 0; } 运行结果如下： hchen@ubuntu:~$ sudo ./pid.mnt Parent [ 3502] - start a container! Container [ 1] - inside the container! root@container:~# ps -elf F S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD 4 S root 1 0 0 80 0 - 6917 wait 19:55 pts/2 00:00:00 /bin/bash 0 R root 14 1 0 80 0 - 5671 - 19:56 pts/2 00:00:00 ps -elf 上面，我们可以看到只有两个进程 ，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多： root@container:~# ls /proc 1 dma key-users net sysvipc 16 driver kmsg pagetypeinfo timer_list acpi execdomains kpagecount partitions timer_stats asound fb kpageflags sched_debug tty buddyinfo filesystems loadavg schedstat uptime bus fs locks scsi version cgroups interrupts mdstat self version_signature cmdline iomem meminfo slabinfo vmallocinfo consoles ioports misc softirqs vmstat cpuinfo irq modules stat zoneinfo crypto kallsyms mounts swaps devices kcore mpt sys diskstats keys mtrr sysrq-trigger 这里，多说一下。在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。 你可能会问，我们是不是还有别的一些文件系统也需要这样mount? 是的。 Docker的 Mount Namespace 下面我将向演示一个\"山寨镜像\"，其模仿了Docker的Mount Namespace。 首先，我们需要一个rootfs，也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录： hchen@ubuntu:~/rootfs$ ls bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var 然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ） hchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin ./bin: bash chown gzip less mount netstat rm tabs tee top tty cat cp hostname ln mountpoint ping sed tac test touch umount chgrp echo ip ls mv ps sh tail timeout tr uname chmod grep kill more nc pwd sleep tar toe truncate which ./usr/bin: awk env groups head id mesg sort strace tail top uniq vi wc xargs 注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录： hchen@ubuntu:~/rootfs/bin$ ldd bash linux-vdso.so.1 => (0x00007fffd33fc000) libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000) libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000) /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000) 下面是我的rootfs中的一些so文件： hchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/ ./lib64: ld-linux-x86-64.so.2 ./lib/x86_64-linux-gnu/: libacl.so.1 libmemusage.so libnss_files-2.19.so libpython3.4m.so.1 libacl.so.1.1.0 libmount.so.1 libnss_files.so.2 libpython3.4m.so.1.0 libattr.so.1 libmount.so.1.1.0 libnss_hesiod-2.19.so libresolv-2.19.so libblkid.so.1 libm.so.6 libnss_hesiod.so.2 libresolv.so.2 libc-2.19.so libncurses.so.5 libnss_nis-2.19.so libselinux.so.1 libcap.a libncurses.so.5.9 libnss_nisplus-2.19.so libtinfo.so.5 libcap.so libncursesw.so.5 libnss_nisplus.so.2 libtinfo.so.5.9 libcap.so.2 libncursesw.so.5.9 libnss_nis.so.2 libutil-2.19.so libcap.so.2.24 libnsl-2.19.so libpcre.so.3 libutil.so.1 libc.so.6 libnsl.so.1 libprocps.so.3 libuuid.so.1 libdl-2.19.so libnss_compat-2.19.so libpthread-2.19.so libz.so.1 libdl.so.2 libnss_compat.so.2 libpthread.so.0 libgpm.so.2 libnss_dns-2.19.so libpython2.7.so.1 libm-2.19.so libnss_dns.so.2 libpython2.7.so.1.0 包括这些命令依赖的一些配置文件： hchen@ubuntu:~/rootfs$ ls ./etc bash.bashrc group hostname hosts ld.so.cache nsswitch.conf passwd profile resolv.conf shadow 你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中。 hchen@ubuntu:~$ ls ./conf hostname hosts resolv.conf 这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。 好了，终于到了我们的程序。 #define _GNU_SOURCE #include <sys/types.h> #include <sys/wait.h> #include <sys/mount.h> #include <stdio.h> #include <sched.h> #include <signal.h> #include <unistd.h> #define STACK_SIZE (1024 * 1024) static char container_stack [ STACK_SIZE ]; char * const container_args [] = { \"/bin/bash\" , \"-l\" , NULL }; int container_main ( void * arg ) { printf ( \"Container [%5d] - inside the container! \\n \" , getpid ()); //set hostname sethostname ( \"container\" , 10 ); //remount \"/proc\" to make sure the \"top\" and \"ps\" show container's information if ( mount ( \"proc\" , \"rootfs/proc\" , \"proc\" , 0 , NULL ) != 0 ) { perror ( \"proc\" ); } if ( mount ( \"sysfs\" , \"rootfs/sys\" , \"sysfs\" , 0 , NULL ) != 0 ) { perror ( \"sys\" ); } if ( mount ( \"none\" , \"rootfs/tmp\" , \"tmpfs\" , 0 , NULL ) != 0 ) { perror ( \"tmp\" ); } if ( mount ( \"udev\" , \"rootfs/dev\" , \"devtmpfs\" , 0 , NULL ) != 0 ) { perror ( \"dev\" ); } if ( mount ( \"devpts\" , \"rootfs/dev/pts\" , \"devpts\" , 0 , NULL ) != 0 ) { perror ( \"dev/pts\" ); } if ( mount ( \"shm\" , \"rootfs/dev/shm\" , \"tmpfs\" , 0 , NULL ) != 0 ) { perror ( \"dev/shm\" ); } if ( mount ( \"tmpfs\" , \"rootfs/run\" , \"tmpfs\" , 0 , NULL ) != 0 ) { perror ( \"run\" ); } /* * 模仿Docker的从外向容器里mount相关的配置文件 * 你可以查看：/var/lib/docker/containers/<container_id>/目录， * 你会看到docker的这些文件的。 */ if ( mount ( \"conf/hosts\" , \"rootfs/etc/hosts\" , \"none\" , MS_BIND , NULL ) != 0 || mount ( \"conf/hostname\" , \"rootfs/etc/hostname\" , \"none\" , MS_BIND , NULL ) != 0 || mount ( \"conf/resolv.conf\" , \"rootfs/etc/resolv.conf\" , \"none\" , MS_BIND , NULL ) != 0 ) { perror ( \"conf\" ); } /* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */ if ( mount ( \"/tmp/t1\" , \"rootfs/mnt\" , \"none\" , MS_BIND , NULL ) != 0 ) { perror ( \"mnt\" ); } /* chroot 隔离目录 */ if ( chdir ( \"./rootfs\" ) != 0 || chroot ( \"./\" ) != 0 ){ perror ( \"chdir/chroot\" ); } execv ( container_args [ 0 ], container_args ); perror ( \"exec\" ); printf ( \"Something's wrong! \\n \" ); return 1 ; } int main () { printf ( \"Parent [%5d] - start a container! \\n \" , getpid ()); int container_pid = clone ( container_main , container_stack + STACK_SIZE , CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD , NULL ); waitpid ( container_pid , NULL , 0 ); printf ( \"Parent - container stopped! \\n \" ); return 0 ; } sudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的\"镜像\"： hchen@ubuntu:~$ sudo ./mount Parent [ 4517] - start a container! Container [ 1] - inside the container! root@container:/# mount proc on /proc type proc (rw,relatime) sysfs on /sys type sysfs (rw,relatime) none on /tmp type tmpfs (rw,relatime) udev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755) devpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000) tmpfs on /run type tmpfs (rw,relatime) /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered) /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered) /dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered) root@container:/# ls /bin /usr/bin /bin: bash chmod echo hostname less more mv ping rm sleep tail test top truncate uname cat chown grep ip ln mount nc ps sed tabs tar timeout touch tty which chgrp cp gzip kill ls mountpoint netstat pwd sh tac tee toe tr umount /usr/bin: awk env groups head id mesg sort strace tail top uniq vi wc xargs 关于如何做一个chroot的目录，这里有个工具叫 DebootstrapChroot ，你可以顺着链接去看看（英文的哦） 接下来的事情，你可以自己玩了，我相信你的想像力 。：） 在下一篇，我将向你介绍User Namespace、Network Namespace以及Namespace的其它东西。 Docker基础技术：Linux Namespace（下)>>> （上篇完，请参看下篇）","tags":"Docker专题","title":"Docker基础技术：Linux Namespace（上）<转>"},{"url":"http://king32783784.github.io/2016/08/12/Docker/","text":"在 Docker基础技术：Linux Namespace（上篇) 中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。 好，下面我们就介绍一下还剩下的这两个Namespace。 User Namespace User Namespace 主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。 要把容器中的uid和真实系统的uid给映射在一起，需要修改 /proc/ /uid_map 和 /proc/ /gid_map 这两个文件。这两个文件的格式为： ID-inside-ns ID-outside-ns length 其中： 第一个字段ID-inside-ns表示在容器显示的UID或GID， 第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。 第三个字段表示映射的范围，一般填1，表示一一对应。 比如，把真实的uid=1000映射成容器内的uid=0 $ cat /proc/2465/uid_map 0 1000 1 再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形 $ cat /proc/ $$ /uid_map 0 0 4294967295 另外，需要注意的是： 写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看Capabilities） 写入的进程必须是此user namespace的父或子的user namespace进程。 另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。 这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂): code: #define _GNU_SOURCE #include <stdio.h> #include <stdlib.h> #include <sys/types.h> #include <sys/wait.h> #include <sys/mount.h> #include <sys/capability.h> #include <stdio.h> #include <sched.h> #include <signal.h> #include <unistd.h> #define STACK_SIZE (1024 * 1024) static char container_stack [ STACK_SIZE ]; char * const container_args [] = { \"/bin/bash\" , NULL }; int pipefd [ 2 ]; void set_map ( char * file , int inside_id , int outside_id , int len ) { FILE * mapfd = fopen ( file , \"w\" ); if ( NULL == mapfd ) { perror ( \"open file error\" ); return ; } fprintf ( mapfd , \"%d %d %d\" , inside_id , outside_id , len ); fclose ( mapfd ); } void set_uid_map ( pid_t pid , int inside_id , int outside_id , int len ) { char file [ 256 ]; sprintf ( file , \"/proc/%d/uid_map\" , pid ); set_map ( file , inside_id , outside_id , len ); } void set_gid_map ( pid_t pid , int inside_id , int outside_id , int len ) { char file [ 256 ]; sprintf ( file , \"/proc/%d/gid_map\" , pid ); set_map ( file , inside_id , outside_id , len ); } int container_main ( void * arg ) { printf ( \"Container [%5d] - inside the container! \\n \" , getpid ()); printf ( \"Container: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld \\n \" , ( long ) geteuid (), ( long ) getegid (), ( long ) getuid (), ( long ) getgid ()); /* 等待父进程通知后再往下执行（进程间的同步） */ char ch ; close ( pipefd [ 1 ]); read ( pipefd [ 0 ], & ch , 1 ); printf ( \"Container [%5d] - setup hostname! \\n \" , getpid ()); //set hostname sethostname ( \"container\" , 10 ); //remount \"/proc\" to make sure the \"top\" and \"ps\" show container's information mount ( \"proc\" , \"/proc\" , \"proc\" , 0 , NULL ); execv ( container_args [ 0 ], container_args ); printf ( \"Something's wrong! \\n \" ); return 1 ; } int main () { const int gid = getgid (), uid = getuid (); printf ( \"Parent: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld \\n \" , ( long ) geteuid (), ( long ) getegid (), ( long ) getuid (), ( long ) getgid ()); pipe ( pipefd ); printf ( \"Parent [%5d] - start a container! \\n \" , getpid ()); int container_pid = clone ( container_main , container_stack + STACK_SIZE , CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD , NULL ); printf ( \"Parent [%5d] - Container [%5d]! \\n \" , getpid (), container_pid ); //To map the uid/gid, // we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent //The file format is // ID-inside-ns ID-outside-ns length //if no mapping, // the uid will be taken from /proc/sys/kernel/overflowuid // the gid will be taken from /proc/sys/kernel/overflowgid set_uid_map ( container_pid , 0 , uid , 1 ); set_gid_map ( container_pid , 0 , gid , 1 ); printf ( \"Parent [%5d] - user/group mapping done! \\n \" , getpid ()); /* 通知子进程 */ close ( pipefd [ 1 ]); waitpid ( container_pid , NULL , 0 ); printf ( \"Parent - container stopped! \\n \" ); return 0 ; } 上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。 整个程序的运行效果如下： hchen@ubuntu:~ \\( id uid=1000(hchen) gid=1000(hchen) groups=1000(hchen) hchen@ubuntu:~\\) ./user #<--以hchen用户运行 Parent: eUID = 1000; eGID = 1000, UID=1000, GID=1000 Parent [ 3262] - start a container! Parent [ 3262] - Container [ 3263]! Parent [ 3262] - user/group mapping done! Container [ 1] - inside the container! Container: eUID = 0; eGID = 0, UID=0, GID=0 #<---Container里的UID/GID都为0了 Container [ 1] - setup hostname! root@container:~# id #<----我们可以看到容器里的用户和命令行提示符是root用户了 uid=0(root) gid=0(root) groups=0(root),65534(nogroup) 虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，我们容器的安全性会得到提高。 我们注意到，User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。 Network Namespace Network的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些\"奇怪\"的数据，呵呵）。这里，我还是用ip命令讲解一下。 首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的\"物理网卡\"其实也就是一个有可以路由的IP的网卡） 上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。 当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）： hchen@ubuntu:~$ ip link show 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state ... link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc ... link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff 3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 ... link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff 5: veth22a38e6: <BROADCAST,UP,LOWER_UP> mtu 1500 qdisc ... link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff 那么，要做成这个样子应该怎么办呢？我们来看一组命令： ## 首先，我们先增加一个网桥lxcbr0，模仿docker0 brctl addbr lxcbr0 brctl stp lxcbr0 off ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址 ## 接下来，我们要创建一个network namespace - ns1 # 增加一个namesapce 命令为 ns1 （使用ip netns add命令） ip netns add ns1 # 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令） ip netns exec ns1 ip link set dev lo up ## 然后，我们需要增加一对虚拟网卡 # 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中 ip link add veth-ns1 type veth peer name lxcbr0.1 # 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了 ip link set veth-ns1 netns ns1 # 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了） ip netns exec ns1 ip link set dev veth-ns1 name eth0 # 为容器中的网卡分配一个IP地址，并激活它 ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up # 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上 brctl addif lxcbr0 lxcbr0.1 # 为容器增加一个路由规则，让容器可以访问外面的网络 ip netns exec ns1 ip route add default via 192.168.10.1 # 在/etc/netns下创建network namespce名称为ns1的目录， # 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了 mkdir -p /etc/netns/ns1 echo \"nameserver 8.8.8.8\" > /etc/netns/ns1/resolv.conf 上面基本上就是docker网络的原理了，只不过， Docker的resolv.conf没有用这样的方式，而是用了上篇中的Mount Namesapce的那种方式 另外，docker是用进程的PID来做Network Namespace的名称的。 了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡： ip link add peerA type veth peer name peerB brctl addif docker0 peerA ip link set peerA up ip link set peerB netns ${ container - pid } ip netns exec ${ container - pid } ip link set dev peerB name eth1 ip netns exec ${ container - pid } ip link set eth1 up ; ip netns exec ${ container - pid } ip addr add ${ ROUTEABLE_IP } dev eth1 ; 上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。 这个需要把外部的\"物理网卡\"配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到\"物理网卡\"上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。 当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。 这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个IPVLAN的驱动，这基本上就是为Docker量身定制的。 Namespace文件 上面就是目前Linux Namespace的玩法。 现在，我来看一下其它的相关东西。 让我们运行一下上篇中的那个pid.mnt的程序（也就是PID Namespace中那个mount proc的程序），然后不要退出。 $ sudo ./pid.mnt [ sudo ] password for hchen: Parent [ 4599 ] - start a container! Container [ 1 ] - inside the container! 我们到另一个shell中查看一下父子进程的PID： hchen@ubuntu:~$ pstree -p 4599 pid.mnt(4599)───bash(4600) 我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上）。 下面是父进程的： hchen@ubuntu:~$ sudo ls -l /proc/4599/ns total 0 lrwxrwxrwx 1 root root 0 4月 7 22:01 ipc -> ipc:[4026531839] lrwxrwxrwx 1 root root 0 4月 7 22:01 mnt -> mnt:[4026531840] lrwxrwxrwx 1 root root 0 4月 7 22:01 net -> net:[4026531956] lrwxrwxrwx 1 root root 0 4月 7 22:01 pid -> pid:[4026531836] lrwxrwxrwx 1 root root 0 4月 7 22:01 user -> user:[4026531837] lrwxrwxrwx 1 root root 0 4月 7 22:01 uts -> uts:[4026531838] 下面是子进程的： hchen@ubuntu:~$ sudo ls -l /proc/4600/ns total 0 lrwxrwxrwx 1 root root 0 4月 7 22:01 ipc -> ipc:[4026531839] lrwxrwxrwx 1 root root 0 4月 7 22:01 mnt -> mnt:[4026532520] lrwxrwxrwx 1 root root 0 4月 7 22:01 net -> net:[4026531956] lrwxrwxrwx 1 root root 0 4月 7 22:01 pid -> pid:[4026532522] lrwxrwxrwx 1 root root 0 4月 7 22:01 user -> user:[4026531837] lrwxrwxrwx 1 root root 0 4月 7 22:01 uts -> uts:[4026532521] 我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。 这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount –bind /proc/4600/ns/uts ~/uts 来hold这个namespace。 另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下： int setns(int fd, int nstype); 其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如： fd = open(\"/proc/4600/ns/nts\", O_RDONLY); // 获取namespace文件描述符 setns(fd, 0); // 加入新的namespace 参考文档 Namespaces in operation Linux Namespace Man Page Creat Containers – Part 1 Introduction to Linux namespaces （全文完） if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Docker专题","title":"Docker基础技术：Linux Namespace（下）<转>"},{"url":"http://king32783784.github.io/2016/06/03/LTP/","text":"file file 用例主要用于测试file命令。 file命令介绍 file命令可以通过查看文件内容来找出特定类型的文件，在UNIX/ Linux系统中，文件类型并不是由文件扩展名来决定的(windows中却正是这么做的),file命令的目的是从多个文件中收集文件类型统计信息。 file --help Usage: file [OPTION...] [FILE...] Determine type of FILEs. --help display this help and exit -v, --version output version information and exit -m, --magic-file LIST use LIST as a colon-separated list of magic number files -z, --uncompress try to look inside compressed files -Z, --uncompress-noreport only print the contents of compressed files -b, --brief do not prepend filenames to output lines -c, --checking-printout print the parsed form of the magic file, use in conjunction with -m to debug a new magic file before installing it -e, --exclude TEST exclude TEST from the list of test to be performed for file. Valid tests are: apptype, ascii, cdf, compress, elf, encoding, soft, tar, text, tokens -f, --files-from FILE read the filenames to be examined from FILE -F, --separator STRING use string as separator instead of `:' -i, --mime output MIME type strings (--mime-type and --mime-encoding) --apple output the Apple CREATOR/TYPE --extension output a slash-separated list of extnsions --mime-type output the MIME type --mime-encoding output the MIME encoding -k, --keep-going don't stop at the first match -l, --list list magic strength -L, --dereference follow symlinks (default) -h, --no-dereference don't follow symlinks -n, --no-buffer do not buffer output -N, --no-pad do not pad output -0, --print0 terminate filenames with ASCII NUL -p, --preserve-date preserve access times on files -P, --parameter set file engine parameter limits indir 15 recursion limit for indirection name 30 use limit for name/use magic elf_notes 256 max ELF notes processed elf_phnum 128 max ELF prog sections processed elf_shnum 32768 max ELF sections processed -r, --raw don't translate unprintable chars to \\ooo -s, --special-files treat special (block/char devices) files as ordinary ones -C, --compile compile file specified by -m -d, --debug print debugging messages 必要参数 -b 文件名不显示 -c 显示详细处理信息 -L 操作对象为符号链接所指向的对象 -z 压缩文件的处理 -C 列出magic.mgc的输出 -n 将结果输出到标准输出 -f<文件名> 指定文件名 -m<文件名> 指定魔法数字名 选择参数 --help 显示帮助信息 -v 显示版本信息 实例： 1.查看所有文件类型 file * 2.2.查看具体某一文件的类型：file filename 3.-b参数，打印出不包含文件名的文件类型信息: 4.-z 参数，可以获取用gzip、zip压缩过的文件的类型 5.-n参数，将信息标准输出 言归正传，file_test.sh 脚本主要验证是否支持多种文件格式，比如tar tar.gz rpm c ascii elf等。 用例设置： Test01：测试文件命令是否识别ASCII文本文件 1）将文本写入已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.txt 3）grep为关键字\"ASCII文本\"的输出 'file'命令 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test02：测试文件命令是否能识别bash shell脚本 1）将一个小shell脚本写入一个已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.sh 3）从'file'命令的输出中Grep关键字\"Bourne-Again shell脚本\" 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test03：测试文件命令是否能识别bash shell脚本 使用Korn shell脚本执行类似的测试（如Test02） Test04：测试文件命令是否可以识别C shell脚本 使用C shell脚本执行类似的测试（如Test02） Test05：测试文件命令是否可以识别C程序文本 使用test2类似方法测试c程序文本 Test06：测试文件命令是否可以识别ELF二进制可执行文件 1）使用readelf确定主机是大端还是小端,并分别为字符串\"MSB\"或\"LSB\"分配TEST_ARCH 2）将小C程序写入已知的\".c\"文件 3）使用\"cc\" Ex：cc xyz xyz.c 4）使用file命令获取对象文件的类型 5）在file输出中，grep ELF .*-bit $ TEST_ARCH executable, .* 字符。 6）如果上述命令成功，则将测试声明为PASS Test07：测试文件命令是否可以识别tar文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar 4）grep从上面的'file'命令的输出的中匹配字符串\"tar\" 5）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL Test08：测试文件命令是否可以tar zip文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用'gzip'命令来压缩tar文件 例如：gzip -f xyz.tar 4）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar.gz 5）grep从上面的文件commnand字符串\"gzip压缩数据，。*\" 6）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL 代码片段 测试file命令能识别出ASCII文本文件。 export TCID=file01 export TST_COUNT=1 $ LTPBIN /tst_resm TINFO \"TEST # 1:file command recogizes ASCII text files\" # log信息 cat > $ LTPTMP /test_file.txt <<EOF this is a text file to test file command EOF # 制作txt文本文件 ## 执行file命令并检查输出。 file $ LTPTMP /test_file.txt > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] # 判断返回值是否为０，验证file命令执行是否成功 then grep -q \"ASCII text\" $ LTPTMP /file.out # 匹配输出类型是否整齐 if [ $ ? -eq 0 ] then $ LTPBIN /test_resm TPASS \"file: Recognised ASCII file correctly\" rm -f $ LTPTMP /test_file.txt else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise ASCII file correctlyi. Reason:\" TFAILCNT= $(( $ TFAILCNT + 1 )) # error code＋１ fi else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: failed to recognize ASCII file correctly\\t\\t\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi TEST #2 测试是否识别shell脚本 export TCID=file02 export TST_COUNT=2 $ LTPBIN /tst_resm TINFO \"TEST # 2: file command recognizes bash shell scripts\" cat > $ LTPTMP /bash_script.sh <<EOF # ! /bin/bash echo \"this is a shell script\" echo \"used to test file command\" EOF file $ LTPTMP /bash_script.sh > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] then grep -q \"Bourne-Again shell script\" $ LTPTMP /file.out if [ $ ? -eq 0 ] then $ LTPBIN /tst_resm TPASS \"file: Recognised bash shell script correctly\" rm -f $ LTPTMP /bash_script.sh else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise bash shell script. Reason\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi else $ LTPBIN /tst_resm TFAIL \"file: Failed to recognize bash shell script\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi 其他测试代码同上面类似，不再一一分析。","tags":"自动化测试-LTP","title":"LTP－Command-file"},{"url":"http://king32783784.github.io/2016/06/01/LTP/","text":"该topic将深入分析ltp的测试内容，着重于具体每个case的测试内容及测试方法。通过对ltp case的分析，加强linux系统的理解和用例设计。本节主要整理ltp的包括测试case的类型和case列表。 整体情况 case主要分为\"commands\"、\"kdump\"、\"kernel\"、\"misc\"、\"network\"、\"open_posix_testsuite\"、\"realtime\"、\"lib\"等部分，主要内容如下： 分类 包含内容 commands ade cpio df eject gzip logrotate mail mkfs sshd tar unzip which at cron du fileutils insmod lsmod mkswap su tmp-tools wc kernel connectors controllers firmware hotplug input ipc logging mce-test module power_management sched syscalls tracing containers device-drivers fs include io lib mem numa pty security times misc crash f00f math network busy_poll dctcp iptables netstress nfsv4 rpc stress tcp_fstopen virt can dhcp iproute lib6 multicast nfs sockets tcp_cmds traceroute xinetd open_posix_testsuite functional tools bin conformance stress realtime perf profiles stress lib kdump commands 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which kernel 主要case包括: case 包含子case connectors connector pec containers libclone mountns mqns netns pidns share sysvipc userns utsname controllers cgroup cgroup_xattr cpuctl cpuset io-throttle memcg pids cgroup_fg cpuacct cpuctl_fj freezer libcontrollers memctl device-drivers acpi base cpufreq drm locking misc_modules pci tbio usb zram agp block dev_sim_framework nls rcu rtc uaccess v4l firmware fw_load_kernel fw_load_user fs acl dmapi ext4-new-features fs_blnd fs_inod fs_perms fsstress ftest iso9660 linktest mongo proc racer stram acls doio fs-bench fs_di fs_main fs_readonly fsx-linux inode lftest openfile quota_remount scsi hotplug cpu_hotplug memory_hotplug input input io aio direct_io disktest ltp-aiodio stress_cd stress_floppy writetest ipc pipeio semaphore logging kmsg mem cpuset mem mtest01 mtest06 oom shmt thp vma hugetlb ksm mmapstress mtest05 mtest07 page swapping tunable vmtests moudle create_module delete_module query_module numa numa power_management pm_ilb_test runpwtests01-06 runpwtests_exelusive01-06 pm_cpu_consolidation pm_include pm_sched_domain pty hangup ptem pty sched cfs-scheduler clisrv hypertherading nptl process_stress pthreads sched_stress tool security cap_bound filecaps integrity mmc_security prot_hsymlinks securbits smack tomoyo syscalls abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev timers clock_gettime clock_settime leapsec timer_create timer_delete timer_settime tracing ftrace misc case 包含子case crash crash f00f foof math abs atof float fptests nextafter network case 包含子case can filter-test dctcp dctcp dhcp dhcp_tests dhcp_lib dnsmasq_tests iproute ip_tests iptables iptables_tests lib6 asapi getaddrinfo in6 multicast mc_cmds mc_commo mc_gethost mc_member mc_opts netstress netstress nfs fsx-linux nfslock01 nfsstat01 nfs_stress nfsv4 acl locks rpc basic_tests rpc-tirpc sockets socket stress broken_ip dns ftp http icmp interface ipsec multicast ns-tools route ssh tcp udp tcp_cmds arping echo ftp netstat rcp rsh sendfile tcpdump trackpath clockdiff finger host ipneigh ping rdist rlogin rwho ssh telnet tcp_fastopen tcp_fastopen traceroute traceroute virt gre01 ipvlan macvlan macvtap vlan vxlan xinted xinted open_posix_testsuite case 包含子case bin run-all-posix-option-group-tests conformance behavior definitions interfaces functional mqueues semaphores threads timers stress mqueues semaphores signals threads timers realtime case 包含子case func async_handler hrtimer-prio matrix_mult periodic_cpu_load pi-tests prio-wake rt-migrate sched_jitter thrad_clock gtod_latency measurement pi_perf prio-preempt pthread_kill_latency sched_football sched_letency m4 m4 perf latency stress pi-tests 接下来会深入分析每个case的具体测试目的及内容。ltp测试用例主要采用shell和Ｃ编写。","tags":"自动化测试-LTP","title":"LTP－Case list"},{"url":"http://king32783784.github.io/2016/08/02/LTP/","text":"从本文开始，开始分析kernel部分的测试用例，该部分测试用例大部分为Ｃ语言编写，因此会穿插加入一定的Ｃ语言或unix环境编程的知识。 abort 设计说明 测试策略 Fork child. Child出现abort,检查返回状态 限制 Core file大小的限制必须大于０ abort 函数名: abort 功 能: 异常终止一个进程 用 法: void abort(void); abort()是使异常程序终止，同时发送SIGABRT信号给调用进程。 #include <stdlib.h> void abort ( void ); 该函数不返回 此函数将SIGABRT信号发送给调用进程（进程不应忽略此信号).ISO C规定，调用abort将向主机环境递送一个未成功终止的通知，其方法是调用raise(SIGABRT)函数。 ISO C要求若捕捉此信号而且相应信号处理程序返回，abort仍不会返回其调用者。如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、_Exit、longjmp或sigloogjmp.POSIX.1也说明 abort并不理会进程对此信号的阻塞和忽略。 让进程捕捉SIGABRT的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不在信号处理程序中终止自己，POSIX.1声明当信号处理程序返回时，abort终止该进程。 ISO C针对此函数的规范将下列问题留由实现决定： 是否要冲洗输出流以及是否删除临时文件。POSIX.1的要求更进一步，要求如果abort调用终止进程，则它对所有打开标准I/O流的效果应当与进程终止前对每个流调用fclose相同。 系统V早期的版本中，abort函数产生SIGIOT信号。更进一步，进程忽略此信号，或者捕捉它并从信号处理程序返回都是可能的，在返回情况下，abort返回到它的调用者。 4.3BSD产生SIGILL信号。在此之前，该函数解除对此信号的阻塞，将其配置恢复为SIG_DFL (终止并构造core文件)。这阻止一个进程忽略或捕捉此信号。 SVR4在产生此信号之前关闭所有I/O流。在另一方面，4.3+BSD则不做此操作。对于保护性的程序设计，如果希望刷新标准I/O流，则在调用abort之前要做这种操作。在err_dump函数中实现了这一点 因为大多数UNIX tmpfile(临时文件)的实现在创建该文件之后立即调用unlink，所以ANSI C关于临时文件的警告通常与我们无关。 abort的POSIX.1实现 #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> void abort ( void ) /*POSIX.1风格的abort()实现*/ { sigset_t mask ; struct sigaction action ; /* * Caller can't igore SIGABRT, if so reset to default. */ sigaction ( SIGABRT , NULL , & action ); if ( action . sa_handler == SIG_IGN ) { action . sa_handler == SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); } if ( action . sa_handler == SIG_DFL ) fflush ( NULL ) /* flush all open stdio stream */ /* * Caller can't block SIGABRT; make sure it's unblocked. */ sigfillset ( & mask ) sigdelset ( & mask , SIGABRT ); /* mask has only SIGABRT turned off */ sigprocmask ( SIG_SETMASK , & mask , NULL ); kill ( getpid (), SIGABRT ); /* send the signal */ /* * if we're here, process caught SIGABRT and returned. */ fflush ( NULL ); /*flush all open stdio streams*/ action . sa_handler = SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); /* reset to default */ sigprocmask ( SIG_SETMASK , & mask , NULL ); /* just in case ...*/ kill ( getpid (), SIGABRT ); /* and one more time*/ exit ( 1 ); /*this should never be executed...*/ 说明：首先查看是否将执行默认动作，若是则冲洗所有标准I/O流。这并不等价于对所有打开的流调用fclose(因为只冲洗，并不关闭它们），但是当进程终止时，系统会关闭所有打开的文件。如果进程捕捉此信号并返回， 那么因为进程产生了更多的输出，所以再一次冲洗所有的流。不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调用_exit或_Exit.这种情况下，内存中任何未冲洗的标准I/O缓冲区都被丢弃。我们假定捕捉此信号，而且_exit或_Exit的调用者并不想要冲洗缓冲区。 应用例子： #include <stdio.h> #include <stdlib.h> void main ( void ) { FILE * stream ; if (( stream = fopen ( \"NOSUCHF.ILE\" , \"r\" )) == NULL ) { perror ( \"Couldn't open file\" ); abort (); } } else fclose ( stream ); } 编译运行一下，看一下执行情况片段： execve(\"./test.o\", [\"./test.o\"], [/* 97 vars */]) = 0 open(\"NOSUCHF.ILE\", O_RDONLY) = -1 ENOENT (No such file or directory) dup(2) = 3 fcntl(3, F_GETFL) = 0x8402 (flags O_RDWR|O_APPEND|O_LARGEFILE) fstat(3, {st_mode=S_IFCHR|0600, st_rdev=makedev(136, 3), ...}) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd18aa86000 write(3, \"Couldn't open file: No such file\"..., 46Couldn't open file: No such file or directory ) = 46 close(3) = 0 munmap(0x7fd18aa86000, 4096) = 0 rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0 gettid() = 18489 tgkill(18489, 18489, SIGABRT) = 0 SIGABRT {si_signo=SIGABRT, si_code=SI_TKILL, si_pid=18489, si_uid=0} --- +++ killed by SIGABRT +++ 已放弃 abort测试代码说明 代码大体结构 |- macro || NUM || MIN_RLIMIT_CORE | |- variable || TCID || TST_TOTAL | |- function || main || setup || cleanup || do_child || instress 先看一下头文件： #include <sys/types.h> #include <sys/wait.h> #include <errno.h> #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/resource.h> #include \"test.h\" #include \"safe_macros.h\" 什么是头文件呢？ 在C语言家族程序中，头文件被大量使用。一般而言，每个C++/C程序通常由头文件(header files)和定义文件(definition files)组成。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明(declaration)，而定义文件用于保存程序的实现 (implementation) 让我们来看，经典程序 \"Hello world!\" 定义文件名\"First.c\" main() <sample-1> 看看上面的程序，没有.h文件,因为程序太简单，没有需要保存的声明。 文件名 First.c 变形 printStr() { printf(\"Hello world!\"); } main() { printStr() } <sample-2> 还是没有, 那就让我们把这个程序再稍微改动一下. 文件名 First.c main() { printStr() } printStr() { printf(\"Hello world!\"); } <sample-3> sample3和sample2是不同的，pritStr()函数定义的顺序不同。sample3是编译不通过的。这里面涉及作用域的问题。在这里只讲述与.h文件相关的顶层作用域。 顶层作用域就是从声明点延伸到源程序文本结束, 就printStr()这个函数来说，他没有单独的声明,只有定义,那么就从他定义的行开始,到first.c文件结束。sample2中，printStr的定义在main函数前面，所以作用域覆盖main函数，而sample3则没有。 这种情况怎么办呢? 有两种方法 ,一个pritStr函数定义到main函数之前，那就让我们来看另一个例子,让我们看看这个方法是不是在任何时候都会起作用. 文件名 First.c play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… } main() { play1() } <sample-4> 函数嵌套, 那么play1和play2这两个函数哪个放到前面呢? 这时就需要我们来使用第二种方法,使用声明. 文件名 First.c play1(); play2(); play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-5> 一个大型的软件项目,可能有几千个,上万个play, 而不只是play1,play2这么简单, 这样就可能有N个类似 play1(); play2(); 这样的声明, 这个时候就需要我们想办法把这样的play1(); play2(); 也另行管理, 而不是把他放在.c文件中, 于是.h文件出现了. 文件名 First.h play1(); play2(); 文件名 First.C #include \"first.h\" play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-6> 如在second.c中还有一个函数需要调用first.c文件中的play1函数, 如何实现呢? Sencond.h 文件 play1(); sencond.c文件 ***() { ……………. Play(); ………………. } <sample-7> 在sencond.h文件内声明play1函数，怎么能调用到first.c文件中的哪个play1函数中呢? 是不是搞错了，没有搞错, 这里涉及到c语言的另一个特性:存储类说明符. C语言的存储类说明符有以下几个, 我来列表说明一下 说明符 用法 Auto 只在块内变量声明中被允许, 表示变量具有本地生存期. Extern 出现在顶层或块的外部变量函数与变量声明中，表示声明的对象具有静态生存期, 连接程序知道其名字. Static 可以放在函数与变量声明中. 在函数定义时, 其只用于指定函数名,而不将函数导出到连接程序. 在函数声明中,表示其后面会有定义声明的函数, 存储类为static. 在数据声明中, 总是表示定义的声明不导出到连接程序. 无疑, 在sample7中的second.h和first.h中,需要我们用extern标志符来修饰play1函数的声明,这样,play1()函数就可以被导出到连接程序, 也就是实现了无论在first.c文件中调用,还是在second.c文件中调用,连接程序都会很聪明的按照我们的意愿,把他连接到first.c文件中的play1函数的定义上去, 而不必我们在second.c文件中也要再写一个一样的play1函数. 但随之有一个小问题, 在sample7中,我们并没有用extern标志符来修饰play1啊, 这里涉及到另一个问题, C语言中有默认的存储类标志符. C99中规定, 所有顶层的默认存储类标志符都是extern . 那么我们如何来区分哪个头文件中的声明在其对应的.c文件中有定义,而哪个又没有呢? 这也许不是必须的，因为无论在哪个文件中定义，聪明的连接程序都会义无返顾的帮我们找到，并导出到连接程序, 但我觉得他确实必要的. 因为我们需要知道这个函数的具体内容是什么,有什么功能, 有了新需求后我也许要修改他， 我需要在短时间内能找到这个函数的定义, 那么我来介绍一下在C语言中一个人为的规范: 在.h文件中声明的函数,如果在其对应的.c文件中有定义,那么我们在声明这个函数时,不使用extern修饰符, 如果反之,则必须显示使用extern修饰符. 这样,在C语言的.h文件中,我们会看到两种类型的函数声明. 带extern的,还不带extern的, 简单明了,一个是引用外部函数，一个是自己声明并定义的函数. 最终如下: Sencond.h 文件 Extern play1(); 那么多都是针对函数的，而实际上.h文件却不是为函数所专用的，还有全局变量. 在大型项目中，对全局变量的使用不可避免, 比如,在first.c中需要使用一个全局变量G_test, 那么我们可以在first.h中,定义 TPYE G_test. 与对函数的使用类似, 在second.c中我们的开发人员发现他也需要使用这个全局变量, 而且要与first.c中一样的那个, 如何处理? 对,我们可以仿照函数中的处理方法, 在second.h中再次声明TPYE G_test, 根据extern的用法,以及c语言中默认的存储类型, 在两个头文件中声明的TPYE G_test,其实其存储类型都是extern, 也就是说不必我们操心, 连接程序会帮助我们处理一切. 但我们又如何区分全局变量哪个是定义声明,哪个是引用声明呢?这个比函数要复杂一些, 一般在C语言中有如下几种模型来区分: 1、 初始化语句模型 顶层声明中，存在初始化语句是，表示这个声明是定义声明，其他声明是引用声明。C语言的所有文件之中，只能有一个定义声明。 按照这个模型，我们可以在first.h中定义如下TPYE G_test=1；那么就确定在first中的是定义声明，在其他的所有声明都是引用声明。 2、 省略存储类型说明 在这个模型中，所有引用声明要显示的包括存储类extern， 而每个外部变量的唯一定义声明中省略存储类说明符。 这个与我们对函数的处理方法类似，不再举例说明。 这里还有一个需要说明，数组全局变量。 在声明定义时，定义数组如下： int G_glob[100]; 在另一个文件中引用声明如下： int * G_glob; 在vc中，是可以编译通过的， 这种情况大家都比较模糊并且需要注意，数组与指针类似，但并不等于说对数组的声明起变量就是指针。 上面所说的的程序在运行时发现了问题，在引用声明的那个文件中，使用这个指针时总是提示内存访问错误，原来我们的连接程序并不把指针与数组等同，连接时，也不把他们当做同一个定义，而是认为是不相关的两个定义，当然会出现错误。正确的使用方法是在引用声明中声明如下： int G_glob[10]; 并且最好再加上一个extern，更加明了。 extern int G_glob[10]; 另外需要说明的是，在引用声明中由于不需要涉及到内存分配，可以简化如下，这样在需要对全局变量的长度进行修改时，不用把所有的引用声明也全部修改了。 extern int G_glob[]; 接下来，看一下linux环境编程头文件常用的有哪些？ linux常用头文件 POSIX标准定义的头文件 | 文件名 | 内容 | | ------- | -------- | dirent.h | 目录项 | fcntl.h | 文件控制 | fnmatch.h | 文件名匹配类型 | glob.h | 路径名模式匹配类型 | grp.h | 组文件 | <netdb.h> | 网络数据库操作 | <pwd.h> | 口令文件 | <regex.h> | 正则表达式 | <tar.h> | TAR归档值 | <termios.h> | 终端I/O | <unistd.h> | 符号常量 | <utime.h> | 文件时间 | <wordexp.h> | 字符扩展类型 | <arpa/inet.h> | INTERNET定义 | <net/if.h> | 套接字本地接口 | <netinet/in.h> | INTERNET地址族 | <netinet/tcp.h> | 传输控制协议定义 | <sys/mman.h> | 内存管理声明 | <sys/select.h> | Select函数 | <sys/socket.h> | 套接字借口 | <sys/stat.h> | 文件状态 | <sys/times.h> | 进程时间 | <sys/types.h> | 基本系统数据类型 | <sys/un.h> | UNIX域套接字定义 | <sys/utsname.h> | 系统名 | <sys/wait.h> | 进程控制 POSIX定义的XSI扩展头文件 | 文件名 | 内容 | | ------- | -------- | <cpio.h> | cpio归档值 | <dlfcn.h> | 动态链接 | <fmtmsg.h> | 消息显示结构 | <ftw.h> | 文件树漫游 | <iconv.h> | 代码集转换使用程序 | <langinfo.h> | 语言信息常量 | <libgen.h> | 模式匹配函数定义 | <monetary.h> | 货币类型 | <ndbm.h> | 数据库操作 | <nl_types.h> | 消息类别 | <poll.h> | 轮询函数 | <search.h>| 搜索表 | <strings.h> | 字符串操作 | <syslog.h> | 系统出错日志记录 | <ucontext.h> | 用户上下文 | <ulimit.h> | 用户限制 | <utmpx.h> | 用户帐户数据库 | <sys/ipc.h> | IPC(命名管道) | <sys/msg.h> | 消息队列 | <sys/resource.h>| 资源操作 | <sys/sem.h> | 信号量 | <sys/shm.h> | 共享存储 | <sys/statvfs.h> | 文件系统信息 | <sys/time.h> | 时间类型 | <sys/timeb.h> | 附加的日期和时间定义 | <sys/uio.h> | 矢量I/O操作 POSIX定义的可选头文件 | 文件名 | 内容 | | ------- | -------- | <aio.h> | 异步I/O | <mqueue.h> | 消息队列 | <pthread.h> | 线程 | <sched.h> | 执行调度 | <semaphore.h> | 信号量 | <spawn.h> | 实时spawn接口 | <stropts.h> | XSI STREAMS接口 | <trace.h> | 事件跟踪 C/C++头文件一览 C语言 | 文件名 | 内容 | | ------- | -------- | <assert.h>| 设定插入点 | <ctype.h> | 字符处理 | <errno.h> | 定义错误码 | <float.h> | 浮点数处理 | <iso646.h> | 对应各种运算符的宏 | <limits.h> | 定义各种数据类型最值的常量 | <locale.h> | 定义本地化C函数 | <math.h> | 定义数学函数 | <setjmp.h> | 异常处理支持 | <signal.h> | 信号机制支持 | <stdarg.h> | 不定参数列表支持 | <stddef.h> | 常用常量 | <stdio.h> | 定义输入／输出函数 | <stdlib.h>| 定义杂项函数及内存分配函数 | <string.h> | 字符串处理 | <time.h> | 定义关于时间的函数 | <wchar.h> | 宽字符处理及输入／输出 | <wctype.h> | 宽字符分类 传统C++ | 文件名 | 内容 | | ------- | -------- | <fstream.h> | 改用<fstream> | <iomanip.h> | 改用<iomainip> | <iostream.h> | 改用<iostream> | <strstrea.h> | 该类不再支持，改用<sstream>中的stringstream 标准C++ | 文件名 | 内容 | | ------- | -------- | <algorithm> | 通用算法 | <bitset> | 位集容器 | <cctype> | 字符处理 | <cerrno> | 定义错误码 | <cfloat> | 浮点数处理 | <ciso646> | 对应各种运算符的宏 | <climits> | 定义各种数据类型最值的常量 | <clocale> | 定义本地化函数 | <cmath> | 定义数学函数 | <complex> | 复数类 | <csignal> | 信号机制支持 | <csetjmp> | 异常处理支持 | <cstdarg> | 不定参数列表支持 | <cstddef> | 常用常量 | <cstdio> | 定义输入／输出函数 | <cstdlib> | 定义杂项函数及内存分配函数 | <cstring> | 字符串处理 | <ctime> | 定义关于时间的函数 | <cwchar> | 宽字符处理及输入／输出 | <cwctype> | 宽字符分类 | <deque> | STL 双端队列容器 | <exception> | 异常处理类 | <fstream> | 文件输入／输出 | <al> | STL 定义运算函数（代替运算符） | <limits> | 定义各种数据类型最值常量 | <list> | STL 线性列表容器 | <locale> | 本地化特定信息 | <map> | STL 映射容器 | <memory> | STL通过分配器进行的内存分配 | <new> | 动态内存分配 | <numeric> | STL常用的数字操作 | <iomanip> | 参数化输入／输出 | <iOS> | 基本输入／输出支持 | <iosfwd> | 输入／输出系统使用的前置声明 | <iostream> | 数据流输入／输出 | <istream> | 基本输入流 | <iterator> | STL迭代器 | <ostream> | 基本输出流 | <queue> | STL 队列容器 | <set> | STL 集合容器 | <sstream> | 基于字符串的流 | <stack> | STL 堆栈容器 | <stdexcept> | 标准异常类 | <streambuf> | /底层输入／输出支持 | <string> | 字符串类 | <typeinfo> | 运行期间类型信息 | <utility> | STL 通用模板类 | <valarray> | 对包含值的数组的操作 | <vector> | STL 动态数组容器 C99增加的部分 | 文件名 | 内容 | | ------- | -------- | <complex.h> | 复数处理 | <fenv.h> | 浮点环境 | <inttypes.h> | 整数格式转换 | <stdbool.h> | 布尔环境 | <stdint.h> | 整型环境 | <tgmath.h> | 通用类型数学宏 回到abort01的测试上来。先看一下执行情况： abort01 0 TINFO : Adjusting RLIMIT_CORE to 1048576 abort01 1 TPASS : abort dumped core abort01 2 TPASS : abort raised SIGIOT abort01 3 TPASS : abort dumped core abort01 4 TPASS : abort raised SIGIOT abort01 5 TPASS : abort dumped core abort01 6 TPASS : abort raised SIGIOT 程序后台执行片段 chdir(\"/tmp/aboeHLyFk\") = 0 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19587 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19587 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19587, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 1 TPASS : abort d\"..., 43abort01 1 TPASS : abort dumped core ) = 43 write(1, \"abort01 2 TPASS : abort r\"..., 45abort01 2 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19588 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19588 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19588, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 3 TPASS : abort d\"..., 43abort01 3 TPASS : abort dumped core ) = 43 write(1, \"abort01 4 TPASS : abort r\"..., 45abort01 4 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19589 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19589 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19589, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 5 TPASS : abort d\"..., 43abort01 5 TPASS : abort dumped core ) = 43 write(1, \"abort01 6 TPASS : abort r\"..., 45abort01 6 TPASS : abort raised SIGIOT ) = 45 unlink(\"core\") 从测试log来看，abort01主要进行abort\"dumped core\"、和\"raised SIGIOT\"两种测试，并且测试了３遍。０为setup打印信息。 #define NUM 3 /*定义fork进程的数量*/ char *TCID; /* tescase的名字*/ int TST_TOTAL; /* testcases数量 */ 主要函数 static void setup(void); static void cleanup(void); static void do_child(); static int instress(); int main(int argc, char *argv[]) 分别分析这几个函数 setup #define MIN_RLIMIT_CORE (1024 * 1024) static void setup(void) { struct rlimit rlim; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); if (rlim.rlim_cur < MIN_RLIMIT_CORE) { test_resm(TINFO, \"Adjusting RLIMIT_CORE to %i\", MIN_RLIMIT_CORE); rlim.rlim_cur = MIN_RLIMIT_CORE; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); } tst_tmpdir() } setup函数的目的是为了调整RLIMIT_CORE的大小。在Linux系统中，Resouce limit指在一个进程的执行过程中，它所能得到的资源的限制，比如进程的core file的最大值，虚拟内存的最大值等。Resouce limit的大小可以直接影响进程的执行状况。其有两个最重要的概念：soft limit 和 hard limit。 struct rlimit { rlim_t rlim_cur; rlim_t rlim_max; }; 是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件 数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。 tst_tmpdir函数说明一下，该函数用来为ltp测试程序创建临时目录，目录名case名称＋随机字母。 cleanup函数 static void cleanup(void) { unlink(\"core\") tst_rmdir(); } 该函数比较简单，用来清理产生的临时文件和软连接。可以做下试验，将main函数中的该函数注释掉，会在tmp下看到产生的core文件。 do_child函数 static void do_child(void) { abort() fprintf(stderr, \"\\tchild - abort failed.\\n\"); exit(1); } abort的调用，进程退出。 instress函数 static int instress(void) { test_resm(TINFO, \"System resources may be too low; fork(), select() etc are likely to fail.\"); return 1; } 系统资源比较低的情况， 出现fork()等调用失败时的处理。也是为兼容UCLINUK测试（如嵌入式系统）。 main函数 控制测试流程和主要的测试代码，以下将重点介绍一些代码片段。 #ifdef WCOREDUMP int core ; core = 0 ; #endif WCOREDUMP(status) 如果孩子进程产生核心转储文件则返回真。这个宏只应该在 WIFSIGNALED 返回真时调用。这个没有在 POSIX.1-2001 里指定并且在一些 UNIX 实现(如 AIX、SunOS)里也没有提供。只在 #ifdef WCOREDUMP ... #endif 内部使用。 #ifdef UCLINUX maybe_run_child ( & do_child , \"\" ); /* UCLINUX的情况 */ #endif setup (); /*调用setup函数*/ for ( i = 0 ; i < NUM ; i ++ ) { /*连续创建３个进程调用do_child函数*/ kidpid = FORK_OR_VFORK (); if ( kidpid == 0 ) { #ifdef UCLINUX if ( self_exec ( argv [ 0 ], \"\" )) { if ( ! instress ()) { perror ( \"fork failed\" ); exit ( 1 ); } } #else do_child (); //调用do_child()函数 #endif } } if ( kidpid < 0 ) if ( ! instress ()) tst_brkm ( TBROK | TERRNO , cleanup , \"fork failed\" ); count = 0 ; while (( child = wait ( & status )) > 0 ) count ++ ; if ( count != 1 ) { tst_brkm ( TBROK , cleanup , \"wrong # children waited on; got %d, expected 1\" , count ); } #ifdef WCOREDUMP core = WCOREDUMP ( status ); //WCOFEDUMP情况 #endif sig = WTERMSIG ( status ); } if ( WIFEXITED ( status )) ex = WEXITSTATUS ( status ); #ifdef WCOREDUMP if ( core == 0 ) { tst_brkm ( TFAIL , cleanup , \"Child did not dump core; exit code = %d, \" \"signal = %d\" , ex , sig ); } else if ( core != - 1 ) { tst_resm ( TPASS , \"abort dumped core\" ); //core值等于０，则没有正常产生core文件，如果core不等于０且不等于-1，说明正常产生了core文件 } #endif if ( sig == SIGIOT ) { tst_resm ( TPASS , \"abort raised SIGIOT\" ); //发出的信号如果为SIGIOT说明信号触发正常 } else { tst_brkm ( TFAIL , cleanup , \"Child did not raise SIGIOT (%d); exit code = %d, \" \"signal = %d\" , SIGIOT , ex , sig ); } } abort测试分析结束。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-abort"},{"url":"http://king32783784.github.io/2016/06/02/LTP/","text":"本节将重点分析commands部分的用例。 Command主要用例 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which ade ade包括对ar、file、ld、ldd、nm、objdump、size命令的验证测试。 ar ar命令是Linux的一个备份压缩命令，可以创建、修改备存文件(archive)，或从备存文件中抽取成员文件。备存文件以一定的结构打包一个至多个其它文件（即成员文件），且成员文件的内容、模式、时间戳等信息将被保存在备存文件中。常见的应用是，使用ar命令将多个目标文件（ .o）打包为静态链接库文件（ .a)。 引出一个问题，库是什么？本质上讲库是一种可执行代码的二进制形式，可以被操作系统加载到内存执行。linux库分为两种：静态库和动态库。区别在于，静态库是在编译过程中已经被载入可执行程序，可执行程序一般较大；共享库（动态库）是可执行程序运行时才加载到内存，编译时仅简单的引用，因此可执行程序较小。库是如何产生的呢？静态库的后缀是.a，它的产生分为两步：１．由源码编译生成一堆.o，每个.o包含这个编译单元的符号表；２．ar命令将很多.o文件打包转换为.a,形成静态库。 ar命令的常用参数 在 ar 命令中，可以从集 cClosTv 中指定任何数量的可选标志。必须从标志集 dhmopqrstwx 中指定一个标志。如果选择-m 或 -r 标志，您可能还要指定一个位置标志（-a 、-b 或-i ）；对于 -a 、-b 或-i 标志，您必须还指定在 ArchiveFile （PositionName ）中一个文件的名称，此名称紧跟在标志列表后，并由空格隔开。 -a PositionName 在 PositionName 参数标识的现有文件后安置指定的文件。 -b PositionName 在 PositionName 参数标识的现有文件前安置指定的文件。 -c 禁止在创建库 时产生的正常消息。 -C 阻止解压缩的文件替换文件系统中同名的文件。 -d 从库中删除指定的文件。 -g 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-g 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成小格式，这样该标志可用来将大格式压缩文档转换成小格式压缩文档。包含 64 位XCOFF 对象的压缩文档不能创建成或转换至小格式。 -h 将指定的文件的成员报头中的修改时间设置为当前日期和时间。如果不指定任何文件名称，则 ar 命令设置所有成员报头的时间戳记。此标志不能和-z 标志一起使用。 -i PositionName 在 PositionName 参数标识的现有文件前安置指定的文件（和 -b 相同）。 -l 将临时文件置于当前（本地）目录中，而非 TMPDIR 目录中（缺省为 /tmp ）。 -m 将指定的文件移动到库中的某个其它位置。缺省情况下，它将指定的文件移动到库的末尾。使用位置标志（abi ）来指定某个其它位置。 -o 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-o 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成大格式，这样该标志可用来将小格式压缩文档转换成大格式压缩文档。 -p 将 Files 参数中指定的文件的内容或在 ArchiveFile 参数中指定的所有文件（如果您不指定任何文件）都写至标准输出。 -q 将指定的文件添加到库的末尾。另外，如果指定同一个文件两次，它可能被放入库中两次。 -r 如果指定的文件已经存在于库中，则替换它。因为指定的文件在库中占据它们替换的文件的同一个位置，位置标志没有任何附加的影响。当和 -u 标志（更新）一起使用时，-r 标志仅替换自从最后一次添加到库中以后修改的文件。 如果指定的文件不存在于库中，则 ar 命令添加它。在这种情况下，位置标志影响放置。如果不指定位置，则将新文件置于库的末尾。如果指定同一个文件两次，它可能被放入库中两次。 -s 无论 ar 命令是否修改了库内容都强制重新生成库符号表。请在库上使用 strip 命令之后，使用此标志来恢复库符号表。 -t 将库的目录写至标准输出。如果指定文件名称，则仅显示指定的那些文件。如果不指定任何文件，-t 标志列出库中的所有文件。 -T 如果压缩文档成员名称比文件系统支持的长，则允许文件名称截短。此选项无效，因为文件系统支持的名称长度等于 255 个字符的最大压缩文档成员名称。 -u 仅复制自它们最后一次复制起更改的文件（请参阅先前讨论过的 -r 标志）。 -v 将建立新库的详细的逐个文件的描述写至标准输出。当和 -t 标志一起使用时，它给出类似于 ls -l 命令给出的长列表。当和 -x 标志一起使用时，它在每个文件前加一个名称。当和 -h 标志一起使用，它列出成员名称和更新的修改时间。 -w 显示压缩文档符号表。每个符号和其中定义此符号的文件的名称一起列出。 -x 通过将指定的文件复制到当前目录来解压缩它们。这些副本和原始文件（保留在库中）具有相同的名称。如果不指定任何文件，-x 标志复制库中的所有文件。此过程不会更改库。 -Xmode 指定 ar 应检查的目标文件的类型。mode 必须是以下项之一： 32 仅处理 32 位目标文件 64 仅处理 64 位目标文件 32_64 处理 32 位 和 64 位目标文件 缺省值是处理 32 位目标文件（忽略 64 位对象）。mode 还可以用 OBJECT_MODE 环境变量来设置。例如，OBJECT_MODE=64 使 ar 处理任何 64 位对象并忽略 32 位对象。-X 标志覆盖 OBJECT_MODE 变量。 -z 创建压缩文档的临时副本并对副本执行所有要求的修改。当所有操作成功完成时，压缩文档的工作副本覆盖原始副本。此标志不能和 -h 标志一起使用。 ArchiveFile 指定压缩文档文件名称；必需。 MemberName ... 各压缩文档成员的名称。 示例１．ar rcs libxxxx.a xx1.o xx2.o 参数r: 在库中插入模块（替换）。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 参数c: 创建一个库。不管库是否存在，都将创建。 参数s: 创建目标文件索引 这在创建较大的库时能加快时间。（补充：如果不需要创建索引，可改成大写S参数；如果。a文件缺少索引，可以使用ranlib命令添加） 示例２．创建一个库 ar -v -q lib.a strlen.o strcpy.o 如果 lib.a 库不存在，则此命令创建它，并将文件 strlen.o 和 strcpy.o 的副本输入其中。如果 lib.a 库存在，则此命令在不检查相同成员的情况下，将新的成员添加到末尾。v 标志设置详细方式，在此方式中ar 命令在其进行时显示进程报告。 示例３．显示库的目录 ar -v -t lib.a 此命令列出了 lib.a 库的目录，显示类似于 ls -l 命令的输出的长列表。要只列出成员文件名称，则省略-v 标志。 示例4. 替换或添加新成员到库中 ar -v -r lib.a strlen.o strcat.o 此命令替换成员 strlen.o 和 strcat.o 。如果 lib.a 如示例 1 中显示的那样创建，则替换strlen.o 成员。因为不存在名为 strcat.o 的成员，所以它被添加到库的末尾。 示例５. 指定在何处插入新成员 ar -v -r -b strlen.o lib.a strcmp.o 此命令添加 strcmp.o 文件，并将该新成员置于 strlen.o 成员之前。 示例６．要更新一个已经更改过的成员 ar -v -r -u lib.a strcpy.o 此命令替换现有 strcpy.o 成员，但仅当文件 strcpy.o 自从最后一次添加到库后已经修改时才替换它。 示例７ 要更改库成员的顺序 ar -v -m -a strcmp.o lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 移动到紧跟在 strcmp.o 成员之后的位置。保留 strcat.o 和 strcpy.o 成员的相对顺序。换句话说，如果在移动之前strcpy.o 成员在 strcat.o 成员之前，那么（移动后）它依旧如此。 示例８ 要解压缩库成员 ar -v -x lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 分别复制到名为 strcat.o 和 strcpy.o 的文件。 示例９ 要解压缩并重命名一个成员 ar -p lib.a strcpy.o >stringcopy.o 此命令将成员 strcpy.o 复制到一个名为 stringcopy.o 的文件。 示例10 要删除一个成员 ar -v -d lib.a strlen.o 此命令从 lib.a 库中删除成员 strlen.o 。 示例11 要从多个用 ld 命令创建的共享模块中创建一个压缩文档库 ar -r -v libshr.a shrsub.o shrsub2.o shrsub3.o ... 此命令从名为 shrsub.o 、shrsub2.o 、shrsub3.o 等等的共享模块中创建名为libshr.a 的压缩文档库。要编译并链接使用 libshr.a 压缩文档库的 main 程序，请使用以下命令： cc -o main main.c -L/u/sharedlib -lshr main 程序现在是可执行的。main 程序引用的任何符号（包含在libshr.a 压缩文档库中）已经因延迟分辨率而作了标记。-l 标志指定应在libshr.a 库中搜索这些符号。 示例12 要列出 lib.a 的内容（忽略任何 32 位目标文件） ar -X64 -t -v lib.a 要从 lib.a 解压缩所有 32 位的目标文件 ar -X32 -x lib.a 要列出 lib.a 中的所有文件，无论是 32 位、64 位或非对象，请输入： ar -X32_64 -t -v lib.a 示例13 在shell脚本中使用 Bash代码 OS= uname -r ar rcs libhycu.a.$OS *.o 示例14 在makefile中使用 Makefile代码 $（BIN1）: $（BIN1_OBJS） ar rcs $@ $&#94; 示例15 创建并使用静态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 如果test.c无误，就会得到test.o这个目标文件。 第三步：由。o文件创建静态库。 ar rcs libtest.a test.o 第四步：在程序中使用静态库。 gcc -o main main.c -L. -ltest 因为是静态编译，生成的执行文件可以独立于。a文件运行。 第五步：执行。 ./main 示例16 创建并使用动态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 前面两步与创建静态库一致。 第三步：由。o文件创建动态库文件。 gcc -shared -fPIC -o libtest.so test.o 第四步：在程序中使用动态库。 gcc -o main main.c -L. -ltest 当静态库和动态库同名时，gcc命令将优先使用动态库。 第五步：执行。 LD_LIBRARY_PATH=. ./main 接下来，看一下ltp是如何测试ar命令的。 ar文件下包括： ar01 file0.in file10.in file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in Makefile等文件，其中ar01是shell编写的测试脚本。 测试目的，测试ar命令的不同选项的功能。测试策略，通过比较单独指定参数和组合参数测试结果进行判断，如果相同测试通过，如果不同，测试失败。 ar测试项的参数为: export TCdat=$LTPROOT/testcases/bin; ar01 直接执行ar01即可。 测试条件，系统存在ar命令。在运行config时，会进行check:如 configure : 4165 : checking for ar configure : 4181 : found /bin/ ar configure : 4192 : result : ar 程序分析： 创建用到的临时文件 LIST=\"file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in file10.in\" LIST=\" $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST \" # Setup function setup() { for i in $ LIST ;do touch $ i done } 结果判定，判断子case的返回值是否为０，TCRESULT为标志位，初始值为０，出错TCRESULT置为１，不同测试内容分别返回不同的编号。 # Cleanup funciton cleanup() { if [ $ TCRESULT = 0 ];then echo \"-----------ar command passed the system test --------\" exit 0 else echo \"-----------ar command failed the system test --------\" exit 1 fi } crtest() { if [ $ ? -ne 0] then TCRESULT=1 echo \"FAIL - could not create lib.a\" cleanup fi } ttest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not output table from lib.a to lib.a.stdout\" cleanup fi } rtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not add file into lib.a\" cleanup fi } mtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not move file into lib.a\" cleanup fi } 通过结果判定的设置来看，主要验证ar命令的库的创建、库列表信息导出、往库中添加文件、移除库中的文件。 测试代码片段： 标志\"a\"：在 PositionName 参数标识的现有文件后安置指定的文件。 ar -cr $ TCtmp /lib.a file1.in file3.in crtest ar -ra file1.in $ TCtmp /lib.a file2.in rtest ar -t $ TCtmp /lib.a > $ TCtmp /lib.a.stdout tttest if diff -b $ TCtmp /lib.a.exp $ TCtmp /lib.a.stdout > /dev/null 2>&1 then echo \"-)1\" else TCRESULT=1 echo \"FAIL -ar with -a option does not place file after \"posname\" fi 具体测试内容列表： （１）The 'a' flag causes files to be placed after 'posname'. （２）The 'a' flag with the 'm' option causes files to be moved after 'posname' （３）The 'b' flag causes files to be placed before 'posname'. （４）The 'b' flag with 'm' option causes files to be moved before 'posname'. （５）-c option suppress the messages （６）The 'qc' option causes suppresion of the default message when 'afile' is created （７）The -d option deletes files from archive when names are specified. （８）The -d option does not delete files from archive when no names are specified. （９）The -d does not affect behaviour of -s option. （10）The 'i' flag causes files to be placed before 'posname'. （11) The 'i' flag with 'm' option causes files to be moved before 'posname'. (12) m option moves the files to end of the archive (13) The -p option causes only printing of contents of file contained in archive. (14) The -p does not affect behaviour of -s option. (15) The command 'ar -q afile name' appends name to the end of 'afile'. (16) q option does not affect the behaviour of option s (17) The -s causes regeneration of symbol table even if a symbol table exists. (18) ar with -t print as desired (19) The -t does not affect behaviour of -s option. (20)The 'u' flag causes files only with later modification date than in archive are replaced. (21) ar with -v flag to print a line for each file (22) The -v option produces a verbose listing like ls -n (23) The 'v' option causes the 'x' option to display a filename for each file extracted. (24) The command 'ar -x afile ' causes all files from the archive to be extracted. (25) The command 'ar -x afile name name' causes only named files from the archive to be extracted. (26) This test will fail under pan, so it's commented out by default. (27) Signal SIGHUP (28) Signal SIGQUIT (29) Signal SIGHUP; ar should not remove archive that existed before invocation. (30) Signal SIGINIT; ar should not remove archive that existed before invocation. (31) Signal SIGQUIT; ar should not remove archive that existed before invocation.","tags":"自动化测试-LTP","title":"LTP－Command"},{"url":"http://king32783784.github.io/2016/08/01/LTP/","text":"syscalls ltp中kernel测试比重很大，尤其是syscalls，包括一下用例： 注：测试内容分析时补充。 用例名称 测试内容 abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev 接下来按照顺序分析系统调用的每一个case,并将每个case的测试内容补充到本文。 附linux系统主要系统调用列表 一、进程控制 fork 创建一个新进程 clone 按指定条件创建子进程 execve 运行可执行文件 exit 中止进程 _exit 立即中止当前进程 getdtablesize 进程所能打开的最大文件数 getpgid 获取指定进程组标识号 setpgid 设置指定进程组标志号 getpgrp 获取当前进程组标识号 setpgrp 设置当前进程组标志号 getpid 获取进程标识号 getppid 获取父进程标识号 getpriority 获取调度优先级 setpriority 设置调度优先级 modify_ldt 读写进程的本地描述表 nanosleep 使进程睡眠指定的时间 nice 改变分时进程的优先级 pause 挂起进程，等待信号 personality 设置进程运行域 prctl 对进程进行特定操作 ptrace 进程跟踪 sched_get_priority_max 取得静态优先级的上限 sched_get_priority_min 取得静态优先级的下限 sched_getparam 取得进程的调度参数 sched_getscheduler 取得指定进程的调度策略 sched_rr_get_interval 取得按RR算法调度的实时进程的时间片长度 sched_setparam 设置进程的调度参数 sched_setscheduler 设置指定进程的调度策略和参数 sched_yield 进程主动让出处理器,并将自己等候调度队列队尾 vfork 创建一个子进程，以供执行新程序，常与execve等同时使用 wait 等待子进程终止 wait3 参见wait waitpid 等待指定子进程终止 wait4 参见waitpid capget 获取进程权限 capset 设置进程权限 getsid 获取会晤标识号 setsid 设置会晤标识号 二、文件系统控制 1、文件读写操作 fcntl 文件控制 open 打开文件 creat 创建新文件 close 关闭文件描述字 read 读文件 write 写文件 readv 从文件读入数据到缓冲数组中 writev 将缓冲数组里的数据写入文件 pread 对文件随机读 pwrite 对文件随机写 lseek 移动文件指针 _llseek 在64位地址空间里移动文件指针 dup 复制已打开的文件描述字 dup2 按指定条件复制文件描述字 flock 文件加/解锁 poll I/O多路转换 truncate 截断文件 ftruncate 参见truncate umask 设置文件权限掩码 fsync 把文件在内存中的部分写回磁盘 2、文件系统操作 access 确定文件的可存取性 chdir 改变当前工作目录 fchdir 参见chdir chmod 改变文件方式 fchmod 参见chmod chown 改变文件的属主或用户组 fchown 参见chown lchown 参见chown chroot 改变根目录 stat 取文件状态信息 lstat 参见stat fstat 参见stat statfs 取文件系统信息 fstatfs 参见statfs readdir 读取目录项 getdents 读取目录项 mkdir 创建目录 mknod 创建索引节点 rmdir 删除目录 rename 文件改名 link 创建链接 symlink 创建符号链接 unlink 删除链接 readlink 读符号链接的值 mount 安装文件系统 umount 卸下文件系统 ustat 取文件系统信息 utime 改变文件的访问修改时间 utimes 参见utime quotactl 控制磁盘配额 三、系统控制 ioctl I/O总控制函数 _sysctl 读/写系统参数 acct 启用或禁止进程记账 getrlimit 获取系统资源上限 setrlimit 设置系统资源上限 getrusage 获取系统资源使用情况 uselib 选择要使用的二进制函数库 ioperm 设置端口I/O权限 iopl 改变进程I/O权限级别 outb 低级端口操作 reboot 重新启动 swapon 打开交换文件和设备 swapoff 关闭交换文件和设备 bdflush 控制bdflush守护进程 sysfs 取核心支持的文件系统类型 sysinfo 取得系统信息 adjtimex 调整系统时钟 alarm 设置进程的闹钟 getitimer 获取计时器值 setitimer 设置计时器值 gettimeofday 取时间和时区 settimeofday 设置时间和时区 stime 设置系统日期和时间 time 取得系统时间 times 取进程运行时间 uname 获取当前UNIX系统的名称、版本和主机等信息 vhangup 挂起当前终端 nfsservctl 对NFS守护进程进行控制 vm86 进入模拟8086模式 create_module 创建可装载的模块项 delete_module 删除可装载的模块项 init_module 初始化模块 query_module 查询模块信息 *get_kernel_syms 取得核心符号,已被query_module代替 四、内存管理 brk 改变数据段空间的分配 sbrk 参见brk mlock 内存页面加锁 munlock 内存页面解锁 mlockall 调用进程所有内存页面加锁 munlockall 调用进程所有内存页面解锁 mmap 映射虚拟内存页 munmap 去除内存页映射 mremap 重新映射虚拟内存地址 msync 将映射内存中的数据写回磁盘 mprotect 设置内存映像保护 getpagesize 获取页面大小 sync 将内存缓冲区数据写回硬盘 cacheflush 将指定缓冲区中的内容写回磁盘 五、网络管理 getdomainname 取域名 setdomainname 设置域名 gethostid 获取主机标识号 sethostid 设置主机标识号 gethostname 获取本主机名称 sethostname 设置主机名称 六、socket控制 socketcall socket系统调用 socket 建立socket bind 绑定socket到端口 connect 连接远程主机 accept 响应socket连接请求 send 通过socket发送信息 sendto 发送UDP信息 sendmsg 参见send recv 通过socket接收信息 recvfrom 接收UDP信息 recvmsg 参见recv listen 监听socket端口 select 对多路同步I/O进行轮询 shutdown 关闭socket上的连接 getsockname 取得本地socket名字 getpeername 获取通信对方的socket名字 getsockopt 取端口设置 setsockopt 设置端口参数 sendfile 在文件或端口间传输数据 socketpair 创建一对已联接的无名socket 七、用户管理 getuid 获取用户标识号 setuid 设置用户标志号 getgid 获取组标识号 setgid 设置组标志号 getegid 获取有效组标识号 setegid 设置有效组标识号 geteuid 获取有效用户标识号 seteuid 设置有效用户标识号 setregid 分别设置真实和有效的的组标识号 setreuid 分别设置真实和有效的用户标识号 getresgid 分别获取真实的,有效的和保存过的组标识号 setresgid 分别设置真实的,有效的和保存过的组标识号 getresuid 分别获取真实的,有效的和保存过的用户标识号 setresuid 分别设置真实的,有效的和保存过的用户标识号 setfsgid 设置文件系统检查时使用的组标识号 setfsuid 设置文件系统检查时使用的用户标识号 getgroups 获取后补组标志清单 setgroups 设置后补组标志清单 八、进程间通信 ipc 进程间通信总控制调用 1、信号 sigaction 设置对指定信号的处理方法 sigprocmask 根据参数对信号集中的信号执行阻塞/解除阻塞等操作 sigpending 为指定的被阻塞信号设置队列 sigsuspend 挂起进程等待特定信号 signal 参见signal kill 向进程或进程组发信号 *sigblock 向被阻塞信号掩码中添加信号,已被sigprocmask代替 *siggetmask 取得现有阻塞信号掩码,已被sigprocmask代替 *sigsetmask 用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替 *sigmask 将给定的信号转化为掩码,已被sigprocmask代替 *sigpause 作用同sigsuspend,已被sigsuspend代替 sigvec 为兼容BSD而设的信号处理函数,作用类似sigaction ssetmask ANSI C的信号处理函数,作用类似sigaction 2、消息 msgctl 消息控制操作 msgget 获取消息队列 msgsnd 发消息 msgrcv 取消息 3、管道 pipe 创建管道 4、信号量 semctl 信号量控制 semget 获取一组信号量 semop 信号量操作 5、共享内存 shmctl 控制共享内存 shmget 获取共享内存 shmat 连接共享内存 shmdt 拆卸共享内存","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls"},{"url":"http://king32783784.github.io/2016/06/03/LTP/","text":"file file 用例主要用于测试file命令。 file命令介绍 file命令可以通过查看文件内容来找出特定类型的文件，在UNIX/ Linux系统中，文件类型并不是由文件扩展名来决定的(windows中却正是这么做的),file命令的目的是从多个文件中收集文件类型统计信息。 file --help Usage: file [OPTION...] [FILE...] Determine type of FILEs. --help display this help and exit -v, --version output version information and exit -m, --magic-file LIST use LIST as a colon-separated list of magic number files -z, --uncompress try to look inside compressed files -Z, --uncompress-noreport only print the contents of compressed files -b, --brief do not prepend filenames to output lines -c, --checking-printout print the parsed form of the magic file, use in conjunction with -m to debug a new magic file before installing it -e, --exclude TEST exclude TEST from the list of test to be performed for file. Valid tests are: apptype, ascii, cdf, compress, elf, encoding, soft, tar, text, tokens -f, --files-from FILE read the filenames to be examined from FILE -F, --separator STRING use string as separator instead of `:' -i, --mime output MIME type strings (--mime-type and --mime-encoding) --apple output the Apple CREATOR/TYPE --extension output a slash-separated list of extnsions --mime-type output the MIME type --mime-encoding output the MIME encoding -k, --keep-going don't stop at the first match -l, --list list magic strength -L, --dereference follow symlinks (default) -h, --no-dereference don't follow symlinks -n, --no-buffer do not buffer output -N, --no-pad do not pad output -0, --print0 terminate filenames with ASCII NUL -p, --preserve-date preserve access times on files -P, --parameter set file engine parameter limits indir 15 recursion limit for indirection name 30 use limit for name/use magic elf_notes 256 max ELF notes processed elf_phnum 128 max ELF prog sections processed elf_shnum 32768 max ELF sections processed -r, --raw don't translate unprintable chars to \\ooo -s, --special-files treat special (block/char devices) files as ordinary ones -C, --compile compile file specified by -m -d, --debug print debugging messages 必要参数 -b 文件名不显示 -c 显示详细处理信息 -L 操作对象为符号链接所指向的对象 -z 压缩文件的处理 -C 列出magic.mgc的输出 -n 将结果输出到标准输出 -f<文件名> 指定文件名 -m<文件名> 指定魔法数字名 选择参数 --help 显示帮助信息 -v 显示版本信息 实例： 1.查看所有文件类型 file * 2.2.查看具体某一文件的类型：file filename 3.-b参数，打印出不包含文件名的文件类型信息: 4.-z 参数，可以获取用gzip、zip压缩过的文件的类型 5.-n参数，将信息标准输出 言归正传，file_test.sh 脚本主要验证是否支持多种文件格式，比如tar tar.gz rpm c ascii elf等。 用例设置： Test01：测试文件命令是否识别ASCII文本文件 1）将文本写入已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.txt 3）grep为关键字\"ASCII文本\"的输出 'file'命令 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test02：测试文件命令是否能识别bash shell脚本 1）将一个小shell脚本写入一个已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.sh 3）从'file'命令的输出中Grep关键字\"Bourne-Again shell脚本\" 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test03：测试文件命令是否能识别bash shell脚本 使用Korn shell脚本执行类似的测试（如Test02） Test04：测试文件命令是否可以识别C shell脚本 使用C shell脚本执行类似的测试（如Test02） Test05：测试文件命令是否可以识别C程序文本 使用test2类似方法测试c程序文本 Test06：测试文件命令是否可以识别ELF二进制可执行文件 1）使用readelf确定主机是大端还是小端,并分别为字符串\"MSB\"或\"LSB\"分配TEST_ARCH 2）将小C程序写入已知的\".c\"文件 3）使用\"cc\" Ex：cc xyz xyz.c 4）使用file命令获取对象文件的类型 5）在file输出中，grep ELF .*-bit $ TEST_ARCH executable, .* 字符。 6）如果上述命令成功，则将测试声明为PASS Test07：测试文件命令是否可以识别tar文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar 4）grep从上面的'file'命令的输出的中匹配字符串\"tar\" 5）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL Test08：测试文件命令是否可以tar zip文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用'gzip'命令来压缩tar文件 例如：gzip -f xyz.tar 4）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar.gz 5）grep从上面的文件commnand字符串\"gzip压缩数据，。*\" 6）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL 代码片段 测试file命令能识别出ASCII文本文件。 export TCID=file01 export TST_COUNT=1 $ LTPBIN /tst_resm TINFO \"TEST # 1:file command recogizes ASCII text files\" # log信息 cat > $ LTPTMP /test_file.txt <<EOF this is a text file to test file command EOF # 制作txt文本文件 ## 执行file命令并检查输出。 file $ LTPTMP /test_file.txt > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] # 判断返回值是否为０，验证file命令执行是否成功 then grep -q \"ASCII text\" $ LTPTMP /file.out # 匹配输出类型是否整齐 if [ $ ? -eq 0 ] then $ LTPBIN /test_resm TPASS \"file: Recognised ASCII file correctly\" rm -f $ LTPTMP /test_file.txt else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise ASCII file correctlyi. Reason:\" TFAILCNT= $(( $ TFAILCNT + 1 )) # error code＋１ fi else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: failed to recognize ASCII file correctly\\t\\t\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi TEST #2 测试是否识别shell脚本 export TCID=file02 export TST_COUNT=2 $ LTPBIN /tst_resm TINFO \"TEST # 2: file command recognizes bash shell scripts\" cat > $ LTPTMP /bash_script.sh <<EOF # ! /bin/bash echo \"this is a shell script\" echo \"used to test file command\" EOF file $ LTPTMP /bash_script.sh > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] then grep -q \"Bourne-Again shell script\" $ LTPTMP /file.out if [ $ ? -eq 0 ] then $ LTPBIN /tst_resm TPASS \"file: Recognised bash shell script correctly\" rm -f $ LTPTMP /bash_script.sh else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise bash shell script. Reason\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi else $ LTPBIN /tst_resm TFAIL \"file: Failed to recognize bash shell script\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi 其他测试代码同上面类似，不再一一分析。","tags":"自动化测试-LTP","title":"LTP－Command-file"},{"url":"http://king32783784.github.io/2016/06/01/LTP/","text":"该topic将深入分析ltp的测试内容，着重于具体每个case的测试内容及测试方法。通过对ltp case的分析，加强linux系统的理解和用例设计。本节主要整理ltp的包括测试case的类型和case列表。 整体情况 case主要分为\"commands\"、\"kdump\"、\"kernel\"、\"misc\"、\"network\"、\"open_posix_testsuite\"、\"realtime\"、\"lib\"等部分，主要内容如下： 分类 包含内容 commands ade cpio df eject gzip logrotate mail mkfs sshd tar unzip which at cron du fileutils insmod lsmod mkswap su tmp-tools wc kernel connectors controllers firmware hotplug input ipc logging mce-test module power_management sched syscalls tracing containers device-drivers fs include io lib mem numa pty security times misc crash f00f math network busy_poll dctcp iptables netstress nfsv4 rpc stress tcp_fstopen virt can dhcp iproute lib6 multicast nfs sockets tcp_cmds traceroute xinetd open_posix_testsuite functional tools bin conformance stress realtime perf profiles stress lib kdump commands 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which kernel 主要case包括: case 包含子case connectors connector pec containers libclone mountns mqns netns pidns share sysvipc userns utsname controllers cgroup cgroup_xattr cpuctl cpuset io-throttle memcg pids cgroup_fg cpuacct cpuctl_fj freezer libcontrollers memctl device-drivers acpi base cpufreq drm locking misc_modules pci tbio usb zram agp block dev_sim_framework nls rcu rtc uaccess v4l firmware fw_load_kernel fw_load_user fs acl dmapi ext4-new-features fs_blnd fs_inod fs_perms fsstress ftest iso9660 linktest mongo proc racer stram acls doio fs-bench fs_di fs_main fs_readonly fsx-linux inode lftest openfile quota_remount scsi hotplug cpu_hotplug memory_hotplug input input io aio direct_io disktest ltp-aiodio stress_cd stress_floppy writetest ipc pipeio semaphore logging kmsg mem cpuset mem mtest01 mtest06 oom shmt thp vma hugetlb ksm mmapstress mtest05 mtest07 page swapping tunable vmtests moudle create_module delete_module query_module numa numa power_management pm_ilb_test runpwtests01-06 runpwtests_exelusive01-06 pm_cpu_consolidation pm_include pm_sched_domain pty hangup ptem pty sched cfs-scheduler clisrv hypertherading nptl process_stress pthreads sched_stress tool security cap_bound filecaps integrity mmc_security prot_hsymlinks securbits smack tomoyo syscalls abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev timers clock_gettime clock_settime leapsec timer_create timer_delete timer_settime tracing ftrace misc case 包含子case crash crash f00f foof math abs atof float fptests nextafter network case 包含子case can filter-test dctcp dctcp dhcp dhcp_tests dhcp_lib dnsmasq_tests iproute ip_tests iptables iptables_tests lib6 asapi getaddrinfo in6 multicast mc_cmds mc_commo mc_gethost mc_member mc_opts netstress netstress nfs fsx-linux nfslock01 nfsstat01 nfs_stress nfsv4 acl locks rpc basic_tests rpc-tirpc sockets socket stress broken_ip dns ftp http icmp interface ipsec multicast ns-tools route ssh tcp udp tcp_cmds arping echo ftp netstat rcp rsh sendfile tcpdump trackpath clockdiff finger host ipneigh ping rdist rlogin rwho ssh telnet tcp_fastopen tcp_fastopen traceroute traceroute virt gre01 ipvlan macvlan macvtap vlan vxlan xinted xinted open_posix_testsuite case 包含子case bin run-all-posix-option-group-tests conformance behavior definitions interfaces functional mqueues semaphores threads timers stress mqueues semaphores signals threads timers realtime case 包含子case func async_handler hrtimer-prio matrix_mult periodic_cpu_load pi-tests prio-wake rt-migrate sched_jitter thrad_clock gtod_latency measurement pi_perf prio-preempt pthread_kill_latency sched_football sched_letency m4 m4 perf latency stress pi-tests 接下来会深入分析每个case的具体测试目的及内容。ltp测试用例主要采用shell和Ｃ编写。","tags":"自动化测试-LTP","title":"LTP－Case list"},{"url":"http://king32783784.github.io/2016/08/05/LTP/","text":"accept用例分析 case本身说明： Verify that accept() returns the proper errno for various failure cases 验证accept()是否返回正确的errno. 测试log accept01 1 TPASS : bad file descriptor successful accept01 2 TPASS : bad file descriptor successful accept01 3 TPASS : invalid socket buffer successful accept01 4 TPASS : invalid salen successful accept01 5 TPASS : invalid salen successful accept01 6 TPASS : no queued connections successful accept01 7 TPASS : UDP accept successful ~ 测试错误类型包括: bad file descriptor、invalid socket buffer、invalid salen、no queued connections、 UDP accept等 accept函数 accept() 接收一个套接字中已建立的连接 使用格式 #include <sys/types.h> #include <sys/socket.h> int accept ( int sockfd , struct sockaddr * addr , socklen_t * addrlen ); 功能参数描述 accept()系统调用主要用在基于链接的套接字类型，比如SOCK_STREAM和SOCK_SEQPACKET.它提取出所监听套接字的等待连接队列中第一个连接请求，创建一个新的套接字，并返回指向该套接字的文件描述符。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。 备注： 新建立的套接字准备发送send()和接收数据recv(). 参数： sockfd, 利用系统调用socket()建立的套接字描述符，通过bind()绑定到一个本地地址（一般为服务器的套接字），并且通过listen()一直在监听连接。 addr, 指向struct sockaddr的指针，该结构用通讯层服务器对等套接字的地址（一般为客户端地址）填写，返回地址addr的确切格式由套接字的地址类别（比如tcp或udp)决定；若addr为NULL，没有有效地址填写，这种情况下，addrlen也不使用，应该置为NULL； 备注： addr是个指向局部数据结构sockaddr_in的指针，这就是要求接入的信息本地的套接字（地址和指针） addrlen, 一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值，函数返回时包含对等地址（一般为服务器地址）的实际数值； 备注： addrlen 是个局部整型变量， 设置为sizeof(struct sockaddr_in) 如果队列中没有等待的连接，套接字也没有被标记为Non-blocking, accept()会阻塞调用函数知道连接出现；如果套接字被标记为Non-blocking, 队列中也没有等待的连接，accept返回错误EAGAIN或EWOULDBLOCK. 备注： 一般来说，实现时accept()为阻塞函数，当监听socket调用accept()时，它先到自己的receive_buf中查看是否有连接数据包； 若有，把数据拷贝处理啊，删掉接收到的数据包，创建新的socket与客户发来的地址建立链接； 若没有，就阻塞等待； 为了在套接字中有到来的连接时得到通知，可以使用select()或poll().当尝试建立新连接时，系统发送一个可读事件，然后调用accept()为该链接获取套接字。另一种方法是，当套接字中有连接到来时设定套接字发送SIGIO信号。 返回值 成功时，返回非负整数，该整数是接收到套接字的描述符；出错时，返回－１，相应的设定全局变量errno. 错误处理 Linux下，accept()把已等待的网络错误传给新建立的连接，当作是accept()返回的错误。这与其他的BSD实现是不同的。为了可靠运行，应该在accept()之后检测协议已定义的一些网络错误，并把这些错误当作EAGAIN并重试。对于tcp/ip协议来说，主要有：ENETDOWN,EPROTO,ENOPROTOOPT,EHOSTDOWN,ENONET,EHOSTUNREACH,EOPNOTSUPP和ENETUNREACH。 accept01.c代码分析 主要函数包括mian、setup、cleanup、setup0、cleanup0、setup1、cleanup1、setup2、setup3 test_case_t结构体 struct test_caset { int domain; /*AF_INIT, AF_UNIX,....*/ int type; /* SOCK_STREAM, SOCK_DGRAM...*/ int proto; /* protocol number(usually 0 = default) */ struct sockaddr *sockaddr; /*socket address buffer */ socklen_t *salen; /* accept's 3rd argument */ int retval; /* syscall return value */ int experrno; /* expected errno */ void (*setup)(void); void(*cleanup)(void); char *desc; } tdat[] = { {PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EBADF, setup0, cleanup0, \"bad file descriptor\"}, //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, ENOTSOCK, setup0, cleanup0, \"bad file descriptor\"}, { //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)3, &sinlen, -1, EINVAL, setup1, cleanup1, \"invalid socket buffer\"}, { //无效套接字缓存区 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, (socklen_t *) 1, -1, EINVAL, setup1, cleanup1, \"invalid salen\"}, { //无效的salen PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup2, cleanup1, \"invalid salen\"}, { PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup3, cleanup1, \"no queued connections\"}, { //队列中没有等待的连接 PF_INET, SOCK_DGRAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EOPNOTSUPP, setup1, cleanup1, \"UDP accept\"},}; int TST_TOTAL = sizeof(tdat) / sizeof(tdat[0]); /*通过数组的长度，计算测试用例数量*/ 先定义测试case需要的结构体，然后进行了 结构体初始化 ，定义了7种错误类型，对应7个测试case，和测试log是对应的。 顺便看一下 SOCK_STREAM和SOCK_DGRAM的区别： sock_stream 是有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料（如文件）传送。 sock_dgram 是无保障的面向消息的socket ， 主要用于在网络上发广播信息。 SOCK_STREAM是基于TCP的，数据传输比较有保障。SOCK_DGRAM是基于UDP的，专门用于局域网，基于广播 SOCK_STREAM 是数据流,一般是tcp/ip协议的编程,SOCK_DGRAM分是数据抱,是udp协议网络编程 再看说一下AF_INET和PF_INET的差别： 在Unix/Linux系统中，在不同的版本中这两者有微小差别.对于BSD,是AF,对于POSIX是PF.理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx 分别看一下这几个错误码 EBADF: 当作为参数的套接字不是一个有效的文件描述符(在Linux下用文件描述符来表示设备文件和普通文件。文件描述符是一个整型的数据，所有对文件的操作都通过文件描述符实现。文件描述符是文件系统中链接用户空间和内核空间的枢纽)时，抛出这个错误码。无效的文件描述符是什么意思呢？就是fd已经close的，或者本身就不是个有效的socket的fd。 ENOTSOCK: 在非socket上执行socket操作。 EINVAL： 无效参数。提供的参数非法。有时也会与socket的当前状态相关，如一个socket并没有进入listening状态，此时调用accept，就会产生EINVAL错误。 EOPNOTSUPP: 不支持的操作。 引用对象的类型不支持尝试的操作。通常，这发生在套接字描述符不支持此操作，例如，试着接受数据报套接字上的连接的套接字。 接下来看几个辅助函数。 1.setup函数 static void setup(void) { TEST_PAUSE; /*初始化本地 sockaddr*/ sin0.sin_family = AF_INET; //绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_INET，即使用IP sin0.sin_port = 0; sin0.sin_addr.s_addr = INADDR_ANY; //指定地址为0.0.0.0的地址 } TEST_PAUSE是一个 宏定义 ，代表usc_global_setup_hook()函数。作用是当设置了暂停标志后，暂停 SIGUSR1 ，当新的信号来时，再继续。下面是usc_global_setup_hook函数实现： #define TEST_PAUSE usc_global_setup_hook(); int usc_global_setup_hook () int usc_global_setup_hook ( void ) { #ifndef UCLINUX /*定义temp变量存储信号旧信号的动作，中断后恢复*/ int ( * _TMP_FUNC ) ( void ); /*中断等待sigusr1.*/ if ( STD_PAUSE ) { _TMP_FUNC = ( int ( * )()) singnal ( SIGUSR1 , STD_go ); pause () signal ( SIGUSR1 , ( void ( * )()) _TMP_FUNC ); } if ( STD_TP_sbrk ) || STD_LP_sbrk ) STD_start_break = sbrk ( 0 ); /*获取原始sbreak大小*/ if ( STD_TP_sbrk ){ sbrk ( STD_TP_sbrk ) : if ( Debug ) print ( \"after sbrk(%d) \\n \" , STD_TP_sbrk ); } #endif return 0 ; } 2.setup0函数case1测试前设置 static void setup0(void) 3.setup2 static void setup2(void) { setup1(); //调用setup1()获取套接字s sinlen = 1; //s置为无效 } 4.setup3 static void setup3(void) { int one = 1; setup1(); SAFE_IOCTL(cleanup, s, FIONBIO, &one); } SAFE_IOCTL #define SAFE_IOCTL ( cleanup_fn , fd , request , ...) \\ ( { int ret = ioctl ( fd , request , __VA_ARGS__ ); \\ ret < 0 ? \\ tst_brkm ( TBROK | TERRNO , cleanup_fn , \\ \"ioctl(%i,%s,...) failed\" , fd , #reques t ) \\ safe_ : ret ;} ) 6.cleanup、cleanup0, cleanup1 static void cleanup(void) { } static void cleanup0(void) { s = -1; } static void cleanup1(void) { (void)close(s); s = -1; } 重新设置s = -1 OK,现在看一下main函数。 int main(int ac, char *av[]) { int lc; tst_parse_opts(ac, av, NULL, NULL); //ltp参数解析函数 setup(); for (lc = 0; TEST_LOOPING(lc); ++lc){ test_count = 0; for (testno = 0; testno < TST_TOTAL; ++testno){ tdat[testno].setup(); TEST(accept(s, tdat[testno].sockaddr, tdat[testno].salen)); if (TEST_RETURN > 0) TEST_RETURN = 0; if (TEST_RETURN != tdat[testno].retval || (TEST_RETURN < 0 && TEST_ERRNO != tdat[testno].experrno)){ \"%ld(expected %d), errno %d (expected\" \"%d)\", tdat[testno].desc, TEST_RETURN, tdat[testno].desc, TEST_ERRNO, tdat[testno].experrno); } else { tst_resm(TPASS, \"%s successful\", tdat[testno].desc); } tdat[testno].cleanup(); } } cleanup(); tst_exit(); } 先看一下tst_parse_opts()函数 void tst_parse_opts(int argc, char *argv[], const option_t *user_optarg, void (*user_help)(void)) { const char *msg; msg = parse_opts(argc, argv, user_optarg, user_help); //parse_opts是参数解析函数，后面文章再进行介绍 if(msg) tst_brkm(TBROK, NULL, \"OPTION PARSING ERROR - %s \", msg); } 接下来调用setup，准备测试环境，初始化本地IP地址。然后是一个嵌套的两层循环，第一次是测试次数的遍历，通过TEST_LOOPING实现。 TEST_LOOPING是int usc_test_looping(int counter)函数，该函数后面的文章再进行解释。tst_count初始化为0。 第二层循环是遍历case数组。tdat[testno].setup()，调用对应setup准备case的特殊设置。 TEST启动测试， #define TEST(SCALL) \\ do { \\ errno = 0; \\ TEST_RETURN = SCALL; \\ TEST_ERRNO = errno; \\ } 然后将tdat中的对应参数，分别执行accept函数，如果预期的返回值不符或则返回值小于0且和预期的错误类型不匹配，则调用tst_resm()，进行出错处理。tst_resm将在后面进行分析。如果符合预期，则打印TPASS，然后调用tdat[testno].clearnup()分别清理环境。 最后调用cleanup()清理，tst_exit()退出，tst_exit()在单独分析ltp测试框架时分析。 到此，我们就清楚accept测试的内容了。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-accept()"},{"url":"http://king32783784.github.io/2016/06/02/LTP/","text":"本节将重点分析commands部分的用例。 Command主要用例 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which ade ade包括对ar、file、ld、ldd、nm、objdump、size命令的验证测试。 ar ar命令是Linux的一个备份压缩命令，可以创建、修改备存文件(archive)，或从备存文件中抽取成员文件。备存文件以一定的结构打包一个至多个其它文件（即成员文件），且成员文件的内容、模式、时间戳等信息将被保存在备存文件中。常见的应用是，使用ar命令将多个目标文件（ .o）打包为静态链接库文件（ .a)。 引出一个问题，库是什么？本质上讲库是一种可执行代码的二进制形式，可以被操作系统加载到内存执行。linux库分为两种：静态库和动态库。区别在于，静态库是在编译过程中已经被载入可执行程序，可执行程序一般较大；共享库（动态库）是可执行程序运行时才加载到内存，编译时仅简单的引用，因此可执行程序较小。库是如何产生的呢？静态库的后缀是.a，它的产生分为两步：１．由源码编译生成一堆.o，每个.o包含这个编译单元的符号表；２．ar命令将很多.o文件打包转换为.a,形成静态库。 ar命令的常用参数 在 ar 命令中，可以从集 cClosTv 中指定任何数量的可选标志。必须从标志集 dhmopqrstwx 中指定一个标志。如果选择-m 或 -r 标志，您可能还要指定一个位置标志（-a 、-b 或-i ）；对于 -a 、-b 或-i 标志，您必须还指定在 ArchiveFile （PositionName ）中一个文件的名称，此名称紧跟在标志列表后，并由空格隔开。 -a PositionName 在 PositionName 参数标识的现有文件后安置指定的文件。 -b PositionName 在 PositionName 参数标识的现有文件前安置指定的文件。 -c 禁止在创建库 时产生的正常消息。 -C 阻止解压缩的文件替换文件系统中同名的文件。 -d 从库中删除指定的文件。 -g 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-g 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成小格式，这样该标志可用来将大格式压缩文档转换成小格式压缩文档。包含 64 位XCOFF 对象的压缩文档不能创建成或转换至小格式。 -h 将指定的文件的成员报头中的修改时间设置为当前日期和时间。如果不指定任何文件名称，则 ar 命令设置所有成员报头的时间戳记。此标志不能和-z 标志一起使用。 -i PositionName 在 PositionName 参数标识的现有文件前安置指定的文件（和 -b 相同）。 -l 将临时文件置于当前（本地）目录中，而非 TMPDIR 目录中（缺省为 /tmp ）。 -m 将指定的文件移动到库中的某个其它位置。缺省情况下，它将指定的文件移动到库的末尾。使用位置标志（abi ）来指定某个其它位置。 -o 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-o 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成大格式，这样该标志可用来将小格式压缩文档转换成大格式压缩文档。 -p 将 Files 参数中指定的文件的内容或在 ArchiveFile 参数中指定的所有文件（如果您不指定任何文件）都写至标准输出。 -q 将指定的文件添加到库的末尾。另外，如果指定同一个文件两次，它可能被放入库中两次。 -r 如果指定的文件已经存在于库中，则替换它。因为指定的文件在库中占据它们替换的文件的同一个位置，位置标志没有任何附加的影响。当和 -u 标志（更新）一起使用时，-r 标志仅替换自从最后一次添加到库中以后修改的文件。 如果指定的文件不存在于库中，则 ar 命令添加它。在这种情况下，位置标志影响放置。如果不指定位置，则将新文件置于库的末尾。如果指定同一个文件两次，它可能被放入库中两次。 -s 无论 ar 命令是否修改了库内容都强制重新生成库符号表。请在库上使用 strip 命令之后，使用此标志来恢复库符号表。 -t 将库的目录写至标准输出。如果指定文件名称，则仅显示指定的那些文件。如果不指定任何文件，-t 标志列出库中的所有文件。 -T 如果压缩文档成员名称比文件系统支持的长，则允许文件名称截短。此选项无效，因为文件系统支持的名称长度等于 255 个字符的最大压缩文档成员名称。 -u 仅复制自它们最后一次复制起更改的文件（请参阅先前讨论过的 -r 标志）。 -v 将建立新库的详细的逐个文件的描述写至标准输出。当和 -t 标志一起使用时，它给出类似于 ls -l 命令给出的长列表。当和 -x 标志一起使用时，它在每个文件前加一个名称。当和 -h 标志一起使用，它列出成员名称和更新的修改时间。 -w 显示压缩文档符号表。每个符号和其中定义此符号的文件的名称一起列出。 -x 通过将指定的文件复制到当前目录来解压缩它们。这些副本和原始文件（保留在库中）具有相同的名称。如果不指定任何文件，-x 标志复制库中的所有文件。此过程不会更改库。 -Xmode 指定 ar 应检查的目标文件的类型。mode 必须是以下项之一： 32 仅处理 32 位目标文件 64 仅处理 64 位目标文件 32_64 处理 32 位 和 64 位目标文件 缺省值是处理 32 位目标文件（忽略 64 位对象）。mode 还可以用 OBJECT_MODE 环境变量来设置。例如，OBJECT_MODE=64 使 ar 处理任何 64 位对象并忽略 32 位对象。-X 标志覆盖 OBJECT_MODE 变量。 -z 创建压缩文档的临时副本并对副本执行所有要求的修改。当所有操作成功完成时，压缩文档的工作副本覆盖原始副本。此标志不能和 -h 标志一起使用。 ArchiveFile 指定压缩文档文件名称；必需。 MemberName ... 各压缩文档成员的名称。 示例１．ar rcs libxxxx.a xx1.o xx2.o 参数r: 在库中插入模块（替换）。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 参数c: 创建一个库。不管库是否存在，都将创建。 参数s: 创建目标文件索引 这在创建较大的库时能加快时间。（补充：如果不需要创建索引，可改成大写S参数；如果。a文件缺少索引，可以使用ranlib命令添加） 示例２．创建一个库 ar -v -q lib.a strlen.o strcpy.o 如果 lib.a 库不存在，则此命令创建它，并将文件 strlen.o 和 strcpy.o 的副本输入其中。如果 lib.a 库存在，则此命令在不检查相同成员的情况下，将新的成员添加到末尾。v 标志设置详细方式，在此方式中ar 命令在其进行时显示进程报告。 示例３．显示库的目录 ar -v -t lib.a 此命令列出了 lib.a 库的目录，显示类似于 ls -l 命令的输出的长列表。要只列出成员文件名称，则省略-v 标志。 示例4. 替换或添加新成员到库中 ar -v -r lib.a strlen.o strcat.o 此命令替换成员 strlen.o 和 strcat.o 。如果 lib.a 如示例 1 中显示的那样创建，则替换strlen.o 成员。因为不存在名为 strcat.o 的成员，所以它被添加到库的末尾。 示例５. 指定在何处插入新成员 ar -v -r -b strlen.o lib.a strcmp.o 此命令添加 strcmp.o 文件，并将该新成员置于 strlen.o 成员之前。 示例６．要更新一个已经更改过的成员 ar -v -r -u lib.a strcpy.o 此命令替换现有 strcpy.o 成员，但仅当文件 strcpy.o 自从最后一次添加到库后已经修改时才替换它。 示例７ 要更改库成员的顺序 ar -v -m -a strcmp.o lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 移动到紧跟在 strcmp.o 成员之后的位置。保留 strcat.o 和 strcpy.o 成员的相对顺序。换句话说，如果在移动之前strcpy.o 成员在 strcat.o 成员之前，那么（移动后）它依旧如此。 示例８ 要解压缩库成员 ar -v -x lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 分别复制到名为 strcat.o 和 strcpy.o 的文件。 示例９ 要解压缩并重命名一个成员 ar -p lib.a strcpy.o >stringcopy.o 此命令将成员 strcpy.o 复制到一个名为 stringcopy.o 的文件。 示例10 要删除一个成员 ar -v -d lib.a strlen.o 此命令从 lib.a 库中删除成员 strlen.o 。 示例11 要从多个用 ld 命令创建的共享模块中创建一个压缩文档库 ar -r -v libshr.a shrsub.o shrsub2.o shrsub3.o ... 此命令从名为 shrsub.o 、shrsub2.o 、shrsub3.o 等等的共享模块中创建名为libshr.a 的压缩文档库。要编译并链接使用 libshr.a 压缩文档库的 main 程序，请使用以下命令： cc -o main main.c -L/u/sharedlib -lshr main 程序现在是可执行的。main 程序引用的任何符号（包含在libshr.a 压缩文档库中）已经因延迟分辨率而作了标记。-l 标志指定应在libshr.a 库中搜索这些符号。 示例12 要列出 lib.a 的内容（忽略任何 32 位目标文件） ar -X64 -t -v lib.a 要从 lib.a 解压缩所有 32 位的目标文件 ar -X32 -x lib.a 要列出 lib.a 中的所有文件，无论是 32 位、64 位或非对象，请输入： ar -X32_64 -t -v lib.a 示例13 在shell脚本中使用 Bash代码 OS= uname -r ar rcs libhycu.a.$OS *.o 示例14 在makefile中使用 Makefile代码 $（BIN1）: $（BIN1_OBJS） ar rcs $@ $&#94; 示例15 创建并使用静态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 如果test.c无误，就会得到test.o这个目标文件。 第三步：由。o文件创建静态库。 ar rcs libtest.a test.o 第四步：在程序中使用静态库。 gcc -o main main.c -L. -ltest 因为是静态编译，生成的执行文件可以独立于。a文件运行。 第五步：执行。 ./main 示例16 创建并使用动态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 前面两步与创建静态库一致。 第三步：由。o文件创建动态库文件。 gcc -shared -fPIC -o libtest.so test.o 第四步：在程序中使用动态库。 gcc -o main main.c -L. -ltest 当静态库和动态库同名时，gcc命令将优先使用动态库。 第五步：执行。 LD_LIBRARY_PATH=. ./main 接下来，看一下ltp是如何测试ar命令的。 ar文件下包括： ar01 file0.in file10.in file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in Makefile等文件，其中ar01是shell编写的测试脚本。 测试目的，测试ar命令的不同选项的功能。测试策略，通过比较单独指定参数和组合参数测试结果进行判断，如果相同测试通过，如果不同，测试失败。 ar测试项的参数为: export TCdat=$LTPROOT/testcases/bin; ar01 直接执行ar01即可。 测试条件，系统存在ar命令。在运行config时，会进行check:如 configure : 4165 : checking for ar configure : 4181 : found /bin/ ar configure : 4192 : result : ar 程序分析： 创建用到的临时文件 LIST=\"file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in file10.in\" LIST=\" $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST \" # Setup function setup() { for i in $ LIST ;do touch $ i done } 结果判定，判断子case的返回值是否为０，TCRESULT为标志位，初始值为０，出错TCRESULT置为１，不同测试内容分别返回不同的编号。 # Cleanup funciton cleanup() { if [ $ TCRESULT = 0 ];then echo \"-----------ar command passed the system test --------\" exit 0 else echo \"-----------ar command failed the system test --------\" exit 1 fi } crtest() { if [ $ ? -ne 0] then TCRESULT=1 echo \"FAIL - could not create lib.a\" cleanup fi } ttest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not output table from lib.a to lib.a.stdout\" cleanup fi } rtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not add file into lib.a\" cleanup fi } mtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not move file into lib.a\" cleanup fi } 通过结果判定的设置来看，主要验证ar命令的库的创建、库列表信息导出、往库中添加文件、移除库中的文件。 测试代码片段： 标志\"a\"：在 PositionName 参数标识的现有文件后安置指定的文件。 ar -cr $ TCtmp /lib.a file1.in file3.in crtest ar -ra file1.in $ TCtmp /lib.a file2.in rtest ar -t $ TCtmp /lib.a > $ TCtmp /lib.a.stdout tttest if diff -b $ TCtmp /lib.a.exp $ TCtmp /lib.a.stdout > /dev/null 2>&1 then echo \"-)1\" else TCRESULT=1 echo \"FAIL -ar with -a option does not place file after \"posname\" fi 具体测试内容列表： （１）The 'a' flag causes files to be placed after 'posname'. （２）The 'a' flag with the 'm' option causes files to be moved after 'posname' （３）The 'b' flag causes files to be placed before 'posname'. （４）The 'b' flag with 'm' option causes files to be moved before 'posname'. （５）-c option suppress the messages （６）The 'qc' option causes suppresion of the default message when 'afile' is created （７）The -d option deletes files from archive when names are specified. （８）The -d option does not delete files from archive when no names are specified. （９）The -d does not affect behaviour of -s option. （10）The 'i' flag causes files to be placed before 'posname'. （11) The 'i' flag with 'm' option causes files to be moved before 'posname'. (12) m option moves the files to end of the archive (13) The -p option causes only printing of contents of file contained in archive. (14) The -p does not affect behaviour of -s option. (15) The command 'ar -q afile name' appends name to the end of 'afile'. (16) q option does not affect the behaviour of option s (17) The -s causes regeneration of symbol table even if a symbol table exists. (18) ar with -t print as desired (19) The -t does not affect behaviour of -s option. (20)The 'u' flag causes files only with later modification date than in archive are replaced. (21) ar with -v flag to print a line for each file (22) The -v option produces a verbose listing like ls -n (23) The 'v' option causes the 'x' option to display a filename for each file extracted. (24) The command 'ar -x afile ' causes all files from the archive to be extracted. (25) The command 'ar -x afile name name' causes only named files from the archive to be extracted. (26) This test will fail under pan, so it's commented out by default. (27) Signal SIGHUP (28) Signal SIGQUIT (29) Signal SIGHUP; ar should not remove archive that existed before invocation. (30) Signal SIGINIT; ar should not remove archive that existed before invocation. (31) Signal SIGQUIT; ar should not remove archive that existed before invocation.","tags":"自动化测试-LTP","title":"LTP－Command"},{"url":"http://king32783784.github.io/2016/08/01/LTP/","text":"syscalls ltp中kernel测试比重很大，尤其是syscalls，包括一下用例： 注：测试内容分析时补充。 用例名称 测试内容 abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev 接下来按照顺序分析系统调用的每一个case,并将每个case的测试内容补充到本文。 附linux系统主要系统调用列表 一、进程控制 fork 创建一个新进程 clone 按指定条件创建子进程 execve 运行可执行文件 exit 中止进程 _exit 立即中止当前进程 getdtablesize 进程所能打开的最大文件数 getpgid 获取指定进程组标识号 setpgid 设置指定进程组标志号 getpgrp 获取当前进程组标识号 setpgrp 设置当前进程组标志号 getpid 获取进程标识号 getppid 获取父进程标识号 getpriority 获取调度优先级 setpriority 设置调度优先级 modify_ldt 读写进程的本地描述表 nanosleep 使进程睡眠指定的时间 nice 改变分时进程的优先级 pause 挂起进程，等待信号 personality 设置进程运行域 prctl 对进程进行特定操作 ptrace 进程跟踪 sched_get_priority_max 取得静态优先级的上限 sched_get_priority_min 取得静态优先级的下限 sched_getparam 取得进程的调度参数 sched_getscheduler 取得指定进程的调度策略 sched_rr_get_interval 取得按RR算法调度的实时进程的时间片长度 sched_setparam 设置进程的调度参数 sched_setscheduler 设置指定进程的调度策略和参数 sched_yield 进程主动让出处理器,并将自己等候调度队列队尾 vfork 创建一个子进程，以供执行新程序，常与execve等同时使用 wait 等待子进程终止 wait3 参见wait waitpid 等待指定子进程终止 wait4 参见waitpid capget 获取进程权限 capset 设置进程权限 getsid 获取会晤标识号 setsid 设置会晤标识号 二、文件系统控制 1、文件读写操作 fcntl 文件控制 open 打开文件 creat 创建新文件 close 关闭文件描述字 read 读文件 write 写文件 readv 从文件读入数据到缓冲数组中 writev 将缓冲数组里的数据写入文件 pread 对文件随机读 pwrite 对文件随机写 lseek 移动文件指针 _llseek 在64位地址空间里移动文件指针 dup 复制已打开的文件描述字 dup2 按指定条件复制文件描述字 flock 文件加/解锁 poll I/O多路转换 truncate 截断文件 ftruncate 参见truncate umask 设置文件权限掩码 fsync 把文件在内存中的部分写回磁盘 2、文件系统操作 access 确定文件的可存取性 chdir 改变当前工作目录 fchdir 参见chdir chmod 改变文件方式 fchmod 参见chmod chown 改变文件的属主或用户组 fchown 参见chown lchown 参见chown chroot 改变根目录 stat 取文件状态信息 lstat 参见stat fstat 参见stat statfs 取文件系统信息 fstatfs 参见statfs readdir 读取目录项 getdents 读取目录项 mkdir 创建目录 mknod 创建索引节点 rmdir 删除目录 rename 文件改名 link 创建链接 symlink 创建符号链接 unlink 删除链接 readlink 读符号链接的值 mount 安装文件系统 umount 卸下文件系统 ustat 取文件系统信息 utime 改变文件的访问修改时间 utimes 参见utime quotactl 控制磁盘配额 三、系统控制 ioctl I/O总控制函数 _sysctl 读/写系统参数 acct 启用或禁止进程记账 getrlimit 获取系统资源上限 setrlimit 设置系统资源上限 getrusage 获取系统资源使用情况 uselib 选择要使用的二进制函数库 ioperm 设置端口I/O权限 iopl 改变进程I/O权限级别 outb 低级端口操作 reboot 重新启动 swapon 打开交换文件和设备 swapoff 关闭交换文件和设备 bdflush 控制bdflush守护进程 sysfs 取核心支持的文件系统类型 sysinfo 取得系统信息 adjtimex 调整系统时钟 alarm 设置进程的闹钟 getitimer 获取计时器值 setitimer 设置计时器值 gettimeofday 取时间和时区 settimeofday 设置时间和时区 stime 设置系统日期和时间 time 取得系统时间 times 取进程运行时间 uname 获取当前UNIX系统的名称、版本和主机等信息 vhangup 挂起当前终端 nfsservctl 对NFS守护进程进行控制 vm86 进入模拟8086模式 create_module 创建可装载的模块项 delete_module 删除可装载的模块项 init_module 初始化模块 query_module 查询模块信息 *get_kernel_syms 取得核心符号,已被query_module代替 四、内存管理 brk 改变数据段空间的分配 sbrk 参见brk mlock 内存页面加锁 munlock 内存页面解锁 mlockall 调用进程所有内存页面加锁 munlockall 调用进程所有内存页面解锁 mmap 映射虚拟内存页 munmap 去除内存页映射 mremap 重新映射虚拟内存地址 msync 将映射内存中的数据写回磁盘 mprotect 设置内存映像保护 getpagesize 获取页面大小 sync 将内存缓冲区数据写回硬盘 cacheflush 将指定缓冲区中的内容写回磁盘 五、网络管理 getdomainname 取域名 setdomainname 设置域名 gethostid 获取主机标识号 sethostid 设置主机标识号 gethostname 获取本主机名称 sethostname 设置主机名称 六、socket控制 socketcall socket系统调用 socket 建立socket bind 绑定socket到端口 connect 连接远程主机 accept 响应socket连接请求 send 通过socket发送信息 sendto 发送UDP信息 sendmsg 参见send recv 通过socket接收信息 recvfrom 接收UDP信息 recvmsg 参见recv listen 监听socket端口 select 对多路同步I/O进行轮询 shutdown 关闭socket上的连接 getsockname 取得本地socket名字 getpeername 获取通信对方的socket名字 getsockopt 取端口设置 setsockopt 设置端口参数 sendfile 在文件或端口间传输数据 socketpair 创建一对已联接的无名socket 七、用户管理 getuid 获取用户标识号 setuid 设置用户标志号 getgid 获取组标识号 setgid 设置组标志号 getegid 获取有效组标识号 setegid 设置有效组标识号 geteuid 获取有效用户标识号 seteuid 设置有效用户标识号 setregid 分别设置真实和有效的的组标识号 setreuid 分别设置真实和有效的用户标识号 getresgid 分别获取真实的,有效的和保存过的组标识号 setresgid 分别设置真实的,有效的和保存过的组标识号 getresuid 分别获取真实的,有效的和保存过的用户标识号 setresuid 分别设置真实的,有效的和保存过的用户标识号 setfsgid 设置文件系统检查时使用的组标识号 setfsuid 设置文件系统检查时使用的用户标识号 getgroups 获取后补组标志清单 setgroups 设置后补组标志清单 八、进程间通信 ipc 进程间通信总控制调用 1、信号 sigaction 设置对指定信号的处理方法 sigprocmask 根据参数对信号集中的信号执行阻塞/解除阻塞等操作 sigpending 为指定的被阻塞信号设置队列 sigsuspend 挂起进程等待特定信号 signal 参见signal kill 向进程或进程组发信号 *sigblock 向被阻塞信号掩码中添加信号,已被sigprocmask代替 *siggetmask 取得现有阻塞信号掩码,已被sigprocmask代替 *sigsetmask 用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替 *sigmask 将给定的信号转化为掩码,已被sigprocmask代替 *sigpause 作用同sigsuspend,已被sigsuspend代替 sigvec 为兼容BSD而设的信号处理函数,作用类似sigaction ssetmask ANSI C的信号处理函数,作用类似sigaction 2、消息 msgctl 消息控制操作 msgget 获取消息队列 msgsnd 发消息 msgrcv 取消息 3、管道 pipe 创建管道 4、信号量 semctl 信号量控制 semget 获取一组信号量 semop 信号量操作 5、共享内存 shmctl 控制共享内存 shmget 获取共享内存 shmat 连接共享内存 shmdt 拆卸共享内存","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls"},{"url":"http://king32783784.github.io/2016/06/03/LTP/","text":"file file 用例主要用于测试file命令。 file命令介绍 file命令可以通过查看文件内容来找出特定类型的文件，在UNIX/ Linux系统中，文件类型并不是由文件扩展名来决定的(windows中却正是这么做的),file命令的目的是从多个文件中收集文件类型统计信息。 file --help Usage: file [OPTION...] [FILE...] Determine type of FILEs. --help display this help and exit -v, --version output version information and exit -m, --magic-file LIST use LIST as a colon-separated list of magic number files -z, --uncompress try to look inside compressed files -Z, --uncompress-noreport only print the contents of compressed files -b, --brief do not prepend filenames to output lines -c, --checking-printout print the parsed form of the magic file, use in conjunction with -m to debug a new magic file before installing it -e, --exclude TEST exclude TEST from the list of test to be performed for file. Valid tests are: apptype, ascii, cdf, compress, elf, encoding, soft, tar, text, tokens -f, --files-from FILE read the filenames to be examined from FILE -F, --separator STRING use string as separator instead of `:' -i, --mime output MIME type strings (--mime-type and --mime-encoding) --apple output the Apple CREATOR/TYPE --extension output a slash-separated list of extnsions --mime-type output the MIME type --mime-encoding output the MIME encoding -k, --keep-going don't stop at the first match -l, --list list magic strength -L, --dereference follow symlinks (default) -h, --no-dereference don't follow symlinks -n, --no-buffer do not buffer output -N, --no-pad do not pad output -0, --print0 terminate filenames with ASCII NUL -p, --preserve-date preserve access times on files -P, --parameter set file engine parameter limits indir 15 recursion limit for indirection name 30 use limit for name/use magic elf_notes 256 max ELF notes processed elf_phnum 128 max ELF prog sections processed elf_shnum 32768 max ELF sections processed -r, --raw don't translate unprintable chars to \\ooo -s, --special-files treat special (block/char devices) files as ordinary ones -C, --compile compile file specified by -m -d, --debug print debugging messages 必要参数 -b 文件名不显示 -c 显示详细处理信息 -L 操作对象为符号链接所指向的对象 -z 压缩文件的处理 -C 列出magic.mgc的输出 -n 将结果输出到标准输出 -f<文件名> 指定文件名 -m<文件名> 指定魔法数字名 选择参数 --help 显示帮助信息 -v 显示版本信息 实例： 1.查看所有文件类型 file * 2.2.查看具体某一文件的类型：file filename 3.-b参数，打印出不包含文件名的文件类型信息: 4.-z 参数，可以获取用gzip、zip压缩过的文件的类型 5.-n参数，将信息标准输出 言归正传，file_test.sh 脚本主要验证是否支持多种文件格式，比如tar tar.gz rpm c ascii elf等。 用例设置： Test01：测试文件命令是否识别ASCII文本文件 1）将文本写入已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.txt 3）grep为关键字\"ASCII文本\"的输出 'file'命令 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test02：测试文件命令是否能识别bash shell脚本 1）将一个小shell脚本写入一个已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.sh 3）从'file'命令的输出中Grep关键字\"Bourne-Again shell脚本\" 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test03：测试文件命令是否能识别bash shell脚本 使用Korn shell脚本执行类似的测试（如Test02） Test04：测试文件命令是否可以识别C shell脚本 使用C shell脚本执行类似的测试（如Test02） Test05：测试文件命令是否可以识别C程序文本 使用test2类似方法测试c程序文本 Test06：测试文件命令是否可以识别ELF二进制可执行文件 1）使用readelf确定主机是大端还是小端,并分别为字符串\"MSB\"或\"LSB\"分配TEST_ARCH 2）将小C程序写入已知的\".c\"文件 3）使用\"cc\" Ex：cc xyz xyz.c 4）使用file命令获取对象文件的类型 5）在file输出中，grep ELF .*-bit $ TEST_ARCH executable, .* 字符。 6）如果上述命令成功，则将测试声明为PASS Test07：测试文件命令是否可以识别tar文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar 4）grep从上面的'file'命令的输出的中匹配字符串\"tar\" 5）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL Test08：测试文件命令是否可以tar zip文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用'gzip'命令来压缩tar文件 例如：gzip -f xyz.tar 4）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar.gz 5）grep从上面的文件commnand字符串\"gzip压缩数据，。*\" 6）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL 代码片段 测试file命令能识别出ASCII文本文件。 export TCID=file01 export TST_COUNT=1 $ LTPBIN /tst_resm TINFO \"TEST # 1:file command recogizes ASCII text files\" # log信息 cat > $ LTPTMP /test_file.txt <<EOF this is a text file to test file command EOF # 制作txt文本文件 ## 执行file命令并检查输出。 file $ LTPTMP /test_file.txt > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] # 判断返回值是否为０，验证file命令执行是否成功 then grep -q \"ASCII text\" $ LTPTMP /file.out # 匹配输出类型是否整齐 if [ $ ? -eq 0 ] then $ LTPBIN /test_resm TPASS \"file: Recognised ASCII file correctly\" rm -f $ LTPTMP /test_file.txt else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise ASCII file correctlyi. Reason:\" TFAILCNT= $(( $ TFAILCNT + 1 )) # error code＋１ fi else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: failed to recognize ASCII file correctly\\t\\t\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi TEST #2 测试是否识别shell脚本 export TCID=file02 export TST_COUNT=2 $ LTPBIN /tst_resm TINFO \"TEST # 2: file command recognizes bash shell scripts\" cat > $ LTPTMP /bash_script.sh <<EOF # ! /bin/bash echo \"this is a shell script\" echo \"used to test file command\" EOF file $ LTPTMP /bash_script.sh > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] then grep -q \"Bourne-Again shell script\" $ LTPTMP /file.out if [ $ ? -eq 0 ] then $ LTPBIN /tst_resm TPASS \"file: Recognised bash shell script correctly\" rm -f $ LTPTMP /bash_script.sh else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise bash shell script. Reason\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi else $ LTPBIN /tst_resm TFAIL \"file: Failed to recognize bash shell script\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi 其他测试代码同上面类似，不再一一分析。","tags":"自动化测试-LTP","title":"LTP－Command-file"},{"url":"http://king32783784.github.io/2016/06/01/LTP/","text":"该topic将深入分析ltp的测试内容，着重于具体每个case的测试内容及测试方法。通过对ltp case的分析，加强linux系统的理解和用例设计。本节主要整理ltp的包括测试case的类型和case列表。 整体情况 case主要分为\"commands\"、\"kdump\"、\"kernel\"、\"misc\"、\"network\"、\"open_posix_testsuite\"、\"realtime\"、\"lib\"等部分，主要内容如下： 分类 包含内容 commands ade cpio df eject gzip logrotate mail mkfs sshd tar unzip which at cron du fileutils insmod lsmod mkswap su tmp-tools wc kernel connectors controllers firmware hotplug input ipc logging mce-test module power_management sched syscalls tracing containers device-drivers fs include io lib mem numa pty security times misc crash f00f math network busy_poll dctcp iptables netstress nfsv4 rpc stress tcp_fstopen virt can dhcp iproute lib6 multicast nfs sockets tcp_cmds traceroute xinetd open_posix_testsuite functional tools bin conformance stress realtime perf profiles stress lib kdump commands 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which kernel 主要case包括: case 包含子case connectors connector pec containers libclone mountns mqns netns pidns share sysvipc userns utsname controllers cgroup cgroup_xattr cpuctl cpuset io-throttle memcg pids cgroup_fg cpuacct cpuctl_fj freezer libcontrollers memctl device-drivers acpi base cpufreq drm locking misc_modules pci tbio usb zram agp block dev_sim_framework nls rcu rtc uaccess v4l firmware fw_load_kernel fw_load_user fs acl dmapi ext4-new-features fs_blnd fs_inod fs_perms fsstress ftest iso9660 linktest mongo proc racer stram acls doio fs-bench fs_di fs_main fs_readonly fsx-linux inode lftest openfile quota_remount scsi hotplug cpu_hotplug memory_hotplug input input io aio direct_io disktest ltp-aiodio stress_cd stress_floppy writetest ipc pipeio semaphore logging kmsg mem cpuset mem mtest01 mtest06 oom shmt thp vma hugetlb ksm mmapstress mtest05 mtest07 page swapping tunable vmtests moudle create_module delete_module query_module numa numa power_management pm_ilb_test runpwtests01-06 runpwtests_exelusive01-06 pm_cpu_consolidation pm_include pm_sched_domain pty hangup ptem pty sched cfs-scheduler clisrv hypertherading nptl process_stress pthreads sched_stress tool security cap_bound filecaps integrity mmc_security prot_hsymlinks securbits smack tomoyo syscalls abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev timers clock_gettime clock_settime leapsec timer_create timer_delete timer_settime tracing ftrace misc case 包含子case crash crash f00f foof math abs atof float fptests nextafter network case 包含子case can filter-test dctcp dctcp dhcp dhcp_tests dhcp_lib dnsmasq_tests iproute ip_tests iptables iptables_tests lib6 asapi getaddrinfo in6 multicast mc_cmds mc_commo mc_gethost mc_member mc_opts netstress netstress nfs fsx-linux nfslock01 nfsstat01 nfs_stress nfsv4 acl locks rpc basic_tests rpc-tirpc sockets socket stress broken_ip dns ftp http icmp interface ipsec multicast ns-tools route ssh tcp udp tcp_cmds arping echo ftp netstat rcp rsh sendfile tcpdump trackpath clockdiff finger host ipneigh ping rdist rlogin rwho ssh telnet tcp_fastopen tcp_fastopen traceroute traceroute virt gre01 ipvlan macvlan macvtap vlan vxlan xinted xinted open_posix_testsuite case 包含子case bin run-all-posix-option-group-tests conformance behavior definitions interfaces functional mqueues semaphores threads timers stress mqueues semaphores signals threads timers realtime case 包含子case func async_handler hrtimer-prio matrix_mult periodic_cpu_load pi-tests prio-wake rt-migrate sched_jitter thrad_clock gtod_latency measurement pi_perf prio-preempt pthread_kill_latency sched_football sched_letency m4 m4 perf latency stress pi-tests 接下来会深入分析每个case的具体测试目的及内容。ltp测试用例主要采用shell和Ｃ编写。","tags":"自动化测试-LTP","title":"LTP－Case list"},{"url":"http://king32783784.github.io/2016/08/02/LTP/","text":"从本文开始，开始分析kernel部分的测试用例，该部分测试用例大部分为Ｃ语言编写，因此会穿插加入一定的Ｃ语言或unix环境编程的知识。 abort 设计说明 测试策略 Fork child. Child出现abort,检查返回状态 限制 Core file大小的限制必须大于０ abort 函数名: abort 功 能: 异常终止一个进程 用 法: void abort(void); abort()是使异常程序终止，同时发送SIGABRT信号给调用进程。 #include <stdlib.h> void abort ( void ); 该函数不返回 此函数将SIGABRT信号发送给调用进程（进程不应忽略此信号).ISO C规定，调用abort将向主机环境递送一个未成功终止的通知，其方法是调用raise(SIGABRT)函数。 ISO C要求若捕捉此信号而且相应信号处理程序返回，abort仍不会返回其调用者。如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、_Exit、longjmp或sigloogjmp.POSIX.1也说明 abort并不理会进程对此信号的阻塞和忽略。 让进程捕捉SIGABRT的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不在信号处理程序中终止自己，POSIX.1声明当信号处理程序返回时，abort终止该进程。 ISO C针对此函数的规范将下列问题留由实现决定： 是否要冲洗输出流以及是否删除临时文件。POSIX.1的要求更进一步，要求如果abort调用终止进程，则它对所有打开标准I/O流的效果应当与进程终止前对每个流调用fclose相同。 系统V早期的版本中，abort函数产生SIGIOT信号。更进一步，进程忽略此信号，或者捕捉它并从信号处理程序返回都是可能的，在返回情况下，abort返回到它的调用者。 4.3BSD产生SIGILL信号。在此之前，该函数解除对此信号的阻塞，将其配置恢复为SIG_DFL (终止并构造core文件)。这阻止一个进程忽略或捕捉此信号。 SVR4在产生此信号之前关闭所有I/O流。在另一方面，4.3+BSD则不做此操作。对于保护性的程序设计，如果希望刷新标准I/O流，则在调用abort之前要做这种操作。在err_dump函数中实现了这一点 因为大多数UNIX tmpfile(临时文件)的实现在创建该文件之后立即调用unlink，所以ANSI C关于临时文件的警告通常与我们无关。 abort的POSIX.1实现 #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> void abort ( void ) /*POSIX.1风格的abort()实现*/ { sigset_t mask ; struct sigaction action ; /* * Caller can't igore SIGABRT, if so reset to default. */ sigaction ( SIGABRT , NULL , & action ); if ( action . sa_handler == SIG_IGN ) { action . sa_handler == SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); } if ( action . sa_handler == SIG_DFL ) fflush ( NULL ) /* flush all open stdio stream */ /* * Caller can't block SIGABRT; make sure it's unblocked. */ sigfillset ( & mask ) sigdelset ( & mask , SIGABRT ); /* mask has only SIGABRT turned off */ sigprocmask ( SIG_SETMASK , & mask , NULL ); kill ( getpid (), SIGABRT ); /* send the signal */ /* * if we're here, process caught SIGABRT and returned. */ fflush ( NULL ); /*flush all open stdio streams*/ action . sa_handler = SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); /* reset to default */ sigprocmask ( SIG_SETMASK , & mask , NULL ); /* just in case ...*/ kill ( getpid (), SIGABRT ); /* and one more time*/ exit ( 1 ); /*this should never be executed...*/ 说明：首先查看是否将执行默认动作，若是则冲洗所有标准I/O流。这并不等价于对所有打开的流调用fclose(因为只冲洗，并不关闭它们），但是当进程终止时，系统会关闭所有打开的文件。如果进程捕捉此信号并返回， 那么因为进程产生了更多的输出，所以再一次冲洗所有的流。不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调用_exit或_Exit.这种情况下，内存中任何未冲洗的标准I/O缓冲区都被丢弃。我们假定捕捉此信号，而且_exit或_Exit的调用者并不想要冲洗缓冲区。 应用例子： #include <stdio.h> #include <stdlib.h> void main ( void ) { FILE * stream ; if (( stream = fopen ( \"NOSUCHF.ILE\" , \"r\" )) == NULL ) { perror ( \"Couldn't open file\" ); abort (); } } else fclose ( stream ); } 编译运行一下，看一下执行情况片段： execve(\"./test.o\", [\"./test.o\"], [/* 97 vars */]) = 0 open(\"NOSUCHF.ILE\", O_RDONLY) = -1 ENOENT (No such file or directory) dup(2) = 3 fcntl(3, F_GETFL) = 0x8402 (flags O_RDWR|O_APPEND|O_LARGEFILE) fstat(3, {st_mode=S_IFCHR|0600, st_rdev=makedev(136, 3), ...}) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd18aa86000 write(3, \"Couldn't open file: No such file\"..., 46Couldn't open file: No such file or directory ) = 46 close(3) = 0 munmap(0x7fd18aa86000, 4096) = 0 rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0 gettid() = 18489 tgkill(18489, 18489, SIGABRT) = 0 SIGABRT {si_signo=SIGABRT, si_code=SI_TKILL, si_pid=18489, si_uid=0} --- +++ killed by SIGABRT +++ 已放弃 abort测试代码说明 代码大体结构 |- macro || NUM || MIN_RLIMIT_CORE | |- variable || TCID || TST_TOTAL | |- function || main || setup || cleanup || do_child || instress 先看一下头文件： #include <sys/types.h> #include <sys/wait.h> #include <errno.h> #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/resource.h> #include \"test.h\" #include \"safe_macros.h\" 什么是头文件呢？ 在C语言家族程序中，头文件被大量使用。一般而言，每个C++/C程序通常由头文件(header files)和定义文件(definition files)组成。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明(declaration)，而定义文件用于保存程序的实现 (implementation) 让我们来看，经典程序 \"Hello world!\" 定义文件名\"First.c\" main() <sample-1> 看看上面的程序，没有.h文件,因为程序太简单，没有需要保存的声明。 文件名 First.c 变形 printStr() { printf(\"Hello world!\"); } main() { printStr() } <sample-2> 还是没有, 那就让我们把这个程序再稍微改动一下. 文件名 First.c main() { printStr() } printStr() { printf(\"Hello world!\"); } <sample-3> sample3和sample2是不同的，pritStr()函数定义的顺序不同。sample3是编译不通过的。这里面涉及作用域的问题。在这里只讲述与.h文件相关的顶层作用域。 顶层作用域就是从声明点延伸到源程序文本结束, 就printStr()这个函数来说，他没有单独的声明,只有定义,那么就从他定义的行开始,到first.c文件结束。sample2中，printStr的定义在main函数前面，所以作用域覆盖main函数，而sample3则没有。 这种情况怎么办呢? 有两种方法 ,一个pritStr函数定义到main函数之前，那就让我们来看另一个例子,让我们看看这个方法是不是在任何时候都会起作用. 文件名 First.c play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… } main() { play1() } <sample-4> 函数嵌套, 那么play1和play2这两个函数哪个放到前面呢? 这时就需要我们来使用第二种方法,使用声明. 文件名 First.c play1(); play2(); play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-5> 一个大型的软件项目,可能有几千个,上万个play, 而不只是play1,play2这么简单, 这样就可能有N个类似 play1(); play2(); 这样的声明, 这个时候就需要我们想办法把这样的play1(); play2(); 也另行管理, 而不是把他放在.c文件中, 于是.h文件出现了. 文件名 First.h play1(); play2(); 文件名 First.C #include \"first.h\" play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-6> 如在second.c中还有一个函数需要调用first.c文件中的play1函数, 如何实现呢? Sencond.h 文件 play1(); sencond.c文件 ***() { ……………. Play(); ………………. } <sample-7> 在sencond.h文件内声明play1函数，怎么能调用到first.c文件中的哪个play1函数中呢? 是不是搞错了，没有搞错, 这里涉及到c语言的另一个特性:存储类说明符. C语言的存储类说明符有以下几个, 我来列表说明一下 说明符 用法 Auto 只在块内变量声明中被允许, 表示变量具有本地生存期. Extern 出现在顶层或块的外部变量函数与变量声明中，表示声明的对象具有静态生存期, 连接程序知道其名字. Static 可以放在函数与变量声明中. 在函数定义时, 其只用于指定函数名,而不将函数导出到连接程序. 在函数声明中,表示其后面会有定义声明的函数, 存储类为static. 在数据声明中, 总是表示定义的声明不导出到连接程序. 无疑, 在sample7中的second.h和first.h中,需要我们用extern标志符来修饰play1函数的声明,这样,play1()函数就可以被导出到连接程序, 也就是实现了无论在first.c文件中调用,还是在second.c文件中调用,连接程序都会很聪明的按照我们的意愿,把他连接到first.c文件中的play1函数的定义上去, 而不必我们在second.c文件中也要再写一个一样的play1函数. 但随之有一个小问题, 在sample7中,我们并没有用extern标志符来修饰play1啊, 这里涉及到另一个问题, C语言中有默认的存储类标志符. C99中规定, 所有顶层的默认存储类标志符都是extern . 那么我们如何来区分哪个头文件中的声明在其对应的.c文件中有定义,而哪个又没有呢? 这也许不是必须的，因为无论在哪个文件中定义，聪明的连接程序都会义无返顾的帮我们找到，并导出到连接程序, 但我觉得他确实必要的. 因为我们需要知道这个函数的具体内容是什么,有什么功能, 有了新需求后我也许要修改他， 我需要在短时间内能找到这个函数的定义, 那么我来介绍一下在C语言中一个人为的规范: 在.h文件中声明的函数,如果在其对应的.c文件中有定义,那么我们在声明这个函数时,不使用extern修饰符, 如果反之,则必须显示使用extern修饰符. 这样,在C语言的.h文件中,我们会看到两种类型的函数声明. 带extern的,还不带extern的, 简单明了,一个是引用外部函数，一个是自己声明并定义的函数. 最终如下: Sencond.h 文件 Extern play1(); 那么多都是针对函数的，而实际上.h文件却不是为函数所专用的，还有全局变量. 在大型项目中，对全局变量的使用不可避免, 比如,在first.c中需要使用一个全局变量G_test, 那么我们可以在first.h中,定义 TPYE G_test. 与对函数的使用类似, 在second.c中我们的开发人员发现他也需要使用这个全局变量, 而且要与first.c中一样的那个, 如何处理? 对,我们可以仿照函数中的处理方法, 在second.h中再次声明TPYE G_test, 根据extern的用法,以及c语言中默认的存储类型, 在两个头文件中声明的TPYE G_test,其实其存储类型都是extern, 也就是说不必我们操心, 连接程序会帮助我们处理一切. 但我们又如何区分全局变量哪个是定义声明,哪个是引用声明呢?这个比函数要复杂一些, 一般在C语言中有如下几种模型来区分: 1、 初始化语句模型 顶层声明中，存在初始化语句是，表示这个声明是定义声明，其他声明是引用声明。C语言的所有文件之中，只能有一个定义声明。 按照这个模型，我们可以在first.h中定义如下TPYE G_test=1；那么就确定在first中的是定义声明，在其他的所有声明都是引用声明。 2、 省略存储类型说明 在这个模型中，所有引用声明要显示的包括存储类extern， 而每个外部变量的唯一定义声明中省略存储类说明符。 这个与我们对函数的处理方法类似，不再举例说明。 这里还有一个需要说明，数组全局变量。 在声明定义时，定义数组如下： int G_glob[100]; 在另一个文件中引用声明如下： int * G_glob; 在vc中，是可以编译通过的， 这种情况大家都比较模糊并且需要注意，数组与指针类似，但并不等于说对数组的声明起变量就是指针。 上面所说的的程序在运行时发现了问题，在引用声明的那个文件中，使用这个指针时总是提示内存访问错误，原来我们的连接程序并不把指针与数组等同，连接时，也不把他们当做同一个定义，而是认为是不相关的两个定义，当然会出现错误。正确的使用方法是在引用声明中声明如下： int G_glob[10]; 并且最好再加上一个extern，更加明了。 extern int G_glob[10]; 另外需要说明的是，在引用声明中由于不需要涉及到内存分配，可以简化如下，这样在需要对全局变量的长度进行修改时，不用把所有的引用声明也全部修改了。 extern int G_glob[]; 接下来，看一下linux环境编程头文件常用的有哪些？ linux常用头文件 POSIX标准定义的头文件 | 文件名 | 内容 | | ------- | -------- | dirent.h | 目录项 | fcntl.h | 文件控制 | fnmatch.h | 文件名匹配类型 | glob.h | 路径名模式匹配类型 | grp.h | 组文件 | <netdb.h> | 网络数据库操作 | <pwd.h> | 口令文件 | <regex.h> | 正则表达式 | <tar.h> | TAR归档值 | <termios.h> | 终端I/O | <unistd.h> | 符号常量 | <utime.h> | 文件时间 | <wordexp.h> | 字符扩展类型 | <arpa/inet.h> | INTERNET定义 | <net/if.h> | 套接字本地接口 | <netinet/in.h> | INTERNET地址族 | <netinet/tcp.h> | 传输控制协议定义 | <sys/mman.h> | 内存管理声明 | <sys/select.h> | Select函数 | <sys/socket.h> | 套接字借口 | <sys/stat.h> | 文件状态 | <sys/times.h> | 进程时间 | <sys/types.h> | 基本系统数据类型 | <sys/un.h> | UNIX域套接字定义 | <sys/utsname.h> | 系统名 | <sys/wait.h> | 进程控制 POSIX定义的XSI扩展头文件 | 文件名 | 内容 | | ------- | -------- | <cpio.h> | cpio归档值 | <dlfcn.h> | 动态链接 | <fmtmsg.h> | 消息显示结构 | <ftw.h> | 文件树漫游 | <iconv.h> | 代码集转换使用程序 | <langinfo.h> | 语言信息常量 | <libgen.h> | 模式匹配函数定义 | <monetary.h> | 货币类型 | <ndbm.h> | 数据库操作 | <nl_types.h> | 消息类别 | <poll.h> | 轮询函数 | <search.h>| 搜索表 | <strings.h> | 字符串操作 | <syslog.h> | 系统出错日志记录 | <ucontext.h> | 用户上下文 | <ulimit.h> | 用户限制 | <utmpx.h> | 用户帐户数据库 | <sys/ipc.h> | IPC(命名管道) | <sys/msg.h> | 消息队列 | <sys/resource.h>| 资源操作 | <sys/sem.h> | 信号量 | <sys/shm.h> | 共享存储 | <sys/statvfs.h> | 文件系统信息 | <sys/time.h> | 时间类型 | <sys/timeb.h> | 附加的日期和时间定义 | <sys/uio.h> | 矢量I/O操作 POSIX定义的可选头文件 | 文件名 | 内容 | | ------- | -------- | <aio.h> | 异步I/O | <mqueue.h> | 消息队列 | <pthread.h> | 线程 | <sched.h> | 执行调度 | <semaphore.h> | 信号量 | <spawn.h> | 实时spawn接口 | <stropts.h> | XSI STREAMS接口 | <trace.h> | 事件跟踪 C/C++头文件一览 C语言 | 文件名 | 内容 | | ------- | -------- | <assert.h>| 设定插入点 | <ctype.h> | 字符处理 | <errno.h> | 定义错误码 | <float.h> | 浮点数处理 | <iso646.h> | 对应各种运算符的宏 | <limits.h> | 定义各种数据类型最值的常量 | <locale.h> | 定义本地化C函数 | <math.h> | 定义数学函数 | <setjmp.h> | 异常处理支持 | <signal.h> | 信号机制支持 | <stdarg.h> | 不定参数列表支持 | <stddef.h> | 常用常量 | <stdio.h> | 定义输入／输出函数 | <stdlib.h>| 定义杂项函数及内存分配函数 | <string.h> | 字符串处理 | <time.h> | 定义关于时间的函数 | <wchar.h> | 宽字符处理及输入／输出 | <wctype.h> | 宽字符分类 传统C++ | 文件名 | 内容 | | ------- | -------- | <fstream.h> | 改用<fstream> | <iomanip.h> | 改用<iomainip> | <iostream.h> | 改用<iostream> | <strstrea.h> | 该类不再支持，改用<sstream>中的stringstream 标准C++ | 文件名 | 内容 | | ------- | -------- | <algorithm> | 通用算法 | <bitset> | 位集容器 | <cctype> | 字符处理 | <cerrno> | 定义错误码 | <cfloat> | 浮点数处理 | <ciso646> | 对应各种运算符的宏 | <climits> | 定义各种数据类型最值的常量 | <clocale> | 定义本地化函数 | <cmath> | 定义数学函数 | <complex> | 复数类 | <csignal> | 信号机制支持 | <csetjmp> | 异常处理支持 | <cstdarg> | 不定参数列表支持 | <cstddef> | 常用常量 | <cstdio> | 定义输入／输出函数 | <cstdlib> | 定义杂项函数及内存分配函数 | <cstring> | 字符串处理 | <ctime> | 定义关于时间的函数 | <cwchar> | 宽字符处理及输入／输出 | <cwctype> | 宽字符分类 | <deque> | STL 双端队列容器 | <exception> | 异常处理类 | <fstream> | 文件输入／输出 | <al> | STL 定义运算函数（代替运算符） | <limits> | 定义各种数据类型最值常量 | <list> | STL 线性列表容器 | <locale> | 本地化特定信息 | <map> | STL 映射容器 | <memory> | STL通过分配器进行的内存分配 | <new> | 动态内存分配 | <numeric> | STL常用的数字操作 | <iomanip> | 参数化输入／输出 | <iOS> | 基本输入／输出支持 | <iosfwd> | 输入／输出系统使用的前置声明 | <iostream> | 数据流输入／输出 | <istream> | 基本输入流 | <iterator> | STL迭代器 | <ostream> | 基本输出流 | <queue> | STL 队列容器 | <set> | STL 集合容器 | <sstream> | 基于字符串的流 | <stack> | STL 堆栈容器 | <stdexcept> | 标准异常类 | <streambuf> | /底层输入／输出支持 | <string> | 字符串类 | <typeinfo> | 运行期间类型信息 | <utility> | STL 通用模板类 | <valarray> | 对包含值的数组的操作 | <vector> | STL 动态数组容器 C99增加的部分 | 文件名 | 内容 | | ------- | -------- | <complex.h> | 复数处理 | <fenv.h> | 浮点环境 | <inttypes.h> | 整数格式转换 | <stdbool.h> | 布尔环境 | <stdint.h> | 整型环境 | <tgmath.h> | 通用类型数学宏 回到abort01的测试上来。先看一下执行情况： abort01 0 TINFO : Adjusting RLIMIT_CORE to 1048576 abort01 1 TPASS : abort dumped core abort01 2 TPASS : abort raised SIGIOT abort01 3 TPASS : abort dumped core abort01 4 TPASS : abort raised SIGIOT abort01 5 TPASS : abort dumped core abort01 6 TPASS : abort raised SIGIOT 程序后台执行片段 chdir(\"/tmp/aboeHLyFk\") = 0 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19587 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19587 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19587, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 1 TPASS : abort d\"..., 43abort01 1 TPASS : abort dumped core ) = 43 write(1, \"abort01 2 TPASS : abort r\"..., 45abort01 2 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19588 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19588 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19588, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 3 TPASS : abort d\"..., 43abort01 3 TPASS : abort dumped core ) = 43 write(1, \"abort01 4 TPASS : abort r\"..., 45abort01 4 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19589 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19589 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19589, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 5 TPASS : abort d\"..., 43abort01 5 TPASS : abort dumped core ) = 43 write(1, \"abort01 6 TPASS : abort r\"..., 45abort01 6 TPASS : abort raised SIGIOT ) = 45 unlink(\"core\") 从测试log来看，abort01主要进行abort\"dumped core\"、和\"raised SIGIOT\"两种测试，并且测试了３遍。０为setup打印信息。 #define NUM 3 /*定义fork进程的数量*/ char *TCID; /* tescase的名字*/ int TST_TOTAL; /* testcases数量 */ 主要函数 static void setup(void); static void cleanup(void); static void do_child(); static int instress(); int main(int argc, char *argv[]) 分别分析这几个函数 setup #define MIN_RLIMIT_CORE (1024 * 1024) static void setup(void) { struct rlimit rlim; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); if (rlim.rlim_cur < MIN_RLIMIT_CORE) { test_resm(TINFO, \"Adjusting RLIMIT_CORE to %i\", MIN_RLIMIT_CORE); rlim.rlim_cur = MIN_RLIMIT_CORE; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); } tst_tmpdir() } setup函数的目的是为了调整RLIMIT_CORE的大小。在Linux系统中，Resouce limit指在一个进程的执行过程中，它所能得到的资源的限制，比如进程的core file的最大值，虚拟内存的最大值等。Resouce limit的大小可以直接影响进程的执行状况。其有两个最重要的概念：soft limit 和 hard limit。 struct rlimit { rlim_t rlim_cur; rlim_t rlim_max; }; 是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件 数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。 tst_tmpdir函数说明一下，该函数用来为ltp测试程序创建临时目录，目录名case名称＋随机字母。 cleanup函数 static void cleanup(void) { unlink(\"core\") tst_rmdir(); } 该函数比较简单，用来清理产生的临时文件和软连接。可以做下试验，将main函数中的该函数注释掉，会在tmp下看到产生的core文件。 do_child函数 static void do_child(void) { abort() fprintf(stderr, \"\\tchild - abort failed.\\n\"); exit(1); } abort的调用，进程退出。 instress函数 static int instress(void) { test_resm(TINFO, \"System resources may be too low; fork(), select() etc are likely to fail.\"); return 1; } 系统资源比较低的情况， 出现fork()等调用失败时的处理。也是为兼容UCLINUK测试（如嵌入式系统）。 main函数 控制测试流程和主要的测试代码，以下将重点介绍一些代码片段。 #ifdef WCOREDUMP int core ; core = 0 ; #endif WCOREDUMP(status) 如果孩子进程产生核心转储文件则返回真。这个宏只应该在 WIFSIGNALED 返回真时调用。这个没有在 POSIX.1-2001 里指定并且在一些 UNIX 实现(如 AIX、SunOS)里也没有提供。只在 #ifdef WCOREDUMP ... #endif 内部使用。 #ifdef UCLINUX maybe_run_child ( & do_child , \"\" ); /* UCLINUX的情况 */ #endif setup (); /*调用setup函数*/ for ( i = 0 ; i < NUM ; i ++ ) { /*连续创建３个进程调用do_child函数*/ kidpid = FORK_OR_VFORK (); if ( kidpid == 0 ) { #ifdef UCLINUX if ( self_exec ( argv [ 0 ], \"\" )) { if ( ! instress ()) { perror ( \"fork failed\" ); exit ( 1 ); } } #else do_child (); //调用do_child()函数 #endif } } if ( kidpid < 0 ) if ( ! instress ()) tst_brkm ( TBROK | TERRNO , cleanup , \"fork failed\" ); count = 0 ; while (( child = wait ( & status )) > 0 ) count ++ ; if ( count != 1 ) { tst_brkm ( TBROK , cleanup , \"wrong # children waited on; got %d, expected 1\" , count ); } #ifdef WCOREDUMP core = WCOREDUMP ( status ); //WCOFEDUMP情况 #endif sig = WTERMSIG ( status ); } if ( WIFEXITED ( status )) ex = WEXITSTATUS ( status ); #ifdef WCOREDUMP if ( core == 0 ) { tst_brkm ( TFAIL , cleanup , \"Child did not dump core; exit code = %d, \" \"signal = %d\" , ex , sig ); } else if ( core != - 1 ) { tst_resm ( TPASS , \"abort dumped core\" ); //core值等于０，则没有正常产生core文件，如果core不等于０且不等于-1，说明正常产生了core文件 } #endif if ( sig == SIGIOT ) { tst_resm ( TPASS , \"abort raised SIGIOT\" ); //发出的信号如果为SIGIOT说明信号触发正常 } else { tst_brkm ( TFAIL , cleanup , \"Child did not raise SIGIOT (%d); exit code = %d, \" \"signal = %d\" , SIGIOT , ex , sig ); } } abort测试分析结束。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-abort"},{"url":"http://king32783784.github.io/2016/08/05/LTP/","text":"accept用例分析 case本身说明： Verify that accept() returns the proper errno for various failure cases 验证accept()是否返回正确的errno. 测试log accept01 1 TPASS : bad file descriptor successful accept01 2 TPASS : bad file descriptor successful accept01 3 TPASS : invalid socket buffer successful accept01 4 TPASS : invalid salen successful accept01 5 TPASS : invalid salen successful accept01 6 TPASS : no queued connections successful accept01 7 TPASS : UDP accept successful ~ 测试错误类型包括: bad file descriptor、invalid socket buffer、invalid salen、no queued connections、 UDP accept等 accept函数 accept() 接收一个套接字中已建立的连接 使用格式 #include <sys/types.h> #include <sys/socket.h> int accept ( int sockfd , struct sockaddr * addr , socklen_t * addrlen ); 功能参数描述 accept()系统调用主要用在基于链接的套接字类型，比如SOCK_STREAM和SOCK_SEQPACKET.它提取出所监听套接字的等待连接队列中第一个连接请求，创建一个新的套接字，并返回指向该套接字的文件描述符。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。 备注： 新建立的套接字准备发送send()和接收数据recv(). 参数： sockfd, 利用系统调用socket()建立的套接字描述符，通过bind()绑定到一个本地地址（一般为服务器的套接字），并且通过listen()一直在监听连接。 addr, 指向struct sockaddr的指针，该结构用通讯层服务器对等套接字的地址（一般为客户端地址）填写，返回地址addr的确切格式由套接字的地址类别（比如tcp或udp)决定；若addr为NULL，没有有效地址填写，这种情况下，addrlen也不使用，应该置为NULL； 备注： addr是个指向局部数据结构sockaddr_in的指针，这就是要求接入的信息本地的套接字（地址和指针） addrlen, 一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值，函数返回时包含对等地址（一般为服务器地址）的实际数值； 备注： addrlen 是个局部整型变量， 设置为sizeof(struct sockaddr_in) 如果队列中没有等待的连接，套接字也没有被标记为Non-blocking, accept()会阻塞调用函数知道连接出现；如果套接字被标记为Non-blocking, 队列中也没有等待的连接，accept返回错误EAGAIN或EWOULDBLOCK. 备注： 一般来说，实现时accept()为阻塞函数，当监听socket调用accept()时，它先到自己的receive_buf中查看是否有连接数据包； 若有，把数据拷贝处理啊，删掉接收到的数据包，创建新的socket与客户发来的地址建立链接； 若没有，就阻塞等待； 为了在套接字中有到来的连接时得到通知，可以使用select()或poll().当尝试建立新连接时，系统发送一个可读事件，然后调用accept()为该链接获取套接字。另一种方法是，当套接字中有连接到来时设定套接字发送SIGIO信号。 返回值 成功时，返回非负整数，该整数是接收到套接字的描述符；出错时，返回－１，相应的设定全局变量errno. 错误处理 Linux下，accept()把已等待的网络错误传给新建立的连接，当作是accept()返回的错误。这与其他的BSD实现是不同的。为了可靠运行，应该在accept()之后检测协议已定义的一些网络错误，并把这些错误当作EAGAIN并重试。对于tcp/ip协议来说，主要有：ENETDOWN,EPROTO,ENOPROTOOPT,EHOSTDOWN,ENONET,EHOSTUNREACH,EOPNOTSUPP和ENETUNREACH。 accept01.c代码分析 主要函数包括mian、setup、cleanup、setup0、cleanup0、setup1、cleanup1、setup2、setup3 test_case_t结构体 struct test_caset { int domain; /*AF_INIT, AF_UNIX,....*/ int type; /* SOCK_STREAM, SOCK_DGRAM...*/ int proto; /* protocol number(usually 0 = default) */ struct sockaddr *sockaddr; /*socket address buffer */ socklen_t *salen; /* accept's 3rd argument */ int retval; /* syscall return value */ int experrno; /* expected errno */ void (*setup)(void); void(*cleanup)(void); char *desc; } tdat[] = { {PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EBADF, setup0, cleanup0, \"bad file descriptor\"}, //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, ENOTSOCK, setup0, cleanup0, \"bad file descriptor\"}, { //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)3, &sinlen, -1, EINVAL, setup1, cleanup1, \"invalid socket buffer\"}, { //无效套接字缓存区 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, (socklen_t *) 1, -1, EINVAL, setup1, cleanup1, \"invalid salen\"}, { //无效的salen PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup2, cleanup1, \"invalid salen\"}, { PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup3, cleanup1, \"no queued connections\"}, { //队列中没有等待的连接 PF_INET, SOCK_DGRAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EOPNOTSUPP, setup1, cleanup1, \"UDP accept\"},}; int TST_TOTAL = sizeof(tdat) / sizeof(tdat[0]); /*通过数组的长度，计算测试用例数量*/ 先定义测试case需要的结构体，然后进行了 结构体初始化 ，定义了7种错误类型，对应7个测试case，和测试log是对应的。 顺便看一下 SOCK_STREAM和SOCK_DGRAM的区别： sock_stream 是有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料（如文件）传送。 sock_dgram 是无保障的面向消息的socket ， 主要用于在网络上发广播信息。 SOCK_STREAM是基于TCP的，数据传输比较有保障。SOCK_DGRAM是基于UDP的，专门用于局域网，基于广播 SOCK_STREAM 是数据流,一般是tcp/ip协议的编程,SOCK_DGRAM分是数据抱,是udp协议网络编程 再看说一下AF_INET和PF_INET的差别： 在Unix/Linux系统中，在不同的版本中这两者有微小差别.对于BSD,是AF,对于POSIX是PF.理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx 分别看一下这几个错误码 EBADF: 当作为参数的套接字不是一个有效的文件描述符(在Linux下用文件描述符来表示设备文件和普通文件。文件描述符是一个整型的数据，所有对文件的操作都通过文件描述符实现。文件描述符是文件系统中链接用户空间和内核空间的枢纽)时，抛出这个错误码。无效的文件描述符是什么意思呢？就是fd已经close的，或者本身就不是个有效的socket的fd。 ENOTSOCK: 在非socket上执行socket操作。 EINVAL： 无效参数。提供的参数非法。有时也会与socket的当前状态相关，如一个socket并没有进入listening状态，此时调用accept，就会产生EINVAL错误。 EOPNOTSUPP: 不支持的操作。 引用对象的类型不支持尝试的操作。通常，这发生在套接字描述符不支持此操作，例如，试着接受数据报套接字上的连接的套接字。 接下来看几个辅助函数。 1.setup函数 static void setup(void) { TEST_PAUSE; /*初始化本地 sockaddr*/ sin0.sin_family = AF_INET; //绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_INET，即使用IP sin0.sin_port = 0; sin0.sin_addr.s_addr = INADDR_ANY; //指定地址为0.0.0.0的地址 } TEST_PAUSE是一个 宏定义 ，代表usc_global_setup_hook()函数。作用是当设置了暂停标志后，暂停 SIGUSR1 ，当新的信号来时，再继续。下面是usc_global_setup_hook函数实现： #define TEST_PAUSE usc_global_setup_hook(); int usc_global_setup_hook () int usc_global_setup_hook ( void ) { #ifndef UCLINUX /*定义temp变量存储信号旧信号的动作，中断后恢复*/ int ( * _TMP_FUNC ) ( void ); /*中断等待sigusr1.*/ if ( STD_PAUSE ) { _TMP_FUNC = ( int ( * )()) singnal ( SIGUSR1 , STD_go ); pause () signal ( SIGUSR1 , ( void ( * )()) _TMP_FUNC ); } if ( STD_TP_sbrk ) || STD_LP_sbrk ) STD_start_break = sbrk ( 0 ); /*获取原始sbreak大小*/ if ( STD_TP_sbrk ){ sbrk ( STD_TP_sbrk ) : if ( Debug ) print ( \"after sbrk(%d) \\n \" , STD_TP_sbrk ); } #endif return 0 ; } 2.setup0函数case1测试前设置 static void setup0(void) 3.setup2 static void setup2(void) { setup1(); //调用setup1()获取套接字s sinlen = 1; //s置为无效 } 4.setup3 static void setup3(void) { int one = 1; setup1(); SAFE_IOCTL(cleanup, s, FIONBIO, &one); } SAFE_IOCTL #define SAFE_IOCTL ( cleanup_fn , fd , request , ...) \\ ( { int ret = ioctl ( fd , request , __VA_ARGS__ ); \\ ret < 0 ? \\ tst_brkm ( TBROK | TERRNO , cleanup_fn , \\ \"ioctl(%i,%s,...) failed\" , fd , #reques t ) \\ safe_ : ret ;} ) 6.cleanup、cleanup0, cleanup1 static void cleanup(void) { } static void cleanup0(void) { s = -1; } static void cleanup1(void) { (void)close(s); s = -1; } 重新设置s = -1 OK,现在看一下main函数。 int main(int ac, char *av[]) { int lc; tst_parse_opts(ac, av, NULL, NULL); //ltp参数解析函数 setup(); for (lc = 0; TEST_LOOPING(lc); ++lc){ test_count = 0; for (testno = 0; testno < TST_TOTAL; ++testno){ tdat[testno].setup(); TEST(accept(s, tdat[testno].sockaddr, tdat[testno].salen)); if (TEST_RETURN > 0) TEST_RETURN = 0; if (TEST_RETURN != tdat[testno].retval || (TEST_RETURN < 0 && TEST_ERRNO != tdat[testno].experrno)){ \"%ld(expected %d), errno %d (expected\" \"%d)\", tdat[testno].desc, TEST_RETURN, tdat[testno].desc, TEST_ERRNO, tdat[testno].experrno); } else { tst_resm(TPASS, \"%s successful\", tdat[testno].desc); } tdat[testno].cleanup(); } } cleanup(); tst_exit(); } 先看一下tst_parse_opts()函数 void tst_parse_opts(int argc, char *argv[], const option_t *user_optarg, void (*user_help)(void)) { const char *msg; msg = parse_opts(argc, argv, user_optarg, user_help); //parse_opts是参数解析函数，后面文章再进行介绍 if(msg) tst_brkm(TBROK, NULL, \"OPTION PARSING ERROR - %s \", msg); } 接下来调用setup，准备测试环境，初始化本地IP地址。然后是一个嵌套的两层循环，第一次是测试次数的遍历，通过TEST_LOOPING实现。 TEST_LOOPING是int usc_test_looping(int counter)函数，该函数后面的文章再进行解释。tst_count初始化为0。 第二层循环是遍历case数组。tdat[testno].setup()，调用对应setup准备case的特殊设置。 TEST启动测试， #define TEST(SCALL) \\ do { \\ errno = 0; \\ TEST_RETURN = SCALL; \\ TEST_ERRNO = errno; \\ } 然后将tdat中的对应参数，分别执行accept函数，如果预期的返回值不符或则返回值小于0且和预期的错误类型不匹配，则调用tst_resm()，进行出错处理。tst_resm将在后面进行分析。如果符合预期，则打印TPASS，然后调用tdat[testno].clearnup()分别清理环境。 最后调用cleanup()清理，tst_exit()退出，tst_exit()在单独分析ltp测试框架时分析。 到此，我们就清楚accept测试的内容了。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-accept()"},{"url":"http://king32783784.github.io/2016/06/02/LTP/","text":"本节将重点分析commands部分的用例。 Command主要用例 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which ade ade包括对ar、file、ld、ldd、nm、objdump、size命令的验证测试。 ar ar命令是Linux的一个备份压缩命令，可以创建、修改备存文件(archive)，或从备存文件中抽取成员文件。备存文件以一定的结构打包一个至多个其它文件（即成员文件），且成员文件的内容、模式、时间戳等信息将被保存在备存文件中。常见的应用是，使用ar命令将多个目标文件（ .o）打包为静态链接库文件（ .a)。 引出一个问题，库是什么？本质上讲库是一种可执行代码的二进制形式，可以被操作系统加载到内存执行。linux库分为两种：静态库和动态库。区别在于，静态库是在编译过程中已经被载入可执行程序，可执行程序一般较大；共享库（动态库）是可执行程序运行时才加载到内存，编译时仅简单的引用，因此可执行程序较小。库是如何产生的呢？静态库的后缀是.a，它的产生分为两步：１．由源码编译生成一堆.o，每个.o包含这个编译单元的符号表；２．ar命令将很多.o文件打包转换为.a,形成静态库。 ar命令的常用参数 在 ar 命令中，可以从集 cClosTv 中指定任何数量的可选标志。必须从标志集 dhmopqrstwx 中指定一个标志。如果选择-m 或 -r 标志，您可能还要指定一个位置标志（-a 、-b 或-i ）；对于 -a 、-b 或-i 标志，您必须还指定在 ArchiveFile （PositionName ）中一个文件的名称，此名称紧跟在标志列表后，并由空格隔开。 -a PositionName 在 PositionName 参数标识的现有文件后安置指定的文件。 -b PositionName 在 PositionName 参数标识的现有文件前安置指定的文件。 -c 禁止在创建库 时产生的正常消息。 -C 阻止解压缩的文件替换文件系统中同名的文件。 -d 从库中删除指定的文件。 -g 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-g 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成小格式，这样该标志可用来将大格式压缩文档转换成小格式压缩文档。包含 64 位XCOFF 对象的压缩文档不能创建成或转换至小格式。 -h 将指定的文件的成员报头中的修改时间设置为当前日期和时间。如果不指定任何文件名称，则 ar 命令设置所有成员报头的时间戳记。此标志不能和-z 标志一起使用。 -i PositionName 在 PositionName 参数标识的现有文件前安置指定的文件（和 -b 相同）。 -l 将临时文件置于当前（本地）目录中，而非 TMPDIR 目录中（缺省为 /tmp ）。 -m 将指定的文件移动到库中的某个其它位置。缺省情况下，它将指定的文件移动到库的末尾。使用位置标志（abi ）来指定某个其它位置。 -o 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-o 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成大格式，这样该标志可用来将小格式压缩文档转换成大格式压缩文档。 -p 将 Files 参数中指定的文件的内容或在 ArchiveFile 参数中指定的所有文件（如果您不指定任何文件）都写至标准输出。 -q 将指定的文件添加到库的末尾。另外，如果指定同一个文件两次，它可能被放入库中两次。 -r 如果指定的文件已经存在于库中，则替换它。因为指定的文件在库中占据它们替换的文件的同一个位置，位置标志没有任何附加的影响。当和 -u 标志（更新）一起使用时，-r 标志仅替换自从最后一次添加到库中以后修改的文件。 如果指定的文件不存在于库中，则 ar 命令添加它。在这种情况下，位置标志影响放置。如果不指定位置，则将新文件置于库的末尾。如果指定同一个文件两次，它可能被放入库中两次。 -s 无论 ar 命令是否修改了库内容都强制重新生成库符号表。请在库上使用 strip 命令之后，使用此标志来恢复库符号表。 -t 将库的目录写至标准输出。如果指定文件名称，则仅显示指定的那些文件。如果不指定任何文件，-t 标志列出库中的所有文件。 -T 如果压缩文档成员名称比文件系统支持的长，则允许文件名称截短。此选项无效，因为文件系统支持的名称长度等于 255 个字符的最大压缩文档成员名称。 -u 仅复制自它们最后一次复制起更改的文件（请参阅先前讨论过的 -r 标志）。 -v 将建立新库的详细的逐个文件的描述写至标准输出。当和 -t 标志一起使用时，它给出类似于 ls -l 命令给出的长列表。当和 -x 标志一起使用时，它在每个文件前加一个名称。当和 -h 标志一起使用，它列出成员名称和更新的修改时间。 -w 显示压缩文档符号表。每个符号和其中定义此符号的文件的名称一起列出。 -x 通过将指定的文件复制到当前目录来解压缩它们。这些副本和原始文件（保留在库中）具有相同的名称。如果不指定任何文件，-x 标志复制库中的所有文件。此过程不会更改库。 -Xmode 指定 ar 应检查的目标文件的类型。mode 必须是以下项之一： 32 仅处理 32 位目标文件 64 仅处理 64 位目标文件 32_64 处理 32 位 和 64 位目标文件 缺省值是处理 32 位目标文件（忽略 64 位对象）。mode 还可以用 OBJECT_MODE 环境变量来设置。例如，OBJECT_MODE=64 使 ar 处理任何 64 位对象并忽略 32 位对象。-X 标志覆盖 OBJECT_MODE 变量。 -z 创建压缩文档的临时副本并对副本执行所有要求的修改。当所有操作成功完成时，压缩文档的工作副本覆盖原始副本。此标志不能和 -h 标志一起使用。 ArchiveFile 指定压缩文档文件名称；必需。 MemberName ... 各压缩文档成员的名称。 示例１．ar rcs libxxxx.a xx1.o xx2.o 参数r: 在库中插入模块（替换）。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 参数c: 创建一个库。不管库是否存在，都将创建。 参数s: 创建目标文件索引 这在创建较大的库时能加快时间。（补充：如果不需要创建索引，可改成大写S参数；如果。a文件缺少索引，可以使用ranlib命令添加） 示例２．创建一个库 ar -v -q lib.a strlen.o strcpy.o 如果 lib.a 库不存在，则此命令创建它，并将文件 strlen.o 和 strcpy.o 的副本输入其中。如果 lib.a 库存在，则此命令在不检查相同成员的情况下，将新的成员添加到末尾。v 标志设置详细方式，在此方式中ar 命令在其进行时显示进程报告。 示例３．显示库的目录 ar -v -t lib.a 此命令列出了 lib.a 库的目录，显示类似于 ls -l 命令的输出的长列表。要只列出成员文件名称，则省略-v 标志。 示例4. 替换或添加新成员到库中 ar -v -r lib.a strlen.o strcat.o 此命令替换成员 strlen.o 和 strcat.o 。如果 lib.a 如示例 1 中显示的那样创建，则替换strlen.o 成员。因为不存在名为 strcat.o 的成员，所以它被添加到库的末尾。 示例５. 指定在何处插入新成员 ar -v -r -b strlen.o lib.a strcmp.o 此命令添加 strcmp.o 文件，并将该新成员置于 strlen.o 成员之前。 示例６．要更新一个已经更改过的成员 ar -v -r -u lib.a strcpy.o 此命令替换现有 strcpy.o 成员，但仅当文件 strcpy.o 自从最后一次添加到库后已经修改时才替换它。 示例７ 要更改库成员的顺序 ar -v -m -a strcmp.o lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 移动到紧跟在 strcmp.o 成员之后的位置。保留 strcat.o 和 strcpy.o 成员的相对顺序。换句话说，如果在移动之前strcpy.o 成员在 strcat.o 成员之前，那么（移动后）它依旧如此。 示例８ 要解压缩库成员 ar -v -x lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 分别复制到名为 strcat.o 和 strcpy.o 的文件。 示例９ 要解压缩并重命名一个成员 ar -p lib.a strcpy.o >stringcopy.o 此命令将成员 strcpy.o 复制到一个名为 stringcopy.o 的文件。 示例10 要删除一个成员 ar -v -d lib.a strlen.o 此命令从 lib.a 库中删除成员 strlen.o 。 示例11 要从多个用 ld 命令创建的共享模块中创建一个压缩文档库 ar -r -v libshr.a shrsub.o shrsub2.o shrsub3.o ... 此命令从名为 shrsub.o 、shrsub2.o 、shrsub3.o 等等的共享模块中创建名为libshr.a 的压缩文档库。要编译并链接使用 libshr.a 压缩文档库的 main 程序，请使用以下命令： cc -o main main.c -L/u/sharedlib -lshr main 程序现在是可执行的。main 程序引用的任何符号（包含在libshr.a 压缩文档库中）已经因延迟分辨率而作了标记。-l 标志指定应在libshr.a 库中搜索这些符号。 示例12 要列出 lib.a 的内容（忽略任何 32 位目标文件） ar -X64 -t -v lib.a 要从 lib.a 解压缩所有 32 位的目标文件 ar -X32 -x lib.a 要列出 lib.a 中的所有文件，无论是 32 位、64 位或非对象，请输入： ar -X32_64 -t -v lib.a 示例13 在shell脚本中使用 Bash代码 OS= uname -r ar rcs libhycu.a.$OS *.o 示例14 在makefile中使用 Makefile代码 $（BIN1）: $（BIN1_OBJS） ar rcs $@ $&#94; 示例15 创建并使用静态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 如果test.c无误，就会得到test.o这个目标文件。 第三步：由。o文件创建静态库。 ar rcs libtest.a test.o 第四步：在程序中使用静态库。 gcc -o main main.c -L. -ltest 因为是静态编译，生成的执行文件可以独立于。a文件运行。 第五步：执行。 ./main 示例16 创建并使用动态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 前面两步与创建静态库一致。 第三步：由。o文件创建动态库文件。 gcc -shared -fPIC -o libtest.so test.o 第四步：在程序中使用动态库。 gcc -o main main.c -L. -ltest 当静态库和动态库同名时，gcc命令将优先使用动态库。 第五步：执行。 LD_LIBRARY_PATH=. ./main 接下来，看一下ltp是如何测试ar命令的。 ar文件下包括： ar01 file0.in file10.in file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in Makefile等文件，其中ar01是shell编写的测试脚本。 测试目的，测试ar命令的不同选项的功能。测试策略，通过比较单独指定参数和组合参数测试结果进行判断，如果相同测试通过，如果不同，测试失败。 ar测试项的参数为: export TCdat=$LTPROOT/testcases/bin; ar01 直接执行ar01即可。 测试条件，系统存在ar命令。在运行config时，会进行check:如 configure : 4165 : checking for ar configure : 4181 : found /bin/ ar configure : 4192 : result : ar 程序分析： 创建用到的临时文件 LIST=\"file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in file10.in\" LIST=\" $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST \" # Setup function setup() { for i in $ LIST ;do touch $ i done } 结果判定，判断子case的返回值是否为０，TCRESULT为标志位，初始值为０，出错TCRESULT置为１，不同测试内容分别返回不同的编号。 # Cleanup funciton cleanup() { if [ $ TCRESULT = 0 ];then echo \"-----------ar command passed the system test --------\" exit 0 else echo \"-----------ar command failed the system test --------\" exit 1 fi } crtest() { if [ $ ? -ne 0] then TCRESULT=1 echo \"FAIL - could not create lib.a\" cleanup fi } ttest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not output table from lib.a to lib.a.stdout\" cleanup fi } rtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not add file into lib.a\" cleanup fi } mtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not move file into lib.a\" cleanup fi } 通过结果判定的设置来看，主要验证ar命令的库的创建、库列表信息导出、往库中添加文件、移除库中的文件。 测试代码片段： 标志\"a\"：在 PositionName 参数标识的现有文件后安置指定的文件。 ar -cr $ TCtmp /lib.a file1.in file3.in crtest ar -ra file1.in $ TCtmp /lib.a file2.in rtest ar -t $ TCtmp /lib.a > $ TCtmp /lib.a.stdout tttest if diff -b $ TCtmp /lib.a.exp $ TCtmp /lib.a.stdout > /dev/null 2>&1 then echo \"-)1\" else TCRESULT=1 echo \"FAIL -ar with -a option does not place file after \"posname\" fi 具体测试内容列表： （１）The 'a' flag causes files to be placed after 'posname'. （２）The 'a' flag with the 'm' option causes files to be moved after 'posname' （３）The 'b' flag causes files to be placed before 'posname'. （４）The 'b' flag with 'm' option causes files to be moved before 'posname'. （５）-c option suppress the messages （６）The 'qc' option causes suppresion of the default message when 'afile' is created （７）The -d option deletes files from archive when names are specified. （８）The -d option does not delete files from archive when no names are specified. （９）The -d does not affect behaviour of -s option. （10）The 'i' flag causes files to be placed before 'posname'. （11) The 'i' flag with 'm' option causes files to be moved before 'posname'. (12) m option moves the files to end of the archive (13) The -p option causes only printing of contents of file contained in archive. (14) The -p does not affect behaviour of -s option. (15) The command 'ar -q afile name' appends name to the end of 'afile'. (16) q option does not affect the behaviour of option s (17) The -s causes regeneration of symbol table even if a symbol table exists. (18) ar with -t print as desired (19) The -t does not affect behaviour of -s option. (20)The 'u' flag causes files only with later modification date than in archive are replaced. (21) ar with -v flag to print a line for each file (22) The -v option produces a verbose listing like ls -n (23) The 'v' option causes the 'x' option to display a filename for each file extracted. (24) The command 'ar -x afile ' causes all files from the archive to be extracted. (25) The command 'ar -x afile name name' causes only named files from the archive to be extracted. (26) This test will fail under pan, so it's commented out by default. (27) Signal SIGHUP (28) Signal SIGQUIT (29) Signal SIGHUP; ar should not remove archive that existed before invocation. (30) Signal SIGINIT; ar should not remove archive that existed before invocation. (31) Signal SIGQUIT; ar should not remove archive that existed before invocation.","tags":"自动化测试-LTP","title":"LTP－Command"},{"url":"http://king32783784.github.io/2016/06/01/LTP/","text":"该topic将深入分析ltp的测试内容，着重于具体每个case的测试内容及测试方法。通过对ltp case的分析，加强linux系统的理解和用例设计。本节主要整理ltp的包括测试case的类型和case列表。 整体情况 case主要分为\"commands\"、\"kdump\"、\"kernel\"、\"misc\"、\"network\"、\"open_posix_testsuite\"、\"realtime\"、\"lib\"等部分，主要内容如下： 分类 包含内容 commands ade cpio df eject gzip logrotate mail mkfs sshd tar unzip which at cron du fileutils insmod lsmod mkswap su tmp-tools wc kernel connectors controllers firmware hotplug input ipc logging mce-test module power_management sched syscalls tracing containers device-drivers fs include io lib mem numa pty security times misc crash f00f math network busy_poll dctcp iptables netstress nfsv4 rpc stress tcp_fstopen virt can dhcp iproute lib6 multicast nfs sockets tcp_cmds traceroute xinetd open_posix_testsuite functional tools bin conformance stress realtime perf profiles stress lib kdump commands 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which kernel 主要case包括: case 包含子case connectors connector pec containers libclone mountns mqns netns pidns share sysvipc userns utsname controllers cgroup cgroup_xattr cpuctl cpuset io-throttle memcg pids cgroup_fg cpuacct cpuctl_fj freezer libcontrollers memctl device-drivers acpi base cpufreq drm locking misc_modules pci tbio usb zram agp block dev_sim_framework nls rcu rtc uaccess v4l firmware fw_load_kernel fw_load_user fs acl dmapi ext4-new-features fs_blnd fs_inod fs_perms fsstress ftest iso9660 linktest mongo proc racer stram acls doio fs-bench fs_di fs_main fs_readonly fsx-linux inode lftest openfile quota_remount scsi hotplug cpu_hotplug memory_hotplug input input io aio direct_io disktest ltp-aiodio stress_cd stress_floppy writetest ipc pipeio semaphore logging kmsg mem cpuset mem mtest01 mtest06 oom shmt thp vma hugetlb ksm mmapstress mtest05 mtest07 page swapping tunable vmtests moudle create_module delete_module query_module numa numa power_management pm_ilb_test runpwtests01-06 runpwtests_exelusive01-06 pm_cpu_consolidation pm_include pm_sched_domain pty hangup ptem pty sched cfs-scheduler clisrv hypertherading nptl process_stress pthreads sched_stress tool security cap_bound filecaps integrity mmc_security prot_hsymlinks securbits smack tomoyo syscalls abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev timers clock_gettime clock_settime leapsec timer_create timer_delete timer_settime tracing ftrace misc case 包含子case crash crash f00f foof math abs atof float fptests nextafter network case 包含子case can filter-test dctcp dctcp dhcp dhcp_tests dhcp_lib dnsmasq_tests iproute ip_tests iptables iptables_tests lib6 asapi getaddrinfo in6 multicast mc_cmds mc_commo mc_gethost mc_member mc_opts netstress netstress nfs fsx-linux nfslock01 nfsstat01 nfs_stress nfsv4 acl locks rpc basic_tests rpc-tirpc sockets socket stress broken_ip dns ftp http icmp interface ipsec multicast ns-tools route ssh tcp udp tcp_cmds arping echo ftp netstat rcp rsh sendfile tcpdump trackpath clockdiff finger host ipneigh ping rdist rlogin rwho ssh telnet tcp_fastopen tcp_fastopen traceroute traceroute virt gre01 ipvlan macvlan macvtap vlan vxlan xinted xinted open_posix_testsuite case 包含子case bin run-all-posix-option-group-tests conformance behavior definitions interfaces functional mqueues semaphores threads timers stress mqueues semaphores signals threads timers realtime case 包含子case func async_handler hrtimer-prio matrix_mult periodic_cpu_load pi-tests prio-wake rt-migrate sched_jitter thrad_clock gtod_latency measurement pi_perf prio-preempt pthread_kill_latency sched_football sched_letency m4 m4 perf latency stress pi-tests 接下来会深入分析每个case的具体测试目的及内容。ltp测试用例主要采用shell和Ｃ编写。","tags":"自动化测试-LTP","title":"LTP－Case list"},{"url":"http://king32783784.github.io/2016/08/02/LTP/","text":"从本文开始，开始分析kernel部分的测试用例，该部分测试用例大部分为Ｃ语言编写，因此会穿插加入一定的Ｃ语言或unix环境编程的知识。 abort 设计说明 测试策略 Fork child. Child出现abort,检查返回状态 限制 Core file大小的限制必须大于０ abort 函数名: abort 功 能: 异常终止一个进程 用 法: void abort(void); abort()是使异常程序终止，同时发送SIGABRT信号给调用进程。 #include <stdlib.h> void abort ( void ); 该函数不返回 此函数将SIGABRT信号发送给调用进程（进程不应忽略此信号).ISO C规定，调用abort将向主机环境递送一个未成功终止的通知，其方法是调用raise(SIGABRT)函数。 ISO C要求若捕捉此信号而且相应信号处理程序返回，abort仍不会返回其调用者。如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、_Exit、longjmp或sigloogjmp.POSIX.1也说明 abort并不理会进程对此信号的阻塞和忽略。 让进程捕捉SIGABRT的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不在信号处理程序中终止自己，POSIX.1声明当信号处理程序返回时，abort终止该进程。 ISO C针对此函数的规范将下列问题留由实现决定： 是否要冲洗输出流以及是否删除临时文件。POSIX.1的要求更进一步，要求如果abort调用终止进程，则它对所有打开标准I/O流的效果应当与进程终止前对每个流调用fclose相同。 系统V早期的版本中，abort函数产生SIGIOT信号。更进一步，进程忽略此信号，或者捕捉它并从信号处理程序返回都是可能的，在返回情况下，abort返回到它的调用者。 4.3BSD产生SIGILL信号。在此之前，该函数解除对此信号的阻塞，将其配置恢复为SIG_DFL (终止并构造core文件)。这阻止一个进程忽略或捕捉此信号。 SVR4在产生此信号之前关闭所有I/O流。在另一方面，4.3+BSD则不做此操作。对于保护性的程序设计，如果希望刷新标准I/O流，则在调用abort之前要做这种操作。在err_dump函数中实现了这一点 因为大多数UNIX tmpfile(临时文件)的实现在创建该文件之后立即调用unlink，所以ANSI C关于临时文件的警告通常与我们无关。 abort的POSIX.1实现 #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> void abort ( void ) /*POSIX.1风格的abort()实现*/ { sigset_t mask ; struct sigaction action ; /* * Caller can't igore SIGABRT, if so reset to default. */ sigaction ( SIGABRT , NULL , & action ); if ( action . sa_handler == SIG_IGN ) { action . sa_handler == SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); } if ( action . sa_handler == SIG_DFL ) fflush ( NULL ) /* flush all open stdio stream */ /* * Caller can't block SIGABRT; make sure it's unblocked. */ sigfillset ( & mask ) sigdelset ( & mask , SIGABRT ); /* mask has only SIGABRT turned off */ sigprocmask ( SIG_SETMASK , & mask , NULL ); kill ( getpid (), SIGABRT ); /* send the signal */ /* * if we're here, process caught SIGABRT and returned. */ fflush ( NULL ); /*flush all open stdio streams*/ action . sa_handler = SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); /* reset to default */ sigprocmask ( SIG_SETMASK , & mask , NULL ); /* just in case ...*/ kill ( getpid (), SIGABRT ); /* and one more time*/ exit ( 1 ); /*this should never be executed...*/ 说明：首先查看是否将执行默认动作，若是则冲洗所有标准I/O流。这并不等价于对所有打开的流调用fclose(因为只冲洗，并不关闭它们），但是当进程终止时，系统会关闭所有打开的文件。如果进程捕捉此信号并返回， 那么因为进程产生了更多的输出，所以再一次冲洗所有的流。不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调用_exit或_Exit.这种情况下，内存中任何未冲洗的标准I/O缓冲区都被丢弃。我们假定捕捉此信号，而且_exit或_Exit的调用者并不想要冲洗缓冲区。 应用例子： #include <stdio.h> #include <stdlib.h> void main ( void ) { FILE * stream ; if (( stream = fopen ( \"NOSUCHF.ILE\" , \"r\" )) == NULL ) { perror ( \"Couldn't open file\" ); abort (); } } else fclose ( stream ); } 编译运行一下，看一下执行情况片段： execve(\"./test.o\", [\"./test.o\"], [/* 97 vars */]) = 0 open(\"NOSUCHF.ILE\", O_RDONLY) = -1 ENOENT (No such file or directory) dup(2) = 3 fcntl(3, F_GETFL) = 0x8402 (flags O_RDWR|O_APPEND|O_LARGEFILE) fstat(3, {st_mode=S_IFCHR|0600, st_rdev=makedev(136, 3), ...}) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd18aa86000 write(3, \"Couldn't open file: No such file\"..., 46Couldn't open file: No such file or directory ) = 46 close(3) = 0 munmap(0x7fd18aa86000, 4096) = 0 rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0 gettid() = 18489 tgkill(18489, 18489, SIGABRT) = 0 SIGABRT {si_signo=SIGABRT, si_code=SI_TKILL, si_pid=18489, si_uid=0} --- +++ killed by SIGABRT +++ 已放弃 abort测试代码说明 代码大体结构 |- macro || NUM || MIN_RLIMIT_CORE | |- variable || TCID || TST_TOTAL | |- function || main || setup || cleanup || do_child || instress 先看一下头文件： #include <sys/types.h> #include <sys/wait.h> #include <errno.h> #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/resource.h> #include \"test.h\" #include \"safe_macros.h\" 什么是头文件呢？ 在C语言家族程序中，头文件被大量使用。一般而言，每个C++/C程序通常由头文件(header files)和定义文件(definition files)组成。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明(declaration)，而定义文件用于保存程序的实现 (implementation) 让我们来看，经典程序 \"Hello world!\" 定义文件名\"First.c\" main() <sample-1> 看看上面的程序，没有.h文件,因为程序太简单，没有需要保存的声明。 文件名 First.c 变形 printStr() { printf(\"Hello world!\"); } main() { printStr() } <sample-2> 还是没有, 那就让我们把这个程序再稍微改动一下. 文件名 First.c main() { printStr() } printStr() { printf(\"Hello world!\"); } <sample-3> sample3和sample2是不同的，pritStr()函数定义的顺序不同。sample3是编译不通过的。这里面涉及作用域的问题。在这里只讲述与.h文件相关的顶层作用域。 顶层作用域就是从声明点延伸到源程序文本结束, 就printStr()这个函数来说，他没有单独的声明,只有定义,那么就从他定义的行开始,到first.c文件结束。sample2中，printStr的定义在main函数前面，所以作用域覆盖main函数，而sample3则没有。 这种情况怎么办呢? 有两种方法 ,一个pritStr函数定义到main函数之前，那就让我们来看另一个例子,让我们看看这个方法是不是在任何时候都会起作用. 文件名 First.c play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… } main() { play1() } <sample-4> 函数嵌套, 那么play1和play2这两个函数哪个放到前面呢? 这时就需要我们来使用第二种方法,使用声明. 文件名 First.c play1(); play2(); play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-5> 一个大型的软件项目,可能有几千个,上万个play, 而不只是play1,play2这么简单, 这样就可能有N个类似 play1(); play2(); 这样的声明, 这个时候就需要我们想办法把这样的play1(); play2(); 也另行管理, 而不是把他放在.c文件中, 于是.h文件出现了. 文件名 First.h play1(); play2(); 文件名 First.C #include \"first.h\" play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-6> 如在second.c中还有一个函数需要调用first.c文件中的play1函数, 如何实现呢? Sencond.h 文件 play1(); sencond.c文件 ***() { ……………. Play(); ………………. } <sample-7> 在sencond.h文件内声明play1函数，怎么能调用到first.c文件中的哪个play1函数中呢? 是不是搞错了，没有搞错, 这里涉及到c语言的另一个特性:存储类说明符. C语言的存储类说明符有以下几个, 我来列表说明一下 说明符 用法 Auto 只在块内变量声明中被允许, 表示变量具有本地生存期. Extern 出现在顶层或块的外部变量函数与变量声明中，表示声明的对象具有静态生存期, 连接程序知道其名字. Static 可以放在函数与变量声明中. 在函数定义时, 其只用于指定函数名,而不将函数导出到连接程序. 在函数声明中,表示其后面会有定义声明的函数, 存储类为static. 在数据声明中, 总是表示定义的声明不导出到连接程序. 无疑, 在sample7中的second.h和first.h中,需要我们用extern标志符来修饰play1函数的声明,这样,play1()函数就可以被导出到连接程序, 也就是实现了无论在first.c文件中调用,还是在second.c文件中调用,连接程序都会很聪明的按照我们的意愿,把他连接到first.c文件中的play1函数的定义上去, 而不必我们在second.c文件中也要再写一个一样的play1函数. 但随之有一个小问题, 在sample7中,我们并没有用extern标志符来修饰play1啊, 这里涉及到另一个问题, C语言中有默认的存储类标志符. C99中规定, 所有顶层的默认存储类标志符都是extern . 那么我们如何来区分哪个头文件中的声明在其对应的.c文件中有定义,而哪个又没有呢? 这也许不是必须的，因为无论在哪个文件中定义，聪明的连接程序都会义无返顾的帮我们找到，并导出到连接程序, 但我觉得他确实必要的. 因为我们需要知道这个函数的具体内容是什么,有什么功能, 有了新需求后我也许要修改他， 我需要在短时间内能找到这个函数的定义, 那么我来介绍一下在C语言中一个人为的规范: 在.h文件中声明的函数,如果在其对应的.c文件中有定义,那么我们在声明这个函数时,不使用extern修饰符, 如果反之,则必须显示使用extern修饰符. 这样,在C语言的.h文件中,我们会看到两种类型的函数声明. 带extern的,还不带extern的, 简单明了,一个是引用外部函数，一个是自己声明并定义的函数. 最终如下: Sencond.h 文件 Extern play1(); 那么多都是针对函数的，而实际上.h文件却不是为函数所专用的，还有全局变量. 在大型项目中，对全局变量的使用不可避免, 比如,在first.c中需要使用一个全局变量G_test, 那么我们可以在first.h中,定义 TPYE G_test. 与对函数的使用类似, 在second.c中我们的开发人员发现他也需要使用这个全局变量, 而且要与first.c中一样的那个, 如何处理? 对,我们可以仿照函数中的处理方法, 在second.h中再次声明TPYE G_test, 根据extern的用法,以及c语言中默认的存储类型, 在两个头文件中声明的TPYE G_test,其实其存储类型都是extern, 也就是说不必我们操心, 连接程序会帮助我们处理一切. 但我们又如何区分全局变量哪个是定义声明,哪个是引用声明呢?这个比函数要复杂一些, 一般在C语言中有如下几种模型来区分: 1、 初始化语句模型 顶层声明中，存在初始化语句是，表示这个声明是定义声明，其他声明是引用声明。C语言的所有文件之中，只能有一个定义声明。 按照这个模型，我们可以在first.h中定义如下TPYE G_test=1；那么就确定在first中的是定义声明，在其他的所有声明都是引用声明。 2、 省略存储类型说明 在这个模型中，所有引用声明要显示的包括存储类extern， 而每个外部变量的唯一定义声明中省略存储类说明符。 这个与我们对函数的处理方法类似，不再举例说明。 这里还有一个需要说明，数组全局变量。 在声明定义时，定义数组如下： int G_glob[100]; 在另一个文件中引用声明如下： int * G_glob; 在vc中，是可以编译通过的， 这种情况大家都比较模糊并且需要注意，数组与指针类似，但并不等于说对数组的声明起变量就是指针。 上面所说的的程序在运行时发现了问题，在引用声明的那个文件中，使用这个指针时总是提示内存访问错误，原来我们的连接程序并不把指针与数组等同，连接时，也不把他们当做同一个定义，而是认为是不相关的两个定义，当然会出现错误。正确的使用方法是在引用声明中声明如下： int G_glob[10]; 并且最好再加上一个extern，更加明了。 extern int G_glob[10]; 另外需要说明的是，在引用声明中由于不需要涉及到内存分配，可以简化如下，这样在需要对全局变量的长度进行修改时，不用把所有的引用声明也全部修改了。 extern int G_glob[]; 接下来，看一下linux环境编程头文件常用的有哪些？ linux常用头文件 POSIX标准定义的头文件 | 文件名 | 内容 | | ------- | -------- | dirent.h | 目录项 | fcntl.h | 文件控制 | fnmatch.h | 文件名匹配类型 | glob.h | 路径名模式匹配类型 | grp.h | 组文件 | <netdb.h> | 网络数据库操作 | <pwd.h> | 口令文件 | <regex.h> | 正则表达式 | <tar.h> | TAR归档值 | <termios.h> | 终端I/O | <unistd.h> | 符号常量 | <utime.h> | 文件时间 | <wordexp.h> | 字符扩展类型 | <arpa/inet.h> | INTERNET定义 | <net/if.h> | 套接字本地接口 | <netinet/in.h> | INTERNET地址族 | <netinet/tcp.h> | 传输控制协议定义 | <sys/mman.h> | 内存管理声明 | <sys/select.h> | Select函数 | <sys/socket.h> | 套接字借口 | <sys/stat.h> | 文件状态 | <sys/times.h> | 进程时间 | <sys/types.h> | 基本系统数据类型 | <sys/un.h> | UNIX域套接字定义 | <sys/utsname.h> | 系统名 | <sys/wait.h> | 进程控制 POSIX定义的XSI扩展头文件 | 文件名 | 内容 | | ------- | -------- | <cpio.h> | cpio归档值 | <dlfcn.h> | 动态链接 | <fmtmsg.h> | 消息显示结构 | <ftw.h> | 文件树漫游 | <iconv.h> | 代码集转换使用程序 | <langinfo.h> | 语言信息常量 | <libgen.h> | 模式匹配函数定义 | <monetary.h> | 货币类型 | <ndbm.h> | 数据库操作 | <nl_types.h> | 消息类别 | <poll.h> | 轮询函数 | <search.h>| 搜索表 | <strings.h> | 字符串操作 | <syslog.h> | 系统出错日志记录 | <ucontext.h> | 用户上下文 | <ulimit.h> | 用户限制 | <utmpx.h> | 用户帐户数据库 | <sys/ipc.h> | IPC(命名管道) | <sys/msg.h> | 消息队列 | <sys/resource.h>| 资源操作 | <sys/sem.h> | 信号量 | <sys/shm.h> | 共享存储 | <sys/statvfs.h> | 文件系统信息 | <sys/time.h> | 时间类型 | <sys/timeb.h> | 附加的日期和时间定义 | <sys/uio.h> | 矢量I/O操作 POSIX定义的可选头文件 | 文件名 | 内容 | | ------- | -------- | <aio.h> | 异步I/O | <mqueue.h> | 消息队列 | <pthread.h> | 线程 | <sched.h> | 执行调度 | <semaphore.h> | 信号量 | <spawn.h> | 实时spawn接口 | <stropts.h> | XSI STREAMS接口 | <trace.h> | 事件跟踪 C/C++头文件一览 C语言 | 文件名 | 内容 | | ------- | -------- | <assert.h>| 设定插入点 | <ctype.h> | 字符处理 | <errno.h> | 定义错误码 | <float.h> | 浮点数处理 | <iso646.h> | 对应各种运算符的宏 | <limits.h> | 定义各种数据类型最值的常量 | <locale.h> | 定义本地化C函数 | <math.h> | 定义数学函数 | <setjmp.h> | 异常处理支持 | <signal.h> | 信号机制支持 | <stdarg.h> | 不定参数列表支持 | <stddef.h> | 常用常量 | <stdio.h> | 定义输入／输出函数 | <stdlib.h>| 定义杂项函数及内存分配函数 | <string.h> | 字符串处理 | <time.h> | 定义关于时间的函数 | <wchar.h> | 宽字符处理及输入／输出 | <wctype.h> | 宽字符分类 传统C++ | 文件名 | 内容 | | ------- | -------- | <fstream.h> | 改用<fstream> | <iomanip.h> | 改用<iomainip> | <iostream.h> | 改用<iostream> | <strstrea.h> | 该类不再支持，改用<sstream>中的stringstream 标准C++ | 文件名 | 内容 | | ------- | -------- | <algorithm> | 通用算法 | <bitset> | 位集容器 | <cctype> | 字符处理 | <cerrno> | 定义错误码 | <cfloat> | 浮点数处理 | <ciso646> | 对应各种运算符的宏 | <climits> | 定义各种数据类型最值的常量 | <clocale> | 定义本地化函数 | <cmath> | 定义数学函数 | <complex> | 复数类 | <csignal> | 信号机制支持 | <csetjmp> | 异常处理支持 | <cstdarg> | 不定参数列表支持 | <cstddef> | 常用常量 | <cstdio> | 定义输入／输出函数 | <cstdlib> | 定义杂项函数及内存分配函数 | <cstring> | 字符串处理 | <ctime> | 定义关于时间的函数 | <cwchar> | 宽字符处理及输入／输出 | <cwctype> | 宽字符分类 | <deque> | STL 双端队列容器 | <exception> | 异常处理类 | <fstream> | 文件输入／输出 | <al> | STL 定义运算函数（代替运算符） | <limits> | 定义各种数据类型最值常量 | <list> | STL 线性列表容器 | <locale> | 本地化特定信息 | <map> | STL 映射容器 | <memory> | STL通过分配器进行的内存分配 | <new> | 动态内存分配 | <numeric> | STL常用的数字操作 | <iomanip> | 参数化输入／输出 | <iOS> | 基本输入／输出支持 | <iosfwd> | 输入／输出系统使用的前置声明 | <iostream> | 数据流输入／输出 | <istream> | 基本输入流 | <iterator> | STL迭代器 | <ostream> | 基本输出流 | <queue> | STL 队列容器 | <set> | STL 集合容器 | <sstream> | 基于字符串的流 | <stack> | STL 堆栈容器 | <stdexcept> | 标准异常类 | <streambuf> | /底层输入／输出支持 | <string> | 字符串类 | <typeinfo> | 运行期间类型信息 | <utility> | STL 通用模板类 | <valarray> | 对包含值的数组的操作 | <vector> | STL 动态数组容器 C99增加的部分 | 文件名 | 内容 | | ------- | -------- | <complex.h> | 复数处理 | <fenv.h> | 浮点环境 | <inttypes.h> | 整数格式转换 | <stdbool.h> | 布尔环境 | <stdint.h> | 整型环境 | <tgmath.h> | 通用类型数学宏 回到abort01的测试上来。先看一下执行情况： abort01 0 TINFO : Adjusting RLIMIT_CORE to 1048576 abort01 1 TPASS : abort dumped core abort01 2 TPASS : abort raised SIGIOT abort01 3 TPASS : abort dumped core abort01 4 TPASS : abort raised SIGIOT abort01 5 TPASS : abort dumped core abort01 6 TPASS : abort raised SIGIOT 程序后台执行片段 chdir(\"/tmp/aboeHLyFk\") = 0 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19587 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19587 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19587, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 1 TPASS : abort d\"..., 43abort01 1 TPASS : abort dumped core ) = 43 write(1, \"abort01 2 TPASS : abort r\"..., 45abort01 2 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19588 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19588 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19588, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 3 TPASS : abort d\"..., 43abort01 3 TPASS : abort dumped core ) = 43 write(1, \"abort01 4 TPASS : abort r\"..., 45abort01 4 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19589 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19589 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19589, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 5 TPASS : abort d\"..., 43abort01 5 TPASS : abort dumped core ) = 43 write(1, \"abort01 6 TPASS : abort r\"..., 45abort01 6 TPASS : abort raised SIGIOT ) = 45 unlink(\"core\") 从测试log来看，abort01主要进行abort\"dumped core\"、和\"raised SIGIOT\"两种测试，并且测试了３遍。０为setup打印信息。 #define NUM 3 /*定义fork进程的数量*/ char *TCID; /* tescase的名字*/ int TST_TOTAL; /* testcases数量 */ 主要函数 static void setup(void); static void cleanup(void); static void do_child(); static int instress(); int main(int argc, char *argv[]) 分别分析这几个函数 setup #define MIN_RLIMIT_CORE (1024 * 1024) static void setup(void) { struct rlimit rlim; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); if (rlim.rlim_cur < MIN_RLIMIT_CORE) { test_resm(TINFO, \"Adjusting RLIMIT_CORE to %i\", MIN_RLIMIT_CORE); rlim.rlim_cur = MIN_RLIMIT_CORE; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); } tst_tmpdir() } setup函数的目的是为了调整RLIMIT_CORE的大小。在Linux系统中，Resouce limit指在一个进程的执行过程中，它所能得到的资源的限制，比如进程的core file的最大值，虚拟内存的最大值等。Resouce limit的大小可以直接影响进程的执行状况。其有两个最重要的概念：soft limit 和 hard limit。 struct rlimit { rlim_t rlim_cur; rlim_t rlim_max; }; 是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件 数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。 tst_tmpdir函数说明一下，该函数用来为ltp测试程序创建临时目录，目录名case名称＋随机字母。 cleanup函数 static void cleanup(void) { unlink(\"core\") tst_rmdir(); } 该函数比较简单，用来清理产生的临时文件和软连接。可以做下试验，将main函数中的该函数注释掉，会在tmp下看到产生的core文件。 do_child函数 static void do_child(void) { abort() fprintf(stderr, \"\\tchild - abort failed.\\n\"); exit(1); } abort的调用，进程退出。 instress函数 static int instress(void) { test_resm(TINFO, \"System resources may be too low; fork(), select() etc are likely to fail.\"); return 1; } 系统资源比较低的情况， 出现fork()等调用失败时的处理。也是为兼容UCLINUK测试（如嵌入式系统）。 main函数 控制测试流程和主要的测试代码，以下将重点介绍一些代码片段。 #ifdef WCOREDUMP int core ; core = 0 ; #endif WCOREDUMP(status) 如果孩子进程产生核心转储文件则返回真。这个宏只应该在 WIFSIGNALED 返回真时调用。这个没有在 POSIX.1-2001 里指定并且在一些 UNIX 实现(如 AIX、SunOS)里也没有提供。只在 #ifdef WCOREDUMP ... #endif 内部使用。 #ifdef UCLINUX maybe_run_child ( & do_child , \"\" ); /* UCLINUX的情况 */ #endif setup (); /*调用setup函数*/ for ( i = 0 ; i < NUM ; i ++ ) { /*连续创建３个进程调用do_child函数*/ kidpid = FORK_OR_VFORK (); if ( kidpid == 0 ) { #ifdef UCLINUX if ( self_exec ( argv [ 0 ], \"\" )) { if ( ! instress ()) { perror ( \"fork failed\" ); exit ( 1 ); } } #else do_child (); //调用do_child()函数 #endif } } if ( kidpid < 0 ) if ( ! instress ()) tst_brkm ( TBROK | TERRNO , cleanup , \"fork failed\" ); count = 0 ; while (( child = wait ( & status )) > 0 ) count ++ ; if ( count != 1 ) { tst_brkm ( TBROK , cleanup , \"wrong # children waited on; got %d, expected 1\" , count ); } #ifdef WCOREDUMP core = WCOREDUMP ( status ); //WCOFEDUMP情况 #endif sig = WTERMSIG ( status ); } if ( WIFEXITED ( status )) ex = WEXITSTATUS ( status ); #ifdef WCOREDUMP if ( core == 0 ) { tst_brkm ( TFAIL , cleanup , \"Child did not dump core; exit code = %d, \" \"signal = %d\" , ex , sig ); } else if ( core != - 1 ) { tst_resm ( TPASS , \"abort dumped core\" ); //core值等于０，则没有正常产生core文件，如果core不等于０且不等于-1，说明正常产生了core文件 } #endif if ( sig == SIGIOT ) { tst_resm ( TPASS , \"abort raised SIGIOT\" ); //发出的信号如果为SIGIOT说明信号触发正常 } else { tst_brkm ( TFAIL , cleanup , \"Child did not raise SIGIOT (%d); exit code = %d, \" \"signal = %d\" , SIGIOT , ex , sig ); } } abort测试分析结束。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-abort"},{"url":"http://king32783784.github.io/2016/08/05/LTP/","text":"accept用例分析 case本身说明： Verify that accept() returns the proper errno for various failure cases 验证accept()是否返回正确的errno. 测试log accept01 1 TPASS : bad file descriptor successful accept01 2 TPASS : bad file descriptor successful accept01 3 TPASS : invalid socket buffer successful accept01 4 TPASS : invalid salen successful accept01 5 TPASS : invalid salen successful accept01 6 TPASS : no queued connections successful accept01 7 TPASS : UDP accept successful ~ 测试错误类型包括: bad file descriptor、invalid socket buffer、invalid salen、no queued connections、 UDP accept等 accept函数 accept() 接收一个套接字中已建立的连接 使用格式 #include <sys/types.h> #include <sys/socket.h> int accept ( int sockfd , struct sockaddr * addr , socklen_t * addrlen ); 功能参数描述 accept()系统调用主要用在基于链接的套接字类型，比如SOCK_STREAM和SOCK_SEQPACKET.它提取出所监听套接字的等待连接队列中第一个连接请求，创建一个新的套接字，并返回指向该套接字的文件描述符。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。 备注： 新建立的套接字准备发送send()和接收数据recv(). 参数： sockfd, 利用系统调用socket()建立的套接字描述符，通过bind()绑定到一个本地地址（一般为服务器的套接字），并且通过listen()一直在监听连接。 addr, 指向struct sockaddr的指针，该结构用通讯层服务器对等套接字的地址（一般为客户端地址）填写，返回地址addr的确切格式由套接字的地址类别（比如tcp或udp)决定；若addr为NULL，没有有效地址填写，这种情况下，addrlen也不使用，应该置为NULL； 备注： addr是个指向局部数据结构sockaddr_in的指针，这就是要求接入的信息本地的套接字（地址和指针） addrlen, 一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值，函数返回时包含对等地址（一般为服务器地址）的实际数值； 备注： addrlen 是个局部整型变量， 设置为sizeof(struct sockaddr_in) 如果队列中没有等待的连接，套接字也没有被标记为Non-blocking, accept()会阻塞调用函数知道连接出现；如果套接字被标记为Non-blocking, 队列中也没有等待的连接，accept返回错误EAGAIN或EWOULDBLOCK. 备注： 一般来说，实现时accept()为阻塞函数，当监听socket调用accept()时，它先到自己的receive_buf中查看是否有连接数据包； 若有，把数据拷贝处理啊，删掉接收到的数据包，创建新的socket与客户发来的地址建立链接； 若没有，就阻塞等待； 为了在套接字中有到来的连接时得到通知，可以使用select()或poll().当尝试建立新连接时，系统发送一个可读事件，然后调用accept()为该链接获取套接字。另一种方法是，当套接字中有连接到来时设定套接字发送SIGIO信号。 返回值 成功时，返回非负整数，该整数是接收到套接字的描述符；出错时，返回－１，相应的设定全局变量errno. 错误处理 Linux下，accept()把已等待的网络错误传给新建立的连接，当作是accept()返回的错误。这与其他的BSD实现是不同的。为了可靠运行，应该在accept()之后检测协议已定义的一些网络错误，并把这些错误当作EAGAIN并重试。对于tcp/ip协议来说，主要有：ENETDOWN,EPROTO,ENOPROTOOPT,EHOSTDOWN,ENONET,EHOSTUNREACH,EOPNOTSUPP和ENETUNREACH。 accept01.c代码分析 主要函数包括mian、setup、cleanup、setup0、cleanup0、setup1、cleanup1、setup2、setup3 test_case_t结构体 struct test_caset { int domain; /*AF_INIT, AF_UNIX,....*/ int type; /* SOCK_STREAM, SOCK_DGRAM...*/ int proto; /* protocol number(usually 0 = default) */ struct sockaddr *sockaddr; /*socket address buffer */ socklen_t *salen; /* accept's 3rd argument */ int retval; /* syscall return value */ int experrno; /* expected errno */ void (*setup)(void); void(*cleanup)(void); char *desc; } tdat[] = { {PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EBADF, setup0, cleanup0, \"bad file descriptor\"}, //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, ENOTSOCK, setup0, cleanup0, \"bad file descriptor\"}, { //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)3, &sinlen, -1, EINVAL, setup1, cleanup1, \"invalid socket buffer\"}, { //无效套接字缓存区 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, (socklen_t *) 1, -1, EINVAL, setup1, cleanup1, \"invalid salen\"}, { //无效的salen PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup2, cleanup1, \"invalid salen\"}, { PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup3, cleanup1, \"no queued connections\"}, { //队列中没有等待的连接 PF_INET, SOCK_DGRAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EOPNOTSUPP, setup1, cleanup1, \"UDP accept\"},}; int TST_TOTAL = sizeof(tdat) / sizeof(tdat[0]); /*通过数组的长度，计算测试用例数量*/ 先定义测试case需要的结构体，然后进行了 结构体初始化 ，定义了7种错误类型，对应7个测试case，和测试log是对应的。 顺便看一下 SOCK_STREAM和SOCK_DGRAM的区别： sock_stream 是有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料（如文件）传送。 sock_dgram 是无保障的面向消息的socket ， 主要用于在网络上发广播信息。 SOCK_STREAM是基于TCP的，数据传输比较有保障。SOCK_DGRAM是基于UDP的，专门用于局域网，基于广播 SOCK_STREAM 是数据流,一般是tcp/ip协议的编程,SOCK_DGRAM分是数据抱,是udp协议网络编程 再看说一下AF_INET和PF_INET的差别： 在Unix/Linux系统中，在不同的版本中这两者有微小差别.对于BSD,是AF,对于POSIX是PF.理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx 分别看一下这几个错误码 EBADF: 当作为参数的套接字不是一个有效的文件描述符(在Linux下用文件描述符来表示设备文件和普通文件。文件描述符是一个整型的数据，所有对文件的操作都通过文件描述符实现。文件描述符是文件系统中链接用户空间和内核空间的枢纽)时，抛出这个错误码。无效的文件描述符是什么意思呢？就是fd已经close的，或者本身就不是个有效的socket的fd。 ENOTSOCK: 在非socket上执行socket操作。 EINVAL： 无效参数。提供的参数非法。有时也会与socket的当前状态相关，如一个socket并没有进入listening状态，此时调用accept，就会产生EINVAL错误。 EOPNOTSUPP: 不支持的操作。 引用对象的类型不支持尝试的操作。通常，这发生在套接字描述符不支持此操作，例如，试着接受数据报套接字上的连接的套接字。 接下来看几个辅助函数。 1.setup函数 static void setup(void) { TEST_PAUSE; /*初始化本地 sockaddr*/ sin0.sin_family = AF_INET; //绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_INET，即使用IP sin0.sin_port = 0; sin0.sin_addr.s_addr = INADDR_ANY; //指定地址为0.0.0.0的地址 } TEST_PAUSE是一个 宏定义 ，代表usc_global_setup_hook()函数。作用是当设置了暂停标志后，暂停 SIGUSR1 ，当新的信号来时，再继续。下面是usc_global_setup_hook函数实现： #define TEST_PAUSE usc_global_setup_hook(); int usc_global_setup_hook () int usc_global_setup_hook ( void ) { #ifndef UCLINUX /*定义temp变量存储信号旧信号的动作，中断后恢复*/ int ( * _TMP_FUNC ) ( void ); /*中断等待sigusr1.*/ if ( STD_PAUSE ) { _TMP_FUNC = ( int ( * )()) singnal ( SIGUSR1 , STD_go ); pause () signal ( SIGUSR1 , ( void ( * )()) _TMP_FUNC ); } if ( STD_TP_sbrk ) || STD_LP_sbrk ) STD_start_break = sbrk ( 0 ); /*获取原始sbreak大小*/ if ( STD_TP_sbrk ){ sbrk ( STD_TP_sbrk ) : if ( Debug ) print ( \"after sbrk(%d) \\n \" , STD_TP_sbrk ); } #endif return 0 ; } 2.setup0函数case1测试前设置 static void setup0(void) 3.setup2 static void setup2(void) { setup1(); //调用setup1()获取套接字s sinlen = 1; //s置为无效 } 4.setup3 static void setup3(void) { int one = 1; setup1(); SAFE_IOCTL(cleanup, s, FIONBIO, &one); } SAFE_IOCTL #define SAFE_IOCTL ( cleanup_fn , fd , request , ...) \\ ( { int ret = ioctl ( fd , request , __VA_ARGS__ ); \\ ret < 0 ? \\ tst_brkm ( TBROK | TERRNO , cleanup_fn , \\ \"ioctl(%i,%s,...) failed\" , fd , #reques t ) \\ safe_ : ret ;} ) 6.cleanup、cleanup0, cleanup1 static void cleanup(void) { } static void cleanup0(void) { s = -1; } static void cleanup1(void) { (void)close(s); s = -1; } 重新设置s = -1 OK,现在看一下main函数。 int main(int ac, char *av[]) { int lc; tst_parse_opts(ac, av, NULL, NULL); //ltp参数解析函数 setup(); for (lc = 0; TEST_LOOPING(lc); ++lc){ test_count = 0; for (testno = 0; testno < TST_TOTAL; ++testno){ tdat[testno].setup(); TEST(accept(s, tdat[testno].sockaddr, tdat[testno].salen)); if (TEST_RETURN > 0) TEST_RETURN = 0; if (TEST_RETURN != tdat[testno].retval || (TEST_RETURN < 0 && TEST_ERRNO != tdat[testno].experrno)){ \"%ld(expected %d), errno %d (expected\" \"%d)\", tdat[testno].desc, TEST_RETURN, tdat[testno].desc, TEST_ERRNO, tdat[testno].experrno); } else { tst_resm(TPASS, \"%s successful\", tdat[testno].desc); } tdat[testno].cleanup(); } } cleanup(); tst_exit(); } 先看一下tst_parse_opts()函数 void tst_parse_opts(int argc, char *argv[], const option_t *user_optarg, void (*user_help)(void)) { const char *msg; msg = parse_opts(argc, argv, user_optarg, user_help); //parse_opts是参数解析函数，后面文章再进行介绍 if(msg) tst_brkm(TBROK, NULL, \"OPTION PARSING ERROR - %s \", msg); } 接下来调用setup，准备测试环境，初始化本地IP地址。然后是一个嵌套的两层循环，第一次是测试次数的遍历，通过TEST_LOOPING实现。 TEST_LOOPING是int usc_test_looping(int counter)函数，该函数后面的文章再进行解释。tst_count初始化为0。 第二层循环是遍历case数组。tdat[testno].setup()，调用对应setup准备case的特殊设置。 TEST启动测试， #define TEST(SCALL) \\ do { \\ errno = 0; \\ TEST_RETURN = SCALL; \\ TEST_ERRNO = errno; \\ } 然后将tdat中的对应参数，分别执行accept函数，如果预期的返回值不符或则返回值小于0且和预期的错误类型不匹配，则调用tst_resm()，进行出错处理。tst_resm将在后面进行分析。如果符合预期，则打印TPASS，然后调用tdat[testno].clearnup()分别清理环境。 最后调用cleanup()清理，tst_exit()退出，tst_exit()在单独分析ltp测试框架时分析。 到此，我们就清楚accept测试的内容了。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-accept()"},{"url":"http://king32783784.github.io/2016/06/02/LTP/","text":"本节将重点分析commands部分的用例。 Command主要用例 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which ade ade包括对ar、file、ld、ldd、nm、objdump、size命令的验证测试。 ar ar命令是Linux的一个备份压缩命令，可以创建、修改备存文件(archive)，或从备存文件中抽取成员文件。备存文件以一定的结构打包一个至多个其它文件（即成员文件），且成员文件的内容、模式、时间戳等信息将被保存在备存文件中。常见的应用是，使用ar命令将多个目标文件（ .o）打包为静态链接库文件（ .a)。 引出一个问题，库是什么？本质上讲库是一种可执行代码的二进制形式，可以被操作系统加载到内存执行。linux库分为两种：静态库和动态库。区别在于，静态库是在编译过程中已经被载入可执行程序，可执行程序一般较大；共享库（动态库）是可执行程序运行时才加载到内存，编译时仅简单的引用，因此可执行程序较小。库是如何产生的呢？静态库的后缀是.a，它的产生分为两步：１．由源码编译生成一堆.o，每个.o包含这个编译单元的符号表；２．ar命令将很多.o文件打包转换为.a,形成静态库。 ar命令的常用参数 在 ar 命令中，可以从集 cClosTv 中指定任何数量的可选标志。必须从标志集 dhmopqrstwx 中指定一个标志。如果选择-m 或 -r 标志，您可能还要指定一个位置标志（-a 、-b 或-i ）；对于 -a 、-b 或-i 标志，您必须还指定在 ArchiveFile （PositionName ）中一个文件的名称，此名称紧跟在标志列表后，并由空格隔开。 -a PositionName 在 PositionName 参数标识的现有文件后安置指定的文件。 -b PositionName 在 PositionName 参数标识的现有文件前安置指定的文件。 -c 禁止在创建库 时产生的正常消息。 -C 阻止解压缩的文件替换文件系统中同名的文件。 -d 从库中删除指定的文件。 -g 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-g 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成小格式，这样该标志可用来将大格式压缩文档转换成小格式压缩文档。包含 64 位XCOFF 对象的压缩文档不能创建成或转换至小格式。 -h 将指定的文件的成员报头中的修改时间设置为当前日期和时间。如果不指定任何文件名称，则 ar 命令设置所有成员报头的时间戳记。此标志不能和-z 标志一起使用。 -i PositionName 在 PositionName 参数标识的现有文件前安置指定的文件（和 -b 相同）。 -l 将临时文件置于当前（本地）目录中，而非 TMPDIR 目录中（缺省为 /tmp ）。 -m 将指定的文件移动到库中的某个其它位置。缺省情况下，它将指定的文件移动到库的末尾。使用位置标志（abi ）来指定某个其它位置。 -o 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-o 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成大格式，这样该标志可用来将小格式压缩文档转换成大格式压缩文档。 -p 将 Files 参数中指定的文件的内容或在 ArchiveFile 参数中指定的所有文件（如果您不指定任何文件）都写至标准输出。 -q 将指定的文件添加到库的末尾。另外，如果指定同一个文件两次，它可能被放入库中两次。 -r 如果指定的文件已经存在于库中，则替换它。因为指定的文件在库中占据它们替换的文件的同一个位置，位置标志没有任何附加的影响。当和 -u 标志（更新）一起使用时，-r 标志仅替换自从最后一次添加到库中以后修改的文件。 如果指定的文件不存在于库中，则 ar 命令添加它。在这种情况下，位置标志影响放置。如果不指定位置，则将新文件置于库的末尾。如果指定同一个文件两次，它可能被放入库中两次。 -s 无论 ar 命令是否修改了库内容都强制重新生成库符号表。请在库上使用 strip 命令之后，使用此标志来恢复库符号表。 -t 将库的目录写至标准输出。如果指定文件名称，则仅显示指定的那些文件。如果不指定任何文件，-t 标志列出库中的所有文件。 -T 如果压缩文档成员名称比文件系统支持的长，则允许文件名称截短。此选项无效，因为文件系统支持的名称长度等于 255 个字符的最大压缩文档成员名称。 -u 仅复制自它们最后一次复制起更改的文件（请参阅先前讨论过的 -r 标志）。 -v 将建立新库的详细的逐个文件的描述写至标准输出。当和 -t 标志一起使用时，它给出类似于 ls -l 命令给出的长列表。当和 -x 标志一起使用时，它在每个文件前加一个名称。当和 -h 标志一起使用，它列出成员名称和更新的修改时间。 -w 显示压缩文档符号表。每个符号和其中定义此符号的文件的名称一起列出。 -x 通过将指定的文件复制到当前目录来解压缩它们。这些副本和原始文件（保留在库中）具有相同的名称。如果不指定任何文件，-x 标志复制库中的所有文件。此过程不会更改库。 -Xmode 指定 ar 应检查的目标文件的类型。mode 必须是以下项之一： 32 仅处理 32 位目标文件 64 仅处理 64 位目标文件 32_64 处理 32 位 和 64 位目标文件 缺省值是处理 32 位目标文件（忽略 64 位对象）。mode 还可以用 OBJECT_MODE 环境变量来设置。例如，OBJECT_MODE=64 使 ar 处理任何 64 位对象并忽略 32 位对象。-X 标志覆盖 OBJECT_MODE 变量。 -z 创建压缩文档的临时副本并对副本执行所有要求的修改。当所有操作成功完成时，压缩文档的工作副本覆盖原始副本。此标志不能和 -h 标志一起使用。 ArchiveFile 指定压缩文档文件名称；必需。 MemberName ... 各压缩文档成员的名称。 示例１．ar rcs libxxxx.a xx1.o xx2.o 参数r: 在库中插入模块（替换）。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 参数c: 创建一个库。不管库是否存在，都将创建。 参数s: 创建目标文件索引 这在创建较大的库时能加快时间。（补充：如果不需要创建索引，可改成大写S参数；如果。a文件缺少索引，可以使用ranlib命令添加） 示例２．创建一个库 ar -v -q lib.a strlen.o strcpy.o 如果 lib.a 库不存在，则此命令创建它，并将文件 strlen.o 和 strcpy.o 的副本输入其中。如果 lib.a 库存在，则此命令在不检查相同成员的情况下，将新的成员添加到末尾。v 标志设置详细方式，在此方式中ar 命令在其进行时显示进程报告。 示例３．显示库的目录 ar -v -t lib.a 此命令列出了 lib.a 库的目录，显示类似于 ls -l 命令的输出的长列表。要只列出成员文件名称，则省略-v 标志。 示例4. 替换或添加新成员到库中 ar -v -r lib.a strlen.o strcat.o 此命令替换成员 strlen.o 和 strcat.o 。如果 lib.a 如示例 1 中显示的那样创建，则替换strlen.o 成员。因为不存在名为 strcat.o 的成员，所以它被添加到库的末尾。 示例５. 指定在何处插入新成员 ar -v -r -b strlen.o lib.a strcmp.o 此命令添加 strcmp.o 文件，并将该新成员置于 strlen.o 成员之前。 示例６．要更新一个已经更改过的成员 ar -v -r -u lib.a strcpy.o 此命令替换现有 strcpy.o 成员，但仅当文件 strcpy.o 自从最后一次添加到库后已经修改时才替换它。 示例７ 要更改库成员的顺序 ar -v -m -a strcmp.o lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 移动到紧跟在 strcmp.o 成员之后的位置。保留 strcat.o 和 strcpy.o 成员的相对顺序。换句话说，如果在移动之前strcpy.o 成员在 strcat.o 成员之前，那么（移动后）它依旧如此。 示例８ 要解压缩库成员 ar -v -x lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 分别复制到名为 strcat.o 和 strcpy.o 的文件。 示例９ 要解压缩并重命名一个成员 ar -p lib.a strcpy.o >stringcopy.o 此命令将成员 strcpy.o 复制到一个名为 stringcopy.o 的文件。 示例10 要删除一个成员 ar -v -d lib.a strlen.o 此命令从 lib.a 库中删除成员 strlen.o 。 示例11 要从多个用 ld 命令创建的共享模块中创建一个压缩文档库 ar -r -v libshr.a shrsub.o shrsub2.o shrsub3.o ... 此命令从名为 shrsub.o 、shrsub2.o 、shrsub3.o 等等的共享模块中创建名为libshr.a 的压缩文档库。要编译并链接使用 libshr.a 压缩文档库的 main 程序，请使用以下命令： cc -o main main.c -L/u/sharedlib -lshr main 程序现在是可执行的。main 程序引用的任何符号（包含在libshr.a 压缩文档库中）已经因延迟分辨率而作了标记。-l 标志指定应在libshr.a 库中搜索这些符号。 示例12 要列出 lib.a 的内容（忽略任何 32 位目标文件） ar -X64 -t -v lib.a 要从 lib.a 解压缩所有 32 位的目标文件 ar -X32 -x lib.a 要列出 lib.a 中的所有文件，无论是 32 位、64 位或非对象，请输入： ar -X32_64 -t -v lib.a 示例13 在shell脚本中使用 Bash代码 OS= uname -r ar rcs libhycu.a.$OS *.o 示例14 在makefile中使用 Makefile代码 $（BIN1）: $（BIN1_OBJS） ar rcs $@ $&#94; 示例15 创建并使用静态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 如果test.c无误，就会得到test.o这个目标文件。 第三步：由。o文件创建静态库。 ar rcs libtest.a test.o 第四步：在程序中使用静态库。 gcc -o main main.c -L. -ltest 因为是静态编译，生成的执行文件可以独立于。a文件运行。 第五步：执行。 ./main 示例16 创建并使用动态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 前面两步与创建静态库一致。 第三步：由。o文件创建动态库文件。 gcc -shared -fPIC -o libtest.so test.o 第四步：在程序中使用动态库。 gcc -o main main.c -L. -ltest 当静态库和动态库同名时，gcc命令将优先使用动态库。 第五步：执行。 LD_LIBRARY_PATH=. ./main 接下来，看一下ltp是如何测试ar命令的。 ar文件下包括： ar01 file0.in file10.in file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in Makefile等文件，其中ar01是shell编写的测试脚本。 测试目的，测试ar命令的不同选项的功能。测试策略，通过比较单独指定参数和组合参数测试结果进行判断，如果相同测试通过，如果不同，测试失败。 ar测试项的参数为: export TCdat=$LTPROOT/testcases/bin; ar01 直接执行ar01即可。 测试条件，系统存在ar命令。在运行config时，会进行check:如 configure : 4165 : checking for ar configure : 4181 : found /bin/ ar configure : 4192 : result : ar 程序分析： 创建用到的临时文件 LIST=\"file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in file10.in\" LIST=\" $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST \" # Setup function setup() { for i in $ LIST ;do touch $ i done } 结果判定，判断子case的返回值是否为０，TCRESULT为标志位，初始值为０，出错TCRESULT置为１，不同测试内容分别返回不同的编号。 # Cleanup funciton cleanup() { if [ $ TCRESULT = 0 ];then echo \"-----------ar command passed the system test --------\" exit 0 else echo \"-----------ar command failed the system test --------\" exit 1 fi } crtest() { if [ $ ? -ne 0] then TCRESULT=1 echo \"FAIL - could not create lib.a\" cleanup fi } ttest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not output table from lib.a to lib.a.stdout\" cleanup fi } rtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not add file into lib.a\" cleanup fi } mtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not move file into lib.a\" cleanup fi } 通过结果判定的设置来看，主要验证ar命令的库的创建、库列表信息导出、往库中添加文件、移除库中的文件。 测试代码片段： 标志\"a\"：在 PositionName 参数标识的现有文件后安置指定的文件。 ar -cr $ TCtmp /lib.a file1.in file3.in crtest ar -ra file1.in $ TCtmp /lib.a file2.in rtest ar -t $ TCtmp /lib.a > $ TCtmp /lib.a.stdout tttest if diff -b $ TCtmp /lib.a.exp $ TCtmp /lib.a.stdout > /dev/null 2>&1 then echo \"-)1\" else TCRESULT=1 echo \"FAIL -ar with -a option does not place file after \"posname\" fi 具体测试内容列表： （１）The 'a' flag causes files to be placed after 'posname'. （２）The 'a' flag with the 'm' option causes files to be moved after 'posname' （３）The 'b' flag causes files to be placed before 'posname'. （４）The 'b' flag with 'm' option causes files to be moved before 'posname'. （５）-c option suppress the messages （６）The 'qc' option causes suppresion of the default message when 'afile' is created （７）The -d option deletes files from archive when names are specified. （８）The -d option does not delete files from archive when no names are specified. （９）The -d does not affect behaviour of -s option. （10）The 'i' flag causes files to be placed before 'posname'. （11) The 'i' flag with 'm' option causes files to be moved before 'posname'. (12) m option moves the files to end of the archive (13) The -p option causes only printing of contents of file contained in archive. (14) The -p does not affect behaviour of -s option. (15) The command 'ar -q afile name' appends name to the end of 'afile'. (16) q option does not affect the behaviour of option s (17) The -s causes regeneration of symbol table even if a symbol table exists. (18) ar with -t print as desired (19) The -t does not affect behaviour of -s option. (20)The 'u' flag causes files only with later modification date than in archive are replaced. (21) ar with -v flag to print a line for each file (22) The -v option produces a verbose listing like ls -n (23) The 'v' option causes the 'x' option to display a filename for each file extracted. (24) The command 'ar -x afile ' causes all files from the archive to be extracted. (25) The command 'ar -x afile name name' causes only named files from the archive to be extracted. (26) This test will fail under pan, so it's commented out by default. (27) Signal SIGHUP (28) Signal SIGQUIT (29) Signal SIGHUP; ar should not remove archive that existed before invocation. (30) Signal SIGINIT; ar should not remove archive that existed before invocation. (31) Signal SIGQUIT; ar should not remove archive that existed before invocation.","tags":"自动化测试-LTP","title":"LTP－Command"},{"url":"http://king32783784.github.io/2016/08/01/LTP/","text":"syscalls ltp中kernel测试比重很大，尤其是syscalls，包括一下用例： 注：测试内容分析时补充。 用例名称 测试内容 abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev 接下来按照顺序分析系统调用的每一个case,并将每个case的测试内容补充到本文。 附linux系统主要系统调用列表 一、进程控制 fork 创建一个新进程 clone 按指定条件创建子进程 execve 运行可执行文件 exit 中止进程 _exit 立即中止当前进程 getdtablesize 进程所能打开的最大文件数 getpgid 获取指定进程组标识号 setpgid 设置指定进程组标志号 getpgrp 获取当前进程组标识号 setpgrp 设置当前进程组标志号 getpid 获取进程标识号 getppid 获取父进程标识号 getpriority 获取调度优先级 setpriority 设置调度优先级 modify_ldt 读写进程的本地描述表 nanosleep 使进程睡眠指定的时间 nice 改变分时进程的优先级 pause 挂起进程，等待信号 personality 设置进程运行域 prctl 对进程进行特定操作 ptrace 进程跟踪 sched_get_priority_max 取得静态优先级的上限 sched_get_priority_min 取得静态优先级的下限 sched_getparam 取得进程的调度参数 sched_getscheduler 取得指定进程的调度策略 sched_rr_get_interval 取得按RR算法调度的实时进程的时间片长度 sched_setparam 设置进程的调度参数 sched_setscheduler 设置指定进程的调度策略和参数 sched_yield 进程主动让出处理器,并将自己等候调度队列队尾 vfork 创建一个子进程，以供执行新程序，常与execve等同时使用 wait 等待子进程终止 wait3 参见wait waitpid 等待指定子进程终止 wait4 参见waitpid capget 获取进程权限 capset 设置进程权限 getsid 获取会晤标识号 setsid 设置会晤标识号 二、文件系统控制 1、文件读写操作 fcntl 文件控制 open 打开文件 creat 创建新文件 close 关闭文件描述字 read 读文件 write 写文件 readv 从文件读入数据到缓冲数组中 writev 将缓冲数组里的数据写入文件 pread 对文件随机读 pwrite 对文件随机写 lseek 移动文件指针 _llseek 在64位地址空间里移动文件指针 dup 复制已打开的文件描述字 dup2 按指定条件复制文件描述字 flock 文件加/解锁 poll I/O多路转换 truncate 截断文件 ftruncate 参见truncate umask 设置文件权限掩码 fsync 把文件在内存中的部分写回磁盘 2、文件系统操作 access 确定文件的可存取性 chdir 改变当前工作目录 fchdir 参见chdir chmod 改变文件方式 fchmod 参见chmod chown 改变文件的属主或用户组 fchown 参见chown lchown 参见chown chroot 改变根目录 stat 取文件状态信息 lstat 参见stat fstat 参见stat statfs 取文件系统信息 fstatfs 参见statfs readdir 读取目录项 getdents 读取目录项 mkdir 创建目录 mknod 创建索引节点 rmdir 删除目录 rename 文件改名 link 创建链接 symlink 创建符号链接 unlink 删除链接 readlink 读符号链接的值 mount 安装文件系统 umount 卸下文件系统 ustat 取文件系统信息 utime 改变文件的访问修改时间 utimes 参见utime quotactl 控制磁盘配额 三、系统控制 ioctl I/O总控制函数 _sysctl 读/写系统参数 acct 启用或禁止进程记账 getrlimit 获取系统资源上限 setrlimit 设置系统资源上限 getrusage 获取系统资源使用情况 uselib 选择要使用的二进制函数库 ioperm 设置端口I/O权限 iopl 改变进程I/O权限级别 outb 低级端口操作 reboot 重新启动 swapon 打开交换文件和设备 swapoff 关闭交换文件和设备 bdflush 控制bdflush守护进程 sysfs 取核心支持的文件系统类型 sysinfo 取得系统信息 adjtimex 调整系统时钟 alarm 设置进程的闹钟 getitimer 获取计时器值 setitimer 设置计时器值 gettimeofday 取时间和时区 settimeofday 设置时间和时区 stime 设置系统日期和时间 time 取得系统时间 times 取进程运行时间 uname 获取当前UNIX系统的名称、版本和主机等信息 vhangup 挂起当前终端 nfsservctl 对NFS守护进程进行控制 vm86 进入模拟8086模式 create_module 创建可装载的模块项 delete_module 删除可装载的模块项 init_module 初始化模块 query_module 查询模块信息 *get_kernel_syms 取得核心符号,已被query_module代替 四、内存管理 brk 改变数据段空间的分配 sbrk 参见brk mlock 内存页面加锁 munlock 内存页面解锁 mlockall 调用进程所有内存页面加锁 munlockall 调用进程所有内存页面解锁 mmap 映射虚拟内存页 munmap 去除内存页映射 mremap 重新映射虚拟内存地址 msync 将映射内存中的数据写回磁盘 mprotect 设置内存映像保护 getpagesize 获取页面大小 sync 将内存缓冲区数据写回硬盘 cacheflush 将指定缓冲区中的内容写回磁盘 五、网络管理 getdomainname 取域名 setdomainname 设置域名 gethostid 获取主机标识号 sethostid 设置主机标识号 gethostname 获取本主机名称 sethostname 设置主机名称 六、socket控制 socketcall socket系统调用 socket 建立socket bind 绑定socket到端口 connect 连接远程主机 accept 响应socket连接请求 send 通过socket发送信息 sendto 发送UDP信息 sendmsg 参见send recv 通过socket接收信息 recvfrom 接收UDP信息 recvmsg 参见recv listen 监听socket端口 select 对多路同步I/O进行轮询 shutdown 关闭socket上的连接 getsockname 取得本地socket名字 getpeername 获取通信对方的socket名字 getsockopt 取端口设置 setsockopt 设置端口参数 sendfile 在文件或端口间传输数据 socketpair 创建一对已联接的无名socket 七、用户管理 getuid 获取用户标识号 setuid 设置用户标志号 getgid 获取组标识号 setgid 设置组标志号 getegid 获取有效组标识号 setegid 设置有效组标识号 geteuid 获取有效用户标识号 seteuid 设置有效用户标识号 setregid 分别设置真实和有效的的组标识号 setreuid 分别设置真实和有效的用户标识号 getresgid 分别获取真实的,有效的和保存过的组标识号 setresgid 分别设置真实的,有效的和保存过的组标识号 getresuid 分别获取真实的,有效的和保存过的用户标识号 setresuid 分别设置真实的,有效的和保存过的用户标识号 setfsgid 设置文件系统检查时使用的组标识号 setfsuid 设置文件系统检查时使用的用户标识号 getgroups 获取后补组标志清单 setgroups 设置后补组标志清单 八、进程间通信 ipc 进程间通信总控制调用 1、信号 sigaction 设置对指定信号的处理方法 sigprocmask 根据参数对信号集中的信号执行阻塞/解除阻塞等操作 sigpending 为指定的被阻塞信号设置队列 sigsuspend 挂起进程等待特定信号 signal 参见signal kill 向进程或进程组发信号 *sigblock 向被阻塞信号掩码中添加信号,已被sigprocmask代替 *siggetmask 取得现有阻塞信号掩码,已被sigprocmask代替 *sigsetmask 用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替 *sigmask 将给定的信号转化为掩码,已被sigprocmask代替 *sigpause 作用同sigsuspend,已被sigsuspend代替 sigvec 为兼容BSD而设的信号处理函数,作用类似sigaction ssetmask ANSI C的信号处理函数,作用类似sigaction 2、消息 msgctl 消息控制操作 msgget 获取消息队列 msgsnd 发消息 msgrcv 取消息 3、管道 pipe 创建管道 4、信号量 semctl 信号量控制 semget 获取一组信号量 semop 信号量操作 5、共享内存 shmctl 控制共享内存 shmget 获取共享内存 shmat 连接共享内存 shmdt 拆卸共享内存","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls"},{"url":"http://king32783784.github.io/2016/06/03/LTP/","text":"file file 用例主要用于测试file命令。 file命令介绍 file命令可以通过查看文件内容来找出特定类型的文件，在UNIX/ Linux系统中，文件类型并不是由文件扩展名来决定的(windows中却正是这么做的),file命令的目的是从多个文件中收集文件类型统计信息。 file --help Usage: file [OPTION...] [FILE...] Determine type of FILEs. --help display this help and exit -v, --version output version information and exit -m, --magic-file LIST use LIST as a colon-separated list of magic number files -z, --uncompress try to look inside compressed files -Z, --uncompress-noreport only print the contents of compressed files -b, --brief do not prepend filenames to output lines -c, --checking-printout print the parsed form of the magic file, use in conjunction with -m to debug a new magic file before installing it -e, --exclude TEST exclude TEST from the list of test to be performed for file. Valid tests are: apptype, ascii, cdf, compress, elf, encoding, soft, tar, text, tokens -f, --files-from FILE read the filenames to be examined from FILE -F, --separator STRING use string as separator instead of `:' -i, --mime output MIME type strings (--mime-type and --mime-encoding) --apple output the Apple CREATOR/TYPE --extension output a slash-separated list of extnsions --mime-type output the MIME type --mime-encoding output the MIME encoding -k, --keep-going don't stop at the first match -l, --list list magic strength -L, --dereference follow symlinks (default) -h, --no-dereference don't follow symlinks -n, --no-buffer do not buffer output -N, --no-pad do not pad output -0, --print0 terminate filenames with ASCII NUL -p, --preserve-date preserve access times on files -P, --parameter set file engine parameter limits indir 15 recursion limit for indirection name 30 use limit for name/use magic elf_notes 256 max ELF notes processed elf_phnum 128 max ELF prog sections processed elf_shnum 32768 max ELF sections processed -r, --raw don't translate unprintable chars to \\ooo -s, --special-files treat special (block/char devices) files as ordinary ones -C, --compile compile file specified by -m -d, --debug print debugging messages 必要参数 -b 文件名不显示 -c 显示详细处理信息 -L 操作对象为符号链接所指向的对象 -z 压缩文件的处理 -C 列出magic.mgc的输出 -n 将结果输出到标准输出 -f<文件名> 指定文件名 -m<文件名> 指定魔法数字名 选择参数 --help 显示帮助信息 -v 显示版本信息 实例： 1.查看所有文件类型 file * 2.2.查看具体某一文件的类型：file filename 3.-b参数，打印出不包含文件名的文件类型信息: 4.-z 参数，可以获取用gzip、zip压缩过的文件的类型 5.-n参数，将信息标准输出 言归正传，file_test.sh 脚本主要验证是否支持多种文件格式，比如tar tar.gz rpm c ascii elf等。 用例设置： Test01：测试文件命令是否识别ASCII文本文件 1）将文本写入已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.txt 3）grep为关键字\"ASCII文本\"的输出 'file'命令 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test02：测试文件命令是否能识别bash shell脚本 1）将一个小shell脚本写入一个已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.sh 3）从'file'命令的输出中Grep关键字\"Bourne-Again shell脚本\" 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test03：测试文件命令是否能识别bash shell脚本 使用Korn shell脚本执行类似的测试（如Test02） Test04：测试文件命令是否可以识别C shell脚本 使用C shell脚本执行类似的测试（如Test02） Test05：测试文件命令是否可以识别C程序文本 使用test2类似方法测试c程序文本 Test06：测试文件命令是否可以识别ELF二进制可执行文件 1）使用readelf确定主机是大端还是小端,并分别为字符串\"MSB\"或\"LSB\"分配TEST_ARCH 2）将小C程序写入已知的\".c\"文件 3）使用\"cc\" Ex：cc xyz xyz.c 4）使用file命令获取对象文件的类型 5）在file输出中，grep ELF .*-bit $ TEST_ARCH executable, .* 字符。 6）如果上述命令成功，则将测试声明为PASS Test07：测试文件命令是否可以识别tar文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar 4）grep从上面的'file'命令的输出的中匹配字符串\"tar\" 5）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL Test08：测试文件命令是否可以tar zip文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用'gzip'命令来压缩tar文件 例如：gzip -f xyz.tar 4）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar.gz 5）grep从上面的文件commnand字符串\"gzip压缩数据，。*\" 6）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL 代码片段 测试file命令能识别出ASCII文本文件。 export TCID=file01 export TST_COUNT=1 $ LTPBIN /tst_resm TINFO \"TEST # 1:file command recogizes ASCII text files\" # log信息 cat > $ LTPTMP /test_file.txt <<EOF this is a text file to test file command EOF # 制作txt文本文件 ## 执行file命令并检查输出。 file $ LTPTMP /test_file.txt > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] # 判断返回值是否为０，验证file命令执行是否成功 then grep -q \"ASCII text\" $ LTPTMP /file.out # 匹配输出类型是否整齐 if [ $ ? -eq 0 ] then $ LTPBIN /test_resm TPASS \"file: Recognised ASCII file correctly\" rm -f $ LTPTMP /test_file.txt else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise ASCII file correctlyi. Reason:\" TFAILCNT= $(( $ TFAILCNT + 1 )) # error code＋１ fi else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: failed to recognize ASCII file correctly\\t\\t\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi TEST #2 测试是否识别shell脚本 export TCID=file02 export TST_COUNT=2 $ LTPBIN /tst_resm TINFO \"TEST # 2: file command recognizes bash shell scripts\" cat > $ LTPTMP /bash_script.sh <<EOF # ! /bin/bash echo \"this is a shell script\" echo \"used to test file command\" EOF file $ LTPTMP /bash_script.sh > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] then grep -q \"Bourne-Again shell script\" $ LTPTMP /file.out if [ $ ? -eq 0 ] then $ LTPBIN /tst_resm TPASS \"file: Recognised bash shell script correctly\" rm -f $ LTPTMP /bash_script.sh else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise bash shell script. Reason\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi else $ LTPBIN /tst_resm TFAIL \"file: Failed to recognize bash shell script\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi 其他测试代码同上面类似，不再一一分析。","tags":"自动化测试-LTP","title":"LTP－Command-file"},{"url":"http://king32783784.github.io/2016/06/01/LTP/","text":"该topic将深入分析ltp的测试内容，着重于具体每个case的测试内容及测试方法。通过对ltp case的分析，加强linux系统的理解和用例设计。本节主要整理ltp的包括测试case的类型和case列表。 整体情况 case主要分为\"commands\"、\"kdump\"、\"kernel\"、\"misc\"、\"network\"、\"open_posix_testsuite\"、\"realtime\"、\"lib\"等部分，主要内容如下： 分类 包含内容 commands ade cpio df eject gzip logrotate mail mkfs sshd tar unzip which at cron du fileutils insmod lsmod mkswap su tmp-tools wc kernel connectors controllers firmware hotplug input ipc logging mce-test module power_management sched syscalls tracing containers device-drivers fs include io lib mem numa pty security times misc crash f00f math network busy_poll dctcp iptables netstress nfsv4 rpc stress tcp_fstopen virt can dhcp iproute lib6 multicast nfs sockets tcp_cmds traceroute xinetd open_posix_testsuite functional tools bin conformance stress realtime perf profiles stress lib kdump commands 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which kernel 主要case包括: case 包含子case connectors connector pec containers libclone mountns mqns netns pidns share sysvipc userns utsname controllers cgroup cgroup_xattr cpuctl cpuset io-throttle memcg pids cgroup_fg cpuacct cpuctl_fj freezer libcontrollers memctl device-drivers acpi base cpufreq drm locking misc_modules pci tbio usb zram agp block dev_sim_framework nls rcu rtc uaccess v4l firmware fw_load_kernel fw_load_user fs acl dmapi ext4-new-features fs_blnd fs_inod fs_perms fsstress ftest iso9660 linktest mongo proc racer stram acls doio fs-bench fs_di fs_main fs_readonly fsx-linux inode lftest openfile quota_remount scsi hotplug cpu_hotplug memory_hotplug input input io aio direct_io disktest ltp-aiodio stress_cd stress_floppy writetest ipc pipeio semaphore logging kmsg mem cpuset mem mtest01 mtest06 oom shmt thp vma hugetlb ksm mmapstress mtest05 mtest07 page swapping tunable vmtests moudle create_module delete_module query_module numa numa power_management pm_ilb_test runpwtests01-06 runpwtests_exelusive01-06 pm_cpu_consolidation pm_include pm_sched_domain pty hangup ptem pty sched cfs-scheduler clisrv hypertherading nptl process_stress pthreads sched_stress tool security cap_bound filecaps integrity mmc_security prot_hsymlinks securbits smack tomoyo syscalls abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev timers clock_gettime clock_settime leapsec timer_create timer_delete timer_settime tracing ftrace misc case 包含子case crash crash f00f foof math abs atof float fptests nextafter network case 包含子case can filter-test dctcp dctcp dhcp dhcp_tests dhcp_lib dnsmasq_tests iproute ip_tests iptables iptables_tests lib6 asapi getaddrinfo in6 multicast mc_cmds mc_commo mc_gethost mc_member mc_opts netstress netstress nfs fsx-linux nfslock01 nfsstat01 nfs_stress nfsv4 acl locks rpc basic_tests rpc-tirpc sockets socket stress broken_ip dns ftp http icmp interface ipsec multicast ns-tools route ssh tcp udp tcp_cmds arping echo ftp netstat rcp rsh sendfile tcpdump trackpath clockdiff finger host ipneigh ping rdist rlogin rwho ssh telnet tcp_fastopen tcp_fastopen traceroute traceroute virt gre01 ipvlan macvlan macvtap vlan vxlan xinted xinted open_posix_testsuite case 包含子case bin run-all-posix-option-group-tests conformance behavior definitions interfaces functional mqueues semaphores threads timers stress mqueues semaphores signals threads timers realtime case 包含子case func async_handler hrtimer-prio matrix_mult periodic_cpu_load pi-tests prio-wake rt-migrate sched_jitter thrad_clock gtod_latency measurement pi_perf prio-preempt pthread_kill_latency sched_football sched_letency m4 m4 perf latency stress pi-tests 接下来会深入分析每个case的具体测试目的及内容。ltp测试用例主要采用shell和Ｃ编写。","tags":"自动化测试-LTP","title":"LTP－Case list"},{"url":"http://king32783784.github.io/2016/08/02/LTP/","text":"从本文开始，开始分析kernel部分的测试用例，该部分测试用例大部分为Ｃ语言编写，因此会穿插加入一定的Ｃ语言或unix环境编程的知识。 abort 设计说明 测试策略 Fork child. Child出现abort,检查返回状态 限制 Core file大小的限制必须大于０ abort 函数名: abort 功 能: 异常终止一个进程 用 法: void abort(void); abort()是使异常程序终止，同时发送SIGABRT信号给调用进程。 #include <stdlib.h> void abort ( void ); 该函数不返回 此函数将SIGABRT信号发送给调用进程（进程不应忽略此信号).ISO C规定，调用abort将向主机环境递送一个未成功终止的通知，其方法是调用raise(SIGABRT)函数。 ISO C要求若捕捉此信号而且相应信号处理程序返回，abort仍不会返回其调用者。如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、_Exit、longjmp或sigloogjmp.POSIX.1也说明 abort并不理会进程对此信号的阻塞和忽略。 让进程捕捉SIGABRT的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不在信号处理程序中终止自己，POSIX.1声明当信号处理程序返回时，abort终止该进程。 ISO C针对此函数的规范将下列问题留由实现决定： 是否要冲洗输出流以及是否删除临时文件。POSIX.1的要求更进一步，要求如果abort调用终止进程，则它对所有打开标准I/O流的效果应当与进程终止前对每个流调用fclose相同。 系统V早期的版本中，abort函数产生SIGIOT信号。更进一步，进程忽略此信号，或者捕捉它并从信号处理程序返回都是可能的，在返回情况下，abort返回到它的调用者。 4.3BSD产生SIGILL信号。在此之前，该函数解除对此信号的阻塞，将其配置恢复为SIG_DFL (终止并构造core文件)。这阻止一个进程忽略或捕捉此信号。 SVR4在产生此信号之前关闭所有I/O流。在另一方面，4.3+BSD则不做此操作。对于保护性的程序设计，如果希望刷新标准I/O流，则在调用abort之前要做这种操作。在err_dump函数中实现了这一点 因为大多数UNIX tmpfile(临时文件)的实现在创建该文件之后立即调用unlink，所以ANSI C关于临时文件的警告通常与我们无关。 abort的POSIX.1实现 #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> void abort ( void ) /*POSIX.1风格的abort()实现*/ { sigset_t mask ; struct sigaction action ; /* * Caller can't igore SIGABRT, if so reset to default. */ sigaction ( SIGABRT , NULL , & action ); if ( action . sa_handler == SIG_IGN ) { action . sa_handler == SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); } if ( action . sa_handler == SIG_DFL ) fflush ( NULL ) /* flush all open stdio stream */ /* * Caller can't block SIGABRT; make sure it's unblocked. */ sigfillset ( & mask ) sigdelset ( & mask , SIGABRT ); /* mask has only SIGABRT turned off */ sigprocmask ( SIG_SETMASK , & mask , NULL ); kill ( getpid (), SIGABRT ); /* send the signal */ /* * if we're here, process caught SIGABRT and returned. */ fflush ( NULL ); /*flush all open stdio streams*/ action . sa_handler = SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); /* reset to default */ sigprocmask ( SIG_SETMASK , & mask , NULL ); /* just in case ...*/ kill ( getpid (), SIGABRT ); /* and one more time*/ exit ( 1 ); /*this should never be executed...*/ 说明：首先查看是否将执行默认动作，若是则冲洗所有标准I/O流。这并不等价于对所有打开的流调用fclose(因为只冲洗，并不关闭它们），但是当进程终止时，系统会关闭所有打开的文件。如果进程捕捉此信号并返回， 那么因为进程产生了更多的输出，所以再一次冲洗所有的流。不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调用_exit或_Exit.这种情况下，内存中任何未冲洗的标准I/O缓冲区都被丢弃。我们假定捕捉此信号，而且_exit或_Exit的调用者并不想要冲洗缓冲区。 应用例子： #include <stdio.h> #include <stdlib.h> void main ( void ) { FILE * stream ; if (( stream = fopen ( \"NOSUCHF.ILE\" , \"r\" )) == NULL ) { perror ( \"Couldn't open file\" ); abort (); } } else fclose ( stream ); } 编译运行一下，看一下执行情况片段： execve(\"./test.o\", [\"./test.o\"], [/* 97 vars */]) = 0 open(\"NOSUCHF.ILE\", O_RDONLY) = -1 ENOENT (No such file or directory) dup(2) = 3 fcntl(3, F_GETFL) = 0x8402 (flags O_RDWR|O_APPEND|O_LARGEFILE) fstat(3, {st_mode=S_IFCHR|0600, st_rdev=makedev(136, 3), ...}) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd18aa86000 write(3, \"Couldn't open file: No such file\"..., 46Couldn't open file: No such file or directory ) = 46 close(3) = 0 munmap(0x7fd18aa86000, 4096) = 0 rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0 gettid() = 18489 tgkill(18489, 18489, SIGABRT) = 0 SIGABRT {si_signo=SIGABRT, si_code=SI_TKILL, si_pid=18489, si_uid=0} --- +++ killed by SIGABRT +++ 已放弃 abort测试代码说明 代码大体结构 |- macro || NUM || MIN_RLIMIT_CORE | |- variable || TCID || TST_TOTAL | |- function || main || setup || cleanup || do_child || instress 先看一下头文件： #include <sys/types.h> #include <sys/wait.h> #include <errno.h> #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/resource.h> #include \"test.h\" #include \"safe_macros.h\" 什么是头文件呢？ 在C语言家族程序中，头文件被大量使用。一般而言，每个C++/C程序通常由头文件(header files)和定义文件(definition files)组成。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明(declaration)，而定义文件用于保存程序的实现 (implementation) 让我们来看，经典程序 \"Hello world!\" 定义文件名\"First.c\" main() <sample-1> 看看上面的程序，没有.h文件,因为程序太简单，没有需要保存的声明。 文件名 First.c 变形 printStr() { printf(\"Hello world!\"); } main() { printStr() } <sample-2> 还是没有, 那就让我们把这个程序再稍微改动一下. 文件名 First.c main() { printStr() } printStr() { printf(\"Hello world!\"); } <sample-3> sample3和sample2是不同的，pritStr()函数定义的顺序不同。sample3是编译不通过的。这里面涉及作用域的问题。在这里只讲述与.h文件相关的顶层作用域。 顶层作用域就是从声明点延伸到源程序文本结束, 就printStr()这个函数来说，他没有单独的声明,只有定义,那么就从他定义的行开始,到first.c文件结束。sample2中，printStr的定义在main函数前面，所以作用域覆盖main函数，而sample3则没有。 这种情况怎么办呢? 有两种方法 ,一个pritStr函数定义到main函数之前，那就让我们来看另一个例子,让我们看看这个方法是不是在任何时候都会起作用. 文件名 First.c play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… } main() { play1() } <sample-4> 函数嵌套, 那么play1和play2这两个函数哪个放到前面呢? 这时就需要我们来使用第二种方法,使用声明. 文件名 First.c play1(); play2(); play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-5> 一个大型的软件项目,可能有几千个,上万个play, 而不只是play1,play2这么简单, 这样就可能有N个类似 play1(); play2(); 这样的声明, 这个时候就需要我们想办法把这样的play1(); play2(); 也另行管理, 而不是把他放在.c文件中, 于是.h文件出现了. 文件名 First.h play1(); play2(); 文件名 First.C #include \"first.h\" play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-6> 如在second.c中还有一个函数需要调用first.c文件中的play1函数, 如何实现呢? Sencond.h 文件 play1(); sencond.c文件 ***() { ……………. Play(); ………………. } <sample-7> 在sencond.h文件内声明play1函数，怎么能调用到first.c文件中的哪个play1函数中呢? 是不是搞错了，没有搞错, 这里涉及到c语言的另一个特性:存储类说明符. C语言的存储类说明符有以下几个, 我来列表说明一下 说明符 用法 Auto 只在块内变量声明中被允许, 表示变量具有本地生存期. Extern 出现在顶层或块的外部变量函数与变量声明中，表示声明的对象具有静态生存期, 连接程序知道其名字. Static 可以放在函数与变量声明中. 在函数定义时, 其只用于指定函数名,而不将函数导出到连接程序. 在函数声明中,表示其后面会有定义声明的函数, 存储类为static. 在数据声明中, 总是表示定义的声明不导出到连接程序. 无疑, 在sample7中的second.h和first.h中,需要我们用extern标志符来修饰play1函数的声明,这样,play1()函数就可以被导出到连接程序, 也就是实现了无论在first.c文件中调用,还是在second.c文件中调用,连接程序都会很聪明的按照我们的意愿,把他连接到first.c文件中的play1函数的定义上去, 而不必我们在second.c文件中也要再写一个一样的play1函数. 但随之有一个小问题, 在sample7中,我们并没有用extern标志符来修饰play1啊, 这里涉及到另一个问题, C语言中有默认的存储类标志符. C99中规定, 所有顶层的默认存储类标志符都是extern . 那么我们如何来区分哪个头文件中的声明在其对应的.c文件中有定义,而哪个又没有呢? 这也许不是必须的，因为无论在哪个文件中定义，聪明的连接程序都会义无返顾的帮我们找到，并导出到连接程序, 但我觉得他确实必要的. 因为我们需要知道这个函数的具体内容是什么,有什么功能, 有了新需求后我也许要修改他， 我需要在短时间内能找到这个函数的定义, 那么我来介绍一下在C语言中一个人为的规范: 在.h文件中声明的函数,如果在其对应的.c文件中有定义,那么我们在声明这个函数时,不使用extern修饰符, 如果反之,则必须显示使用extern修饰符. 这样,在C语言的.h文件中,我们会看到两种类型的函数声明. 带extern的,还不带extern的, 简单明了,一个是引用外部函数，一个是自己声明并定义的函数. 最终如下: Sencond.h 文件 Extern play1(); 那么多都是针对函数的，而实际上.h文件却不是为函数所专用的，还有全局变量. 在大型项目中，对全局变量的使用不可避免, 比如,在first.c中需要使用一个全局变量G_test, 那么我们可以在first.h中,定义 TPYE G_test. 与对函数的使用类似, 在second.c中我们的开发人员发现他也需要使用这个全局变量, 而且要与first.c中一样的那个, 如何处理? 对,我们可以仿照函数中的处理方法, 在second.h中再次声明TPYE G_test, 根据extern的用法,以及c语言中默认的存储类型, 在两个头文件中声明的TPYE G_test,其实其存储类型都是extern, 也就是说不必我们操心, 连接程序会帮助我们处理一切. 但我们又如何区分全局变量哪个是定义声明,哪个是引用声明呢?这个比函数要复杂一些, 一般在C语言中有如下几种模型来区分: 1、 初始化语句模型 顶层声明中，存在初始化语句是，表示这个声明是定义声明，其他声明是引用声明。C语言的所有文件之中，只能有一个定义声明。 按照这个模型，我们可以在first.h中定义如下TPYE G_test=1；那么就确定在first中的是定义声明，在其他的所有声明都是引用声明。 2、 省略存储类型说明 在这个模型中，所有引用声明要显示的包括存储类extern， 而每个外部变量的唯一定义声明中省略存储类说明符。 这个与我们对函数的处理方法类似，不再举例说明。 这里还有一个需要说明，数组全局变量。 在声明定义时，定义数组如下： int G_glob[100]; 在另一个文件中引用声明如下： int * G_glob; 在vc中，是可以编译通过的， 这种情况大家都比较模糊并且需要注意，数组与指针类似，但并不等于说对数组的声明起变量就是指针。 上面所说的的程序在运行时发现了问题，在引用声明的那个文件中，使用这个指针时总是提示内存访问错误，原来我们的连接程序并不把指针与数组等同，连接时，也不把他们当做同一个定义，而是认为是不相关的两个定义，当然会出现错误。正确的使用方法是在引用声明中声明如下： int G_glob[10]; 并且最好再加上一个extern，更加明了。 extern int G_glob[10]; 另外需要说明的是，在引用声明中由于不需要涉及到内存分配，可以简化如下，这样在需要对全局变量的长度进行修改时，不用把所有的引用声明也全部修改了。 extern int G_glob[]; 接下来，看一下linux环境编程头文件常用的有哪些？ linux常用头文件 POSIX标准定义的头文件 | 文件名 | 内容 | | ------- | -------- | dirent.h | 目录项 | fcntl.h | 文件控制 | fnmatch.h | 文件名匹配类型 | glob.h | 路径名模式匹配类型 | grp.h | 组文件 | <netdb.h> | 网络数据库操作 | <pwd.h> | 口令文件 | <regex.h> | 正则表达式 | <tar.h> | TAR归档值 | <termios.h> | 终端I/O | <unistd.h> | 符号常量 | <utime.h> | 文件时间 | <wordexp.h> | 字符扩展类型 | <arpa/inet.h> | INTERNET定义 | <net/if.h> | 套接字本地接口 | <netinet/in.h> | INTERNET地址族 | <netinet/tcp.h> | 传输控制协议定义 | <sys/mman.h> | 内存管理声明 | <sys/select.h> | Select函数 | <sys/socket.h> | 套接字借口 | <sys/stat.h> | 文件状态 | <sys/times.h> | 进程时间 | <sys/types.h> | 基本系统数据类型 | <sys/un.h> | UNIX域套接字定义 | <sys/utsname.h> | 系统名 | <sys/wait.h> | 进程控制 POSIX定义的XSI扩展头文件 | 文件名 | 内容 | | ------- | -------- | <cpio.h> | cpio归档值 | <dlfcn.h> | 动态链接 | <fmtmsg.h> | 消息显示结构 | <ftw.h> | 文件树漫游 | <iconv.h> | 代码集转换使用程序 | <langinfo.h> | 语言信息常量 | <libgen.h> | 模式匹配函数定义 | <monetary.h> | 货币类型 | <ndbm.h> | 数据库操作 | <nl_types.h> | 消息类别 | <poll.h> | 轮询函数 | <search.h>| 搜索表 | <strings.h> | 字符串操作 | <syslog.h> | 系统出错日志记录 | <ucontext.h> | 用户上下文 | <ulimit.h> | 用户限制 | <utmpx.h> | 用户帐户数据库 | <sys/ipc.h> | IPC(命名管道) | <sys/msg.h> | 消息队列 | <sys/resource.h>| 资源操作 | <sys/sem.h> | 信号量 | <sys/shm.h> | 共享存储 | <sys/statvfs.h> | 文件系统信息 | <sys/time.h> | 时间类型 | <sys/timeb.h> | 附加的日期和时间定义 | <sys/uio.h> | 矢量I/O操作 POSIX定义的可选头文件 | 文件名 | 内容 | | ------- | -------- | <aio.h> | 异步I/O | <mqueue.h> | 消息队列 | <pthread.h> | 线程 | <sched.h> | 执行调度 | <semaphore.h> | 信号量 | <spawn.h> | 实时spawn接口 | <stropts.h> | XSI STREAMS接口 | <trace.h> | 事件跟踪 C/C++头文件一览 C语言 | 文件名 | 内容 | | ------- | -------- | <assert.h>| 设定插入点 | <ctype.h> | 字符处理 | <errno.h> | 定义错误码 | <float.h> | 浮点数处理 | <iso646.h> | 对应各种运算符的宏 | <limits.h> | 定义各种数据类型最值的常量 | <locale.h> | 定义本地化C函数 | <math.h> | 定义数学函数 | <setjmp.h> | 异常处理支持 | <signal.h> | 信号机制支持 | <stdarg.h> | 不定参数列表支持 | <stddef.h> | 常用常量 | <stdio.h> | 定义输入／输出函数 | <stdlib.h>| 定义杂项函数及内存分配函数 | <string.h> | 字符串处理 | <time.h> | 定义关于时间的函数 | <wchar.h> | 宽字符处理及输入／输出 | <wctype.h> | 宽字符分类 传统C++ | 文件名 | 内容 | | ------- | -------- | <fstream.h> | 改用<fstream> | <iomanip.h> | 改用<iomainip> | <iostream.h> | 改用<iostream> | <strstrea.h> | 该类不再支持，改用<sstream>中的stringstream 标准C++ | 文件名 | 内容 | | ------- | -------- | <algorithm> | 通用算法 | <bitset> | 位集容器 | <cctype> | 字符处理 | <cerrno> | 定义错误码 | <cfloat> | 浮点数处理 | <ciso646> | 对应各种运算符的宏 | <climits> | 定义各种数据类型最值的常量 | <clocale> | 定义本地化函数 | <cmath> | 定义数学函数 | <complex> | 复数类 | <csignal> | 信号机制支持 | <csetjmp> | 异常处理支持 | <cstdarg> | 不定参数列表支持 | <cstddef> | 常用常量 | <cstdio> | 定义输入／输出函数 | <cstdlib> | 定义杂项函数及内存分配函数 | <cstring> | 字符串处理 | <ctime> | 定义关于时间的函数 | <cwchar> | 宽字符处理及输入／输出 | <cwctype> | 宽字符分类 | <deque> | STL 双端队列容器 | <exception> | 异常处理类 | <fstream> | 文件输入／输出 | <al> | STL 定义运算函数（代替运算符） | <limits> | 定义各种数据类型最值常量 | <list> | STL 线性列表容器 | <locale> | 本地化特定信息 | <map> | STL 映射容器 | <memory> | STL通过分配器进行的内存分配 | <new> | 动态内存分配 | <numeric> | STL常用的数字操作 | <iomanip> | 参数化输入／输出 | <iOS> | 基本输入／输出支持 | <iosfwd> | 输入／输出系统使用的前置声明 | <iostream> | 数据流输入／输出 | <istream> | 基本输入流 | <iterator> | STL迭代器 | <ostream> | 基本输出流 | <queue> | STL 队列容器 | <set> | STL 集合容器 | <sstream> | 基于字符串的流 | <stack> | STL 堆栈容器 | <stdexcept> | 标准异常类 | <streambuf> | /底层输入／输出支持 | <string> | 字符串类 | <typeinfo> | 运行期间类型信息 | <utility> | STL 通用模板类 | <valarray> | 对包含值的数组的操作 | <vector> | STL 动态数组容器 C99增加的部分 | 文件名 | 内容 | | ------- | -------- | <complex.h> | 复数处理 | <fenv.h> | 浮点环境 | <inttypes.h> | 整数格式转换 | <stdbool.h> | 布尔环境 | <stdint.h> | 整型环境 | <tgmath.h> | 通用类型数学宏 回到abort01的测试上来。先看一下执行情况： abort01 0 TINFO : Adjusting RLIMIT_CORE to 1048576 abort01 1 TPASS : abort dumped core abort01 2 TPASS : abort raised SIGIOT abort01 3 TPASS : abort dumped core abort01 4 TPASS : abort raised SIGIOT abort01 5 TPASS : abort dumped core abort01 6 TPASS : abort raised SIGIOT 程序后台执行片段 chdir(\"/tmp/aboeHLyFk\") = 0 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19587 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19587 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19587, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 1 TPASS : abort d\"..., 43abort01 1 TPASS : abort dumped core ) = 43 write(1, \"abort01 2 TPASS : abort r\"..., 45abort01 2 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19588 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19588 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19588, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 3 TPASS : abort d\"..., 43abort01 3 TPASS : abort dumped core ) = 43 write(1, \"abort01 4 TPASS : abort r\"..., 45abort01 4 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19589 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19589 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19589, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 5 TPASS : abort d\"..., 43abort01 5 TPASS : abort dumped core ) = 43 write(1, \"abort01 6 TPASS : abort r\"..., 45abort01 6 TPASS : abort raised SIGIOT ) = 45 unlink(\"core\") 从测试log来看，abort01主要进行abort\"dumped core\"、和\"raised SIGIOT\"两种测试，并且测试了３遍。０为setup打印信息。 #define NUM 3 /*定义fork进程的数量*/ char *TCID; /* tescase的名字*/ int TST_TOTAL; /* testcases数量 */ 主要函数 static void setup(void); static void cleanup(void); static void do_child(); static int instress(); int main(int argc, char *argv[]) 分别分析这几个函数 setup #define MIN_RLIMIT_CORE (1024 * 1024) static void setup(void) { struct rlimit rlim; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); if (rlim.rlim_cur < MIN_RLIMIT_CORE) { test_resm(TINFO, \"Adjusting RLIMIT_CORE to %i\", MIN_RLIMIT_CORE); rlim.rlim_cur = MIN_RLIMIT_CORE; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); } tst_tmpdir() } setup函数的目的是为了调整RLIMIT_CORE的大小。在Linux系统中，Resouce limit指在一个进程的执行过程中，它所能得到的资源的限制，比如进程的core file的最大值，虚拟内存的最大值等。Resouce limit的大小可以直接影响进程的执行状况。其有两个最重要的概念：soft limit 和 hard limit。 struct rlimit { rlim_t rlim_cur; rlim_t rlim_max; }; 是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件 数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。 tst_tmpdir函数说明一下，该函数用来为ltp测试程序创建临时目录，目录名case名称＋随机字母。 cleanup函数 static void cleanup(void) { unlink(\"core\") tst_rmdir(); } 该函数比较简单，用来清理产生的临时文件和软连接。可以做下试验，将main函数中的该函数注释掉，会在tmp下看到产生的core文件。 do_child函数 static void do_child(void) { abort() fprintf(stderr, \"\\tchild - abort failed.\\n\"); exit(1); } abort的调用，进程退出。 instress函数 static int instress(void) { test_resm(TINFO, \"System resources may be too low; fork(), select() etc are likely to fail.\"); return 1; } 系统资源比较低的情况， 出现fork()等调用失败时的处理。也是为兼容UCLINUK测试（如嵌入式系统）。 main函数 控制测试流程和主要的测试代码，以下将重点介绍一些代码片段。 #ifdef WCOREDUMP int core ; core = 0 ; #endif WCOREDUMP(status) 如果孩子进程产生核心转储文件则返回真。这个宏只应该在 WIFSIGNALED 返回真时调用。这个没有在 POSIX.1-2001 里指定并且在一些 UNIX 实现(如 AIX、SunOS)里也没有提供。只在 #ifdef WCOREDUMP ... #endif 内部使用。 #ifdef UCLINUX maybe_run_child ( & do_child , \"\" ); /* UCLINUX的情况 */ #endif setup (); /*调用setup函数*/ for ( i = 0 ; i < NUM ; i ++ ) { /*连续创建３个进程调用do_child函数*/ kidpid = FORK_OR_VFORK (); if ( kidpid == 0 ) { #ifdef UCLINUX if ( self_exec ( argv [ 0 ], \"\" )) { if ( ! instress ()) { perror ( \"fork failed\" ); exit ( 1 ); } } #else do_child (); //调用do_child()函数 #endif } } if ( kidpid < 0 ) if ( ! instress ()) tst_brkm ( TBROK | TERRNO , cleanup , \"fork failed\" ); count = 0 ; while (( child = wait ( & status )) > 0 ) count ++ ; if ( count != 1 ) { tst_brkm ( TBROK , cleanup , \"wrong # children waited on; got %d, expected 1\" , count ); } #ifdef WCOREDUMP core = WCOREDUMP ( status ); //WCOFEDUMP情况 #endif sig = WTERMSIG ( status ); } if ( WIFEXITED ( status )) ex = WEXITSTATUS ( status ); #ifdef WCOREDUMP if ( core == 0 ) { tst_brkm ( TFAIL , cleanup , \"Child did not dump core; exit code = %d, \" \"signal = %d\" , ex , sig ); } else if ( core != - 1 ) { tst_resm ( TPASS , \"abort dumped core\" ); //core值等于０，则没有正常产生core文件，如果core不等于０且不等于-1，说明正常产生了core文件 } #endif if ( sig == SIGIOT ) { tst_resm ( TPASS , \"abort raised SIGIOT\" ); //发出的信号如果为SIGIOT说明信号触发正常 } else { tst_brkm ( TFAIL , cleanup , \"Child did not raise SIGIOT (%d); exit code = %d, \" \"signal = %d\" , SIGIOT , ex , sig ); } } abort测试分析结束。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-abort"},{"url":"http://king32783784.github.io/2016/08/05/LTP/","text":"accept用例分析 case本身说明： Verify that accept() returns the proper errno for various failure cases 验证accept()是否返回正确的errno. 测试log accept01 1 TPASS : bad file descriptor successful accept01 2 TPASS : bad file descriptor successful accept01 3 TPASS : invalid socket buffer successful accept01 4 TPASS : invalid salen successful accept01 5 TPASS : invalid salen successful accept01 6 TPASS : no queued connections successful accept01 7 TPASS : UDP accept successful ~ 测试错误类型包括: bad file descriptor、invalid socket buffer、invalid salen、no queued connections、 UDP accept等 accept函数 accept() 接收一个套接字中已建立的连接 使用格式 #include <sys/types.h> #include <sys/socket.h> int accept ( int sockfd , struct sockaddr * addr , socklen_t * addrlen ); 功能参数描述 accept()系统调用主要用在基于链接的套接字类型，比如SOCK_STREAM和SOCK_SEQPACKET.它提取出所监听套接字的等待连接队列中第一个连接请求，创建一个新的套接字，并返回指向该套接字的文件描述符。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。 备注： 新建立的套接字准备发送send()和接收数据recv(). 参数： sockfd, 利用系统调用socket()建立的套接字描述符，通过bind()绑定到一个本地地址（一般为服务器的套接字），并且通过listen()一直在监听连接。 addr, 指向struct sockaddr的指针，该结构用通讯层服务器对等套接字的地址（一般为客户端地址）填写，返回地址addr的确切格式由套接字的地址类别（比如tcp或udp)决定；若addr为NULL，没有有效地址填写，这种情况下，addrlen也不使用，应该置为NULL； 备注： addr是个指向局部数据结构sockaddr_in的指针，这就是要求接入的信息本地的套接字（地址和指针） addrlen, 一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值，函数返回时包含对等地址（一般为服务器地址）的实际数值； 备注： addrlen 是个局部整型变量， 设置为sizeof(struct sockaddr_in) 如果队列中没有等待的连接，套接字也没有被标记为Non-blocking, accept()会阻塞调用函数知道连接出现；如果套接字被标记为Non-blocking, 队列中也没有等待的连接，accept返回错误EAGAIN或EWOULDBLOCK. 备注： 一般来说，实现时accept()为阻塞函数，当监听socket调用accept()时，它先到自己的receive_buf中查看是否有连接数据包； 若有，把数据拷贝处理啊，删掉接收到的数据包，创建新的socket与客户发来的地址建立链接； 若没有，就阻塞等待； 为了在套接字中有到来的连接时得到通知，可以使用select()或poll().当尝试建立新连接时，系统发送一个可读事件，然后调用accept()为该链接获取套接字。另一种方法是，当套接字中有连接到来时设定套接字发送SIGIO信号。 返回值 成功时，返回非负整数，该整数是接收到套接字的描述符；出错时，返回－１，相应的设定全局变量errno. 错误处理 Linux下，accept()把已等待的网络错误传给新建立的连接，当作是accept()返回的错误。这与其他的BSD实现是不同的。为了可靠运行，应该在accept()之后检测协议已定义的一些网络错误，并把这些错误当作EAGAIN并重试。对于tcp/ip协议来说，主要有：ENETDOWN,EPROTO,ENOPROTOOPT,EHOSTDOWN,ENONET,EHOSTUNREACH,EOPNOTSUPP和ENETUNREACH。 accept01.c代码分析 主要函数包括mian、setup、cleanup、setup0、cleanup0、setup1、cleanup1、setup2、setup3 test_case_t结构体 struct test_caset { int domain; /*AF_INIT, AF_UNIX,....*/ int type; /* SOCK_STREAM, SOCK_DGRAM...*/ int proto; /* protocol number(usually 0 = default) */ struct sockaddr *sockaddr; /*socket address buffer */ socklen_t *salen; /* accept's 3rd argument */ int retval; /* syscall return value */ int experrno; /* expected errno */ void (*setup)(void); void(*cleanup)(void); char *desc; } tdat[] = { {PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EBADF, setup0, cleanup0, \"bad file descriptor\"}, //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, ENOTSOCK, setup0, cleanup0, \"bad file descriptor\"}, { //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)3, &sinlen, -1, EINVAL, setup1, cleanup1, \"invalid socket buffer\"}, { //无效套接字缓存区 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, (socklen_t *) 1, -1, EINVAL, setup1, cleanup1, \"invalid salen\"}, { //无效的salen PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup2, cleanup1, \"invalid salen\"}, { PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup3, cleanup1, \"no queued connections\"}, { //队列中没有等待的连接 PF_INET, SOCK_DGRAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EOPNOTSUPP, setup1, cleanup1, \"UDP accept\"},}; int TST_TOTAL = sizeof(tdat) / sizeof(tdat[0]); /*通过数组的长度，计算测试用例数量*/ 先定义测试case需要的结构体，然后进行了 结构体初始化 ，定义了7种错误类型，对应7个测试case，和测试log是对应的。 顺便看一下 SOCK_STREAM和SOCK_DGRAM的区别： sock_stream 是有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料（如文件）传送。 sock_dgram 是无保障的面向消息的socket ， 主要用于在网络上发广播信息。 SOCK_STREAM是基于TCP的，数据传输比较有保障。SOCK_DGRAM是基于UDP的，专门用于局域网，基于广播 SOCK_STREAM 是数据流,一般是tcp/ip协议的编程,SOCK_DGRAM分是数据抱,是udp协议网络编程 再看说一下AF_INET和PF_INET的差别： 在Unix/Linux系统中，在不同的版本中这两者有微小差别.对于BSD,是AF,对于POSIX是PF.理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx 分别看一下这几个错误码 EBADF: 当作为参数的套接字不是一个有效的文件描述符(在Linux下用文件描述符来表示设备文件和普通文件。文件描述符是一个整型的数据，所有对文件的操作都通过文件描述符实现。文件描述符是文件系统中链接用户空间和内核空间的枢纽)时，抛出这个错误码。无效的文件描述符是什么意思呢？就是fd已经close的，或者本身就不是个有效的socket的fd。 ENOTSOCK: 在非socket上执行socket操作。 EINVAL： 无效参数。提供的参数非法。有时也会与socket的当前状态相关，如一个socket并没有进入listening状态，此时调用accept，就会产生EINVAL错误。 EOPNOTSUPP: 不支持的操作。 引用对象的类型不支持尝试的操作。通常，这发生在套接字描述符不支持此操作，例如，试着接受数据报套接字上的连接的套接字。 接下来看几个辅助函数。 1.setup函数 static void setup(void) { TEST_PAUSE; /*初始化本地 sockaddr*/ sin0.sin_family = AF_INET; //绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_INET，即使用IP sin0.sin_port = 0; sin0.sin_addr.s_addr = INADDR_ANY; //指定地址为0.0.0.0的地址 } TEST_PAUSE是一个 宏定义 ，代表usc_global_setup_hook()函数。作用是当设置了暂停标志后，暂停 SIGUSR1 ，当新的信号来时，再继续。下面是usc_global_setup_hook函数实现： #define TEST_PAUSE usc_global_setup_hook(); int usc_global_setup_hook () int usc_global_setup_hook ( void ) { #ifndef UCLINUX /*定义temp变量存储信号旧信号的动作，中断后恢复*/ int ( * _TMP_FUNC ) ( void ); /*中断等待sigusr1.*/ if ( STD_PAUSE ) { _TMP_FUNC = ( int ( * )()) singnal ( SIGUSR1 , STD_go ); pause () signal ( SIGUSR1 , ( void ( * )()) _TMP_FUNC ); } if ( STD_TP_sbrk ) || STD_LP_sbrk ) STD_start_break = sbrk ( 0 ); /*获取原始sbreak大小*/ if ( STD_TP_sbrk ){ sbrk ( STD_TP_sbrk ) : if ( Debug ) print ( \"after sbrk(%d) \\n \" , STD_TP_sbrk ); } #endif return 0 ; } 2.setup0函数case1测试前设置 static void setup0(void) 3.setup2 static void setup2(void) { setup1(); //调用setup1()获取套接字s sinlen = 1; //s置为无效 } 4.setup3 static void setup3(void) { int one = 1; setup1(); SAFE_IOCTL(cleanup, s, FIONBIO, &one); } SAFE_IOCTL #define SAFE_IOCTL ( cleanup_fn , fd , request , ...) \\ ( { int ret = ioctl ( fd , request , __VA_ARGS__ ); \\ ret < 0 ? \\ tst_brkm ( TBROK | TERRNO , cleanup_fn , \\ \"ioctl(%i,%s,...) failed\" , fd , #reques t ) \\ safe_ : ret ;} ) 6.cleanup、cleanup0, cleanup1 static void cleanup(void) { } static void cleanup0(void) { s = -1; } static void cleanup1(void) { (void)close(s); s = -1; } 重新设置s = -1 OK,现在看一下main函数。 int main(int ac, char *av[]) { int lc; tst_parse_opts(ac, av, NULL, NULL); //ltp参数解析函数 setup(); for (lc = 0; TEST_LOOPING(lc); ++lc){ test_count = 0; for (testno = 0; testno < TST_TOTAL; ++testno){ tdat[testno].setup(); TEST(accept(s, tdat[testno].sockaddr, tdat[testno].salen)); if (TEST_RETURN > 0) TEST_RETURN = 0; if (TEST_RETURN != tdat[testno].retval || (TEST_RETURN < 0 && TEST_ERRNO != tdat[testno].experrno)){ \"%ld(expected %d), errno %d (expected\" \"%d)\", tdat[testno].desc, TEST_RETURN, tdat[testno].desc, TEST_ERRNO, tdat[testno].experrno); } else { tst_resm(TPASS, \"%s successful\", tdat[testno].desc); } tdat[testno].cleanup(); } } cleanup(); tst_exit(); } 先看一下tst_parse_opts()函数 void tst_parse_opts(int argc, char *argv[], const option_t *user_optarg, void (*user_help)(void)) { const char *msg; msg = parse_opts(argc, argv, user_optarg, user_help); //parse_opts是参数解析函数，后面文章再进行介绍 if(msg) tst_brkm(TBROK, NULL, \"OPTION PARSING ERROR - %s \", msg); } 接下来调用setup，准备测试环境，初始化本地IP地址。然后是一个嵌套的两层循环，第一次是测试次数的遍历，通过TEST_LOOPING实现。 TEST_LOOPING是int usc_test_looping(int counter)函数，该函数后面的文章再进行解释。tst_count初始化为0。 第二层循环是遍历case数组。tdat[testno].setup()，调用对应setup准备case的特殊设置。 TEST启动测试， #define TEST(SCALL) \\ do { \\ errno = 0; \\ TEST_RETURN = SCALL; \\ TEST_ERRNO = errno; \\ } 然后将tdat中的对应参数，分别执行accept函数，如果预期的返回值不符或则返回值小于0且和预期的错误类型不匹配，则调用tst_resm()，进行出错处理。tst_resm将在后面进行分析。如果符合预期，则打印TPASS，然后调用tdat[testno].clearnup()分别清理环境。 最后调用cleanup()清理，tst_exit()退出，tst_exit()在单独分析ltp测试框架时分析。 到此，我们就清楚accept测试的内容了。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-accept()"},{"url":"http://king32783784.github.io/2016/08/01/LTP/","text":"syscalls ltp中kernel测试比重很大，尤其是syscalls，包括一下用例： 注：测试内容分析时补充。 用例名称 测试内容 abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev 接下来按照顺序分析系统调用的每一个case,并将每个case的测试内容补充到本文。 附linux系统主要系统调用列表 一、进程控制 fork 创建一个新进程 clone 按指定条件创建子进程 execve 运行可执行文件 exit 中止进程 _exit 立即中止当前进程 getdtablesize 进程所能打开的最大文件数 getpgid 获取指定进程组标识号 setpgid 设置指定进程组标志号 getpgrp 获取当前进程组标识号 setpgrp 设置当前进程组标志号 getpid 获取进程标识号 getppid 获取父进程标识号 getpriority 获取调度优先级 setpriority 设置调度优先级 modify_ldt 读写进程的本地描述表 nanosleep 使进程睡眠指定的时间 nice 改变分时进程的优先级 pause 挂起进程，等待信号 personality 设置进程运行域 prctl 对进程进行特定操作 ptrace 进程跟踪 sched_get_priority_max 取得静态优先级的上限 sched_get_priority_min 取得静态优先级的下限 sched_getparam 取得进程的调度参数 sched_getscheduler 取得指定进程的调度策略 sched_rr_get_interval 取得按RR算法调度的实时进程的时间片长度 sched_setparam 设置进程的调度参数 sched_setscheduler 设置指定进程的调度策略和参数 sched_yield 进程主动让出处理器,并将自己等候调度队列队尾 vfork 创建一个子进程，以供执行新程序，常与execve等同时使用 wait 等待子进程终止 wait3 参见wait waitpid 等待指定子进程终止 wait4 参见waitpid capget 获取进程权限 capset 设置进程权限 getsid 获取会晤标识号 setsid 设置会晤标识号 二、文件系统控制 1、文件读写操作 fcntl 文件控制 open 打开文件 creat 创建新文件 close 关闭文件描述字 read 读文件 write 写文件 readv 从文件读入数据到缓冲数组中 writev 将缓冲数组里的数据写入文件 pread 对文件随机读 pwrite 对文件随机写 lseek 移动文件指针 _llseek 在64位地址空间里移动文件指针 dup 复制已打开的文件描述字 dup2 按指定条件复制文件描述字 flock 文件加/解锁 poll I/O多路转换 truncate 截断文件 ftruncate 参见truncate umask 设置文件权限掩码 fsync 把文件在内存中的部分写回磁盘 2、文件系统操作 access 确定文件的可存取性 chdir 改变当前工作目录 fchdir 参见chdir chmod 改变文件方式 fchmod 参见chmod chown 改变文件的属主或用户组 fchown 参见chown lchown 参见chown chroot 改变根目录 stat 取文件状态信息 lstat 参见stat fstat 参见stat statfs 取文件系统信息 fstatfs 参见statfs readdir 读取目录项 getdents 读取目录项 mkdir 创建目录 mknod 创建索引节点 rmdir 删除目录 rename 文件改名 link 创建链接 symlink 创建符号链接 unlink 删除链接 readlink 读符号链接的值 mount 安装文件系统 umount 卸下文件系统 ustat 取文件系统信息 utime 改变文件的访问修改时间 utimes 参见utime quotactl 控制磁盘配额 三、系统控制 ioctl I/O总控制函数 _sysctl 读/写系统参数 acct 启用或禁止进程记账 getrlimit 获取系统资源上限 setrlimit 设置系统资源上限 getrusage 获取系统资源使用情况 uselib 选择要使用的二进制函数库 ioperm 设置端口I/O权限 iopl 改变进程I/O权限级别 outb 低级端口操作 reboot 重新启动 swapon 打开交换文件和设备 swapoff 关闭交换文件和设备 bdflush 控制bdflush守护进程 sysfs 取核心支持的文件系统类型 sysinfo 取得系统信息 adjtimex 调整系统时钟 alarm 设置进程的闹钟 getitimer 获取计时器值 setitimer 设置计时器值 gettimeofday 取时间和时区 settimeofday 设置时间和时区 stime 设置系统日期和时间 time 取得系统时间 times 取进程运行时间 uname 获取当前UNIX系统的名称、版本和主机等信息 vhangup 挂起当前终端 nfsservctl 对NFS守护进程进行控制 vm86 进入模拟8086模式 create_module 创建可装载的模块项 delete_module 删除可装载的模块项 init_module 初始化模块 query_module 查询模块信息 *get_kernel_syms 取得核心符号,已被query_module代替 四、内存管理 brk 改变数据段空间的分配 sbrk 参见brk mlock 内存页面加锁 munlock 内存页面解锁 mlockall 调用进程所有内存页面加锁 munlockall 调用进程所有内存页面解锁 mmap 映射虚拟内存页 munmap 去除内存页映射 mremap 重新映射虚拟内存地址 msync 将映射内存中的数据写回磁盘 mprotect 设置内存映像保护 getpagesize 获取页面大小 sync 将内存缓冲区数据写回硬盘 cacheflush 将指定缓冲区中的内容写回磁盘 五、网络管理 getdomainname 取域名 setdomainname 设置域名 gethostid 获取主机标识号 sethostid 设置主机标识号 gethostname 获取本主机名称 sethostname 设置主机名称 六、socket控制 socketcall socket系统调用 socket 建立socket bind 绑定socket到端口 connect 连接远程主机 accept 响应socket连接请求 send 通过socket发送信息 sendto 发送UDP信息 sendmsg 参见send recv 通过socket接收信息 recvfrom 接收UDP信息 recvmsg 参见recv listen 监听socket端口 select 对多路同步I/O进行轮询 shutdown 关闭socket上的连接 getsockname 取得本地socket名字 getpeername 获取通信对方的socket名字 getsockopt 取端口设置 setsockopt 设置端口参数 sendfile 在文件或端口间传输数据 socketpair 创建一对已联接的无名socket 七、用户管理 getuid 获取用户标识号 setuid 设置用户标志号 getgid 获取组标识号 setgid 设置组标志号 getegid 获取有效组标识号 setegid 设置有效组标识号 geteuid 获取有效用户标识号 seteuid 设置有效用户标识号 setregid 分别设置真实和有效的的组标识号 setreuid 分别设置真实和有效的用户标识号 getresgid 分别获取真实的,有效的和保存过的组标识号 setresgid 分别设置真实的,有效的和保存过的组标识号 getresuid 分别获取真实的,有效的和保存过的用户标识号 setresuid 分别设置真实的,有效的和保存过的用户标识号 setfsgid 设置文件系统检查时使用的组标识号 setfsuid 设置文件系统检查时使用的用户标识号 getgroups 获取后补组标志清单 setgroups 设置后补组标志清单 八、进程间通信 ipc 进程间通信总控制调用 1、信号 sigaction 设置对指定信号的处理方法 sigprocmask 根据参数对信号集中的信号执行阻塞/解除阻塞等操作 sigpending 为指定的被阻塞信号设置队列 sigsuspend 挂起进程等待特定信号 signal 参见signal kill 向进程或进程组发信号 *sigblock 向被阻塞信号掩码中添加信号,已被sigprocmask代替 *siggetmask 取得现有阻塞信号掩码,已被sigprocmask代替 *sigsetmask 用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替 *sigmask 将给定的信号转化为掩码,已被sigprocmask代替 *sigpause 作用同sigsuspend,已被sigsuspend代替 sigvec 为兼容BSD而设的信号处理函数,作用类似sigaction ssetmask ANSI C的信号处理函数,作用类似sigaction 2、消息 msgctl 消息控制操作 msgget 获取消息队列 msgsnd 发消息 msgrcv 取消息 3、管道 pipe 创建管道 4、信号量 semctl 信号量控制 semget 获取一组信号量 semop 信号量操作 5、共享内存 shmctl 控制共享内存 shmget 获取共享内存 shmat 连接共享内存 shmdt 拆卸共享内存","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls"},{"url":"http://king32783784.github.io/2016/06/03/LTP/","text":"file file 用例主要用于测试file命令。 file命令介绍 file命令可以通过查看文件内容来找出特定类型的文件，在UNIX/ Linux系统中，文件类型并不是由文件扩展名来决定的(windows中却正是这么做的),file命令的目的是从多个文件中收集文件类型统计信息。 file --help Usage: file [OPTION...] [FILE...] Determine type of FILEs. --help display this help and exit -v, --version output version information and exit -m, --magic-file LIST use LIST as a colon-separated list of magic number files -z, --uncompress try to look inside compressed files -Z, --uncompress-noreport only print the contents of compressed files -b, --brief do not prepend filenames to output lines -c, --checking-printout print the parsed form of the magic file, use in conjunction with -m to debug a new magic file before installing it -e, --exclude TEST exclude TEST from the list of test to be performed for file. Valid tests are: apptype, ascii, cdf, compress, elf, encoding, soft, tar, text, tokens -f, --files-from FILE read the filenames to be examined from FILE -F, --separator STRING use string as separator instead of `:' -i, --mime output MIME type strings (--mime-type and --mime-encoding) --apple output the Apple CREATOR/TYPE --extension output a slash-separated list of extnsions --mime-type output the MIME type --mime-encoding output the MIME encoding -k, --keep-going don't stop at the first match -l, --list list magic strength -L, --dereference follow symlinks (default) -h, --no-dereference don't follow symlinks -n, --no-buffer do not buffer output -N, --no-pad do not pad output -0, --print0 terminate filenames with ASCII NUL -p, --preserve-date preserve access times on files -P, --parameter set file engine parameter limits indir 15 recursion limit for indirection name 30 use limit for name/use magic elf_notes 256 max ELF notes processed elf_phnum 128 max ELF prog sections processed elf_shnum 32768 max ELF sections processed -r, --raw don't translate unprintable chars to \\ooo -s, --special-files treat special (block/char devices) files as ordinary ones -C, --compile compile file specified by -m -d, --debug print debugging messages 必要参数 -b 文件名不显示 -c 显示详细处理信息 -L 操作对象为符号链接所指向的对象 -z 压缩文件的处理 -C 列出magic.mgc的输出 -n 将结果输出到标准输出 -f<文件名> 指定文件名 -m<文件名> 指定魔法数字名 选择参数 --help 显示帮助信息 -v 显示版本信息 实例： 1.查看所有文件类型 file * 2.2.查看具体某一文件的类型：file filename 3.-b参数，打印出不包含文件名的文件类型信息: 4.-z 参数，可以获取用gzip、zip压缩过的文件的类型 5.-n参数，将信息标准输出 言归正传，file_test.sh 脚本主要验证是否支持多种文件格式，比如tar tar.gz rpm c ascii elf等。 用例设置： Test01：测试文件命令是否识别ASCII文本文件 1）将文本写入已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.txt 3）grep为关键字\"ASCII文本\"的输出 'file'命令 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test02：测试文件命令是否能识别bash shell脚本 1）将一个小shell脚本写入一个已知文件 2）使用'file'命令获取已知文件的类型 例如：文件xyz.sh 3）从'file'命令的输出中Grep关键字\"Bourne-Again shell脚本\" 4）如果上述步骤成功，则将测试声明为PASS,否则为fail Test03：测试文件命令是否能识别bash shell脚本 使用Korn shell脚本执行类似的测试（如Test02） Test04：测试文件命令是否可以识别C shell脚本 使用C shell脚本执行类似的测试（如Test02） Test05：测试文件命令是否可以识别C程序文本 使用test2类似方法测试c程序文本 Test06：测试文件命令是否可以识别ELF二进制可执行文件 1）使用readelf确定主机是大端还是小端,并分别为字符串\"MSB\"或\"LSB\"分配TEST_ARCH 2）将小C程序写入已知的\".c\"文件 3）使用\"cc\" Ex：cc xyz xyz.c 4）使用file命令获取对象文件的类型 5）在file输出中，grep ELF .*-bit $ TEST_ARCH executable, .* 字符。 6）如果上述命令成功，则将测试声明为PASS Test07：测试文件命令是否可以识别tar文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar 4）grep从上面的'file'命令的输出的中匹配字符串\"tar\" 5）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL Test08：测试文件命令是否可以tar zip文件 1）将文本写入三个不同的文件 2）使用\"tar\"命令存档文件 例如：tar -cf ... 3）使用'gzip'命令来压缩tar文件 例如：gzip -f xyz.tar 4）使用\"file\"命令获取归档文件的类型 例如：文件xyz.tar.gz 5）grep从上面的文件commnand字符串\"gzip压缩数据，。*\" 6）声明测试为PASS，如果上面的步骤成功，否则声明测试为FAIL 代码片段 测试file命令能识别出ASCII文本文件。 export TCID=file01 export TST_COUNT=1 $ LTPBIN /tst_resm TINFO \"TEST # 1:file command recogizes ASCII text files\" # log信息 cat > $ LTPTMP /test_file.txt <<EOF this is a text file to test file command EOF # 制作txt文本文件 ## 执行file命令并检查输出。 file $ LTPTMP /test_file.txt > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] # 判断返回值是否为０，验证file命令执行是否成功 then grep -q \"ASCII text\" $ LTPTMP /file.out # 匹配输出类型是否整齐 if [ $ ? -eq 0 ] then $ LTPBIN /test_resm TPASS \"file: Recognised ASCII file correctly\" rm -f $ LTPTMP /test_file.txt else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise ASCII file correctlyi. Reason:\" TFAILCNT= $(( $ TFAILCNT + 1 )) # error code＋１ fi else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: failed to recognize ASCII file correctly\\t\\t\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi TEST #2 测试是否识别shell脚本 export TCID=file02 export TST_COUNT=2 $ LTPBIN /tst_resm TINFO \"TEST # 2: file command recognizes bash shell scripts\" cat > $ LTPTMP /bash_script.sh <<EOF # ! /bin/bash echo \"this is a shell script\" echo \"used to test file command\" EOF file $ LTPTMP /bash_script.sh > $ LTPTMP /file.out 2>&1 if [ $ ? -eq 0 ] then grep -q \"Bourne-Again shell script\" $ LTPTMP /file.out if [ $ ? -eq 0 ] then $ LTPBIN /tst_resm TPASS \"file: Recognised bash shell script correctly\" rm -f $ LTPTMP /bash_script.sh else $ LTPBIN /tst_res TFAIL $ LTPTMP /file.out \\ \"file: Failed to recognise bash shell script. Reason\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi else $ LTPBIN /tst_resm TFAIL \"file: Failed to recognize bash shell script\" TFAILCNT= $(( $ TFAILCNT + 1 )) fi 其他测试代码同上面类似，不再一一分析。","tags":"自动化测试-LTP","title":"LTP－Command-file"},{"url":"http://king32783784.github.io/2016/08/02/LTP/","text":"从本文开始，开始分析kernel部分的测试用例，该部分测试用例大部分为Ｃ语言编写，因此会穿插加入一定的Ｃ语言或unix环境编程的知识。 abort 设计说明 测试策略 Fork child. Child出现abort,检查返回状态 限制 Core file大小的限制必须大于０ abort 函数名: abort 功 能: 异常终止一个进程 用 法: void abort(void); abort()是使异常程序终止，同时发送SIGABRT信号给调用进程。 #include <stdlib.h> void abort ( void ); 该函数不返回 此函数将SIGABRT信号发送给调用进程（进程不应忽略此信号).ISO C规定，调用abort将向主机环境递送一个未成功终止的通知，其方法是调用raise(SIGABRT)函数。 ISO C要求若捕捉此信号而且相应信号处理程序返回，abort仍不会返回其调用者。如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、_Exit、longjmp或sigloogjmp.POSIX.1也说明 abort并不理会进程对此信号的阻塞和忽略。 让进程捕捉SIGABRT的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不在信号处理程序中终止自己，POSIX.1声明当信号处理程序返回时，abort终止该进程。 ISO C针对此函数的规范将下列问题留由实现决定： 是否要冲洗输出流以及是否删除临时文件。POSIX.1的要求更进一步，要求如果abort调用终止进程，则它对所有打开标准I/O流的效果应当与进程终止前对每个流调用fclose相同。 系统V早期的版本中，abort函数产生SIGIOT信号。更进一步，进程忽略此信号，或者捕捉它并从信号处理程序返回都是可能的，在返回情况下，abort返回到它的调用者。 4.3BSD产生SIGILL信号。在此之前，该函数解除对此信号的阻塞，将其配置恢复为SIG_DFL (终止并构造core文件)。这阻止一个进程忽略或捕捉此信号。 SVR4在产生此信号之前关闭所有I/O流。在另一方面，4.3+BSD则不做此操作。对于保护性的程序设计，如果希望刷新标准I/O流，则在调用abort之前要做这种操作。在err_dump函数中实现了这一点 因为大多数UNIX tmpfile(临时文件)的实现在创建该文件之后立即调用unlink，所以ANSI C关于临时文件的警告通常与我们无关。 abort的POSIX.1实现 #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> void abort ( void ) /*POSIX.1风格的abort()实现*/ { sigset_t mask ; struct sigaction action ; /* * Caller can't igore SIGABRT, if so reset to default. */ sigaction ( SIGABRT , NULL , & action ); if ( action . sa_handler == SIG_IGN ) { action . sa_handler == SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); } if ( action . sa_handler == SIG_DFL ) fflush ( NULL ) /* flush all open stdio stream */ /* * Caller can't block SIGABRT; make sure it's unblocked. */ sigfillset ( & mask ) sigdelset ( & mask , SIGABRT ); /* mask has only SIGABRT turned off */ sigprocmask ( SIG_SETMASK , & mask , NULL ); kill ( getpid (), SIGABRT ); /* send the signal */ /* * if we're here, process caught SIGABRT and returned. */ fflush ( NULL ); /*flush all open stdio streams*/ action . sa_handler = SIG_DFL ; sigaction ( SIGABRT , & action , NULL ); /* reset to default */ sigprocmask ( SIG_SETMASK , & mask , NULL ); /* just in case ...*/ kill ( getpid (), SIGABRT ); /* and one more time*/ exit ( 1 ); /*this should never be executed...*/ 说明：首先查看是否将执行默认动作，若是则冲洗所有标准I/O流。这并不等价于对所有打开的流调用fclose(因为只冲洗，并不关闭它们），但是当进程终止时，系统会关闭所有打开的文件。如果进程捕捉此信号并返回， 那么因为进程产生了更多的输出，所以再一次冲洗所有的流。不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调用_exit或_Exit.这种情况下，内存中任何未冲洗的标准I/O缓冲区都被丢弃。我们假定捕捉此信号，而且_exit或_Exit的调用者并不想要冲洗缓冲区。 应用例子： #include <stdio.h> #include <stdlib.h> void main ( void ) { FILE * stream ; if (( stream = fopen ( \"NOSUCHF.ILE\" , \"r\" )) == NULL ) { perror ( \"Couldn't open file\" ); abort (); } } else fclose ( stream ); } 编译运行一下，看一下执行情况片段： execve(\"./test.o\", [\"./test.o\"], [/* 97 vars */]) = 0 open(\"NOSUCHF.ILE\", O_RDONLY) = -1 ENOENT (No such file or directory) dup(2) = 3 fcntl(3, F_GETFL) = 0x8402 (flags O_RDWR|O_APPEND|O_LARGEFILE) fstat(3, {st_mode=S_IFCHR|0600, st_rdev=makedev(136, 3), ...}) = 0 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd18aa86000 write(3, \"Couldn't open file: No such file\"..., 46Couldn't open file: No such file or directory ) = 46 close(3) = 0 munmap(0x7fd18aa86000, 4096) = 0 rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0 gettid() = 18489 tgkill(18489, 18489, SIGABRT) = 0 SIGABRT {si_signo=SIGABRT, si_code=SI_TKILL, si_pid=18489, si_uid=0} --- +++ killed by SIGABRT +++ 已放弃 abort测试代码说明 代码大体结构 |- macro || NUM || MIN_RLIMIT_CORE | |- variable || TCID || TST_TOTAL | |- function || main || setup || cleanup || do_child || instress 先看一下头文件： #include <sys/types.h> #include <sys/wait.h> #include <errno.h> #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <sys/resource.h> #include \"test.h\" #include \"safe_macros.h\" 什么是头文件呢？ 在C语言家族程序中，头文件被大量使用。一般而言，每个C++/C程序通常由头文件(header files)和定义文件(definition files)组成。头文件作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明(declaration)，而定义文件用于保存程序的实现 (implementation) 让我们来看，经典程序 \"Hello world!\" 定义文件名\"First.c\" main() <sample-1> 看看上面的程序，没有.h文件,因为程序太简单，没有需要保存的声明。 文件名 First.c 变形 printStr() { printf(\"Hello world!\"); } main() { printStr() } <sample-2> 还是没有, 那就让我们把这个程序再稍微改动一下. 文件名 First.c main() { printStr() } printStr() { printf(\"Hello world!\"); } <sample-3> sample3和sample2是不同的，pritStr()函数定义的顺序不同。sample3是编译不通过的。这里面涉及作用域的问题。在这里只讲述与.h文件相关的顶层作用域。 顶层作用域就是从声明点延伸到源程序文本结束, 就printStr()这个函数来说，他没有单独的声明,只有定义,那么就从他定义的行开始,到first.c文件结束。sample2中，printStr的定义在main函数前面，所以作用域覆盖main函数，而sample3则没有。 这种情况怎么办呢? 有两种方法 ,一个pritStr函数定义到main函数之前，那就让我们来看另一个例子,让我们看看这个方法是不是在任何时候都会起作用. 文件名 First.c play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… } main() { play1() } <sample-4> 函数嵌套, 那么play1和play2这两个函数哪个放到前面呢? 这时就需要我们来使用第二种方法,使用声明. 文件名 First.c play1(); play2(); play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-5> 一个大型的软件项目,可能有几千个,上万个play, 而不只是play1,play2这么简单, 这样就可能有N个类似 play1(); play2(); 这样的声明, 这个时候就需要我们想办法把这样的play1(); play2(); 也另行管理, 而不是把他放在.c文件中, 于是.h文件出现了. 文件名 First.h play1(); play2(); 文件名 First.C #include \"first.h\" play2() { ………………. play1() ……………….. } play1() { …………………….. play2() …………………… ); } main() { play1() } <sample-6> 如在second.c中还有一个函数需要调用first.c文件中的play1函数, 如何实现呢? Sencond.h 文件 play1(); sencond.c文件 ***() { ……………. Play(); ………………. } <sample-7> 在sencond.h文件内声明play1函数，怎么能调用到first.c文件中的哪个play1函数中呢? 是不是搞错了，没有搞错, 这里涉及到c语言的另一个特性:存储类说明符. C语言的存储类说明符有以下几个, 我来列表说明一下 说明符 用法 Auto 只在块内变量声明中被允许, 表示变量具有本地生存期. Extern 出现在顶层或块的外部变量函数与变量声明中，表示声明的对象具有静态生存期, 连接程序知道其名字. Static 可以放在函数与变量声明中. 在函数定义时, 其只用于指定函数名,而不将函数导出到连接程序. 在函数声明中,表示其后面会有定义声明的函数, 存储类为static. 在数据声明中, 总是表示定义的声明不导出到连接程序. 无疑, 在sample7中的second.h和first.h中,需要我们用extern标志符来修饰play1函数的声明,这样,play1()函数就可以被导出到连接程序, 也就是实现了无论在first.c文件中调用,还是在second.c文件中调用,连接程序都会很聪明的按照我们的意愿,把他连接到first.c文件中的play1函数的定义上去, 而不必我们在second.c文件中也要再写一个一样的play1函数. 但随之有一个小问题, 在sample7中,我们并没有用extern标志符来修饰play1啊, 这里涉及到另一个问题, C语言中有默认的存储类标志符. C99中规定, 所有顶层的默认存储类标志符都是extern . 那么我们如何来区分哪个头文件中的声明在其对应的.c文件中有定义,而哪个又没有呢? 这也许不是必须的，因为无论在哪个文件中定义，聪明的连接程序都会义无返顾的帮我们找到，并导出到连接程序, 但我觉得他确实必要的. 因为我们需要知道这个函数的具体内容是什么,有什么功能, 有了新需求后我也许要修改他， 我需要在短时间内能找到这个函数的定义, 那么我来介绍一下在C语言中一个人为的规范: 在.h文件中声明的函数,如果在其对应的.c文件中有定义,那么我们在声明这个函数时,不使用extern修饰符, 如果反之,则必须显示使用extern修饰符. 这样,在C语言的.h文件中,我们会看到两种类型的函数声明. 带extern的,还不带extern的, 简单明了,一个是引用外部函数，一个是自己声明并定义的函数. 最终如下: Sencond.h 文件 Extern play1(); 那么多都是针对函数的，而实际上.h文件却不是为函数所专用的，还有全局变量. 在大型项目中，对全局变量的使用不可避免, 比如,在first.c中需要使用一个全局变量G_test, 那么我们可以在first.h中,定义 TPYE G_test. 与对函数的使用类似, 在second.c中我们的开发人员发现他也需要使用这个全局变量, 而且要与first.c中一样的那个, 如何处理? 对,我们可以仿照函数中的处理方法, 在second.h中再次声明TPYE G_test, 根据extern的用法,以及c语言中默认的存储类型, 在两个头文件中声明的TPYE G_test,其实其存储类型都是extern, 也就是说不必我们操心, 连接程序会帮助我们处理一切. 但我们又如何区分全局变量哪个是定义声明,哪个是引用声明呢?这个比函数要复杂一些, 一般在C语言中有如下几种模型来区分: 1、 初始化语句模型 顶层声明中，存在初始化语句是，表示这个声明是定义声明，其他声明是引用声明。C语言的所有文件之中，只能有一个定义声明。 按照这个模型，我们可以在first.h中定义如下TPYE G_test=1；那么就确定在first中的是定义声明，在其他的所有声明都是引用声明。 2、 省略存储类型说明 在这个模型中，所有引用声明要显示的包括存储类extern， 而每个外部变量的唯一定义声明中省略存储类说明符。 这个与我们对函数的处理方法类似，不再举例说明。 这里还有一个需要说明，数组全局变量。 在声明定义时，定义数组如下： int G_glob[100]; 在另一个文件中引用声明如下： int * G_glob; 在vc中，是可以编译通过的， 这种情况大家都比较模糊并且需要注意，数组与指针类似，但并不等于说对数组的声明起变量就是指针。 上面所说的的程序在运行时发现了问题，在引用声明的那个文件中，使用这个指针时总是提示内存访问错误，原来我们的连接程序并不把指针与数组等同，连接时，也不把他们当做同一个定义，而是认为是不相关的两个定义，当然会出现错误。正确的使用方法是在引用声明中声明如下： int G_glob[10]; 并且最好再加上一个extern，更加明了。 extern int G_glob[10]; 另外需要说明的是，在引用声明中由于不需要涉及到内存分配，可以简化如下，这样在需要对全局变量的长度进行修改时，不用把所有的引用声明也全部修改了。 extern int G_glob[]; 接下来，看一下linux环境编程头文件常用的有哪些？ linux常用头文件 POSIX标准定义的头文件 | 文件名 | 内容 | | ------- | -------- | dirent.h | 目录项 | fcntl.h | 文件控制 | fnmatch.h | 文件名匹配类型 | glob.h | 路径名模式匹配类型 | grp.h | 组文件 | <netdb.h> | 网络数据库操作 | <pwd.h> | 口令文件 | <regex.h> | 正则表达式 | <tar.h> | TAR归档值 | <termios.h> | 终端I/O | <unistd.h> | 符号常量 | <utime.h> | 文件时间 | <wordexp.h> | 字符扩展类型 | <arpa/inet.h> | INTERNET定义 | <net/if.h> | 套接字本地接口 | <netinet/in.h> | INTERNET地址族 | <netinet/tcp.h> | 传输控制协议定义 | <sys/mman.h> | 内存管理声明 | <sys/select.h> | Select函数 | <sys/socket.h> | 套接字借口 | <sys/stat.h> | 文件状态 | <sys/times.h> | 进程时间 | <sys/types.h> | 基本系统数据类型 | <sys/un.h> | UNIX域套接字定义 | <sys/utsname.h> | 系统名 | <sys/wait.h> | 进程控制 POSIX定义的XSI扩展头文件 | 文件名 | 内容 | | ------- | -------- | <cpio.h> | cpio归档值 | <dlfcn.h> | 动态链接 | <fmtmsg.h> | 消息显示结构 | <ftw.h> | 文件树漫游 | <iconv.h> | 代码集转换使用程序 | <langinfo.h> | 语言信息常量 | <libgen.h> | 模式匹配函数定义 | <monetary.h> | 货币类型 | <ndbm.h> | 数据库操作 | <nl_types.h> | 消息类别 | <poll.h> | 轮询函数 | <search.h>| 搜索表 | <strings.h> | 字符串操作 | <syslog.h> | 系统出错日志记录 | <ucontext.h> | 用户上下文 | <ulimit.h> | 用户限制 | <utmpx.h> | 用户帐户数据库 | <sys/ipc.h> | IPC(命名管道) | <sys/msg.h> | 消息队列 | <sys/resource.h>| 资源操作 | <sys/sem.h> | 信号量 | <sys/shm.h> | 共享存储 | <sys/statvfs.h> | 文件系统信息 | <sys/time.h> | 时间类型 | <sys/timeb.h> | 附加的日期和时间定义 | <sys/uio.h> | 矢量I/O操作 POSIX定义的可选头文件 | 文件名 | 内容 | | ------- | -------- | <aio.h> | 异步I/O | <mqueue.h> | 消息队列 | <pthread.h> | 线程 | <sched.h> | 执行调度 | <semaphore.h> | 信号量 | <spawn.h> | 实时spawn接口 | <stropts.h> | XSI STREAMS接口 | <trace.h> | 事件跟踪 C/C++头文件一览 C语言 | 文件名 | 内容 | | ------- | -------- | <assert.h>| 设定插入点 | <ctype.h> | 字符处理 | <errno.h> | 定义错误码 | <float.h> | 浮点数处理 | <iso646.h> | 对应各种运算符的宏 | <limits.h> | 定义各种数据类型最值的常量 | <locale.h> | 定义本地化C函数 | <math.h> | 定义数学函数 | <setjmp.h> | 异常处理支持 | <signal.h> | 信号机制支持 | <stdarg.h> | 不定参数列表支持 | <stddef.h> | 常用常量 | <stdio.h> | 定义输入／输出函数 | <stdlib.h>| 定义杂项函数及内存分配函数 | <string.h> | 字符串处理 | <time.h> | 定义关于时间的函数 | <wchar.h> | 宽字符处理及输入／输出 | <wctype.h> | 宽字符分类 传统C++ | 文件名 | 内容 | | ------- | -------- | <fstream.h> | 改用<fstream> | <iomanip.h> | 改用<iomainip> | <iostream.h> | 改用<iostream> | <strstrea.h> | 该类不再支持，改用<sstream>中的stringstream 标准C++ | 文件名 | 内容 | | ------- | -------- | <algorithm> | 通用算法 | <bitset> | 位集容器 | <cctype> | 字符处理 | <cerrno> | 定义错误码 | <cfloat> | 浮点数处理 | <ciso646> | 对应各种运算符的宏 | <climits> | 定义各种数据类型最值的常量 | <clocale> | 定义本地化函数 | <cmath> | 定义数学函数 | <complex> | 复数类 | <csignal> | 信号机制支持 | <csetjmp> | 异常处理支持 | <cstdarg> | 不定参数列表支持 | <cstddef> | 常用常量 | <cstdio> | 定义输入／输出函数 | <cstdlib> | 定义杂项函数及内存分配函数 | <cstring> | 字符串处理 | <ctime> | 定义关于时间的函数 | <cwchar> | 宽字符处理及输入／输出 | <cwctype> | 宽字符分类 | <deque> | STL 双端队列容器 | <exception> | 异常处理类 | <fstream> | 文件输入／输出 | <al> | STL 定义运算函数（代替运算符） | <limits> | 定义各种数据类型最值常量 | <list> | STL 线性列表容器 | <locale> | 本地化特定信息 | <map> | STL 映射容器 | <memory> | STL通过分配器进行的内存分配 | <new> | 动态内存分配 | <numeric> | STL常用的数字操作 | <iomanip> | 参数化输入／输出 | <iOS> | 基本输入／输出支持 | <iosfwd> | 输入／输出系统使用的前置声明 | <iostream> | 数据流输入／输出 | <istream> | 基本输入流 | <iterator> | STL迭代器 | <ostream> | 基本输出流 | <queue> | STL 队列容器 | <set> | STL 集合容器 | <sstream> | 基于字符串的流 | <stack> | STL 堆栈容器 | <stdexcept> | 标准异常类 | <streambuf> | /底层输入／输出支持 | <string> | 字符串类 | <typeinfo> | 运行期间类型信息 | <utility> | STL 通用模板类 | <valarray> | 对包含值的数组的操作 | <vector> | STL 动态数组容器 C99增加的部分 | 文件名 | 内容 | | ------- | -------- | <complex.h> | 复数处理 | <fenv.h> | 浮点环境 | <inttypes.h> | 整数格式转换 | <stdbool.h> | 布尔环境 | <stdint.h> | 整型环境 | <tgmath.h> | 通用类型数学宏 回到abort01的测试上来。先看一下执行情况： abort01 0 TINFO : Adjusting RLIMIT_CORE to 1048576 abort01 1 TPASS : abort dumped core abort01 2 TPASS : abort raised SIGIOT abort01 3 TPASS : abort dumped core abort01 4 TPASS : abort raised SIGIOT abort01 5 TPASS : abort dumped core abort01 6 TPASS : abort raised SIGIOT 程序后台执行片段 chdir(\"/tmp/aboeHLyFk\") = 0 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19587 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19587 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19587, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 1 TPASS : abort d\"..., 43abort01 1 TPASS : abort dumped core ) = 43 write(1, \"abort01 2 TPASS : abort r\"..., 45abort01 2 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19588 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19588 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19588, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 3 TPASS : abort d\"..., 43abort01 3 TPASS : abort dumped core ) = 43 write(1, \"abort01 4 TPASS : abort r\"..., 45abort01 4 TPASS : abort raised SIGIOT ) = 45 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb05157a9d0) = 19589 wait4(-1, [{WIFSIGNALED(s) && WTERMSIG(s) == SIGABRT && WCOREDUMP(s)}], 0, NULL) = 19589 SIGCHLD {si_signo=SIGCHLD, si_code=CLD_DUMPED, si_pid=19589, si_uid=0, si_status=SIGABRT, si_utime=0, si_stime=0} --- wait4(-1, 0x7ffd43788f30, 0, NULL) = -1 ECHILD (No child processes) write(1, \"abort01 5 TPASS : abort d\"..., 43abort01 5 TPASS : abort dumped core ) = 43 write(1, \"abort01 6 TPASS : abort r\"..., 45abort01 6 TPASS : abort raised SIGIOT ) = 45 unlink(\"core\") 从测试log来看，abort01主要进行abort\"dumped core\"、和\"raised SIGIOT\"两种测试，并且测试了３遍。０为setup打印信息。 #define NUM 3 /*定义fork进程的数量*/ char *TCID; /* tescase的名字*/ int TST_TOTAL; /* testcases数量 */ 主要函数 static void setup(void); static void cleanup(void); static void do_child(); static int instress(); int main(int argc, char *argv[]) 分别分析这几个函数 setup #define MIN_RLIMIT_CORE (1024 * 1024) static void setup(void) { struct rlimit rlim; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); if (rlim.rlim_cur < MIN_RLIMIT_CORE) { test_resm(TINFO, \"Adjusting RLIMIT_CORE to %i\", MIN_RLIMIT_CORE); rlim.rlim_cur = MIN_RLIMIT_CORE; SAFE_GETRLIMIT(NULL, RLIMIT_CORE, &rlim); } tst_tmpdir() } setup函数的目的是为了调整RLIMIT_CORE的大小。在Linux系统中，Resouce limit指在一个进程的执行过程中，它所能得到的资源的限制，比如进程的core file的最大值，虚拟内存的最大值等。Resouce limit的大小可以直接影响进程的执行状况。其有两个最重要的概念：soft limit 和 hard limit。 struct rlimit { rlim_t rlim_cur; rlim_t rlim_max; }; 是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件 数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。 tst_tmpdir函数说明一下，该函数用来为ltp测试程序创建临时目录，目录名case名称＋随机字母。 cleanup函数 static void cleanup(void) { unlink(\"core\") tst_rmdir(); } 该函数比较简单，用来清理产生的临时文件和软连接。可以做下试验，将main函数中的该函数注释掉，会在tmp下看到产生的core文件。 do_child函数 static void do_child(void) { abort() fprintf(stderr, \"\\tchild - abort failed.\\n\"); exit(1); } abort的调用，进程退出。 instress函数 static int instress(void) { test_resm(TINFO, \"System resources may be too low; fork(), select() etc are likely to fail.\"); return 1; } 系统资源比较低的情况， 出现fork()等调用失败时的处理。也是为兼容UCLINUK测试（如嵌入式系统）。 main函数 控制测试流程和主要的测试代码，以下将重点介绍一些代码片段。 #ifdef WCOREDUMP int core ; core = 0 ; #endif WCOREDUMP(status) 如果孩子进程产生核心转储文件则返回真。这个宏只应该在 WIFSIGNALED 返回真时调用。这个没有在 POSIX.1-2001 里指定并且在一些 UNIX 实现(如 AIX、SunOS)里也没有提供。只在 #ifdef WCOREDUMP ... #endif 内部使用。 #ifdef UCLINUX maybe_run_child ( & do_child , \"\" ); /* UCLINUX的情况 */ #endif setup (); /*调用setup函数*/ for ( i = 0 ; i < NUM ; i ++ ) { /*连续创建３个进程调用do_child函数*/ kidpid = FORK_OR_VFORK (); if ( kidpid == 0 ) { #ifdef UCLINUX if ( self_exec ( argv [ 0 ], \"\" )) { if ( ! instress ()) { perror ( \"fork failed\" ); exit ( 1 ); } } #else do_child (); //调用do_child()函数 #endif } } if ( kidpid < 0 ) if ( ! instress ()) tst_brkm ( TBROK | TERRNO , cleanup , \"fork failed\" ); count = 0 ; while (( child = wait ( & status )) > 0 ) count ++ ; if ( count != 1 ) { tst_brkm ( TBROK , cleanup , \"wrong # children waited on; got %d, expected 1\" , count ); } #ifdef WCOREDUMP core = WCOREDUMP ( status ); //WCOFEDUMP情况 #endif sig = WTERMSIG ( status ); } if ( WIFEXITED ( status )) ex = WEXITSTATUS ( status ); #ifdef WCOREDUMP if ( core == 0 ) { tst_brkm ( TFAIL , cleanup , \"Child did not dump core; exit code = %d, \" \"signal = %d\" , ex , sig ); } else if ( core != - 1 ) { tst_resm ( TPASS , \"abort dumped core\" ); //core值等于０，则没有正常产生core文件，如果core不等于０且不等于-1，说明正常产生了core文件 } #endif if ( sig == SIGIOT ) { tst_resm ( TPASS , \"abort raised SIGIOT\" ); //发出的信号如果为SIGIOT说明信号触发正常 } else { tst_brkm ( TFAIL , cleanup , \"Child did not raise SIGIOT (%d); exit code = %d, \" \"signal = %d\" , SIGIOT , ex , sig ); } } abort测试分析结束。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-abort"},{"url":"http://king32783784.github.io/2016/08/05/LTP/","text":"accept用例分析 case本身说明： Verify that accept() returns the proper errno for various failure cases 验证accept()是否返回正确的errno. 测试log accept01 1 TPASS : bad file descriptor successful accept01 2 TPASS : bad file descriptor successful accept01 3 TPASS : invalid socket buffer successful accept01 4 TPASS : invalid salen successful accept01 5 TPASS : invalid salen successful accept01 6 TPASS : no queued connections successful accept01 7 TPASS : UDP accept successful ~ 测试错误类型包括: bad file descriptor、invalid socket buffer、invalid salen、no queued connections、 UDP accept等 accept函数 accept() 接收一个套接字中已建立的连接 使用格式 #include <sys/types.h> #include <sys/socket.h> int accept ( int sockfd , struct sockaddr * addr , socklen_t * addrlen ); 功能参数描述 accept()系统调用主要用在基于链接的套接字类型，比如SOCK_STREAM和SOCK_SEQPACKET.它提取出所监听套接字的等待连接队列中第一个连接请求，创建一个新的套接字，并返回指向该套接字的文件描述符。新建立的套接字不在监听状态，原来所监听的套接字也不受该系统调用的影响。 备注： 新建立的套接字准备发送send()和接收数据recv(). 参数： sockfd, 利用系统调用socket()建立的套接字描述符，通过bind()绑定到一个本地地址（一般为服务器的套接字），并且通过listen()一直在监听连接。 addr, 指向struct sockaddr的指针，该结构用通讯层服务器对等套接字的地址（一般为客户端地址）填写，返回地址addr的确切格式由套接字的地址类别（比如tcp或udp)决定；若addr为NULL，没有有效地址填写，这种情况下，addrlen也不使用，应该置为NULL； 备注： addr是个指向局部数据结构sockaddr_in的指针，这就是要求接入的信息本地的套接字（地址和指针） addrlen, 一个值结果参数，调用函数必须初始化为包含addr所指向结构大小的数值，函数返回时包含对等地址（一般为服务器地址）的实际数值； 备注： addrlen 是个局部整型变量， 设置为sizeof(struct sockaddr_in) 如果队列中没有等待的连接，套接字也没有被标记为Non-blocking, accept()会阻塞调用函数知道连接出现；如果套接字被标记为Non-blocking, 队列中也没有等待的连接，accept返回错误EAGAIN或EWOULDBLOCK. 备注： 一般来说，实现时accept()为阻塞函数，当监听socket调用accept()时，它先到自己的receive_buf中查看是否有连接数据包； 若有，把数据拷贝处理啊，删掉接收到的数据包，创建新的socket与客户发来的地址建立链接； 若没有，就阻塞等待； 为了在套接字中有到来的连接时得到通知，可以使用select()或poll().当尝试建立新连接时，系统发送一个可读事件，然后调用accept()为该链接获取套接字。另一种方法是，当套接字中有连接到来时设定套接字发送SIGIO信号。 返回值 成功时，返回非负整数，该整数是接收到套接字的描述符；出错时，返回－１，相应的设定全局变量errno. 错误处理 Linux下，accept()把已等待的网络错误传给新建立的连接，当作是accept()返回的错误。这与其他的BSD实现是不同的。为了可靠运行，应该在accept()之后检测协议已定义的一些网络错误，并把这些错误当作EAGAIN并重试。对于tcp/ip协议来说，主要有：ENETDOWN,EPROTO,ENOPROTOOPT,EHOSTDOWN,ENONET,EHOSTUNREACH,EOPNOTSUPP和ENETUNREACH。 accept01.c代码分析 主要函数包括mian、setup、cleanup、setup0、cleanup0、setup1、cleanup1、setup2、setup3 test_case_t结构体 struct test_caset { int domain; /*AF_INIT, AF_UNIX,....*/ int type; /* SOCK_STREAM, SOCK_DGRAM...*/ int proto; /* protocol number(usually 0 = default) */ struct sockaddr *sockaddr; /*socket address buffer */ socklen_t *salen; /* accept's 3rd argument */ int retval; /* syscall return value */ int experrno; /* expected errno */ void (*setup)(void); void(*cleanup)(void); char *desc; } tdat[] = { {PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EBADF, setup0, cleanup0, \"bad file descriptor\"}, //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, ENOTSOCK, setup0, cleanup0, \"bad file descriptor\"}, { //无效的文件描述符 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)3, &sinlen, -1, EINVAL, setup1, cleanup1, \"invalid socket buffer\"}, { //无效套接字缓存区 PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, (socklen_t *) 1, -1, EINVAL, setup1, cleanup1, \"invalid salen\"}, { //无效的salen PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup2, cleanup1, \"invalid salen\"}, { PF_INET, SOCK_STREAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EINVAL, setup3, cleanup1, \"no queued connections\"}, { //队列中没有等待的连接 PF_INET, SOCK_DGRAM, 0, (struct sockaddr *)&fsin1, &sinlen, -1, EOPNOTSUPP, setup1, cleanup1, \"UDP accept\"},}; int TST_TOTAL = sizeof(tdat) / sizeof(tdat[0]); /*通过数组的长度，计算测试用例数量*/ 先定义测试case需要的结构体，然后进行了 结构体初始化 ，定义了7种错误类型，对应7个测试case，和测试log是对应的。 顺便看一下 SOCK_STREAM和SOCK_DGRAM的区别： sock_stream 是有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料（如文件）传送。 sock_dgram 是无保障的面向消息的socket ， 主要用于在网络上发广播信息。 SOCK_STREAM是基于TCP的，数据传输比较有保障。SOCK_DGRAM是基于UDP的，专门用于局域网，基于广播 SOCK_STREAM 是数据流,一般是tcp/ip协议的编程,SOCK_DGRAM分是数据抱,是udp协议网络编程 再看说一下AF_INET和PF_INET的差别： 在Unix/Linux系统中，在不同的版本中这两者有微小差别.对于BSD,是AF,对于POSIX是PF.理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx 分别看一下这几个错误码 EBADF: 当作为参数的套接字不是一个有效的文件描述符(在Linux下用文件描述符来表示设备文件和普通文件。文件描述符是一个整型的数据，所有对文件的操作都通过文件描述符实现。文件描述符是文件系统中链接用户空间和内核空间的枢纽)时，抛出这个错误码。无效的文件描述符是什么意思呢？就是fd已经close的，或者本身就不是个有效的socket的fd。 ENOTSOCK: 在非socket上执行socket操作。 EINVAL： 无效参数。提供的参数非法。有时也会与socket的当前状态相关，如一个socket并没有进入listening状态，此时调用accept，就会产生EINVAL错误。 EOPNOTSUPP: 不支持的操作。 引用对象的类型不支持尝试的操作。通常，这发生在套接字描述符不支持此操作，例如，试着接受数据报套接字上的连接的套接字。 接下来看几个辅助函数。 1.setup函数 static void setup(void) { TEST_PAUSE; /*初始化本地 sockaddr*/ sin0.sin_family = AF_INET; //绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_INET，即使用IP sin0.sin_port = 0; sin0.sin_addr.s_addr = INADDR_ANY; //指定地址为0.0.0.0的地址 } TEST_PAUSE是一个 宏定义 ，代表usc_global_setup_hook()函数。作用是当设置了暂停标志后，暂停 SIGUSR1 ，当新的信号来时，再继续。下面是usc_global_setup_hook函数实现： #define TEST_PAUSE usc_global_setup_hook(); int usc_global_setup_hook () int usc_global_setup_hook ( void ) { #ifndef UCLINUX /*定义temp变量存储信号旧信号的动作，中断后恢复*/ int ( * _TMP_FUNC ) ( void ); /*中断等待sigusr1.*/ if ( STD_PAUSE ) { _TMP_FUNC = ( int ( * )()) singnal ( SIGUSR1 , STD_go ); pause () signal ( SIGUSR1 , ( void ( * )()) _TMP_FUNC ); } if ( STD_TP_sbrk ) || STD_LP_sbrk ) STD_start_break = sbrk ( 0 ); /*获取原始sbreak大小*/ if ( STD_TP_sbrk ){ sbrk ( STD_TP_sbrk ) : if ( Debug ) print ( \"after sbrk(%d) \\n \" , STD_TP_sbrk ); } #endif return 0 ; } 2.setup0函数case1测试前设置 static void setup0(void) 3.setup2 static void setup2(void) { setup1(); //调用setup1()获取套接字s sinlen = 1; //s置为无效 } 4.setup3 static void setup3(void) { int one = 1; setup1(); SAFE_IOCTL(cleanup, s, FIONBIO, &one); } SAFE_IOCTL #define SAFE_IOCTL ( cleanup_fn , fd , request , ...) \\ ( { int ret = ioctl ( fd , request , __VA_ARGS__ ); \\ ret < 0 ? \\ tst_brkm ( TBROK | TERRNO , cleanup_fn , \\ \"ioctl(%i,%s,...) failed\" , fd , #reques t ) \\ safe_ : ret ;} ) 6.cleanup、cleanup0, cleanup1 static void cleanup(void) { } static void cleanup0(void) { s = -1; } static void cleanup1(void) { (void)close(s); s = -1; } 重新设置s = -1 OK,现在看一下main函数。 int main(int ac, char *av[]) { int lc; tst_parse_opts(ac, av, NULL, NULL); //ltp参数解析函数 setup(); for (lc = 0; TEST_LOOPING(lc); ++lc){ test_count = 0; for (testno = 0; testno < TST_TOTAL; ++testno){ tdat[testno].setup(); TEST(accept(s, tdat[testno].sockaddr, tdat[testno].salen)); if (TEST_RETURN > 0) TEST_RETURN = 0; if (TEST_RETURN != tdat[testno].retval || (TEST_RETURN < 0 && TEST_ERRNO != tdat[testno].experrno)){ \"%ld(expected %d), errno %d (expected\" \"%d)\", tdat[testno].desc, TEST_RETURN, tdat[testno].desc, TEST_ERRNO, tdat[testno].experrno); } else { tst_resm(TPASS, \"%s successful\", tdat[testno].desc); } tdat[testno].cleanup(); } } cleanup(); tst_exit(); } 先看一下tst_parse_opts()函数 void tst_parse_opts(int argc, char *argv[], const option_t *user_optarg, void (*user_help)(void)) { const char *msg; msg = parse_opts(argc, argv, user_optarg, user_help); //parse_opts是参数解析函数，后面文章再进行介绍 if(msg) tst_brkm(TBROK, NULL, \"OPTION PARSING ERROR - %s \", msg); } 接下来调用setup，准备测试环境，初始化本地IP地址。然后是一个嵌套的两层循环，第一次是测试次数的遍历，通过TEST_LOOPING实现。 TEST_LOOPING是int usc_test_looping(int counter)函数，该函数后面的文章再进行解释。tst_count初始化为0。 第二层循环是遍历case数组。tdat[testno].setup()，调用对应setup准备case的特殊设置。 TEST启动测试， #define TEST(SCALL) \\ do { \\ errno = 0; \\ TEST_RETURN = SCALL; \\ TEST_ERRNO = errno; \\ } 然后将tdat中的对应参数，分别执行accept函数，如果预期的返回值不符或则返回值小于0且和预期的错误类型不匹配，则调用tst_resm()，进行出错处理。tst_resm将在后面进行分析。如果符合预期，则打印TPASS，然后调用tdat[testno].clearnup()分别清理环境。 最后调用cleanup()清理，tst_exit()退出，tst_exit()在单独分析ltp测试框架时分析。 到此，我们就清楚accept测试的内容了。","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls-accept()"},{"url":"http://king32783784.github.io/2016/06/02/LTP/","text":"本节将重点分析commands部分的用例。 Command主要用例 主要case包括： case 包含子case ade ar file ld ldd nm objdump size at at cpio cpio cron cron df df du du eject eject fileutils cp ln mkdir mv gzip gzip insmod insmod logrotate logrotate lsmod lsmod mail mail mkfs mkfs mkswap mkswap sssd sssd su su tar tar tpm-tools tmp tpmtoken unzip unzip wc wc which which ade ade包括对ar、file、ld、ldd、nm、objdump、size命令的验证测试。 ar ar命令是Linux的一个备份压缩命令，可以创建、修改备存文件(archive)，或从备存文件中抽取成员文件。备存文件以一定的结构打包一个至多个其它文件（即成员文件），且成员文件的内容、模式、时间戳等信息将被保存在备存文件中。常见的应用是，使用ar命令将多个目标文件（ .o）打包为静态链接库文件（ .a)。 引出一个问题，库是什么？本质上讲库是一种可执行代码的二进制形式，可以被操作系统加载到内存执行。linux库分为两种：静态库和动态库。区别在于，静态库是在编译过程中已经被载入可执行程序，可执行程序一般较大；共享库（动态库）是可执行程序运行时才加载到内存，编译时仅简单的引用，因此可执行程序较小。库是如何产生的呢？静态库的后缀是.a，它的产生分为两步：１．由源码编译生成一堆.o，每个.o包含这个编译单元的符号表；２．ar命令将很多.o文件打包转换为.a,形成静态库。 ar命令的常用参数 在 ar 命令中，可以从集 cClosTv 中指定任何数量的可选标志。必须从标志集 dhmopqrstwx 中指定一个标志。如果选择-m 或 -r 标志，您可能还要指定一个位置标志（-a 、-b 或-i ）；对于 -a 、-b 或-i 标志，您必须还指定在 ArchiveFile （PositionName ）中一个文件的名称，此名称紧跟在标志列表后，并由空格隔开。 -a PositionName 在 PositionName 参数标识的现有文件后安置指定的文件。 -b PositionName 在 PositionName 参数标识的现有文件前安置指定的文件。 -c 禁止在创建库 时产生的正常消息。 -C 阻止解压缩的文件替换文件系统中同名的文件。 -d 从库中删除指定的文件。 -g 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-g 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成小格式，这样该标志可用来将大格式压缩文档转换成小格式压缩文档。包含 64 位XCOFF 对象的压缩文档不能创建成或转换至小格式。 -h 将指定的文件的成员报头中的修改时间设置为当前日期和时间。如果不指定任何文件名称，则 ar 命令设置所有成员报头的时间戳记。此标志不能和-z 标志一起使用。 -i PositionName 在 PositionName 参数标识的现有文件前安置指定的文件（和 -b 相同）。 -l 将临时文件置于当前（本地）目录中，而非 TMPDIR 目录中（缺省为 /tmp ）。 -m 将指定的文件移动到库中的某个其它位置。缺省情况下，它将指定的文件移动到库的末尾。使用位置标志（abi ）来指定某个其它位置。 -o 对压缩文档成员进行排序以确保用最小数量的未用空间获得最大的加载效率。在几乎所有情况下，-o 标志以压缩文档成员的逻辑链接顺序物理地安置它们。最终生成的压缩文档通常写成大格式，这样该标志可用来将小格式压缩文档转换成大格式压缩文档。 -p 将 Files 参数中指定的文件的内容或在 ArchiveFile 参数中指定的所有文件（如果您不指定任何文件）都写至标准输出。 -q 将指定的文件添加到库的末尾。另外，如果指定同一个文件两次，它可能被放入库中两次。 -r 如果指定的文件已经存在于库中，则替换它。因为指定的文件在库中占据它们替换的文件的同一个位置，位置标志没有任何附加的影响。当和 -u 标志（更新）一起使用时，-r 标志仅替换自从最后一次添加到库中以后修改的文件。 如果指定的文件不存在于库中，则 ar 命令添加它。在这种情况下，位置标志影响放置。如果不指定位置，则将新文件置于库的末尾。如果指定同一个文件两次，它可能被放入库中两次。 -s 无论 ar 命令是否修改了库内容都强制重新生成库符号表。请在库上使用 strip 命令之后，使用此标志来恢复库符号表。 -t 将库的目录写至标准输出。如果指定文件名称，则仅显示指定的那些文件。如果不指定任何文件，-t 标志列出库中的所有文件。 -T 如果压缩文档成员名称比文件系统支持的长，则允许文件名称截短。此选项无效，因为文件系统支持的名称长度等于 255 个字符的最大压缩文档成员名称。 -u 仅复制自它们最后一次复制起更改的文件（请参阅先前讨论过的 -r 标志）。 -v 将建立新库的详细的逐个文件的描述写至标准输出。当和 -t 标志一起使用时，它给出类似于 ls -l 命令给出的长列表。当和 -x 标志一起使用时，它在每个文件前加一个名称。当和 -h 标志一起使用，它列出成员名称和更新的修改时间。 -w 显示压缩文档符号表。每个符号和其中定义此符号的文件的名称一起列出。 -x 通过将指定的文件复制到当前目录来解压缩它们。这些副本和原始文件（保留在库中）具有相同的名称。如果不指定任何文件，-x 标志复制库中的所有文件。此过程不会更改库。 -Xmode 指定 ar 应检查的目标文件的类型。mode 必须是以下项之一： 32 仅处理 32 位目标文件 64 仅处理 64 位目标文件 32_64 处理 32 位 和 64 位目标文件 缺省值是处理 32 位目标文件（忽略 64 位对象）。mode 还可以用 OBJECT_MODE 环境变量来设置。例如，OBJECT_MODE=64 使 ar 处理任何 64 位对象并忽略 32 位对象。-X 标志覆盖 OBJECT_MODE 变量。 -z 创建压缩文档的临时副本并对副本执行所有要求的修改。当所有操作成功完成时，压缩文档的工作副本覆盖原始副本。此标志不能和 -h 标志一起使用。 ArchiveFile 指定压缩文档文件名称；必需。 MemberName ... 各压缩文档成员的名称。 示例１．ar rcs libxxxx.a xx1.o xx2.o 参数r: 在库中插入模块（替换）。当插入的模块名已经在库中存在，则替换同名的模块。如果若干模块中有一个模块在库中不存在，ar显示一个错误消息，并不替换其他同名模块。默认的情况下，新的成员增加在库的结尾处，可以使用其他任选项来改变增加的位置。 参数c: 创建一个库。不管库是否存在，都将创建。 参数s: 创建目标文件索引 这在创建较大的库时能加快时间。（补充：如果不需要创建索引，可改成大写S参数；如果。a文件缺少索引，可以使用ranlib命令添加） 示例２．创建一个库 ar -v -q lib.a strlen.o strcpy.o 如果 lib.a 库不存在，则此命令创建它，并将文件 strlen.o 和 strcpy.o 的副本输入其中。如果 lib.a 库存在，则此命令在不检查相同成员的情况下，将新的成员添加到末尾。v 标志设置详细方式，在此方式中ar 命令在其进行时显示进程报告。 示例３．显示库的目录 ar -v -t lib.a 此命令列出了 lib.a 库的目录，显示类似于 ls -l 命令的输出的长列表。要只列出成员文件名称，则省略-v 标志。 示例4. 替换或添加新成员到库中 ar -v -r lib.a strlen.o strcat.o 此命令替换成员 strlen.o 和 strcat.o 。如果 lib.a 如示例 1 中显示的那样创建，则替换strlen.o 成员。因为不存在名为 strcat.o 的成员，所以它被添加到库的末尾。 示例５. 指定在何处插入新成员 ar -v -r -b strlen.o lib.a strcmp.o 此命令添加 strcmp.o 文件，并将该新成员置于 strlen.o 成员之前。 示例６．要更新一个已经更改过的成员 ar -v -r -u lib.a strcpy.o 此命令替换现有 strcpy.o 成员，但仅当文件 strcpy.o 自从最后一次添加到库后已经修改时才替换它。 示例７ 要更改库成员的顺序 ar -v -m -a strcmp.o lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 移动到紧跟在 strcmp.o 成员之后的位置。保留 strcat.o 和 strcpy.o 成员的相对顺序。换句话说，如果在移动之前strcpy.o 成员在 strcat.o 成员之前，那么（移动后）它依旧如此。 示例８ 要解压缩库成员 ar -v -x lib.a strcat.o strcpy.o 此命令将成员 strcat.o 和 strcpy.o 分别复制到名为 strcat.o 和 strcpy.o 的文件。 示例９ 要解压缩并重命名一个成员 ar -p lib.a strcpy.o >stringcopy.o 此命令将成员 strcpy.o 复制到一个名为 stringcopy.o 的文件。 示例10 要删除一个成员 ar -v -d lib.a strlen.o 此命令从 lib.a 库中删除成员 strlen.o 。 示例11 要从多个用 ld 命令创建的共享模块中创建一个压缩文档库 ar -r -v libshr.a shrsub.o shrsub2.o shrsub3.o ... 此命令从名为 shrsub.o 、shrsub2.o 、shrsub3.o 等等的共享模块中创建名为libshr.a 的压缩文档库。要编译并链接使用 libshr.a 压缩文档库的 main 程序，请使用以下命令： cc -o main main.c -L/u/sharedlib -lshr main 程序现在是可执行的。main 程序引用的任何符号（包含在libshr.a 压缩文档库中）已经因延迟分辨率而作了标记。-l 标志指定应在libshr.a 库中搜索这些符号。 示例12 要列出 lib.a 的内容（忽略任何 32 位目标文件） ar -X64 -t -v lib.a 要从 lib.a 解压缩所有 32 位的目标文件 ar -X32 -x lib.a 要列出 lib.a 中的所有文件，无论是 32 位、64 位或非对象，请输入： ar -X32_64 -t -v lib.a 示例13 在shell脚本中使用 Bash代码 OS= uname -r ar rcs libhycu.a.$OS *.o 示例14 在makefile中使用 Makefile代码 $（BIN1）: $（BIN1_OBJS） ar rcs $@ $&#94; 示例15 创建并使用静态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 如果test.c无误，就会得到test.o这个目标文件。 第三步：由。o文件创建静态库。 ar rcs libtest.a test.o 第四步：在程序中使用静态库。 gcc -o main main.c -L. -ltest 因为是静态编译，生成的执行文件可以独立于。a文件运行。 第五步：执行。 ./main 示例16 创建并使用动态库 第一步：编辑源文件，test.h test.c main.c。其中main.c文件中包含main函数，作为程序入口；test.c中包含main函数中需要用到的函数。 vi test.h test.c main.c 第二步：将test.c编译成目标文件。 gcc -c test.c 前面两步与创建静态库一致。 第三步：由。o文件创建动态库文件。 gcc -shared -fPIC -o libtest.so test.o 第四步：在程序中使用动态库。 gcc -o main main.c -L. -ltest 当静态库和动态库同名时，gcc命令将优先使用动态库。 第五步：执行。 LD_LIBRARY_PATH=. ./main 接下来，看一下ltp是如何测试ar命令的。 ar文件下包括： ar01 file0.in file10.in file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in Makefile等文件，其中ar01是shell编写的测试脚本。 测试目的，测试ar命令的不同选项的功能。测试策略，通过比较单独指定参数和组合参数测试结果进行判断，如果相同测试通过，如果不同，测试失败。 ar测试项的参数为: export TCdat=$LTPROOT/testcases/bin; ar01 直接执行ar01即可。 测试条件，系统存在ar命令。在运行config时，会进行check:如 configure : 4165 : checking for ar configure : 4181 : found /bin/ ar configure : 4192 : result : ar 程序分析： 创建用到的临时文件 LIST=\"file1.in file2.in file3.in file4.in file5.in file6.in file7.in file8.in file9.in file10.in\" LIST=\" $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST $ LIST \" # Setup function setup() { for i in $ LIST ;do touch $ i done } 结果判定，判断子case的返回值是否为０，TCRESULT为标志位，初始值为０，出错TCRESULT置为１，不同测试内容分别返回不同的编号。 # Cleanup funciton cleanup() { if [ $ TCRESULT = 0 ];then echo \"-----------ar command passed the system test --------\" exit 0 else echo \"-----------ar command failed the system test --------\" exit 1 fi } crtest() { if [ $ ? -ne 0] then TCRESULT=1 echo \"FAIL - could not create lib.a\" cleanup fi } ttest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not output table from lib.a to lib.a.stdout\" cleanup fi } rtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not add file into lib.a\" cleanup fi } mtest() { if [ $ ? -ne 0 ] then TCRESULT=1 echo \"FAIL - could not move file into lib.a\" cleanup fi } 通过结果判定的设置来看，主要验证ar命令的库的创建、库列表信息导出、往库中添加文件、移除库中的文件。 测试代码片段： 标志\"a\"：在 PositionName 参数标识的现有文件后安置指定的文件。 ar -cr $ TCtmp /lib.a file1.in file3.in crtest ar -ra file1.in $ TCtmp /lib.a file2.in rtest ar -t $ TCtmp /lib.a > $ TCtmp /lib.a.stdout tttest if diff -b $ TCtmp /lib.a.exp $ TCtmp /lib.a.stdout > /dev/null 2>&1 then echo \"-)1\" else TCRESULT=1 echo \"FAIL -ar with -a option does not place file after \"posname\" fi 具体测试内容列表： （１）The 'a' flag causes files to be placed after 'posname'. （２）The 'a' flag with the 'm' option causes files to be moved after 'posname' （３）The 'b' flag causes files to be placed before 'posname'. （４）The 'b' flag with 'm' option causes files to be moved before 'posname'. （５）-c option suppress the messages （６）The 'qc' option causes suppresion of the default message when 'afile' is created （７）The -d option deletes files from archive when names are specified. （８）The -d option does not delete files from archive when no names are specified. （９）The -d does not affect behaviour of -s option. （10）The 'i' flag causes files to be placed before 'posname'. （11) The 'i' flag with 'm' option causes files to be moved before 'posname'. (12) m option moves the files to end of the archive (13) The -p option causes only printing of contents of file contained in archive. (14) The -p does not affect behaviour of -s option. (15) The command 'ar -q afile name' appends name to the end of 'afile'. (16) q option does not affect the behaviour of option s (17) The -s causes regeneration of symbol table even if a symbol table exists. (18) ar with -t print as desired (19) The -t does not affect behaviour of -s option. (20)The 'u' flag causes files only with later modification date than in archive are replaced. (21) ar with -v flag to print a line for each file (22) The -v option produces a verbose listing like ls -n (23) The 'v' option causes the 'x' option to display a filename for each file extracted. (24) The command 'ar -x afile ' causes all files from the archive to be extracted. (25) The command 'ar -x afile name name' causes only named files from the archive to be extracted. (26) This test will fail under pan, so it's commented out by default. (27) Signal SIGHUP (28) Signal SIGQUIT (29) Signal SIGHUP; ar should not remove archive that existed before invocation. (30) Signal SIGINIT; ar should not remove archive that existed before invocation. (31) Signal SIGQUIT; ar should not remove archive that existed before invocation.","tags":"自动化测试-LTP","title":"LTP－Command"},{"url":"http://king32783784.github.io/2016/08/01/LTP/","text":"syscalls ltp中kernel测试比重很大，尤其是syscalls，包括一下用例： 注：测试内容分析时补充。 用例名称 测试内容 abort accept accept4 access acct add_key adjtimex alarm asyncio bdflush bind brk cacheflush capget capset chdir chmod chown chroot clock_getres clock_nanosleep clock_nanosleep2 clone close cma confstr connect creat dup dup2 dup3 epoll epoll2 epoll_create1 epoll_ctl epoll_pwait epoll_wait eventfd eventfd2 execl execle execlp execv execve execvp exit exit_group faccessat fadvise fallocate fanotify fchdir fchmod fchmodat fchown fchownat fcntl fdatasync flock fmtmsg fork fpathconf fstat fstatat fstatfs fsync ftruncate futex futimesat getcontext getcpu getcwd getdents getdomainname getdtablesize getegid geteuid getgid getgroups gethostbyname_r gethostid gethostname getitimer get_mempolicy getpagesize getpeername getpgid getpgrp getpid getppid getpriority getrandom getresgid getresuid getrlimit get_robust_list getrusage getsid getsockname getsockopt gettid gettimeofday getuid getxattr inotify inotify_init io_cancel ioctl io_destroy io_getevents ioperm iopl io_setup io_submit ipc kcmp keyctl kill lchown lgetxattr link linkat listen llistxattr llseek lseek lstat madvise Makefile mallopt mbind memcmp memcpy memmap memset migrate_pages mincore mkdir mkdirat mknod mknodat mlock mlockall mmap modify_ldt mount move_pages mprotect mq_notify mq_open mq_timedreceive mq_timedsend mq_unlink mremap msync munlock munlockall munmap nanosleep newuname nftw nice open openat paging pathconf pause perf_event_open personality pipe pipe2 poll ppoll prctl pread preadv profil pselect ptrace pwrite pwritev quotactl read readahead readdir readlink readlinkat readv reboot recv recvfrom recvmsg remap_file_pages removexattr rename renameat renameat2 request_key rmdir rt_sigaction rt_sigprocmask rt_sigqueueinfo rt_sigsuspend rt_sigtimedwait sbrk sched_getaffinity sched_getattr sched_getparam sched_get_priority_max sched_get_priority_min sched_getscheduler sched_rr_get_interval sched_setaffinity sched_setattr sched_setparam sched_setscheduler sched_yield select send sendfile sendmsg sendto setdomainname setegid setfsgid setfsuid setgid setgroups sethostname setitimer setns setpgid setpgrp setpriority setregid setresgid setresuid setreuid setrlimit set_robust_list setsid setsockopt set_thread_area set_tid_address settimeofday setuid setxattr sgetmask sigaction sigaltstack sighold signal signalfd signalfd4 sigpending sigprocmask sigrelse sigsuspend sigtimedwait sigwait sigwaitinfo socket socketcall socketpair sockioctl splice ssetmask stat statfs statvfs stime string swapoff swapon switch symlink symlinkat sync sync_file_range syscall sysconf sysctl sysfs sysinfo syslog tee time timerfd timer_getoverrun timer_gettime times tkill truncate ulimit umask umount umount2 uname unlink unlinkat unshare ustat utils utime utimensat utimes vfork vhangup vmsplice wait wait4 waitid waitpid write writev 接下来按照顺序分析系统调用的每一个case,并将每个case的测试内容补充到本文。 附linux系统主要系统调用列表 一、进程控制 fork 创建一个新进程 clone 按指定条件创建子进程 execve 运行可执行文件 exit 中止进程 _exit 立即中止当前进程 getdtablesize 进程所能打开的最大文件数 getpgid 获取指定进程组标识号 setpgid 设置指定进程组标志号 getpgrp 获取当前进程组标识号 setpgrp 设置当前进程组标志号 getpid 获取进程标识号 getppid 获取父进程标识号 getpriority 获取调度优先级 setpriority 设置调度优先级 modify_ldt 读写进程的本地描述表 nanosleep 使进程睡眠指定的时间 nice 改变分时进程的优先级 pause 挂起进程，等待信号 personality 设置进程运行域 prctl 对进程进行特定操作 ptrace 进程跟踪 sched_get_priority_max 取得静态优先级的上限 sched_get_priority_min 取得静态优先级的下限 sched_getparam 取得进程的调度参数 sched_getscheduler 取得指定进程的调度策略 sched_rr_get_interval 取得按RR算法调度的实时进程的时间片长度 sched_setparam 设置进程的调度参数 sched_setscheduler 设置指定进程的调度策略和参数 sched_yield 进程主动让出处理器,并将自己等候调度队列队尾 vfork 创建一个子进程，以供执行新程序，常与execve等同时使用 wait 等待子进程终止 wait3 参见wait waitpid 等待指定子进程终止 wait4 参见waitpid capget 获取进程权限 capset 设置进程权限 getsid 获取会晤标识号 setsid 设置会晤标识号 二、文件系统控制 1、文件读写操作 fcntl 文件控制 open 打开文件 creat 创建新文件 close 关闭文件描述字 read 读文件 write 写文件 readv 从文件读入数据到缓冲数组中 writev 将缓冲数组里的数据写入文件 pread 对文件随机读 pwrite 对文件随机写 lseek 移动文件指针 _llseek 在64位地址空间里移动文件指针 dup 复制已打开的文件描述字 dup2 按指定条件复制文件描述字 flock 文件加/解锁 poll I/O多路转换 truncate 截断文件 ftruncate 参见truncate umask 设置文件权限掩码 fsync 把文件在内存中的部分写回磁盘 2、文件系统操作 access 确定文件的可存取性 chdir 改变当前工作目录 fchdir 参见chdir chmod 改变文件方式 fchmod 参见chmod chown 改变文件的属主或用户组 fchown 参见chown lchown 参见chown chroot 改变根目录 stat 取文件状态信息 lstat 参见stat fstat 参见stat statfs 取文件系统信息 fstatfs 参见statfs readdir 读取目录项 getdents 读取目录项 mkdir 创建目录 mknod 创建索引节点 rmdir 删除目录 rename 文件改名 link 创建链接 symlink 创建符号链接 unlink 删除链接 readlink 读符号链接的值 mount 安装文件系统 umount 卸下文件系统 ustat 取文件系统信息 utime 改变文件的访问修改时间 utimes 参见utime quotactl 控制磁盘配额 三、系统控制 ioctl I/O总控制函数 _sysctl 读/写系统参数 acct 启用或禁止进程记账 getrlimit 获取系统资源上限 setrlimit 设置系统资源上限 getrusage 获取系统资源使用情况 uselib 选择要使用的二进制函数库 ioperm 设置端口I/O权限 iopl 改变进程I/O权限级别 outb 低级端口操作 reboot 重新启动 swapon 打开交换文件和设备 swapoff 关闭交换文件和设备 bdflush 控制bdflush守护进程 sysfs 取核心支持的文件系统类型 sysinfo 取得系统信息 adjtimex 调整系统时钟 alarm 设置进程的闹钟 getitimer 获取计时器值 setitimer 设置计时器值 gettimeofday 取时间和时区 settimeofday 设置时间和时区 stime 设置系统日期和时间 time 取得系统时间 times 取进程运行时间 uname 获取当前UNIX系统的名称、版本和主机等信息 vhangup 挂起当前终端 nfsservctl 对NFS守护进程进行控制 vm86 进入模拟8086模式 create_module 创建可装载的模块项 delete_module 删除可装载的模块项 init_module 初始化模块 query_module 查询模块信息 *get_kernel_syms 取得核心符号,已被query_module代替 四、内存管理 brk 改变数据段空间的分配 sbrk 参见brk mlock 内存页面加锁 munlock 内存页面解锁 mlockall 调用进程所有内存页面加锁 munlockall 调用进程所有内存页面解锁 mmap 映射虚拟内存页 munmap 去除内存页映射 mremap 重新映射虚拟内存地址 msync 将映射内存中的数据写回磁盘 mprotect 设置内存映像保护 getpagesize 获取页面大小 sync 将内存缓冲区数据写回硬盘 cacheflush 将指定缓冲区中的内容写回磁盘 五、网络管理 getdomainname 取域名 setdomainname 设置域名 gethostid 获取主机标识号 sethostid 设置主机标识号 gethostname 获取本主机名称 sethostname 设置主机名称 六、socket控制 socketcall socket系统调用 socket 建立socket bind 绑定socket到端口 connect 连接远程主机 accept 响应socket连接请求 send 通过socket发送信息 sendto 发送UDP信息 sendmsg 参见send recv 通过socket接收信息 recvfrom 接收UDP信息 recvmsg 参见recv listen 监听socket端口 select 对多路同步I/O进行轮询 shutdown 关闭socket上的连接 getsockname 取得本地socket名字 getpeername 获取通信对方的socket名字 getsockopt 取端口设置 setsockopt 设置端口参数 sendfile 在文件或端口间传输数据 socketpair 创建一对已联接的无名socket 七、用户管理 getuid 获取用户标识号 setuid 设置用户标志号 getgid 获取组标识号 setgid 设置组标志号 getegid 获取有效组标识号 setegid 设置有效组标识号 geteuid 获取有效用户标识号 seteuid 设置有效用户标识号 setregid 分别设置真实和有效的的组标识号 setreuid 分别设置真实和有效的用户标识号 getresgid 分别获取真实的,有效的和保存过的组标识号 setresgid 分别设置真实的,有效的和保存过的组标识号 getresuid 分别获取真实的,有效的和保存过的用户标识号 setresuid 分别设置真实的,有效的和保存过的用户标识号 setfsgid 设置文件系统检查时使用的组标识号 setfsuid 设置文件系统检查时使用的用户标识号 getgroups 获取后补组标志清单 setgroups 设置后补组标志清单 八、进程间通信 ipc 进程间通信总控制调用 1、信号 sigaction 设置对指定信号的处理方法 sigprocmask 根据参数对信号集中的信号执行阻塞/解除阻塞等操作 sigpending 为指定的被阻塞信号设置队列 sigsuspend 挂起进程等待特定信号 signal 参见signal kill 向进程或进程组发信号 *sigblock 向被阻塞信号掩码中添加信号,已被sigprocmask代替 *siggetmask 取得现有阻塞信号掩码,已被sigprocmask代替 *sigsetmask 用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替 *sigmask 将给定的信号转化为掩码,已被sigprocmask代替 *sigpause 作用同sigsuspend,已被sigsuspend代替 sigvec 为兼容BSD而设的信号处理函数,作用类似sigaction ssetmask ANSI C的信号处理函数,作用类似sigaction 2、消息 msgctl 消息控制操作 msgget 获取消息队列 msgsnd 发消息 msgrcv 取消息 3、管道 pipe 创建管道 4、信号量 semctl 信号量控制 semget 获取一组信号量 semop 信号量操作 5、共享内存 shmctl 控制共享内存 shmget 获取共享内存 shmat 连接共享内存 shmdt 拆卸共享内存","tags":"自动化测试-LTP","title":"LTP－kernel-syscalls"},{"url":"http://king32783784.github.io/2016/11/13/python/","text":"pyqt是对Qt的封装。Ｑt是面向对象的图形用户界面库，可以在多个操作系统上使用。 PyQt基本操作 基本的界面： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/env python #*-* coding=utf-8 *-* import sys from PyQt4 import QtCore , QtGui # 导入PyQt模块 class MyWindow ( QtGui . QMainWindow ): # 通过继承QtGui.QMainWindow创建类 def __init__ ( self ): # 初始化方法 QtGui . QMainWindow . __init__ ( self ) # 调用父类的初始化方法 self . setWindowTitle ( \"pyQt\" ) # 设置窗口标题 self . resize ( 400 , 600 ) # 设置窗口大小 app = QtGui . QApplication ( sys . argv ) # 创建QApplication对象 mywindow = MyWindow () # 创建MyWindow对象 mywindow . show () # 显示窗口 app . exec_ () # 进入消息循环 运行效果： 添加一个标签： PyQt提供了丰富的组件进行GUI编程，可以方便的使用组件，并使用信号/插槽进行组件的通信，处理组件事件。 使用QtGui.QLabel可以创建标签。使用setText方法可以设置标签的文字。使用setTextFormat可以设置中文字的格式。当创建标签后使用QMainWindow 的setCentralWidget方法将标签添加到窗口中。常见的方法： setPicture():设置标签中的图片 setText():设置标签中的文字 setTextFormat:设置标签文字的格式 setAlignment:设置标签中文本的对齐方式 下面将创建一个标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #! /usr/bin/env python # *-* coding=utf-8 *-* import sys from PyQt4 import QtCore , QtGui class Window ( QtGui . QMainWindow ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) set . resize ( 400 , 600 ) #添加标签 label = QtGui . QLabel ( \"start test\" ) # 创建标签 label . setAlignment ( QtCore . Qt . AlignCenter ) # 设置标签文字的对齐样式 self . setCentralWidget ( label ) # 向窗口添加标签 app = QtGui . QApplicatin ( sys . argv ) demo = Window () demo . show () app . exec_ () 运行效果： 布局组件和空白项 布局组件 在窗口中使用setCentralWidget只能添加一个组件。如果想添加多个组件，可以使用布局组件。空白项用于占位，配合布局组件更好的控制界面。 布局组件：主要用于控制内部组件的大小、位置等。布局组件可以包含其他的组件，也可以嵌套其他的布局组件。 常见的布局组件： QLayout: 基本的布局组件，只能被继承 QHBoxLayout: 横向Box布局组件 QVBoxLayout: 竖向Box布局组件 QGridLayout: Grid布局组件 布局组件共有的方法： addWidget():添加组件 addLayout():添加其他布局组件 下面是一个使用布局组件布置标签的例子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/env python # *-* coding=utf-8 *-* import sys from PyQt4 import QtCore , QtGui class Window ( QtGui . QWidget ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb-i\" ) self . resize ( 500 , 600 ） label1 = QtGui . QLabel ( \"sysbench\" ) # 创建标签 label2 = QtGui . QLabel ( \"iozone\" ) label3 = QtGui . QLabel ( \"lmbench\" ) label4 = QtGui . QLabel ( \"netperf\" ) label5 = QtGui . QLabel ( \"pingpong\" ) label6 = QtGui . QLabel ( \"unixbench\" ) gridLayout = QtGui . QGridLayout () # 创建网格布局组件 gridLayout . addWidget ( label1 , 0 , 0 ) # 向布局中添加标签，第１行第一列 gridLayout . addWidget ( label2 , 0 , 1 ) gridLayout . addWidget ( label3 , 0 , 2 ) gridLayout . addWidget ( label4 , 1 , 0 ) gridLayout . addWidget ( label5 , 1 , 1 ) gridLayout . addWidget ( label6 , 1 , 2 ) self . setLayout ( gridLayout ) ＃ 设置布局组件 # 添加水平布局 # hBoxLayout1 = QtGui.QHBoxLayout() # 创建横向布局组件 # hBoxLayout1.addWidget(label1) # hBoxLayout1.addWidget(label2) # hBoxLayout1.addWidget(label3) # hBoxLayout1.addWidget(label4) # hBoxLayout1.addWidget(label5) # hBoxLayout1.addWidget(label6) # self.setLayout( hBoxLayout1) # 添加垂直布局 # vBoxLayout = QtGui.QVBoxLayout() # 创建垂直布局组件 # vBoxLayout.addWidget(label1) # vBoxLayout.addWidget(label2) # vBoxLayout.addWidget(label3) # vBoxLayout.addWidget(label4) # vBoxLayout.addWidget(label5) # vBoxLayout.addWidget(label6) # self.setLayout(vBoxLayout) app = QtGui . QApplication ( sys . argv ) demo = Window () demo . show () app . exec_ () 运行效果： 空白项 PyQt中的空白项可以占据位置，这样就可以更好的布置其他的组件。使用QtGui.QSpaerItem创建空白项，可以使用宽度和高度进行设置。 使用布局组件的addItem方法将其添加到布局组件中。 下面看一个例子： #!/usr/bin/env python # - - coding:utf-8 - - import sys from PyQt4 import QtCore , QtGui class MyWindow ( QtGui . QWidget ): def __init__ ( self ): QtGui . QWidget . __init__ ( self ) self . setWindowTitle ( 'test' ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 spacer1 = QtGui . QSpacerItem ( 300 , 40 ) # 创建空白项 spacer2 = QtGui . QSpacerItem ( 300 , 40 ) label = QtGui . QLabel ( 'Label' , self ) # 创建标签 label . setAlignment ( QtCore . Qt . AlignCenter ) #设置标签文本样式 gridlayout . addItem ( spacer1 , 0 , 0 ) # 添加空白项 gridlayout . addWidget ( label , 1 , 0 ) # 添加标签 gridlayout . addItem ( spacer2 , 2 , 0 ) self . setLayout ( gridlayout ) # 向窗口中添加布局组件 app = QtGui . QApplication ( sys . argv ) mywindow = MyWindow () mywindow . show () app . exec_ () 运行效果： 按钮基本使用 使用PyQt中的QtGui.QPushButton可以创建按钮。在PyQt中按钮事件是以信号/插槽的形式进行的，将按钮事件绑定到类的方法上。 创建按钮 当使用QtGui.QPushButton创建按钮后可以使用一下几种方法设置按钮的样式、属性等。 setDefault():将按钮设置为默认按钮 setFlat(): 将按钮设置为平坦模式 setMenu(): 设置按钮关联的菜单。 menu(): 获得按钮关联的菜单 下面例子创建两个按钮 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/usr/bin/env python # *-* coding=utf-8 *-* import sys from PyQt4 import QtGui , QtCore class Window ( QtGui . QWidget ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb-i\" ) self . resize ( 400 , 600 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 button1 = QtGui . QPushButton ( \"spec2000\" ) # 生成button1 gridlayout . addWidget ( button1 , 0 , 0 , 1 , 3 ) # 添加button1 button2 = QtGui . QPushButton ( \"iozone\" ) button2 . setFlat ( True ) gridlayout . addWidget ( button2 , 1 , 1 , 1 , 3 ) self . setLayout ( gridlayout ) # 向窗口中添加布局组件 app = QtGui . QApplication ( sys . argv ) demo = Window () demo . show () app . exec_ () 运行效果 信号和信号槽 Qt中的组件使用信号和信号槽的形式来进行通信。Qt的组件中有很多预定义的信号，当事件触发时，组件发出对应的信号。信号被发送给信号槽进行处理。信号槽是处理特定信号的函数。在PyQt同样，需要使用组件的connect方法将组件信号绑定到其处理插槽上。connect方法的原型如下： connect(QObject, SIGNAL(), SLOT(), Qt.ConnectionType) 参数含义如下： QObject: 发送信号的组件 SIGNAL(): 组件发送的信号 SLOT(): 信号槽函数 Qt.ConnectionType: 可选参数，连接类型 下面的例子使用connect方法将按钮的\"clicked()\"信号连接到事件处理信息槽的函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #!/usr/bin/env python # -*- coding:utf-8 -*- import sys from PyQt4 import QtCore , QtGui class MyWindow ( QtGui . QWidget ): def __init__ ( self ): QtGui . QWidget . __init__ ( self ) self . setWindowTitle ( 'test' ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 self . button1 = QtGui . QPushButton ( 'Button1' ) gridlayout . addWidget ( self . button1 , 1 , 1 , 1 , 3 ) self . button2 = QtGui . QPushButton ( 'Button2' ) gridlayout . addWidget ( self . button2 , 2 , 2 ) self . setLayout ( gridlayout ) # 向窗口添加布局组件 self . connect ( self . button1 , # button1事件 QtCore . SIGNAL ( 'clicked()' ), # clicked()信号 self . OnButton1 ) # 信号处理函数 self . connect ( self . button2 , # button2事件 QtCore . SIGNAL ( 'clicked()' ), # clicked()信号 self . OnButton2 ) # 信号处理函数 def OnButton1 ( self ): self . button1 . setText ( 'clicked' ) print ( \"button1 is cliecked\" ) def OnButton2 ( self ): self . button2 . setText ( 'clicked' ) print ( \"button2 is cliecked\" ) app = QtGui . QApplication ( sys . argv ) mywindow = MyWindow () mywindow . show () app . exec_ () 运行效果如下：","tags":"Python-pyqt","title":"pyqt基本操作"},{"url":"http://king32783784.github.io/2016/11/15/python/","text":"对话框 PyQT提供基本的消息框和标准对话框。在PyQt也可以根据需要创建自定义的对话框。 使用PyQt提供的类和方法可以创建和使用消息框、标准对话框等。标准对话框包含基本的打开，关闭，字体选择对话框和颜色选择对话框等。 消息框 使用QtGui.QMessageBox类中的方法可以创建简单的消息框，用于向用户传递信息。QtGui.QMessageBox类中包含一下方法： about():创建关于消息框 aboutQt(): 创建关于Qt消息框 critical(): 创建错误处理对话框 infomation(): 创建信息消息框 question(): 创建询问消息框 warning(): 创建警告消息框 以下是示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #!/usr/bin/env python #*-* coding=utf-8 *-* import sys from PyQt4 import QtGui , QtCore class MyWindow ( QtGui . QWidget ): def __init__ ( self ): super ( MyWindow , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 self . label = QtGui . QLabel ( 'MessBox example' ) gridlayout . addWidget ( self . label , 1 , 3 , 1 , 3 ) #添加标签 self . button1 = QtGui . QPushButton ( \"About\" ) # 生成button1 gridlayout . addWidget ( self . button1 , 2 , 1 ) # 添加button到布局组件 self . button2 = QtGui . QPushButton ( \"AboutQt\" ) # 生成button2 gridlayout . addWidget ( self . button2 , 2 , 2 ) self . button3 = QtGui . QPushButton ( \"Critical\" ) gridlayout . addWidget ( self . button3 , 2 , 3 ) self . button4 = QtGui . QPushButton ( \"Info\" ) gridlayout . addWidget ( self . button4 , 2 , 4 ) self . button5 = QtGui . QPushButton ( \"Question\" ) gridlayout . addWidget ( self . button5 , 2 , 5 ) self . button6 = QtGui . QPushButton ( \"warning\" ) gridlayout . addWidget ( self . button6 , 2 , 6 ) spacer = QtGui . QSpacerItem ( 200 , 80 ) gridlayout . addItem ( spacer , 3 , 1 , 1 , 5 ) self . setLayout ( gridlayout ) # 向窗口中添加布局组件 self . connect ( self . button1 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton1 ) # button1事件 self . connect ( self . button2 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton2 ) self . connect ( self . button3 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton3 ) self . connect ( self . button4 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton4 ) self . connect ( self . button5 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton5 ) self . connect ( self . button6 , QtCore . SIGNAL ( 'clicked()' ), self . Onbutton6 ) def Onbutton1 ( self ): # button1插槽函数 self . button1 . setText ( 'clicked' ) QtGui . QMessageBox . about ( self , 'pyQt' , 'About' ) # 创建About消息框 def Onbutton2 ( self ): self . button2 . setText ( 'clicked' ) QtGui . QMessageBox . aboutQt ( self , \"PyQt\" ) def Onbutton3 ( self ): self . button3 . setText ( 'clicked' ) r = QtGui . QMessageBox . critical ( self , \"PyQt\" , \"Critical\" , QtGui . QMessageBox . Abort , QtGui . QMessageBox . Retry , QtGui . QMessageBox . Ignore ) if r == QtGui . QMessageBox . Abort : self . setWindowTitle ( \"Abort\" ) elif r == QtGui . QMessageBox . Retry : self . setWindowTitle ( \"Retry\" ) else : self . setWindowTitle ( \"Ignore\" ) def Onbutton4 ( self ): self . button4 . setText ( 'clicked' ) QtGui . QMessageBox . information ( self , \"Pyqt\" , \"information\" ) def Onbutton5 ( self ): self . button5 . setText ( 'clicked' ) r = QtGui . QMessageBox . question ( self , \"PyQt\" , \"Question\" , QtGui . QMessageBox . Yes , QtGui . QMessageBox . No , QtGui . QMessageBox . Cancel ) def Onbutton6 ( self ): self . button6 . setText ( 'clicked' ) r = QtGui . QMessageBox . warning ( self , \"PyQT\" , 'warning' , QtGui . QMessageBox . Yes , QtGui . QMessageBox . No ) app = QtGui . QApplication ( sys . argv ) win = MyWindow () win . show () app . exec_ () 运行效果： 标准对话框 PyQt使用QtGui.QFileDialog提供的方法可以创建文件打开、关闭对话框。使用QtGui.QFontDialog可以创建文章选择对话框，使用QtGui.QColorDialog可以创建颜色选择对话框。 其中QtGui.QFileDialog: getExistingDirectory(): 创建选取路径对话框 getOpenFileName(): 创建打开文件对话框 getOpenFileNames(): 创建打开文件对话框，可以同时打开多个文件 getSaveFileNmae(): 创建保存文件对话框 对于QtGui.QFontDialog,静态方法只有getFont,创建字体选择对话框。QtGui.QColorDialog，可以使用getColor创建颜色选择对话框。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/usr/bin/env python #*-* coding=utf-8 *-* import sys from PyQt4 import QtGui , QtCore class MyWindow ( QtGui . QWidget ): def __init__ ( self ): super ( MyWindow , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () self . label = QtGui . QLabel ( 'StandarDialog example' ) gridlayout . addWidget ( self . label , 1 , 2 ) self . button1 = QtGui . QPushButton ( \"File\" ) # 生成button1 gridlayout . addWidget ( self . button1 , 2 , 1 ) self . button2 = QtGui . QPushButton ( \"Font\" ) # 生成button2 gridlayout . addWidget ( self . button2 , 2 , 2 ) self . button3 = QtGui . QPushButton ( \"Color\" ) gridlayout . addWidget ( self . button3 , 2 , 3 ) spacer = QtGui . QSpacerItem ( 200 , 80 ) gridlayout . addItem ( spacer , 3 , 1 , 1 , 3 ) self . setLayout ( gridlayout ) # 向窗口添加布局组件 self . connect ( self . button1 , QtCore . SIGNAL ( 'clicked()' ), self . OnButton1 ) self . connect ( self . button2 , QtCore . SIGNAL ( 'clicked()' ), self . OnButton2 ) self . connect ( self . button3 , QtCore . SIGNAL ( 'clicked()' ), self . OnButton3 ) def OnButton1 ( self ): self . button1 . setText ( 'clicked' ) filename = QtGui . QFileDialog . getOpenFileName ( self , 'Open' ) # 创建文件打开对话框 if not filename . isEmpty (): self . label . setText ( filename ) def OnButton2 ( self ): self . button2 . setText ( 'clicked' ) font , ok = QtGui . QFontDialog . getFont () # 创建字体选择对话框 if ok : self . label . setText ( font . key ()) def OnButton3 ( self ): self . button3 . setText ( 'clicked' ) color = QtGui . QColorDialog . getColor () # 创建颜色选择对话框 if color . isValid (): self . label . setText ( color . name ()) app = QtGui . QApplication ( sys . argv ) win = MyWindow () win . show () app . exec_ () 运行效果： 自定义对话框 通过继承QtGui.QDialog类可以创建自定义的对话框。所创建的对话框和窗口一样，可以向其添加组件。使用connect方法响应组件时间。 自定义对话框例子： #coding=utf-8 import sys from PyQt4 import QtGui , QtCore class MyDialog ( QtGui . QDialog ): def __init__ ( self ): super ( MyDialog , self ) . __init__ () self . gridlayout = QtGui . QGridLayout () self . label = QtGui . QLabel ( \"Input:\" ) self . gridlayout . addWidget ( self . label , 0 , 0 ) self . textField = QtGui . QLineEdit () # 创建单行文本框 self . gridlayout . addWidget ( self . textField , 0 , 1 ) # 添加文本框到布局组件 self . okButton = QtGui . QPushButton ( \"OK\" ) # 创建OK按钮 self . gridlayout . addWidget ( self . okButton , 1 , 0 ) #添加按钮到布局组件 self . cancelButton = QtGui . QPushButton ( \"Cancel\" ) # 创建cancel按钮 self . gridlayout . addWidget ( self . cancelButton , 1 , 1 ) self . setLayout ( self . gridlayout ) self . connect ( self . okButton , QtCore . SIGNAL ( 'clicked()' ), self . OnOk ) self . connect ( self . cancelButton , QtCore . SIGNAL ( 'clicked()' ), self . OnCancel ) def OnOk ( self ): self . text = self . textField . text () # 获取文本框中的内容 self . done ( 1 ) # 结束对话框返回１ def OnCancel ( self ): self . done ( 0 ) class Window ( QtGui . QWidget ): def __init__ ( self ): super ( Window , self ) . __init__ () self . setWindowTitle ( \"Lpb-i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () self . creatDialogButton = QtGui . QPushButton ( \"Create a new Dialog\" ) #生成button gridlayout . addWidget ( self . creatDialogButton , 1 , 1 ) self . setLayout ( gridlayout ) self . connect ( self . creatDialogButton , QtCore . SIGNAL ( 'clicked()' ), self . OnButton ) def OnButton ( self ): dialog = MyDialog () r = dialog . exec_ () if r : self . creatDialogButton . setText ( dialog . text ) app = QtGui . QApplication ( sys . argv ) win = Window () win . show () app . exec_ () 运行效果： 资源文件 Qt中资源文件是以'.ui'为后缀的文件。Qt提供Qt Designer用于创建资源文件。使用Qt Designer创建的资源文件可以在pyqt中使用。使用资源文件可以简化界面设计，也可以将界面和代码分离，提高程序的可维护性。 示例 #coding=utf-8 import sys from PyQt4 import QtGui , QtCore , uic class MyDialog ( QtGui . QDialog ): def __init__ ( self ): QtGui . QDialog . __init__ ( self ) uic . loadUi ( \"res.ui\" , self ) # 载入资源文件 class MyWindow ( QtGui . QWidget ): def __init__ ( self ): super ( MyWindow , self ) . __init__ () self . setWindowTitle ( \"Lpb_i\" ) self . resize ( 300 , 200 ) gridlayout = QtGui . QGridLayout () # 创建布局组件 self . button = QtGui . QPushButton ( \"CreateDialog\" ) # 生成button1 gridlayout . addWidget ( self . button , 1 , 1 ) self . setLayout ( gridlayout ) self . connect ( self . button , QtCore . SIGNAL ( 'clicked()' ), self . OnButton ) def OnButton ( self ): dialog = MyDialog () r = dialog . exec_ (); if r : self . button . setText ( dialog . lineEdit . text ()) app = QtGui . QApplication ( sys . argv ) demo = MyWindow () demo . show () app . exec_ ()","tags":"Python-pyqt","title":"pyqt基本操作(三）"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/14/autotest/","text":"Client Control files 主要内容 jobs 例子 扩展测试 流程控制 系统信息抓取 分析器 创建文件系统 job执行期间重启 并行运行多个测试 control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试. job例子 可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样: job.run_test('kernbench') 参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/ /control 在autotestclient端的顶层目录下,你可以执行测试: $ client/autotest-local <control_file_name> 在control文件中同样可以指定测试参数 job.run_test('kernbench', iterations=2, threads=5) 第一个参数是测试名称; 第二个参数是执行次数和线程数,大多数你可以执行它的默认参数. 还可以指定一个tag参数,用来给测试结果目录命名: job.run_test('kernbench', iterations=2, threads=5, tag='mine') 测试时会创建结果目录\"kernbench.mine\"来替代之前的\"kernbench\".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果. 扩展测试 当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求. 流程控制 真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子. for t in [8, 16, 32]: job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t) 系统信息抓取 每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,\"uname-a\"的输出信息.可以在测试结果目录找那个查看. sysinfo/(每次重启前的数据), /sysinfo(每次测试前的数据) 每次收集的信息列表的内容,可以通过查看 clent/bin/base_sysinfo.py .当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义 的系统信息收集: job.add_sysinfo_file(\"/proc/vmstat\") 可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现: job.add_sysinfo_file(\"/proc/vmstat\", on_ervey_test=True) 另外一种方式: job.add_sysinfo_command(\"lspci -v\", logfile=\"lspci.txt\") 这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会 执行. 使用分析器 你可以启用一个或多个分析器.下面是添加和移除的例子: job.profilers.add('oprofile') job.run_test('sleeptest') job.profilers.delete('oprofile') 多个测试使用方式: job.profilers.add('oprofile') job.run_test('kernbench') job.run_test('dbench') job.profilers.delete('oprofile') 它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的 当然,在profilers/ /control下有所有的示例. 创建文件系统 autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试: # uncomment this line, and replace the device with something sensible # for you ... # fs = job.filesystem('/dev/hda2', job.tmpdir) for fstype in ('ext2', 'ext3'): fs.mkfs(fstype) fs.mount() try: job.run_test('fsx', job.tmpdir, tag=fstype) finally: fs.unmount() 同样支持为不同的文件系统添加不同的挂载参数: fs = job.filesystem('/dev/sda3', job.tmpdir) iters=10 for fstype, mountopts, tag in (('ext2', '', 'ext2'), ('ext3', '-o data=writeback', 'ext3writeback'), ('ext3', '-o data=ordered', 'ext3ordered'), ('ext3', '-o data=journal', 'ext3journal')): fs.mkfs(fstype) fs.mount(args=mountopts) try: job.run_test('fsx', job.tmpdir, tag=tag) job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag) job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag) job.run_test('tiobench', dir=job.tmpdir, tag=tag) finally: fs.umount() job测试中重启 当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块. def step_init(): job.next_step([step_test]) testkernel = job.kernel('2.6.18') testkernel.config('http://mbligj.org/congig/opteron2') testkernel.build() testkernel.boot() #does autotest by default def step_test(): job.run_test('kernbench', iterations=2, threads=5) job.run_test('dbench', iterations=5) 通过指定 step_init 表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境. 一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试 不太现实.如果出现超时,会杀死子线程. 因此,代码插入到control文件中是正确的: def step_init(): job.next_step([step_test]) testkernel = job.kernel('testkernel.rpm') testkernel.install() testkernel.boot() def step_test() job.run_test('ltp') 相关代码插入到测试模块中,是不行的. class Kerneltest ( test . test ): def execute ( self ): testkernel = job . kernel ( 'testkernel.rpm' ) testkernel . boot () 直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用. 当面对分步执行时,循环会变得更加困难. def step_init(): step_test(1) def step_test(iteration): if (iteration < 5): job.next_step([step_test, iteration + 1]) print \"boot: %d\" % iteration job.run_test('kernbench', tag=\"%s\" % i) job.reboot() 并行运行 job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。 def first_task(): job.run_test('kernbench') def second_task(): job.run_test('dbench') job.parallel([first_task], [second_task]) 控制文件会同时执行kernbench和dbench.代码还可以如此写: job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench']) 如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。 并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件. Top &#94; 上一篇 Autotest：Autotest-Local>>> 下一篇 Autotest：Autotest-Control file specification>>>","tags":"自动化测试-Autotest","title":"Autotest-client control"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/08/18/autotest/","text":"linux发行版检测 Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上. 这个功能是由probe类群的实现和注册实现的. 这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等. 快速检查发行版 autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect(). 它的用法简单命了: from autotest.client.shared import distro detected_distro = distro . detect () 这样就可以返回发行版检测的结果,但是不太适用于 UNKNOWN_DISIRO . name version release arch 例如: >>>detected_distro = distro.detect() >>>print detected_distro.name redhat 未知发行版 当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊. autotest.clientshared.distro.UNKNOWN_DISIRO =<LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown> 意味着,这个发行版不能找到对应的匹配信息. 编写一个发行版probe 为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能. 如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口. 检查发行版的名字 最简单的探针就是查看存在的文件并返回发行版的名字. class ReadHatProbe ( Probe ): CHECK_FILE = '/etc/redhat-realease' CHECK_FILE_DISTRO_NAME = 'redhat' 如果要使用probe,需要先注册: from autotest.client.shared import distro distro . register_probe ( RedHatProbe ) 这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。 侦测发行版的名字和版本 如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX Probe.CHECK_VERSION_REGEX=None 注册自己的probes Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测. 注册的简单方式就剩调用register_probe(): autotest.client.shared.distro.register_probe(probe_class) 注意,要注册的自己的probes必须是probe的子类. API参考 LinuxDistro class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) 源码 收集linux发行版信息的简单方式. Probe class autotest.client.shared.distro.Probe 源码 CHECK_FILE=None CHECK_FILE_CONTAINS=None CHECK_FILE_DISTRO_NAME =None CHECK_VERSION_REGEX = None Check_name_for_file() check_name_for_file_contains() check_release() check_version() get_distro() name_for_file() name_for_file_contains() release() version() register _ probe() autotest.client.shared.distro.register_probe(probe_class) 源码 注册probe detect() autotest.client.shared.distro.detect() 源码 尝试检测这台机器上的Linux发行版本 Source code for autotest.client.shared.distro \"\"\" This module provides the client facilities to detect the Linux Distribution it's running under. This is a replacement for the get_os_vendor() function from the utils modules. \"\"\" import os import platform import re __all__ = [ 'LinuxDistro' , 'UNKNOWN_DISTRO_NAME' , 'UNKNOWN_DISTRO_VERSION' , 'UNKNOWN_DISTRO_RELEASE' , 'UNKNOWN_DISTRO_ARCH' , 'Probe' , 'register_probe' , 'detect' ] # [__all__用法]() # pylint: disable=R0903 LinuxDistro : class LinuxDistro ( object ): ''' Simple collection of infomation for a Linux Distribution ''' def __init__ ( self , name , version , release , arch ): ''' Initalizes a new Linux Distro :param name: 一个简单的区别于其他发型版的名字 :type name : 字符 :parm vesion:发行版的主版本. :type vesion: 字符 :param release: 发行版的发型号或子版本. :type vesion:字符 :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit :type arch: 字符 ''' self . name = name self . version = version self . release = release self . arch = arch def __repr__ ( self ): # [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python) return '<LinuxDistro: name= %s , version= %s , release= %s , arch= %s >' % ( self . name , self . version , self . release , self . arch ) UNKNOWN_DISTRO_NAME = 'unknown' UNKNOWN_DISTRO_VERSION = 0 UNKNOWN_DISTRO_RELEASE = 0 UNKNOWN_DISTRO_ARCH = 'unknown' # 定义未知发行版默认信息 #: 未知发行版,反馈以下信息 UNKNOWN_DISTRO = LinuxDistro ( UNKNOWN_DISTRO_NAME , UNKNOWN_DISTRO_VERSION , UNKNOWN_DISTRO_RELEASE , UNKNOWN_DISTRO_ARCH ) Probe : class probe ( object ): ''' 探测机器信息并且确认是否存在的发行版 ''' #:指定运行机器上发行版中的文件. CHECK_FILE = None #:设置指向文件的检查内容,默认为None,只检查是否存在 CHECK_FILE_CONTAINS = None #:如果文件指定,指定发行版名字 CHECK_FILE_DISTRO_NAME = None #:指定发行版版本 CHECK_VERSION_REGEX = None def __init__ ( self ): self . score = 0 def check_name_for_file ( self ): ''' 查找一个文件并返回distro.确认是否指定了特定文件 ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file ( self ): ''' 获取distro名称,如果\"CHECK_FILE\"设置并且存在 ''' if self . check_name_for_file (): if os . path . exists ( self . CHECK_FILE ): return self . CHECK_FILE_DISTRO_NAME def check_name_for_file_contains ( self ): ''' 该类查找text并返回distro. The conditions that must be true include the file that identifies the distro file being set (:attr:`CHECK_FILE`), the text to look for inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`) ''' if self . CHECK_FILE is None : return False if self . CHECK_FILE_CONTAINS is None : return False if self . CHECK_FILE_DISTRO_NAME is None : return False return True def name_for_file_contains ( self ): ''' 获取distro如果CHECK_FILE指定并且有效 ''' if self . check_name_for_file_contains (): if os . path . exits ( self . CHECK_FILE ): for line in open ( self . CHECK_FILE ) . readlines (): if self . CHECK_FILE_CONTAINS in line : return self . CHECK_FILE_DISTRO_NAME def check_version ( self ): ''' 检查在文件中是否找到regex并返回distro ''' if self . CHECK_FILE is None : return False if self . CHECK_VERSION_REGEX is None : return False return True def _get_version_match ( self ): ''' 返回匹配备注文件中的版本信息 ''' if self . check_version (): if os . patch . exists ( self . CHECK_FILE ): version_file_content = open ( self . CHECK_FILE ) . read () else : return None return self . CHECK_VERSION_REGEX . match ( version_file_content ) def version ( self ): ''' 返回distro的版本信息 ''' version = UNKNOWN_DISTRO_VERSION match = self . _get_version_match () if match is not None : if match . groups () > 0 : version = match . groups ()[ 0 ] return version def check_release ( self ): ''' 检查是否存在符合条件的版本号 ''' return ( self . check_version () and self . CHECK_VERSION_REGEX . groups > 1 ) def release ( self ): ''' 返回 distro的版本号 ''' release = UNKNOWN_DISTRO_RELEASE match = self . _get_version_match () if match is not None : if match . groups () > 1 : release = match . groups ()[ 1 ] return release def get_distro ( self ): ''' 返回 class:'LinuxDistro' probe detected ''' name = None version = UNKNOWN_DISTRO_VERSION release = UNKNOWN_DISTRO_RELEASE arch = UNKNOWN_DISTRO_ARCH distro = None if self . check_name_for_file (): name = self . name_for_file (): self . score += 1 if self . check_name_for_file_contains (): name = self . name_for_file_contains () self . score += 1 if self . check_version (): version = self . version () self . score += 1 if self . check_release (): release = self . release () self . score += 1 # 实在想不到比这更好的方式 arch = os . uname ()[ 4 ] # 名字是首先要侦测的.它可以告诉我们是哪个发行版. if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class StdLibProbe ( Probe ): ''' Probe是使用python库内建的probe. 这个Probe得分比较低,作为备用probe. ''' def get_distro ( self ): name = None version = UNKNOWN_DISTRO_VERSION realease = UNKONWN_DISTRO_RELEASE arch = UNKONWN_DISTRO_ARCH d_name , d_version_release , d_codename = platform . dist () if d_name : name = d_name if '.' in d_version_release : d_version , d_release = d_version_release . split ( '.' , 1 ) version = d_version release = d_release else : version = d_version_release arch = os . uname ()[ 4 ] if name is not None : distro = LinuxDistro ( name , version , release , arch ) else : distro = UNKNOWN_DISTRO return distro class RedHatProbe ( Probe ) ''' 红帽发行版版本检查 ''' CHECK_FILE = '/etc/redhat=release' CHECK_FILE_CONTAINS = 'Red Hat' CHECK_FILE_DISTRO_NAME = 'redhat' CHECK_VERSION_REGEX = re . compile ( r'Red Hat Enterprise Linux Server release(\\d{1,2})\\.(\\d{1,2}).*' ) class CentosProbe ( RedHatProbe ): ''' Centos系统检测 ''' CHECK_FILE = '/etc/redhat-release' CHECK_FILE_CONTAINS = 'CentOS' CHECK_FILE_DISTRO_NAME = 'centos' CHECK_VERSION_REGEX = re . compile ( r'CentOS release(\\d{1,2})\\.(\\d{1,2}).*' ) class FedoraProbe ( RedHatProbe ): ''' Probe with version checks for Fedora systems ''' CHECK_FILE = '/etc/fedora-release' CHECK_FILE_CONTAINS = 'Fedora' CHECK_FILE_DISTRO_NAME = 'fedora' CHECK_VERSION_REGEX = re . compile ( r'Fedora release (\\d{1,2}).*' ) class DebianProbe ( Probe ): ''' Simple probe with file checks for Debian systems ''' CHECK_FILE = '/etc/debian-version' CHECK_FILE_DISTRO_NAME = 'debian' class UbuntuProbe ( Probe ): ''' Simple probe with file checks for Ubuntu systems ''' CHECK_FILE = '/etc/os-release' CHECK_FILE_CONTAINS = 'Ubuntu' CHECK_FILE_DISTRO_NAME = 'ubuntu' CHECK_VERSION_REGEX = re . compile ( r'VERSION_ID=\"(\\d+.\\d+)\"' ) class SuseProbe ( Probe ): CHECK_FILE = '/etc/SuSE-release' CHECK_FILE_DISTRO_NAME = 'sles' CHECK_VERSION_REGEX = re . compile ( r'SUSE.*\\nVERSION = (.*)\\nPATCHLEVEL = (.*)' ) #: 已注册probes列表 REGISTERED_PROBES = [] register_probe : register_probe (): def register_probe ( probe_class ): ''' 注册probe ''' if probe_class not in REGISTERED_PROBES : REGISTERED_PROBES . appen ( probe_class ) register_probe ( RedHatProbe ) register_probe ( CentosProbe ) register_probe ( FedoraProbe ) register_probe ( DebianProbe ) register_probe ( UbuntuProbe ) register_probe ( SuseProbe ) register_probe ( StdLibProbe ) detect : def detect (): ''' 尝试在机器上侦测发行版 ''' results = [] for probe_class in REGISTERED_PROBES : probe_instance = probe_class () didtro_result = probe_instance . get_distro () if distro_result is not UNKNOWN_DISTRO : results . append (( distro_result , probe_instance )) results . sort ( key = lambda t : t [ 1 ] . score ) if len ( results ) > 0 : distro = results [ - 1 ][ 0 ] else : distro = UNKNOWN_DISTRO return dostro class Spec ( object ): ''' 发行版最低发行要求 ''' def __init__ ( self , name , min_version = None , min_release = None , arch = None ): self . name = name self . min_version = min_version self . min_release = min_release self . arch = arch Top &#94; 上一篇 Autotest：Autotest-Using and developing job profilers 下一篇 Autotest:Autotest-others>>>","tags":"自动化测试-Autotest","title":"Autotest-Linux distribution detection"},{"url":"http://king32783784.github.io/2015/08/15/autotest/","text":"Control file specification 该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改. 主要内容: 命名control文件 常用变量 示例 control文件命名 control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义． 例如，５００次硬重启测试，一个正规的定义就是 control.hard500 常用变量 下面是一个常用变量的列表 变量名 描述 *AUTHOR 测试编写的个人或公司信息 ＤEPENENCIES 测试依赖信息，比如\"CONSOLE\" *DOC 描述测试包括哪些参数的说明 EXPERIMENTAL 如果定义为True,测试忽略 *NAME 前端识别测试的名称 RUN_VERIFY 定义scheduler是否执行验证，默认为True SYNC_COUNT 次数，接受大于等于１的参数，默认为１ *TIME 说明测试时长， ＳＨＯＲＴ<15m, MEDIUM < 4H ,LONG >4H TEST_CLASS 描述类属于类型，如内核．硬件 TEST_CATEGORY 描述测试的类型，如压力，功能 *TEST_TYPE 测试类型：client server 标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py AUTHOR(必填) 设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的． DEPENDENCIES（可选，默认：none) 相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙： DEPENDENCY =\"bluetooth\" 其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 DOC(必需) 文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义． EXPERIMENTAL(可选默认：False) 如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 NAME(必需) 指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用． RUN_VERIFY(可选，默认TRUE) 用来定义scheduler是否进行验证 SYNC_COUNT(可选默认１) １代表的是可以异步执行，大于１代表需同步执行 如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件 例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败． TIME(Required) 测试需要的时间，不包括设置时间． Time Description SHORT 小于１５分钟 MEDIUM 少于４Ｈ LONG 大于４Ｈ TEST_CATEGORY(必需) 定义测试属于哪一类 例如 功能性或压力 TEST_CLASS(必需) xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。 如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。 示例测试类 内核 硬件 TEST_TYPE 这个要告诉前端什么类型的测试．有效值是server或client. 示例 TIME ='MEDIUM' AUTHOR = 'Scott Zawalski ( scott@xxx.com )' TEST_CLASS = 'Hardware' TEST_CATEGORY = 'Functional' NAME = 'Hard Reboot' SYNC_COUNT = 1 TEST_TYPE = 'server' TEST_CLASS = 'Hardware' DEPENDCIES = 'POWER, CONSOLE' DOC = \"\"\" Tests the reliability of platforms when rebooted. This test allows you to do a hard reboot or a software reboot. Args: type: can be \"soft\" or \"hard\", default is \"hard\" e.g. job.run_test('reboot', machine, type=\"soft\") This control file does a HARD reboot \"\"\" def run(machine): job.run_test('reboot', machine, type=\"hard\") parallel_simple(run, machines) Top &#94; 上一篇 Autotest:Autotest-client control>>> 下一篇 Autotest:Autotest-add test>>>","tags":"自动化测试-Autotest","title":"Autotest-Control file specification"},{"url":"http://king32783784.github.io/2015/08/19/autotest/","text":"执行外部测试 autotest可以像执行自身测试一样执行外部测试． 执行测试 一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址． job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2') 这样就会执行下载，安装，解压测试． 构建外部下载测试 外部下载的测试包含bz2包和测试目录． 1．包名 my_test.tar.bz2 2. 测试脚本 my_test.py * 3. 测试脚本中的以本身命名的类 class my_test(test.test): 例如： from autotest_lib.client.bin import test class my_test ( test . test ): version = 1 def initialize ( self ): print \"INIT\" def run_once ( self ): print \"RUN\" $ tar -C example_test -jcvf my_test.tar.bz2 . Autotest 的keyval文件 在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如 key1=value1 key2=value2 测试结果中错误信息 debug debug/ ├── build_log.gz ├── client.DEBUG ├── client.ERROR ├── client.INFO └── client.WARNING autotest local 还有一些小的细节问题，不再一一介绍． 下篇将开始介绍Remote (Former Server)． Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)>>>","tags":"自动化测试-Autotest","title":"Autotest-others"},{"url":"http://king32783784.github.io/2015/08/21/autotest/","text":"KVM支持 如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做： 1.创建虚拟机，运行在虚拟层的机器 2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。 3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。 4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest 可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。 下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。 remote_host = hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host = kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-33.tar.gz\") addresses =[{\"mac\": \"02:00:00:00:00:%02x\" %(num,), \"ip\": \"192.168.2.%d\" % (num,)} for num in range(1, 32)] kvm_on_remote_host.install(addreses) qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g = hosts.KVMGuest(kvm_on_remote_host, qemu_options) g.wait_up() print g.run(\"unme -a\").stdout.strip() Compiling qemu_options 你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）. 如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。 如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。 Kernel Considerations 下面介绍一些内核配置项，为定制自己的内核做参考。 Host Kernel CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢 KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分 Guest Kernel Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。 Disk Image Coniderations 镜像需要作为qemu的一个选项，例如： qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" g= hosts.KVMGuest(kvm_on_remote_host, qemu_options) /var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考 QEMU文档 来了解QEMU信息。 IP Address Configuration 有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置： auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh map 02:00:00:00:00:01 vhost1 map 02:00:00:00:00:02 vhost2 iface vhost1 inet static address 10.0.2.1 netmask 255.0.0.0 geteway 10.0.0.1 iface vhost2 inet static address 10.0.2.2 netmask 255.0.0.0 geteway 10.0.0.1 /usr/local/bin/get-mac-address.sh : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/sh set -e export LANG = C iface = \" $1 \" mac = $( /sbin/ifconfig \" $iface \" | sed -n -e '/&#94;' .*HWaddr \\( [ : [ :xdigit: ]] * \\) .*/ { s// \\1 / ; y/ABCDEF/abcdef/ ; p ; q ; } ') which=\"\" while read testmac scheme; do if [\"$which\" ]; then continue;fi if [\"$mac\" = \"$(echo \"$testmac\" | sed -e ' y/ABCDEF/abcdef/ ' ) \"]; then which=\" $scheme \"; fi done if [\" $which \"]; then echo $which ; exit 0; fi exit 1 /etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/python header = \"\"\" #This file describes the network interfaces available on your system # and how to activate them. For more infomation, see interfaces(5). # The loopback network interface auto lo iface lo inet loopback # The primary network interface auto eth0 mapping eth0 script /usr/local/bin/get-mac-address.sh\"\"\" map_entry = \" map 00:1a:11:00:00: %02x vhost %d \" host_entry = \"\"\"iface vhost %d inet static address 10.0.2. %d netmask 255.0.0.0 gateway 10.0.0.1\"\"\" print header first_value = 1 last_value = 16 for i in range ( first_value , last_value + 1 ): print map_entry % ( i , i ,) print \"\" for i in range ( first_value , last_value + 1 ): print host_entry % ( i , i ,) SSH Authentication 类似于SSHHost，也需要设置免密码登陆。 Serial Console 虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 * grub 配置文件（/boot/grub/menu.lst) serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1 terminal --timeout=3 serial console kernel启动选项 console=tty0 console=ttyS0,9600 /etc/inittab T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100 Top &#94; 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(一）>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(三）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(二）"},{"url":"http://king32783784.github.io/2015/08/16/autotest/","text":"测试模块开发 测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的） 测试模块需要： 可以跨多硬件架构 可以支持不同的发行版 至少一个维护者 提供一个默认的简单例子 对自己目录外的东西不做修改 添加测试项 增加一个测试项，可能是最容易的开发工作了． 每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括 一个control 文件（tests/mytest/control) 一个测试包装脚本（tests/mytest/mytest.py) * 如果不仅仅是python脚本中实现的，还需要补充测试源码 可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py, 包括其中命名为dbench的类．这些这新开发的测试中 也必须要有． control文件至少是： job.run_test('dbench') 这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西． 目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／ 大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能： initialize() -这个是每个测试前执行的，而且每次都要执行． setup()- 这个会在第一次测试时执行，并且会进行源码的编译 run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器 postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代． 测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节． setup 一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译． #http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz def setup(self, tarball='dbench-3.04.tar.gz'): tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir) 注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ． utils.extract_taball_to_dir(tarball, self.srcdir) os.chdir(self.srcdir) utils.system('./configure') utils.system('make') 解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境; 我们使用了本地的system(),而不是os.system 如果返回值不是0,会自动抛出一个异常. 除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装. 如何使用? from autotest.client.shared import software_manager backend = software_manager . SoftwareManager () backend . install ( 'package_name' ) run_once 它是实际执行测试的.核心只是: self.results.append(utils.system_output(cmd)) 运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理. postprocess_iteration 对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench 只有两个参数,\"throughout\",\"nprocs\".这个函数,每次iteration调用一次.最后会出现一个文件结果: throughout = 217 nprocs = 4 throughout =220 nprocs = 4 其他方法 这些方法没有用在dbench,但是可以进行添加 warmup 在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试. cleanup 测试后的清理工作 execute 通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写. 添加自己的测试 只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑. Top &#94; 上一篇 Autotest：Autotest-Control file specification>>> 下一篇 Autotest:Using and developing job profilers>>>","tags":"自动化测试-Autotest","title":"Autotest-add test"},{"url":"http://king32783784.github.io/2015/08/22/autotest/","text":"Running Autotest In a Guest 接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。 给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项\"opcontrol --setup\"应根据host中vmlinux位置调整。 remote_host=hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses= [{\"mac\":\"02:00:00:00:00:01\", \"ip\":\"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait.up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(g1) control_file=\"\"\" #~ job.profiles.add(\"oprofile\", events=[\"CPU_CLK_UNHALTED:8000\"]) job.run_test(\"linus_stress\") \"\"\" results_dir= \"g1_results\" # --start oprofile remote_host.run(\"opcontrol --shutdown\") remote_host.run(\"opcontrol --reset\") remote_host.run(\"opcontrol --setup\" # \"--vmlinux /lib/modules/#(uname -r)build/vmlinux \"--no-vmlinx\" \"--event CPU_CLK_UNHALTED:8000\") remote_host.run(\"opcontrol --start\") at.run(control_file, results_dir, g1) # --stop opofile remote_host.run(\"opcontrol --stop\") tmpdir= remote_host.get_tmp_dir() remote_host.run('opreport -l &> \"%s\"' %(sh_escape(os.path.join(tmpdir, \"report\")),)) remote_host.get_file(os.path.join(tmpdir, \"repoet\"), os.path.join(results_dir, \"host_oprofile\")) Changing the Guest Kernel Usual\"Way KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-comiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] kvm_on_remote_host.install(addresses, build=False, insert_moudles=False) qemu_options=\"-m 256 -hda /var/local/vdisk.img -snapshot\" g1= hosts.KVMguest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb\") kernel.install(g1) g1.reboot() print g1.run(\"uname -a\").stdout \"QEMU\" Way 通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。 remote_host= hosts.SSHHost(\"192.168.1.1\") kvm_on_remote_host= kvm.KVM(remote_host) kvm_on_remote_host.get(\"/var/local/src/kvm-compiled.tar.gz\") addresses=[{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}) kvm_on_remote_host.install(addresses, build=False, install_modules=False) kernel= deb_kernel.DEBKernel() kernel.get(\"/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb\") kernel_dir= kernel.extract(remote_host) qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel \"%s\" -append \"%s\"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape(\"root=/dev/hda1 ro console=tty0 console=ttyS0, 9600\"),) g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options) g1.wait_up() print g1.run(\"uname -a\").stdout Parallel commands Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。 这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。 def check_kernel(host, version, package): if host.run(\"uname -r\").stdout.strip() != version: package.install(host) host.reboot() def install_kvm(kvm_on_host_var_name, host, source, addresses): exec(\"global %(var_name)s\\n\" \"%(var_name)s= kvm.KVM(host)\\n\" \"%(var_name)s.get(source)\\n\" \"%(var_name)s.install(addresses)\\n\" % {\"var_name\":kvm_on_host_var_name}) remote_host1= hosts.SSHHost(\"192.168.1.1\") remote_host2= hosts.SSHHost(\"192.168.1.2\") kernel= deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb\") host1_command= subcommand(check_kernel, [remote_host1, \"2.6.21.3-3\", kernel]) host2_command= subcommand(check_kernel, [remote_host2, \"2.6.21.3-3\", kernel]) parallel([host1_command, host2_command]) install_kvm(\"kvm_on_remote_host1\", remote_host1, \"/var/local/src/kvm-33.tar.gz\", [{\"mac\": \"02:00:00:00:00:01\", \"ip\": \"10.0.0.1\"}] qemu_options= \"-m 256 -hda /var/local/vdisk.img -snapshot\" gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options) gserver.wait_up() at= autotest.Autotest() at.get(\"/home/foo/autotest/client\") at.install(gserver) at.install(remote_host2) server_results_dir= \"results-netperf-guest-to-host-far-server\" client_results_dir= \"results-netperf-guest-to-host-far-client\" server_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"server\", tag=\"server\")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),) client_control_file= 'job.run_test(\"netperf2\", \"%s\", \"%s\", \"client\", tag=\"client\")' % (sh_escapt(gserver.hostname), sh_escape(remote_host2.hostname),) server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver]) client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2]) parallel([server_command, client_command]) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(二）>> 下一篇 Autotest:Autotest-client Package(1)>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)(三）"},{"url":"http://king32783784.github.io/2015/08/17/autotest/","text":"使用和添加测试分析器 添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子: 一个控制文件. profilers/myprofiler/control 分析器控制脚本. profilers/myprofiler.py 分析器的源码(如果不仅仅是控制脚本) 我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核. 控制文件非常简单,像这样: job.profilers.add('readprofile') job.run_test('sleeptest', 1) job.profilers.delete('readprofile') 只是说明\"请再以下测试中使用readprofile\".一次测试,如果想添加多个分析器,可以多次调用profilers.add. 还有源码包\"util-linux-2.12r.tar.bz2\",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到 profiler主类,定义版本.可以看到以下个函数: setup() 它会在第一次用profiler时执行,并且编译源码. intialize() 将在导入profiler时执行 start() 启动分析 stop() 停止分析 report() 利用profiler数据生成报告 接下来 看一下这些方法的细节. Setup setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译. #http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2 def setup(self, tarball = 'util-linux-2.12r.tar.bz2'): self.tarball = unmap_url(self.bindir, tarball, self.tmpdir) extract_tarball_to_dir(self.tarball, self.srcdir) 注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径. os.chdir(self.srcdir) system('./configure') os.chdir('sys-utils') system('make readprofile) 先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值 不是0,它将会自动抛出异常. Initialize def initialize(self): try: system('grep -iq\" profile = \"/proc/cmdline\") except: raise CmdError, 'readprofile not enabled' self.cmd = self.srcdir + '/sys-utils/readprofile' 它会在我们导入profiler后执行,用来检查 readprofile是否使能. Start def start(self, test): system(self.cmd + '-r') 启动profiler, 只是执行readprofile -r Stop def stop(self, test): # There's no real way to stop readprofile, so we stash the # rad data at this point instead. BAD EXAMPLE TO COPY!;-) self.rawprofile = test.profdir + '/profile.raw' print \"STOP\" shutil.copyfile('/proc/profile', self.rawprofile) 一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响. Report def report(self, test): args = ' -n' args += ' -m' + get_systemmap() args += ' -p' + self.rawprofile cmd = self.cmd + ' ' + args txtprofile = test.profdir + '/profile.text' system(cmd + ' | sort -nr > ' + txtprofile) system('bzip2' + self.rawprofile) 将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建. 添加自己的profiler 只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名. Top &#94; 上一篇 Autotest：Autotest-add test>> 下一篇 Autotest:Autotest-Linux distribution detection>>>","tags":"自动化测试-Autotest","title":"Autotest-Using and developing job profilers"},{"url":"http://king32783784.github.io/2015/11/01/autotest/","text":"autotest_local 模块 class autotest.client.autotest_local.AutotestLocalAPP 本地自动测试，指定一个control文件启动测试 import os import sys try : import autotest.common as common # pylint: disable=W0611 rootdir = os . path . abspath ( os . path . dirname ( common . __file__ )) autodir = os . path . join ( rootdir , 'client' ) autodirbin = os . path . join ( rootdir , 'client' , 'bin' ) except ImportError : import common # pylint: disable=W0611 autodirbin = os . path . realpath ( sys . argv [ 0 ]) autodir = os . path . dirname ( autodirbin ) sys . path . insert ( 0 , autidirbin ) autodirtest = os . path . join ( autodir , \"tests\" ) os . environ [ 'AUTODIR' ] = autodir os . environ [ 'AUTODIRBIN' ] = autidirbin os . environ [ 'AUTODIRTEST' ] = autodirtest os . environ [ 'PYTHONPATH' ] = autodirbin from autotest.client import job from autotest.client.shared.settings import settings from autotest.client import cmdparser , optparser class AutotestLocalAPP : ''' Autotest local app runs tests locally Point it to a control file and let it rock ''' def __init__ ( self ): self . _set_parsers () def _set_parsers ( self ): self . opt_parser = optparser . AutotestLocalOptionParser () self . cmd_parser = cmdparser . CommandParser () def usage ( self ): self . opt_parser . print_help () sys . exit ( 1 ) def parse_cmdline ( self ): self . optios , args = self . opt_parser . parse_args () if self . options . test_directory is not None : if os . path . isdir ( self . options . test_directory ): os . environ [ 'CUSTOM_DIR' ] = self . options . test_directory else : print \"The custom directory specifed does not exist, ignoring it ...\" self . args = self . cmd_parser . parse_args ( args , self . options ) # Check for a control file if not in prebuild mode if len ( args ) != 1 and self . options . client_test_setup is None : print \"Missing self . usage () def main ( self ): self . parse_cmdline () drop_caches = settings . get_value ( 'CLIENT' , 'drop_caches' , type = bool , default = True ) if self . options . client_test_setup : from autotest.client import setup_job exit_code = 0 try : setup_job . setup_test ( self . options ) except Exception : exit_code = 1 sys . exit ( exit_code ) # JOB: run the specifed job control file job . runjob ( os . realpath ( self . args [ 0 ], drop_caches , self . options ) 上一篇 Autotest： Autotest-Autotest Remote (Autoserv)(三）>> 下一篇 Autotest:>>>","tags":"自动化测试-Autotest","title":"Autotest-client Package(1)"},{"url":"http://king32783784.github.io/2015/08/20/autotest/","text":"Autoserv 是\"自动化机器控制\"的框架 Autoserv 目的是控制机器，它可以： 电源管理 安装内核 修改bootloader * 运行任意命令 运行Autotest Local(客户端）测试 传输文件 被控制的机器可以是： 本机 远程机器（通过ssh 和 conmux) 虚拟机(通过ＫＶＭ） 控制文件 类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。 这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用： remote_host = host.SSHHost(\"192.168.1.1\") print remote_host.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") print kernel.get_version() print kernel.get_image_name() print kernel.get_initrd_name() kerne.install(remote_host) remote_host.reboot() print remote_host.run(\"uname -a\").stdout Hosts \"Host\"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加 其他类型的host，需要确保添加到server/hosts/ init .py文件。 Host的主要方法 以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看 ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。 run(command) reboot() get_file(source, dest) send_file(source, dest) get_tmp_dir is_up() wait_up(timeout) wait_down(timeout) get_num_cpu() CmdResult 类 run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。 CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是： command: 包含命令行本身的字符 exit_status: 进程整数退出代码 stdout:包含程序标准输出的字符串 stderr: 包含程序错误输出的字符串 duration: 程序运行的持续时间 aborted: 导致终端命令中止的信号（０） Host的主要类型 SSHHost SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过 ssh运行命令，通过scp进行文件传输。 如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。 ConmuxSSHHost ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。 SiteHost Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。 创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。 KVMGuest KVMGuest 表示可以运行程序的KVM 虚拟机。 它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现\"硬复位\".可以通过查看 KVM section 查看更多的KVM和KVMguest信息。 Bootloader Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel() 当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。 InstallableObject InstallableObject 表示一个可以再host上安装软件包。通过下面两个方法实现： get(location) install(host) get()表示获取安装包，它可以获取多种类型保存位置的包： 本地目录 URL地址 python文件对象 如果参数不是上述类型，get()会默认将获取的内容当为包内容 get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。 Autotest Support Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的 类实现的。Auotest对象是一个installableＯbject.要想使用它，必须： 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest ＳＶＮ库自动获取。而且会在目标主机中完成。 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件： autodir=/usr/local/autotest/ run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。 下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的\"job_results\"目录下。 remote_host = hosts.SSHHost(\"192.168.1.1\") at = autotest.Autotest() at.get(\"/var/local/autotest/client\") at.install(remote_host) control_file = \"\"\" job.profilers.add(\"oprofile\", events= [\"CPU_CLK_UNHALED:8000\"]) job.run_test(\"linux_stress\") \"\"\" results_dir = \"job_results\" at.run(control_file, results_dir, remote_host) Kernel Objects Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。 kernels支持依赖以下方法： get(location) 用户installableObject方法 install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数， 需要可以添加，并传递给add_kernel()方法用来启动内核。 get_version() get_image_name() get_image_name() 同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py DEBKernels 有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是 kvm和qumu的 -kernel选项。 下面给出一个Autoserv安装内核的控制文件的例子： rh = hosts.SSHHost(\"192.168.1.1\") print rh.run(\"uname -a\").stdout kernel = deb_kernel.DEBKernel() kernel.get(\"/var/local/linux-2.6.22.deb\") kernel.install(rh) rh.reboot() print rh.run(\"uname -a\").stdout 一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm): if not machines: raise \"Specify the machines to run on via the -m flag\" hosts = [hosts.SSHHost(h) for h in machines] kernel = rpm_kernel.RPMKernel() kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm') for host in hosts: print host.run(\"uame -a\").stdout kernel.install(host, default=True) host.reboot() print host.run(\"uname -a\").stdout print \"Done\" 未完待续 Top &#94; 上一篇 Autotest：Autotest-others>> 下一篇 Autotest:Autotest-Autotest Remote (Autoserv)(二）>>>","tags":"自动化测试-Autotest","title":"Autotest-Autotest Remote (Autoserv)（一）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/13/selenium/","text":"该topic将开始学习selenium的使用。主要内容如下 1.安装 2.入门 3.导航 4.元素定位 5.等待 6.页面对象 7.WebDriver API 8.常见问题 安装 简介 Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。 Selenium&python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\\3.2及以上。 本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。 下载Selenium python支持包 可以在 PyPI page for selenium package 下载Selenium python支持包。更好的方式是通过pip去安装，在python3.5已集成进标准库: pip install selenium 可以考虑使用 virtualenv 创建的独立python环境。Python 3.5的 pyvenv 和virtualenv类似。 针对windows环境的说明 1.安装python 3.5 2.在cmd.exe命令行下，使用pip命令安装 C:\\Python35\\scripts\\pip.exe install selenium 这样就可以运行python脚本，例如一个脚本放到C:\\my_selenium_script.py,可以这样执行： C:\\Python35\\python.exe C:\\my_selenium_script.py 下载Selenium server Selenium server是一个Java程序。建议使用JRE1.6或以上版本运行Selenium server. 可以从 下载 下载Selenium server2.x,文件名类似selenium-server-standalone-2.x.x.jar. 在此之前，确认系统中已经安装了ＪＲＥ。 如果java支持，可以通过下面命令来启动Selenium server: java -jar selenium-server-standalone-2.x.x.jar Top &#94; 下一篇 selenium-专题２>>>","tags":"自动化测试-Selenium","title":"selenium-基本介绍"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2015/01/21/selenium/","text":"Remote WebDriver WebDriver实现。 class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None) Bases: object 控制浏览器向remote server发送命令。Remote server 运行的协议定义为 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol . 属性： * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串 * capabilities- Dictionaty of effective capabilities of this browser session as returned remote server,见 https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities * command_executor -远程链接。RemoteConnection对象执行命令。 * error_handler- errorhandler. ErrorHandler对象用于处理错误。 add_cookie(cookie_dict) 添加cookie到当前会话。 Args: * cookie_dict:字典对象，具有所需要的秘钥－\"name\"和\"value\". keys选项 \"path\", \"domain\", \"secure\", \"expiry\" 用法： driver.add_cookie({'name':'foo', 'value':'bar'}) driver.add_cookie({'name':'foo', 'value': 'bar', 'path':'/'}) driver.add_cookie({'name':'foo', 'value':'bar','path':'/','secure':True}) back() 浏览器历史记录中后退一步 用法：driver.back() close() 关闭当前窗口 用法：driver.close() create_web_element(element_id) 创建指定元素id的web元素 delete_all_cookies() 删除会话中所有的cookies 用法：driver.delete_all_cookies delete_cookies(name) 删除给出名字的单一cookie 用法：driver.delete_cookie('my_cookie') execute(driver_command, params=None) 通过 command.CommandExecutor发送命令 参数： * driver_command: 执行命令名称的字符串 * params: 使用命令发送的命名参数的字典 返回：命令的json导入到字典对象 excute_async_scipt(scipt, *args) 异步执行当前窗口／框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_async_script('document.title') execute_script(script, *args) 同步执行当前窗口/框架中的javascript Args: * script: 要执行的javascript * *ags: 任何javascript适用的参数 用法：driver.execute_scipt('document.title') file_detector_context(*args, **kwds) 在limited context覆盖当前的file detector. 确保original file detector已设置。 例如： with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') 参数： file_detector_clss－ 如果类不同，需要提供文件检测器的类 从当前file_detector，那么该类用args和kwargs实例化，并在上下文管理器的持续时间期间用作文件检测器。 args－ 期间需要传递给file detector的可选参数 kwargs - 关键字参数，传递方式和args相同 find_element(by='id', value=None) 'Private'方法由find_element_by_ 方法们使用 用法： 使用相应的find_element_by_ 替换 返回： WebElement find_element_by_class_name(name) 按类名查找元素 参数： name-要查找元素的类名 用法： driver.find_element_by_class_name(\"foo\") find_element_by_css_selector(css_selector) 通过css selector查找元素 参数：css_selector 查找元素使用的css selector 用法：driver.find_element_by_css_selector('#foo') find_element_by_id(id_) 通过id查找元素 参数： id 查找元素的id 用法： driver.find_element_by_id('foo') find_element_by_link_text(link_text) 通过link text查找元素 参数： link_text 查找元素的link_text 用法： driver.find_element_by_link_text('Sign ln') find_element_by_name(name) 通过name查找元素 参数： name: 查找元素的name 用法： driver.find_element_by_name('foo') find_element_by_xpath(xpath) 通过xpath查找元素 args: xpath 查找元素的xpath定位器 用法：driver.find_element_by_xpath('//div/td/[1]') find_element(by='id', value=None) find_elements_by_ methods使用的'Pvivate'方法 用法： 使用符合要求的find_elements_by_ 替换现有的 返回类型： WebElement列表 find_elements_by_class_name(name) 按类名查找元素 参数name: 查找元素的类名 用法：driver.find_elements_by_class_name('foo') find_elements_by_css_selector(css_selector) 按css selector查找元素 css_selector: 查找元素使用的css selector 用法：driver.find_element_by_css_selector('.foo') find_elements_by_id(id_) 按id查找多个元素 id_:要查找元素的id find_elements_by_link_text(text) 通过链接文本查找元素 link_text: 查找元素的链接文本 driver.find_elements_by_link_text('Sign In') find_elements_by_name(name) 按名称查找元素 name:查找元素的名称 driver.find_elements_by_name('foo') find_elements_by_partial_link_text(link_text) 通过部分匹配链接文本查找元素。 link_text: 查找元素部分匹配的链接文本 driver.find_element_by_partial_link_text('Sign') find_elements_by_tag_name(name) 通过tag name查找元素 name: 查找元素使用的tag name driver.find_elements_by_tag_name('foo') find_elements_by_xpath(xpath) 通过xpath查找多个元素 xpath: 要查找元素的xpath的定位符 driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") forward() 回退一次浏览器历史记录 driver.forward() get(url) 在当前浏览器窗口加载网页 get_cookie(name) 按名称找到单个cookie,如果找到，返回cookie,没有返回None driver.get_cookie('my_cookie') get_cookies() 返回一组字典，对应当前会话可用的cookies driver.get_cookies() get_log(log_type) 获取给定log类型的log log_type:返回log的log类型 用法：driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') get_screenshot_as_base64() 获取当前窗口截屏的base64编码字符串 这个在嵌入图像到html时非常有用。 用法：driver.get_screentshot_as_base64() get_screenshot_as_file(filename) 获取当前窗口的截屏。如果存在，返回False 任何IOError，否则返回True.在filename中使用绝对路径 filename: 将屏幕截图保存到的完整路径。 driver.get_screenshot_as_file('/Screenshots/foo.png') get_screenshot_as_png() 获取当前窗口的截屏，并保存为二进制数据。 driver.get_screenshot_as_png() get_window_position(windowHandle='current') 获取当前窗口的x,y位置 driver.get_window_position() get_window_size(windowHandle='current') 获取当前窗口的宽和高 driver.get_window_size() implicitly_wait(time_to_wait) 设置固定超时时间等待元素被找到，或命令完成 这个方法只需要在每个对话框执行一次。设置timeout需要调用execute_async_script. time_to_wait:等待的时间 driver.implicitly_wait(30) maximize_window() 将当前webdriver的窗口最大化 quit() 退出dirver并关闭每一个关联的窗口 driver.quit() refresh() 刷新当前的窗口 driver.refresh() save_screenshot(filename) 同 get_screenshot_as_file. set_page_load_timeout(time_to_wait) 设置等待网页加载完成的时间（抛出异常之前） time_to_wait:等待的时间 driver.set_page_load_timeout(30) set_script_timeout(time_to_wait) 设置脚本运行的时间，直到抛出异常之前 time_to_wait:等待时间 driver.set_script_timeout(30) set_window_position(x,y, windowHandle='current') 设置当前窗口的x,y driver.set_window_position(0,0) set_window_size( width, height, windowHandle='current') 设置当前窗口的高和宽 driver.set_window_size(800,600) start_client() 启动新窗口前调用。这个方法使用时可以重写。 start_session(desired_capabilities, browser_profile=None) 创建所需功能的新会话 browser_name : 浏览器请求的名称 vesion: 哪些浏览器版本要求。 platform: 哪个平台要求在浏览器上。 javascript_enabled :新回话是否应支持JavaScript。 browser_profile : 一个selenium.webdriver.firefox.firefox_profile.FirefoxProfile对象。只有当被请求的Firefox使用。 stop_client() 执行quit命令后调用。用户可以根据需要自定义shutdown行为方法 switch_to_active_element() Deprecated use driver.switch_to.active_element switch_to_alert() Deprecated use driver.switch_to.alert switch_to_default_content() Deprecated use driver.switch_to.default_content switch_to_frame(frame_reference) Deprecated use driver.switch_to.frame switch_to_window(window_name) Deprecated use driver.switch_to.window application_cache 返回一个与浏览器的应用程序缓存交互的ApplicationCache对象 current_url 获取当前页的URL driver.current_url current_window_handle 返回当前窗口的handle driver.current_window_handle desired_capabilities 返回正在使用当前所需功能的驱动程序 file_detector log_types 获取可用log types的列表 driver.log_types mobile name 返回此实例中底层浏览器的名称 driver.name orientation 获取当前设备的当前位置 orientation = driver.orientation page_source 获取当前页面的源码 driver.page_source switch_to title 返回当前页面的ｔｉｔｌｅ driver.title window_handles 返回当前会话中所有窗口的句柄 driver.window_handles WebElement class selenium.webdriver.remote.webelement.WebElement(parent, id_, w3c=False) Bases : object 表示一个 DOM 元素 通常与一个文档交互的所有有趣操作将通过该接口来执行 所有方法调用前会做一个 freshness check , 确保引用元素仍然有效。这实际上是检查元素是否仍然连接到 DOM . 如果检测测试失败，将会抛出 StaleElementReferenceException 异常，并且所有调用都会失败。 clear () 清除文本，如果是一个文本输入元素。 click () 点击元素 find_element ( by = 'id' , value = None ) find_element_by_class_name ( name ) 通过子元素的类名查找元素 name : 查找元素的类名 find_element_by_css_selector ( css_selector ) 通过子元素的 CSS selector 查找元素 css_selector : CSS selector string 例如‘ a . nav # home ' find_element_by_id(id_) 通过子元素的ID查找元素 id_: 用于定位的子元素的ID find_elements_by_partial_link_text(link_text) 通过子元素的link text查找元素的列表 link_text：元素的Link text find_element_by_tag_name(name) 通过子元素的tag name查找元素的列表 name - html的tag的name（如h1,a,span) find_elements_by_xpath(xpath) 通过xpath查找元素 xpath:xpath位置字符 基本路径相对于这个元素的位置 这将选择此元素下的所有链接。 myelement.find_elements_by_xpath(\".//a\") 然而，将会选择该页面本身的所有links myelement.find_elements_by_xpath(\"//a\") get_attribute(name) 获取给定元素的属性或特性 这个方法会首先尝试返回给定名字的属性的值。如果具有该名称的属性不存在，它返回具有相同名称的属性值。如果什么都没有，返回None name:检索的属性的名字 例如： #check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") is_displayed() 判断该元素是否对用户可见。 is_enabled() 返回元素是否已启用 is_selected() 返回元素是否已选择 可以用来检查复选框或单选框是否已选择 Screenshot(filename) 获取当前元素的截屏。如果出现任何IOError,返回False,否则返回True。filename使用绝对路径。 filename: 保存截屏文件的绝对路径 用法：element.Screenshot(' /Screenshots/ foo . png ') send_keys(*value) 模拟键入元素 value: 键入字符串，或设置表单。设置文件输出，可以为文件的绝对路径 可以用来发送简单的按键事件或填充表单： form_textfield = driver.find_element_by_name(' username ') form_textfield.send_keys(\"admin\") 同样可以用于设置文件输入。 file_input = driver.find_element_by_name(' profilePic ') file_input.send_keys(\"path/to/profilepic.gif\") #Generally it' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \"path/to/profilepic.gif\" )) submit () 提交表单 value_of_css_property ( property_name ) CSS 属性的值 id selenium 使用的内部编号 主要内部用户使用。可以用于简单检查 2 个元素是否为同一元素，可以使用\" == \"： if element1 == element2 : print ( \"These 2 are equal\" ) location 在渲染画布中元素的位置 location_once_scrolled_into_view 元素可能在没有提示的情况下修改。用它可以找到我们可以点击的元素。此方法可以将元素滚动到视图。 返回屏幕上的顶部左侧角落的位置，或者 None 如果该元素是不可见的。 parent Internal reference to the WebDriver instance this element was found from . rect 元素的位置和大小的字典 screenshot_as_base64 获取当前元素截屏的 base64 位编码 用法： img_b64 = element . screenshot_as_base64 screensh_as_png 获取当前元素截屏的二进制 用法： element_png = element . screensh_as_png size 元素的大小 tag_name 元素的 tagname 属性 text 元素的文本 UI Support class selenium.webdriver.support.select.Select(webelement) deselect_all() 清除所有选中的条目。只对选中多个支持的选择有效。如果SELECT如果不支持复合选择，则抛出NotImplementedError. deselect_by_index(index) 取消给定索引出的选项。通过元素的\"index\"属性进行，不仅仅通过计数。 index: 被取消选项的索引 如果指定的index没有SELECT,将抛出\"NoSuchElementException\"异常。 deselect_by_value(value) 取消匹配参数值的选项。例如给点参数\"foo\"，将取消这样的选项： <option value= \"foo\" > Bar </option> value: 要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 deselect_by_visible_text(text) 取消同参数值匹配的可见文本的选择项。例如给出\"Bar\"，这样的选项就会取消： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 select_by_index(index) 选择指定索引的选项。通过元素的index属性进行，不是通过counting. index:被选中选项的索引 如果给定的索引指定的选项不存在，将抛出\"NoSuchElementException\"异常 select_by_value(value) 选择匹配参数值的所有选项。例如，给定\"foo\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> vale:需要匹配的值 如果没有选项匹配给定的参数值，将抛出\"NoSuchElementException\"异常。 select_by_visible_text(text) 选择所有匹配可视文本的选项。例如给定参数\"Bar\"，这样的选项将会选中： <option value= \"foo\" > Bar </option> text:要匹配的可见文本 如果没有选项匹配给定的参数值，将会抛出StaleElementReferenceException异常。 all_selected_options 返回属于这个选项标签的所有选择选项的列表 first_selected_option 返回选项标签的第一个选项（或则当前已选中的选项） options 返回属于这个选择标签的所有选项的列表 class selenium.webdriver.support.wait.WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) Bases:object until(method, message=\") Calls the method provided with the driver as an argument until the return value is not False. until_not(method, message='') Calls the method provided with the driver as an argument until the return value is False. Color Support class selenium.webdriver.support.color.Color(red, green, blue, alpha=1) Bases:object 颜色转换支持类。 例如： from selenium.webdriver.support.color import Color print(Color.from_string('#00ff33').rgba) print(Color.from_string('rgb(1, 255, 3)').hex) print(Color.from_string('blue').rgba) static from_string(str_) hex rgb rgba Expected conditions Support class selenium.webdriver.support.expected_conditions.alert_is_present Bases:object 弹出预期alert class selenium.webdriver.support.expected_conditions.element_located_selection_state_to_be(locator, is_selected) Bases : object An expectation to locate an element and check if the selection state specified is in that state . locator is a tuple of ( by , path ) is_selected is a boolean class selenium.webdriver.support.expected_conditions.element_located_to_be_selected(locator) Bases : object An expectation for the element to be located is selected . locator is a tuple of ( by , path ) class selenium.webdriver.support.expected_conditions.element_selection_state_to_be(element, is_selected) Bases : object An expectation for checking if the given element is selected . element is WebElement object is_selected is a Boolean . \" class selenium.webdriver.support.expected_conditions.element_to_be_clickable(locator) Bases : object An Expectation for checking an element is visible and enabled such that you can click it . class selenium.webdriver.support.expected_conditions.element_to_be_selected(element) Bases : object An expectation for checking the selection is selected . element is WebElement object class selenium.webdriver.support.expected_conditions.frame_to_be_available_and_switch_to_it(locator) Bases : object An expectation for checking whether the given frame is available to switch to . If the frame is available it switches the given driver to the specified frame . class selenium.webdriver.support.expected_conditions.invisibility_of_element_located(locator) Bases : object An Expectation for checking that an element is either invisible or not present on the DOM . locator used to find the element class selenium.webdriver.support.expected_conditions.presence_of_all_elements_located(locator) Bases : object An expectation for checking that there is at least one element present on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.presence_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page . This does not necessarily mean that the element is visible . locator - used to find the element returns the WebElement once it is located class selenium.webdriver.support.expected_conditions.staleness_of(element) Bases : object Wait until an element is no longer attached to the DOM . element is the element to wait for . returns False if the element is still attached to the DOM , true otherwise . class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element(locator, text_) Bases : object An expectation for checking if the given text is present in the specified element . locator , text class selenium.webdriver.support.expected_conditions.text_to_be_present_in_element_value(locator, text_) Bases : object An expectation for checking if the given text is present in the element ' s locator , text class selenium.webdriver.support.expected_conditions.title_contains(title) Bases : object An expectation for checking that the title contains a case - sensitive substring . title is the fragment of title expected returns True when the title matches , False otherwise class selenium.webdriver.support.expected_conditions.title_is(title) Bases : object An expectation for checking the title of a page . title is the expected title , which must be an exact match returns True if the title matches , false otherwise . class selenium.webdriver.support.expected_conditions.visibility_of(element) Bases : object An expectation for checking that an element , known to be present on the DOM of a page , is visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . element is the WebElement returns the ( same ) WebElement once it is visible class selenium.webdriver.support.expected_conditions.visibility_of_any_elements_located(locator) Bases : object An expectation for checking that there is at least one element visible on a web page . locator is used to find the element returns the list of WebElements once they are located class selenium.webdriver.support.expected_conditions.visibility_of_element_located(locator) Bases : object An expectation for checking that an element is present on the DOM of a page and visible . Visibility means that the element is not only displayed but also has a height and width that is greater than 0 . locator - used to find the element returns the WebElement once it is located and visible Top &#94; 上一篇 Selenium主题8 下一篇 Selenium主题10","tags":"自动化测试-Selenium","title":"selenium-Remote WebDriver"},{"url":"http://king32783784.github.io/2015/01/26/selenium/","text":"示例9 各种元素定位方法 下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #!/bin/bash/env python # *-* coding: utf-8 *-* import unittest import time from selenium import webdriver from selenium.webdriver.common.keys import Keys testurl = \"http://192.168.32.3/\" class ElementLocal ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def localbyid ( self , iddriver , idvalue ): return iddriver . find_element_by_id ( idvalue ) def localbyname ( self , namedriver , namevalue ): return namedriver . find_element_by_name ( namevalue ) def localbyxpath ( self , xpathdriver , xpathvalue ): return xpathdriver . find_element_by_xpath ( xpathvalue ) def localbylinktext ( self , linkdriver , linktextvalue ): return linkdriver . find_element_by_link_text ( linktextvalue ) def localbyclassname ( self , classdriver , classnamevalue ): return classdriver . find_element_by_class_name ( classnamevalue ) def localbytagname ( self , tagdriver , tagnamevalue ): return tagdriver . find_element_by_tag_name ( tagnamevalue ) def localbycssselector ( self , cssdriver , cssvalue ): return cssdriver . find_elements_by_css_selector ( cssvalue )[ 1 ] def localbypartiallink ( self , partialdriver , partialvalue ): return partialdriver . find_element_by_partial_link_text ( partialvalue ) def dosearch ( self , element , searchvalue ): element . clear () element . send_keys ( searchvalue ) element . send_keys ( Keys . RETURN ) def test_localmethod ( self ): driver = self . driver driver . get ( testurl ) self . assertIn ( \"Bugzilla Main Page\" , driver . title ) search = self . localbyid ( driver , \"quicksearch_main\" ) self . dosearch ( search , \"11023\" ) self . assertIn ( \"11023\" , driver . title ) namedriver = self . localbynametest ( driver ) xpathdriver = self . localbyxpathtest ( namedriver ) linkdriver = self . localbylinktexttest ( xpathdriver ) classdriver = self . localbyclassnametest ( linkdriver ) tagdriver = self . localbytagnametest ( classdriver ) cssdriver = self . localbycsstest ( tagdriver ) self . localbypartiallinktest ( cssdriver ) def localbynametest ( self , driver ): search = self . localbyname ( driver , \"quicksearch\" ) self . dosearch ( search , \"11024\" ) self . assertIn ( \"11024\" , driver . title ) time . sleep ( 3 ) return driver def localbyxpathtest ( self , driver ): search = self . localbyxpath ( driver , \"//*[@id='quicksearch_top']\" ) self . dosearch ( search , \"11025\" ) self . assertIn ( \"11025\" , driver . title ) time . sleep ( 3 ) return driver def localbylinktexttest ( self , driver ): home = self . localbylinktext ( driver , \"Home\" ) home . click () time . sleep ( 3 ) return driver def localbyclassnametest ( self , driver ): search = self . localbyclassname ( driver , \"txt\" ) self . dosearch ( search , \"11026\" ) self . assertIn ( \"11026\" , driver . title ) time . sleep ( 3 ) return driver def localbytagnametest ( self , driver ): title = self . localbytagname ( driver , \"a\" ) title . click () time . sleep ( 3 ) return driver def localbycsstest ( self , driver ): search = self . localbycssselector ( driver , \"a.bz_common_actions\" ) search . click () time . sleep ( 3 ) return driver def localbypartiallinktest ( self , driver ): sample = self . localbypartiallink ( driver , \"Hom\" ) sample . click () time . sleep ( 3 ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 说明： 示例代码比较简单，就不在一一解释，主要覆盖了几种元素定位方式，可能在页面中找这些元素定位的特征反而比较费劲。 上一篇 selenium-Sample(三) 下一篇 selenium-Sample(五)","tags":"自动化测试-Selenium","title":"selenium-Sample(四）"},{"url":"http://king32783784.github.io/2015/01/20/selenium/","text":"Alert 警告相关的实现 class selenium . webdriver . common . alert . Alert ( driver ) Bases: object 允许使用alerts . 使用这个类作为与alert互动的接口 。 它包括dismissing ( 忽略 ）， accepting ( 接受 ）， inputting （ 输入 ） 和获取警告提示的文本信息的方法 。 接受 ／ 忽略警报信息 ： Alert ( driver ). accpet () Alert ( driver ). dismiss () 往警报信息中输入 ： name_prompt = Alert ( driver ) name_prompt . send_keys ( \"Willian Shakesphere\" ) name_prompt . accept () 读取警报信息作为验证 ： alert_text = Alert ( driver ). text self . assertEqual ( \"Do you wish to quit?\" , alert_text ) accept () 接受可用的警报信息 Usage:: Alert ( driver ). accept () # 确认一个警告提示框 authenticate ( username , password ) 发送用户名 ／ 密码到身份验证框 （ 例如Basic HTTP Auth ), 隐性发送 \" clicks ok \" 用法:: driver . switch_to . alert . authenticate ( 'cheese' , 'secretGouda' ) 参数 ： － username: 用户名对话框的字符串 - password: 密码对话框的字符串 dismiss () 忽略警报 send_keys ( keysToSend ) 向Alert发送键 Aargs: * keysToSend: 发送给Alert的文本 text 获取警报的文本 特殊键 该键实现如下 class selenium.webdriver.common.keys.Keys Bases: object 一套特殊的键码： ADD=u'\\ue025' ALT=u'\\ue00a' ARROW_DOWN=u'\\ue015' ARROW_RIGHT=u'\\ue014' ARROW_UP=u'\\ue013' BACKSPACE=u'\\ue003' BACK_SPACE=u'\\ue003' CHANCE=u'\\ue001' CLEAR=u'\\ue005' COMMAND=u'\\ue03d' CONTROL=u'\\ue009' DECIMAL=u'\\ue028' DELETE=u'\\ue017' DIVIDE=u'\\ue029' DOWN=u'\\ue015' END=u'\\ue010' ENTER=u'\\ue007' EQUALS=u'\\ue019' ESCAPE=u'\\ue00c' F1=u'\\ue031' F10=u'\\ue03a' F11=u'\\ue03b' F12=u'\\ue032' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013 定位元素 有很多特征可以用于元素定位，实现如下： class selenium . webdriver . common . by . By Bases:object CLASS_NAME = 'class name' CSS_SELECTOR = 'css selector' ID = 'id' LINK_TEXT = 'link text' NAME = 'name' PARTIAL_LINK_TEXT = 'partial link text' TAG_NAME = 'tag name' XPATH = 'xpath' Desired Capabilities Desired Capabilities实现如下： class selenium . webdriver . common . desired_capabilities . desired_capabilities Bases : object 设置默认支持的所需功能 . 以此为起点创建 desired capbilities 对象用于连接 selenium 服务器或 grid 的 remote webdrivers 请求 . 例如： from selenium import webdriver selenium_grid_url = \"http://198.0.0.1:4444/wd/hub\" # Creat a desired capabilities object as a starting point. capabilities = DesiredCapabilities . FIREFOX . copy () capabilities [ 'platform' ] = \"WINDOWS\" capabilities [ 'version' ] = \"10\" # Instantiate an instance of Remove WebDriver with the desired capabilities. driver = webdriver . Remote ( desired_capabilities = capabilities , command_executor = selenium_grid_url ) 注： DesiredCapabilities 对象始终使用\" . copy () \"，避免出现改变全局类实例的副作用。 ANDROID = { 'platform' : 'ANDROID' , 'browserName' : 'andorid' , 'version' : \",'javascriptEnabled':True} CHROME = { 'platform' : 'ANY' , 'browserName' : 'chrome' , 'version' : \", 'javascriptEnabled': True} EDGE = { 'platform' : 'WINDOWS' , 'broserNAME' : 'MicrosoftEdge' , 'version' : \"} FIREFOX = { 'platform' : 'ANY' , 'browserName' : 'firefox' , 'version' : \",'marionette':False,'javascriptEnabled':True} HTMLUNIT = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : \"} HTMLUNITWITHJS = { 'platform' : 'ANY' , 'browserName' : 'htmlunit' , 'version' : 'firefox' , 'javascriptEnabled' : True } INTERNETEXPLORER = { 'platform' : 'WINDOWS' , 'browserName' : 'internet explorer' , 'version' : \", 'javascriptEnabled':True} IPAD = { 'platform' : 'MAC' , 'browserName' : 'iPad' , 'version' : \", 'javascriptEnabled':True} IPHONE = { 'platform' : 'MAC' , 'browserName' : 'iPhone' , 'version' : \", 'javascriptEnabled':True} OPERA = { 'platform' : 'ANY' , 'browserName' : 'opera' , 'version' : \". 'javascriptEnabled':True} PHANTOMJS = { 'platform' : 'ANY' , 'browserName' : 'phantomjs' , 'version' : \", 'javascriptEnabled':True} SAFART = { 'platform' : 'MAC' , 'browserName' : 'safari' , 'version' : \",'javascriptEnabled':True} 公共部分 Utils 方法。 selenium.webdriver.common.utils.find_connectable_ip(host, port=None) 将hostname解析为ip,建议ipv4. 之所以建议ipv4,不是因为只支持ipv4,是因为一些dirvers（如firfoxdriver)不支持ipv6连接。 如果提供了可选的端口号，仅监听给定端口号的ip. 参数： * host - hostname * port - 可选的端口号 返回值： 一个单一的ip地址，字符串类型。如果找到任意ipv4地址，就会返回。或则，找到任意的ipv6地址，也会返回。如果都没有找到，返回None. selenium.webdriver.common.utils.free_port() 确定一个使用套接字的空闲端口 selenium.webdriver.common.utils.is_connectable(port, host='localhost') 尝试通过端口连接server,查看server是否在运行。 参数：* port: 连接的端口 selenium.webdriver.common.utils.is_url_connectable(port) 尝试通过端口连接到／status HTTP server，查看HTTPserver是否响应。 参数： *port: 连接的端口 selenium.webdriver.common.utils.join_host_port(host, port) 将hostname和port拼接到一起 这是一个小的实现用于应对ipv6,如： _join_host_port('::1',80) == '[::1]:80'. 参数： *host - hostname *port - 整数端口 selenium.webdriver.common.utils.keys_to_typing(value) 处理元素键入的值 Firefox WebDriver class selenium . webdriver . firefox . webdriver . WebDriver ( firefox_profile = None , firefox_binary = None , timeout = 30 , capabilities = None , proxy = None , executable_path = 'wires' , firefox_options = None ) Base: selenium . webdriver . remote . webdriver . WebDriver quit () 退出driver并每一个相关窗口 set_context ( context ) NATIVE_EVENTS_ALLOWED = True firefox_profile Chrome WebDriver class selenium . webdriver . chrome . webdriver . WebDriver ( executable_path = 'chromedriver' , prot = 0 , chrome_options = None , service_args = None , desired_capabilities = None , service_log_path = None ) Bases: selenium . webdriver . remote . webdriver . WebDriver 控制ChromeDriver , 并允许drive browser . Chromedriver下载地址 [ http: // chromedriver . storage . googleapis . com / index . html ]( http: // chromedriver . storage . googleapis . com / index . html ) create_options () launch_app ( id ) 启动由id指定的Chrome app . quit () 关闭浏览器和关闭启动ChromeDriver时启动的ChromeDriver . Top &#94; 上一篇 Selenium主题7 下一篇 Selenium主题9","tags":"自动化测试-Selenium","title":"selenium-API-2"},{"url":"http://king32783784.github.io/2015/01/14/selenium/","text":"入门 简单用法 如果已经具备了Selenium＆Python，可以这样开始使用： from selenium import webdriver from selenium.webdriver.common.keys import Keys driver = webdriver . Firefox () driver . get ( \"http://www.python.org\" ) assert \"Python\" in driver . title elem = driver . find_element_by_name ( \"q\" ) elem . clear () elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source driver . close () 上面的脚本可以保存到一个文件（例如： - python_org_search.py），那么就可以像这样运行： python python_org_search.py 示例解释 selenium.webdriver 模块提供了WebDriver全部实现。目前支持WebDriver实现的是Firefox、Chrome、IE和Remote. Keys类提供键盘操作比如RETURN, F1,ALT等。 from selenium import webdriver form selenium.webdriver.common.keys import keys 接下来，火狐的WebDriver实例被创建。 driver = webdriver.Firefox() driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source 最后，要关闭浏览器窗口。还可以通过调用quit方法去关闭。quit方法会退出整个浏览器，close会关闭一个标签页，默认情况下，大部分浏览器会关闭整个浏览器： driver.close() sample1: 测试百度首页的查询功能： 百度搜索框\" \" code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import time from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) driver = webdriver . Firefox () driver . get ( \"https://www.baidu.com/\" ) assert \"百度一下，你就知道\" in driver . title #elem = driver.find_element_by_name(\"wd\") #locate by name ##elem = driver.find_element_by_id(\"kw\") #locate by id elem = driver . find_element_by_xpath ( \"//*[@id='kw']\" ) # locate by xpath elem . clear () # elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) driver . implicitly_wait ( 100 ) assert \"No results found.\" not in driver . page_source time . sleep ( 10 ) driver . close () 使用Selenium编写测试 Selenium 大部分情况下都是用来编写测试用例的。Selenium本身是不提供测试工具或框架的。可以通过Python的unittest 模块去编写case,另外还可以通过pt.test或ｎｏｓｅ框架。 下面是一个使用unittest框架的例子，测试的是python.org 的搜索功能： import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys class PythonOrgSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_python_org ( self ): driver = self . driver driver . get ( \"http://www.python.org\" ) self . assertIn ( \"python\" , driver . title ) elem = driver . find_element_by_name ( \"q\" ) elem . send_keys ( \"pycon\" ) elem . send_keys ( Keys . RETURN ) assert \"No results found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 可以运行以下命令进行验证： python test_python_org_search.py 示例解析 最初，基本模块需要导入。unittest基于java的junit的内嵌模块。该模块提供了测试组织的框架。selenium.webdriver模块提供了WebDriver的所有实现。目前支持的是firefox chrome ie remote。Ｋeys类提供了键盘输入如RETURN F1 ALT等. import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys 测试用例类继承自unittest.TestCase,通过这个方式说明这是一个测试用例： class PythonOrgSearch ( unittest . TestCase ): Setup是初始化的一部分，这个方法在进行编写测试用例之前被每个测试方法调用。这里以firfox webdriver为例。 def setUp(self): self.driver = webdriver.Firefox() 这是一个测试用例的方法。这个测试用例方法总是characters 测试开始。第一行是创建一个本地driver,来源于setUp方法。 def test_search_in_python_org(self): driver = self.driver driver.get 方法会导航到URL指定的页面。Ｗebdriver会等待页面加载完成。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。 driver.get(\"http://www.python.org\") 下一行断言确认包含\"Python\"字母在里面： assert \"Python\" in driver.title webdriver 提供一些如find_element_by_*的方法用于定位元素。例如，输入文本元素可以通过find_element_by_name方法使用名称属性来定位。定位方法会在后续进行详细解释。 elem = driver.find_element_by_name(\"q\") 接下来，是发送关键信息，比较像从键盘输入。特殊关键信息可以通过selenium.webdriver.common.keys中的Keys 类实现。安全考虑，首先要确认输入区没有其他信息（如\"搜索框\"），以免影响搜索结果： elem.clear() elem.send_keys(\"pycon\") elem.send_keys(Keys.RETURN) 提交页面后，可以看到搜索结果或没有找到。为了确保找到了一些结果，我们需要做一些断言： assert \"No results found.\" not in driver.page_source tearDown方法每个测试方法之后都会调用。这是用来清理动作的地方。当前这个方法，实现了浏览器的关闭。同样可以调用quit方法替换close.quit方法有些地方是关闭一个标签页，默认情况下是关闭整个浏览器。 def tearDown(self): self.driver.close() 最后是标准代码用于执行测试： if __name__ == \"__main__\" unittest.main() sample 测试百度搜索 code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash/env python # -*- coding: utf-8 -*- import sys import unittest from selenium import webdriver from selenium.webdriver.common.keys import Keys reload ( sys ) sys . setdefaultencoding ( 'utf8' ) class BaiduSearch ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () def test_search_in_baidu ( self ): driver = self . driver driver . get ( \"https://www.baidu.com\" ) self . assertIn ( \"百度一下，你就知道\" , driver . title ) elem = driver . find_element_by_id ( \"kw\" ) elem . clear () elem . send_keys ( \"isoft\" ) elem . send_keys ( Keys . RETURN ) assert \"No result found.\" not in driver . page_source def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 使用Selenium remote WebDriver 使用remote WebDriver之前需确保Selenium server在运行。启动该server命令： java -jar selenium-server-standalone-2.x.x.jar 运行Selenium server时，会返回以下信息： 15:43:08.541 INFO - RemoteWebDriver instances should connect to: http://127.0.0.1:4444/wd/hub 上面的反馈信息说明可以使用这个URL连接到remote WebDriver.示例如下： from selenium import webdriver from selenium.webdriver.common.desired_capabilities import DesiredCapbilities driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . CHROME ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapbilities . OPERA ) driver = webdriver . Remote ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = DesiredCapabilities . HTMLUNITWITHJS ) 功能是个字典结构，可以通过字典来明确指定这些值： driver = webdriver.Remote( command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities={'browserName': 'htmlunit', 'version':'2', 'javascriptEnabled': True}) Top &#94; 上一篇 Selenium主题1 下一篇 Selenium主题3","tags":"自动化测试-Selenium","title":"selenium-入门"},{"url":"http://king32783784.github.io/2015/01/16/selenium/","text":"元素定位 提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素： *find_element_by_id *find_element_by_name *find_element_by_xpath *find_element_by_link_text *find_element_by_partial_link_text *find_element_by_tag_name *find_element_by_class_name *find_element_By_css_selector 要找到多个元素（这些方法将返回一个列表）： *find_elements_by_name *find_elements_by_xpath *find_elements_by_link_text *find_elements_by_partial_link_text *find_elements_by_tag_name *find_elements_by_class_name *find_elements_by_css_selector 除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和 find_elements. 用法例子： from selenium.webdriver.common.by import By driver . find_element ( By . XPATH , '//button[test()=\"Some text\"]' ) driver . find_elements ( By . XPATH , '//button' ) 这些都是类可用的属性： ID = \"id\" XPATH = \"xpath\" LINK_TEXT = \"link text\" PARTIAL_LINK_TEXT = \"partial link text\" NAME = \"name\" TAG_NAME = \"tag name\" CLASS_NAME = \"class name\" CSS_SELECTOR = \"css selector\" 1.使用ID定位 当你知道元素的id属性时，可以用ＩＤ定位。这种方式，将返回第一个和ＩＤ属性匹配的元素。如果没有匹配的元素，将会触发NoSuchElementException异常. 例如，参考这个页面的源代码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> </form> </body> <html> 可以通过下面方式定位form元素： login_form = driver.find_element_by_id('loginForm') 2.使用名称定位 当知道元素的名称属性时，可以通过名称的方式定位。这种方式，将返回第一个和name属性匹配的元素。如果没有匹配的元素，将触发NoSuchElementException异常。 例如，参考页源码： <html> <body> <form id = \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> username和password元素可以通过下面的方式定位： username = driver.find_element_by_name('username') password = driver.find_element_by_name('password') 这样在\"Clear\"按钮之前，\"login\"按钮将先被获取： continue = driver.find_element_by_name('continue') 3.使用Xpath定位 Xpath是ＸＭＬ文档中定于节点的语言。ＨTML可以看做是XML的一种实现，Selenium可以通过这一强大的语言去定位web应用的元素。XPath定位方法超过了id和name定位方法，它可以实现一些更多的定位可能，比如定位页面中第三个复选框。 使用Xpath定位一个很大原因是需要定位一个没有合适的is/name的元素。XPath可以定位相对路径的元素，还可以定位有id/name的元素。Xpath还可以用于指定通过id/name定位的元素。 XPaths可以获取所有root(html)中的元素的位置，虽然结果可能会失败，但对ＡＰＰ基本不会造成影响。可以借助通过id/name定位目标元素临近的元素的相对关系去定位目标元素。这种方式一般不太会改变，所有能增加测试的鲁棒性。 例如，参考下面的页源码： <html> <body> <form id= \"loginForm\" > <input name= \"username\" type= \"text\" /> <input name= \"password\" type= \"password\" /> <input name= \"continue\" type= \"submit\" value= \"Login\" /> <input name= \"continue\" type= \"button\" value= \"Clear\" /> </form> </body> <html> form元素可以通过以下方式定位： login_form = driver.find_element_by_xpath(\"/html/body/form[1]\") login_form = driver.find_element_by_xpath(\"//form[1]\") login_form = driver.find_element_by_xpath(\"//form[@id='loginForm']\") 1.绝对路径（只对HTML可能造成轻微影响） 2.HTML中第一个form元素 3.通过表单元素的id定位值为\"loginForm\"的表单元素 username元素可以通过以下方式定位： username = driver.find_element_by_xpath(\"//form[input/@name='username']\") username = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[1]\") username = driver.find_element_by_xpath(\"//input[@name='username']\") 1.通过第一个form元素的input子元素中name属性为\"username\"的元素定位 2.通过name属性为\"loginForm\"的form元素的input元素的第一个子元素定位 3.通第一个name属性为\"username\"的input元素定位 \"Clear\"元素可以通过以下方式定位： clear_button = driver.find_element_by_xpath(\"//input[@name='continue'][@type='button']\") clear_button = driver.find_element_by_xpath(\"//form[@id='loginForm']/input[4]\") 1.通过name属性为\"continue\"的input元素中name属性为\"button\"的元素定位。 2.通过id值为'loginForm'的form元素的第４个input子元素定位 上面的例子基本覆盖了基本用法，如果想了解更多，可以参考一下链接： W3Schools Xpath Tutorial W3C Xpath Recommendition XPath Tutorial 也有几个非常有用的附加组件，可帮助通过XPath定位元素： XPath Checker Firebug * XPath Helper 4.通过链接文本定位超链接 当你知道一个锚点的链接文本，可以通过下面方式定位。这种方式，会返回第一个匹配的位置。如果没有匹配的元素，将会触发NoSuchElementException异常。 参考一下页源码： <html> <body> <p> Are you sure you want to do this? </p> <a href= \"continue.html\" > Continue </a> <a href= \"cancel.html\" > Cancel </a> </body> <html> continue.html的链接可以这样定位： continue_link = driver.find_element_by_link_text('Continue') continue_link = driver.find_element_by_partial_link_text('Conti') 5.通过Tag Name定位元素 当知道tag name的情况下，可以通过tag name去定位元素。同样，这个方式只会返回第一个匹配tagname的元素。如果找不到，同样会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <h1> Welcome </h1> <p> Site content goes here. </p> </body> <html> h1元素可以这样定位： heading1 = driver.find_element_by_tag_name('h1') 6.通过class name定位元素 下面的方式可以通过class name属性去定位元素。同样会返回第一个匹配的元素。如果找不到元素，就会触发NoSuchElementException异常。 页源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_class_name('content') 7.通过CSS选择器定位元素 使用下面的方式，可以通过CSS选择器去定位元素。同样，该方式也是返回第一个匹配CSS选择器的元素。如果没有匹配的元素，则触发NoSuchElementException异常。 页面源码参考如下： <html> <body> <p class= \"content\" > Site content goes here. </p> </body> <html> 元素\"p\"可以通过下面的方式定位： content = driver.find_element_by_css_selector('p.content') Top &#94; 上一篇 Selenium主题3 下一篇 Selenium主题5","tags":"自动化测试-Selenium","title":"selenium-元素定位"},{"url":"http://king32783784.github.io/2015/01/19/selenium/","text":"WebDriver API 注：这不是官方API文档，官方在这： Selenium Documentation 本篇覆盖了Selenium Webdriver的所有接口。 推荐导入样式 本节API展示了类的绝对位置。推荐的导入风格如下： from selenium import webdriver 然后，可以访问的类如下： webdriver.Firefox webdriver.FirefoxProfile webdriver.Chrome webdriver.ChromeOptions webdriver.Ie webdriver.Opera webdriver.PhantomJS webdriver.Remote webdriver.DesiredCapabilities webdriver.ActionChains webdriver.TouchActions webdriver.Proxy 特殊键类（keys)可以这样导入： from selenium.webdriver.common.keys import Keys 异常类可以这样导入（以实际的类名替换TheNameOfTheExceptionClass): from selenium.common.exceptions import [ TheNameOfTheExceptionClass ] API使用约定 一些属性（如方法）是可调用的，一些属性（如properties)是不可调用的，所有可调用的属性均以圆括号结尾。 属性的例子： current_url 当前加载页面的URL Usage: driver.current_url 方法的例子： * close() 选择关闭的窗口 Usage: driver.close() 异常 所有的webdriver代码都可能会触发异常 exception Selenium.common.exceptions.ElementNotSelectableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidElementStateException 试图选择一个不能选择的元素时抛出 例如，选择\"script\"元素 exception selenium.common.exceptions.ElementNotVisibleException(msg=None,screen=None,stacktrace=None) Bases:selenium.common.exceptions.InvalidElementStateException 当一个元素存在于DOM中，但是不可访问的，如果试图与之互动，则会触发该异常。 大多数情况是试图点击或读取试图中隐藏的元素的文本 exception selenium.common.exceptions.ErrorInResponseException(response, msg) Bases : selenium . common . exceptions . WebDriverException 服务端发生错误时抛出 当和firefox插件或remote driver server通信时可能会触发 exception selenium.common.exceptions.ImeActivationFailedException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当激活输入法引擎失败时触发 exception selenium.common.exceptions.ImeNotAvailableException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException IME支持不可用时。当平台上任何依赖IME的方法，调用IME不可用时，均会触发。 exception selenium.common.exceptions.InvalidCookieDomainException(msg=None, srceen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 试图在超出当前URL的不同域添加一个cookie时触发 exceptin selenium.common.exceptions.InvalidElementStateException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.InvalidSelectorException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . NoSuchElementException 当selector被用来查找返回一个不是WebElement时触发。 目前只用在当selector查找一个无效的 xpath或 xpath指向的不是一个WebElements. exception selenium.common.exceptions.InvalidSwitchToTargetException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到的frame或窗口目标不存在时触发 exeption selenium.common.exceptions.MoveTargetOutOfBoundsException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当供给ActionsChains move() 方法的目标无效时触发，如超出文本 exception selenium.common.exceptions.NoAlertPresentException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当切换到没有弹出警告时触发。 当通过调用Alert()类的操作后，屏幕中未弹出警告窗口时触发。 exception selenium.common.exceptions.NoSuchAttributeException(msg=None,screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当元素的属性找不到时抛出 可能会检查测试时浏览器中属性。在不同浏览器中，相同的属性可能会有不同的名称。 exception selenium.common.exceptionsNoSuchElemention(msg=None, screen=None,stacktrace) Bases : selenium . common . exceptions . WebDriverException 当元素找不到时抛出该异常。 如果遇到此异常，可能要检查以下内容： * 检查find_by...使用的selector * 元素在查找时没有在页面上 页面可能仍在加载中，需要使用wait方法去等待 exception selenium.common.exceptions.NoSuchFrameException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的Frame不存在时触发 exception selenium.common.exceptions.NoSuchWindowException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exceptions . InvalidSwitchToTargetException 当切换的窗口不存在时触发 要想获取当前活动窗口的句柄，可以通过下面的方法获取活动窗口的句柄列表： print driver.windown_handles exception selenium.common.exceptions.RemoteDriverServerException(msg=None, screen=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException exception selenium.common.exceptions.StaleElementReferenceException(msg=None. screen=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当引用一个过期的元素时触发该异常 过期的意思是不再在页面的ＤＯＭ中出现。 触发StaleElementReferenceException的原因包括，但不限于： * 很长时间没有操作页面，当定位元素时，页面已经更新。 * 元素出现后，该元素可能被删除后重新添加到屏幕的。这可能发生在javascript框架更新和节点重建时。 * 元素可能在iframe中，或文本内容已更新 exception selenium.common.exceptions.TimeoutException(msg=Noe, scren=None, stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当已命令没有在规定时间内完成时会触发该异常 exception selenium.common.exceptions.UnableToSetCookieException(msg=None, screen=None, stacktrace=None) Bases : selenium . common . exeptions . WebDriverException 当driver设置cookie失败时抛出 exception selenium.common.exceptions.UnexpectdAlertPresentException(msg=None, screen=None, stacktrace=None, alert_text=None) Bases : selenium . common . exceptions . WebDriverException 当未知的警告窗口弹出时抛出 通常阻止执行许多预期命令的webdriver时抛出 exception selenium.common.exceptions.UnexpectedTagNameException(msg=None, scren=None,stacktrace=None) Bases : selenium . common . exceptions . WebDriverException 当支持的类没有得到预期的web元素时抛出 exception selenium.common.exceptions.WebDriverException(msg=None, screen=None, stacktrace=None) Bases : exceptions . Exception Webdriver 基本异常 动作链 该动作链实施， class selenium . webdriver . common . action_chains . ActionChains ( driver ) Base:object ActionChains是底层自动化交互 ， 比如鼠标移动 ， 鼠标按键操作 ， 按键和上下文交互菜单 。 可以用来做一些负责的动作比如悬停和拖放等 。 生成用户操作 当你调用ActionChains 类的一些方法实现动作 ， 这些动作可以存储到ActionChains类中 。 当你调用perform (), 这些事件会顺序发射执行 。 action_chains可以在链模式中使用 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".new #submen1\" ) action_chains ( driver ). move_to_element ( menu ). click ( hidden_submenu ). perform () 或动作一个接一个顺序执行 ： menu = driver . find_element_by_css_selector ( \".nav\" ) hidden_submenu = driver . find_element_by_css_selector ( \".nav #submenu1\" ) actions = ActionChains ( driver ) actions . move_to_elment ( menu ) actions . click ( hidden_submenu ) actions . perform () 无论哪种方式 ， 这些动作都会顺序调用执行 。 click ( on_element = None ) 点击一个元素 Args: * on_element: 鼠标点击元素 ， 如果没有 ， 点击当前鼠标的位置 。 click_and_hold ( on_elememt = None ) 按住在元素上按住鼠标左键 Args: * on_element: 鼠标点击元素 ， 没有 ， 点击当前鼠标的位置 context_click ( on_element = None ) 在元素上右击 Args: * on_element: 上下文点击该元素 ， 如果没有 ， 点击鼠标当前的位置 double_click ( on_element = None ) 双击元素 Args: * on_element: 双击该元素 ， 如果 ， 双击鼠标当前的位置 drag_and_drop ( source , target ) 在source element 左击并保持 然后移动到目标元素并且是否鼠标 Args: * source: 鼠标按下的元素 * target: 鼠标移动到元素 drag_and_drop_by_offset ( source , xoffset , yoffset ) 左击点击source element , 然后 ， 移动到目标偏移地址 ， 并释放鼠标 Args: * source: 鼠标点击的元素 * xoffset: 元素移动的X偏移量 * yoffset: 元素移动的Ｙ偏移量 key_down ( value , element = None ) 仅发送一个按键 ， 不释放 ( 多用于组合键 ） 需要和修饰键一起使用 （ 控制 ， alt和shift ) Aargs: * value: 被发送的修饰键 ， 在Keys类中定义 * element: 发送键作用的元素 。 如果为空 ， 则向作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () key_up ( value , element = None ) 释放修饰键 Aargs: * value: 发送的修饰键盘 ， 在Keys类中定义 。 * element: 作用于的元素 ， 如果为空 ， 默认作用于当前焦点元素 例如 ， 按下ctrl + c: ActionChains ( driver ). key_down ( Keys . CONTROL ). send_keys ( 'c' ). key_up ( Keys . CONTROL ). perform () move_by_offset ( xoffset , yoffset ) 从当前鼠标位置 ， 移动一定的偏移位置 Aargs: * xoffset: X偏移量 ， 可以为正或负的整数 * yoffset: y偏移量 ， 可以为正或负的整数 move_to_element ( to_element ) 移动鼠标到元素的中间 Args: * to_element: 移动的目标WebElement move_to_element_with_offset ( to_element , xoffset , yoffset ) 指定元素偏移一定量 偏移量相对于元素的左上角 Args: * to_elemnt: 被移动的WebElement * xoffset: x偏移量 * yoffset: y偏移量 perform () 执行所有存储的操作 release ( on_element = None ) 释放作用于元素的按键 Args: * on_element: 指定作用的元素 ， 如果为空 ， 释放当前鼠标作用的位置 send_keys (* keys_to_send ) 发送按键到当前焦点元素 Args: * keys_to_send: 发送的按键 。 修饰键常量可以在 ‘ Keys'类中找到 send_keys_to_element ( element , * keys_to_send ) 发送按键到一个元素 Args: * element: 发送按键作用的元素 * keys_to_send: 发送的按键类型 ， 修饰键常量可以在 \" Keys'类中找到 。 Top &#94; 上一篇 Selenium主题6 下一篇 Selenium主题8","tags":"自动化测试-Selenium","title":"selenium-API"},{"url":"http://king32783784.github.io/2015/02/01/selenium/","text":"示例10 不同等待方法示例 等待方法包括多种策略，具体参见前面文章。 示例代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 #!/bin/bash/env python # *-* coding:utf-8 *-* import sys import unittest from subprocess import call from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC reload ( sys ) sys . setdefaultencoding ( 'utf8' ) testurl = \"https://www.baidu.com/\" testurl1 = \"http://192.168.32.3/\" class TestWait ( unittest . TestCase ): def setUp ( self ): self . driver = webdriver . Firefox () # presence_of_element_located方法 def test_byID ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"kw\" )) ) print ( \"Wait by presence_of_element_located sucessfull\" ) except : print ( \"Wait by presence_of_element_located failed\" ) # title_is 方法 def test_byTitle ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_is ( '百度一下，你就知道' )) print ( \"Wait by title_is sucessfull\" ) except : print ( \"Wait by title_is failed\" ) def test_byTitlecontains ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . title_contains ( '百度' )) print ( \"Wait by title_contains sucessfull\" ) except : print ( \"Wait by title_contains failed\" ) def test_byname ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of_element_located (( By . NAME , \"wd\" )) ) print ( \"Wait by visibility_of_element_located sucessfull\" ) except : print ( \"Wait by visibility_of_element_located by name failed\" ) def test_byelement ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_name ( \"wd\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . visibility_of ( elem )) print ( \"Wait by visibility_of sucessfull\" ) except : print ( \"Wait by visibility_of failed\" ) def test_bypresenceelements ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_all_elements_located (( By . NAME , \"wd\" )) ) print ( \"Wait by presence_of_all_elements_located sucessfull\" ) except : print ( \"Wait by presenceelements failed\" ) def test_bytextinelement ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element (( By . NAME , \"tj_trhao123\" ), \"hao123\" )) print ( \"Wait by text_to_be_present_in_element sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element failed\" ) def test_bytextvalue ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . text_to_be_present_in_element_value (( By . ID , \"su\" ), \"百度一下\" )) print ( \"Wait by text_to_be_present_in_element_value sucessfull\" ) except : print ( \"Wait by text_to_be_present_in_element_value failed\" ) def test_byframe ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . frame_to_be_available_and_switch_to_it (( By . NAME , \"tj_trhao123\" ))) print ( \"Wait by frame_to_be_available_and_switch_to_it sucessfull\" ) except : print ( \"Wait by frame_to_be_available_and_switch_to_it failed\" ) def test_byinvisibility ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . invisibility_of_element_located (( By . NAME , \"tj_trha\" ))) print ( \"Wait by invisibility_of_element_located sucessfull\" ) except : print ( \"Wait by invisibility_of_element_located failed\" ) def test_byclickable ( self ): driver = self . driver driver . get ( testurl ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_clickable (( By . ID , \"su\" ))) print ( \"Wait by element_to_be_clickable sucessfull\" ) except : print ( \"Wait by element_to_be_clickable failed\" ) def test_bystaleness ( self ): driver = self . driver driver . get ( testurl ) elem = driver . find_element_by_id ( \"su\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . staleness_of ( elem )) print ( \"Wait by staleness_of failed\" ) except : print ( \"Wait by staleness_of sucessfull\" ) def test_bybeselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () elem = driver . find_element_by_xpath ( \"//*[@id='product']/option[1]\" ) try : elemnt = WebDriverWait ( driver , 10 ) . until ( EC . element_to_be_selected ( elem )) print ( \"Wait by element_to_be_selected sucessfull\" ) except : print ( \"Wait by element_to_be_selected failed\" ) def test_bylocatedselected ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"short_desc\" )): driver . find_element_by_xpath ( \"//*[@id='tab_specific']/a\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_to_be_selected (( By . XPATH , \"//*[@id='product']/option[1]\" ))) print ( \"Wait by element_located_to_be_selected sucessfull\" ) except : print ( \"Wait by element_located_to_be_selected failed\" ) def test_byselectionstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"bug_status\" ))): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : elem = driver . find_element_by_xpath ( \"//*[@id='custom_search_filter_section']/table/tbody/tr[1]/td/label\" ) element = WebDriverWait ( driver , 10 ) . until ( EC . element_selection_state_to_be ( elem , True )) print ( \"Wait by element_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_selection_state_to_be failed\" ) def test_bylocatedstate ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( 'query' ) . click () if EC . presence_of_element_located (( By . ID , \"bug_status\" )): driver . find_element_by_id ( \"tab_advanced\" ) . click () driver . find_element_by_xpath ( \"//*[@id='negate0']\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . element_located_selection_state_to_be (( By . XPATH , \"//*[@id='negate0'\" ))) print ( \"Wait by element_located_selection_state_to_be sucessfull\" ) except : print ( \"Wait by element_located_selection_state_to_be failed\" ) def test_byisalert ( self ): driver = self . driver driver . get ( testurl1 ) driver . find_element_by_id ( \"find\" ) . click () try : element = WebDriverWait ( driver , 10 ) . until ( EC . alert_is_present ()) element . accept () print ( \"Wait by alert_is_present sucessfull\" ) except : print ( \"Wait by alert_is_present failed\" ) def test_byimplicitly ( self ): driver = self . driver driver . implicitly_wait ( 20 ) call ( \"date\" , shell = True ) driver . get ( testurl1 ) try : driver . find_element_by_id ( \"test\" ) except : pass call ( \"date\" , shell = True ) def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 示例中覆盖了expected_condition类中的大部分等待方式。包括title_is 、title_contains、presence_of_element_located、visibility_of_element_located、visibility_of、presence_of_all_elements_located、text_to_be_present_in_element、text_to_be_present_in_element_value、frame_to_be_available_and_switch_to_it、invisibility_of_element_located、element_to_be_clickable-it is Displayed and Enabled、staleness_of、element_to_be_selected、element_located_to_be_selected、element_selection_state_to_be、element_located_selection_state_to_be、alert_is_present 及implicitly_wait. 下一篇会研究一下expected_condition中各个类的实现。","tags":"自动化测试-Selenium","title":"selenium-Sample(五）"},{"url":"http://king32783784.github.io/2015/01/23/selenium/","text":"应用示例 1.通过selenium爬取\"https://stocksnap.io/\"上的图片。 简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。 代码如下： #!/bin/bash/env python # -*- coding: utf-8 -*- import time import urllib import urllib2 import re import os from selenium import webdriver # 爬取页面地址 url = \"https://stocksnap.io/\" class GetpicHtml ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def gethtml ( self ): self . driver . maximize_window () img_url_dic = {} self . driver . get ( url ) # 模拟滚动窗口以浏览下载更多图片 pos = 0 m = 0 # 图片编号 for i in range ( 10 ): pos += i * 500 # 每次下滚500 js = \"document.documentElement.scrollTop= %d \" % pos self . driver . execute_script ( js ) time . sleep ( 1 ) elemlist = self . driver . find_elements_by_xpath ( \"//*[@id='main']/a[*]/img\" ) for elem in elemlist : img_url = elem . get_attribute ( 'src' ) if img_url != None and not img_url_dic . has_key ( img_url ): img_url_dic [ m ] = img_url m += 1 self . driver . close () return img_url_dic class DownloadFile ( object ): def __init__ ( self , url_list , local_dir ): self . url_list = url_list self . local_dir = local_dir def downloadfile ( self , localname , url ): try : response = urllib2 . urlopen ( url ) urllib . urlretrieve ( url , localname ) except : print ( \" %s Download error:\" % localname ) exit ( 1 ) def control ( self ): for k , v in self . url_list . iteritems (): filename = re . findall ( r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\" , v )[ 0 ] + \".jpg\" localname = os . path . join ( self . local_dir , filename ) self . downloadfile ( localname , v ) if __name__ == '__main__' : getsrc = GetpicHtml () urllist = getsrc . gethtml () downloadpic = DownloadFile ( urllist , \"/home/isoft_lp/tmp\" ) 代码说明： driver.execute_script(js) 调用execute_scripts执行JavaScript脚本，随后会重点说明该方法； elemlist= self.driver.find_elements_by_xpath(\"//*[@id='main']/a[*]/img\") 通过xpath获取图片元素； 元素内容\" \"<img src=\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/9XCA8GIDBS.jpg\" height=\"280\" width=\"420\">\"； img_url = elem.get_attribute('src') 获取图片源地址； filename = re.findall(r\"https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/(.+?).jpg\", v)[0] + \".jpg\" 获取图片文件的原名字； response = urllib2.urlopen(url) urllib.urlretrieve(url, localname) 指定url和本地地址，进行文件的下载 ２．自动登陆https://github.com/ 简要说明，通过selenium打开firefox浏览器，导航到指定网站，点击Sign in,自动输入账号密码，实现自动登陆。 代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # 登陆网址 url = \"https://github.com/\" # 账号密码 loginname = \"xxxx@xx\" passwordvalue = \"xxxxx\" class AutoLoginGithub ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () # 导航到github登陆页面 def getloginpage ( self ): self . driver . get ( url ) # 定位signin按钮 signin = self . driver . find_element_by_xpath ( '/html/body/header/div/div/div/a[2]' ) # 点击signin按钮，进入登陆页面 actions = ActionChains ( self . driver ) # 移动光标至sigin按钮 actions . move_to_element ( signin ) actions . click ( signin ) actions . perform () return self . driver def autologin ( self ): # 获取新的页面对象 driver = self . getloginpage () ＃ 定位账号输入框 login = driver . find_element_by_id ( \"login_field\" ) ＃ 输入账号信息 login . send_keys ( loginname ) ＃ 定位密码输入框 password = driver . find_element_by_id ( \"password\" ) ＃ 输入密码信息 password . send_keys ( passwordvalue ) ＃ 定位登陆按钮 dologin = driver . find_element_by_xpath ( \"//*[@id='login']/form/div[4]/input[3]\" ) ＃ 点击登陆按钮 actions = ActionChains ( driver ) actions . move_to_element ( dologin ) actions . click ( dologin ) actions . perform () time . sleep ( 3 ) driver . close () if __name__ == '__main__' : autologin = AutoLoginGithub () autologin . autologin () 代码说明： 以下代码，实现按钮的点击 actions = ActionChains(self.driver) # 移动光标至sigin按钮 actions.move_to_element(signin) actions.click(signin) actions.perform() 未完待续 上一篇 Selenium主题10 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(一）"},{"url":"http://king32783784.github.io/2015/01/24/selenium/","text":"常见应用的示例 Sample List 填写表单示例1-自动设置bugzilla Simple Search 填写表单示例2-自动设置bugzilla Advanced Search 拖放drag和drop示例-待定 窗口和框架之间移动示例-待定 弹出对话框示例-待定 历史记录和位置示例-待定 Cookies示例-待定 元素定位不同方式示例-待定 ID定位 名称定位 Xpath定位 链接文本定位超链接 Tag Name定位 class name定位 css选择器定位 等待-不同条件显示等待示例-待定 title_is title_contains presence_of_element_locate visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element_value text_to_be_present_in_element frame_to_be_available_and_switch_to_it invisibility_of_element_located elements_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be arelt_is_present 等待-等待示例-隐式等待 页面对象设计模式示例 ... ... 示例3. 填写表单示例1-自动设置bugzilla Simple Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select # test网址 url = \"http://192.168.32.3/\" class SampleSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver # 导航到samplesearch页面 def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) simplesearch = searchdriver . find_element_by_id ( \"tab_specific\" ) sampledriver = self . doclick ( searchdriver , simplesearch ) return sampledriver def setseclect ( self , driver , name , values ): select = Select ( driver . find_element_by_name ( name )) for value in values : select . select_by_value ( value ) return driver def dosearch ( self ): search = self . getSearchpage () statusvalues = ( '__all__' ,) status = self . setseclect ( search , 'bug_status' , statusvalues ) productvalues = ( 'iSoft_Desktop_v4.0_for loongson' ,) product = self . setseclect ( status , 'product' , productvalues ) searchbutton = product . find_element_by_xpath ( \"//*[@id='search']\" ) self . doclick ( product , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autologin = SampleSearch () autologin . dosearch () 分析： doclick方法实现对选定元素的点击。 getSearchpage 方法获取简单搜索页面 dosearch方法是流程控制 重点讲一下setseclect方法， def setseclect(self, driver, name, values): select = Select(driver.find_element_by_name(name))) # 通过Select类的调用，获取下拉框 for value in values: # 进行指定下拉框选项的设定 select.select_by_value(value) return driver 实现对下拉框的定位和下拉框值的设定。 示例4. 填写表单示例2-自动设置bugzilla Advanced Search code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class AdvanceSearch ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def doclick ( self , driver , elem ): actions = ActionChains ( driver ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () return driver def getSearchpage ( self ): self . driver . get ( url ) search = self . driver . find_element_by_id ( 'query' ) searchdriver = self . doclick ( self . driver , search ) return searchdriver def setseclect ( self , driver , selects ): for k , v in selects . iteritems (): selectlist = Select ( driver . find_element_by_name ( k )) for value in v : selectlist . select_by_value ( value ) return driver def dosearch ( self ): product = [ 'iSoft_Desktop_v4.x_x86-64' , 'iSoft_Desktop_v4.0_x86-64' ] selects = { 'product' : product ,} search = self . getSearchpage () setselect = self . setseclect ( search , selects ) searchbutton = setselect . find_element_by_id ( 'Search' ) self . doclick ( setselect , searchbutton ) time . sleep ( 10 ) self . driver . close () if __name__ == '__main__' : autosearch = AdvanceSearch () autosearch . dosearch () 分析： 大部分和上一个例子代码类似。其中setseclect方法不同 def setseclect(self, driver, selects): for k, v in selects.iteritems(): selectlist = Select(driver.find_element_by_name(k)) for value in v: selectlist.select_by_value(value) return driver 通过一个字典将选择框的name属性和要选择的项目列表传入。通过遍历，将两个项目复选。 上一篇 selenium-Sample(一) 下一篇 selenium-Sample(二)","tags":"自动化测试-Selenium","title":"selenium-Sample(二）"},{"url":"http://king32783784.github.io/2015/01/18/selenium/","text":"一、页面对象 该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。 使用页面对象模式的好处： 创建多测试用例共用的可重复代码 减少重复的代码 如果用户界面发生改变，只需修改一次对应部分 1.测试用例 以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。 import unittest from selenium import webdriver import page class PythonOrgSearch ( unittest . TestCase ): '''A sample teest class to show how page object works''' def setUp ( self ): self . driver = webdriver . Firefox () self . driver . get ( \"http://www.python.org\" ) def test_search_in_python_org ( self ): \"\"\" Tests python.org search feature. searchs for the word \"pycon\" then verified that some results show up. Note that it does not look for any particular test in search results page. This test verifies that the results were not empty. \"\"\" # Load the main page. In this case the home page of Python.org. main_page = page . MainPage ( self . driver ) #Checks if the word \"python\" is in title assert main_page . is_title_matches (), \"python.org title desn't match.\" #Sets the text of search textbox to \"pycon\" main_page . search_text_element = \"pycon\" main_page . click_go_button () search_results_page = page . SearchResultsPage ( self . driver ) #Verifies that the results page is not empty assert search_results_page . is_results_found (), \"No results found.\" def tearDown ( self ): self . driver . close () if __name__ == \"__main__\" : unittest . main () 2.Page 对象类 Page 对象模式是为每个页面创建一个对象。按照此方法，创建一个测试代码与技术实施之间的隔离层。 page.py可以为： from element import BasePageElement from locators import MainPageLocators class SearchTextElement ( BasePageElement ): \"\"\" This class gets search text from the specified locator\"\"\" # The locator for search box where search string is entered locator = 'q' class BasePage ( object ): \"\"\" Base class to initialize the base page that will be called from all pages\"\"\" def __init__ ( self , driver ): self . driver = driver class MainPage ( BasePage ): \"\"\"Home page action methods come here. I.e. Python.org\"\"\" #Declares a variable that will contain the retrieved text search_text_element = SearchTextElement () def is_title_matches ( self ): \"\"\"Verifies that the hardcoded text \"Python\" appers in page title\"\"\" return \"Python\" in self . driver . title def click_go_button ( self ): \"\"\"Triggers the search\"\"\" element = self . driver . find_element ( * MainPageLocators . GO_BUTTON ) element . click () class SearchResultsPage ( BasePage ): \"\"\"Search results page action methods come here\"\"\" def is_results_found ( self ): # Probably should search for this text in the specific page # element, but as for now it works fine return \"No results found.\" not in self . driver . page_source 3.Page elements element.py 可以是这样： from selenium.webdriver.support.ui import WebDriverWait class BasePageElement ( object ): \"\"\"Base page class that is initialized on every page object class.\"\"\" def __set__ ( self , obj , value ): \"\"\"Sets the text to the value supplied\"\"\" driver = obj . driver WebDriverWait ( driver , 100 ) . until ( lambda driver : driver . find_element_by_name ( self . locator )) element = driver . find_element_by_name ( self . locator ) return element . get_attribute ( \"value\" ) 4.Locators 一种方式为将locators字符串和使用的地方分离。下面的例子，同一页面的locators属于同一个类。 locators.py： from selenium.webdriver.common.by import By class MainPageLOcators ( object ): \"\"\"A class for main page locators. All main page locators should come here\"\"\" GO_BUTTON = ( By . ID , 'submit' ) class SearchResultPageLocators ( object ): \"\"\"A class for search results locators. All search results locators should come here\"\"\" pass Top &#94; 上一篇 Selenium主题5 下一篇 Selenium主题7","tags":"自动化测试-Selenium","title":"selenium-页面对象"},{"url":"http://king32783784.github.io/2015/01/15/selenium/","text":"一 导航 使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现： driver.get(\"http://www.google.com\") driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait. 1.页面交互 只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下： <input type=\"text\" name=\"passwd\" id=\"passwd-id\" /> 你可以使用下面方法找到该元素： element = driver.find_element_by_id(\"passwd-id\") element = driver.find_element_by_name(\"passwd\") element = driver.find_element_by_xpath(\"//input[@id='passwd-id']\") 还可以通过文本去找到链接，但要小心。该文本必须完全匹配。同样需要小心使用XPATH. 如果有多个元素匹配，只有第一个会返回。如果都没有找到，则会触发NoSuchElementException异常。 WebDriver有一个\"Object-based\"API;所有类型的元素使用相同的接口。这意味着，虽然使用IDE自动补全功能会看到大量可用的方法，但是并不是所有的都可用或有效。不必担心，Webdriver 会尽量去做正确的事情，如果调用了一个没有意义的方法，会触发异常。 获取了元素之后，就可以输入文本： element.send_keys(\"some text\") 还可以通过\"Key\"类模拟使用方向键： element.send_keys(\" and some\", Keys.ARROW_DOWN) send_keys可以将键盘快捷键应用到任何元素中，例如Gmail.但有一个副作用是输入的文本区的内容不能自动清除。相反，输入的内容会追加到输入区。可以clear方法容易的清除这些内容： element.clear() 2.填写表单 前面已经说了如何在输入区输入文本，但其他元素呢？可以使用\"toggle\"下拉状态，使用\"setSelected\"进行选择框的设置。 element = driver.find_element_by_xpath(\"//select[@name='name']\" all_options = element.find_element_by_tag_name(\"option\") for option in all_options: print(\"Value is: %s\" % option.get_attribute(\"value\")) option.click() 它会找到第一个\"SELECT\"元素，并且循环打印每个选项的值，并且选中。 这不是处理SELECT元素最有效的方式。WebDriver支持一个\"Select\"类，这个类提供了处理这些的方法： from selenium.webdriver.support.ui import Select select = Select ( driver . find_element_by_name ( 'name' ) select . select_by_index ( index ) select . select_by_visible_text ( \"text\" ) select . select_by_value ( value ) WebDriver 同样提供取消所有选项的功能： select = Select(driver.find_element_by_id('id')) select.deselect_all() 这会取消页面上第一个SELECT中选项。 假设在一次测试中，我们需要所有默认选项的列表。Select类提供的方法可以返回一个列表。 select = Select(driver.find_element_by_xpath(\"xpath\") all_selected_options = select.all_selected_options 获取所有可用的选项： options = select.options 当完成表格填写后，需要提交。一种方式就是找到\"submit\"键进行点击： #Assume the button has the ID \"submit\":) driver.find_element_by_id(\"submit\").click() 另外，WebDriver有适用每个元素\"submit\"的简单方法。如果你在form中调用submit方法，webdriver会遍历DOM并调用submit，直到找到form的结束。如果元素不是一个form,就会触发NoSuchElementException异常： element.submit() 3.拖放 可用使用drag和drop，或移动元素，或移动到另一个元素： element = driver . find_element_by_name ( \"source\" ) target = driver . find_element_by_name ( \"target\" ) from selenium.webdriver import ActionChains action_chains = ActionChains ( driver ) action_chains . drag_and_drop ( element , target ) . perform () 4.窗口和框架之间移动 现在的web应用很少只有一个窗口或没有框架的。WebDriver支持使用\"switch_to_window\"方法移动不同名称的窗口： driver.switch_to_window(\"windowName\") 现在应用到driver的调用，全部解析到指定名称的窗口。但是如何获取窗口的名称呢？看下打开的javascript或链接： <a href= \"somewhere.html\" target= \"windowName\" > Click here to open a window </a> 或则，可以通过窗口句柄去使用\"switch_to_window\"方法。了解了这个，就可以像这样打开每一个遍历的窗口： for handle in driver.window_handles: driver.switch_to_window(handle) 还可以进行frame到frame的摆动（或在frame中）： driver.switch_to_frame(\"frameName\") 可以通过.路径访问子框架，或通过它的索引指定框架： driver.switch_to_frame(\"frameName.0.child\") 这样就会到达名字为frameName框架的第一个子框架的名为\"child\"的框架。如果使用from top ，所有框架都会被evaluated. 当我们操作框架时，有时我们需要从子框架返回到它的父框架： driver.switch_to_default_content() 5.弹出对话框 Selenium WebDriver内置了对弹出对话框的支持。当触发动作弹出一个对话框后，可以通过 alert访问： alert = driver.switch_to_alert() 这会返回当前打开的alert对象。获取对象后，可以接受、忽略、读取内容或输入标志等操作。该接口同样适用于警报、确认、提示等对话框。可以参阅相关ＡＰＩ了解更多内容。 6.导航：历史记录和位置 前面，我们通过\"get\"命令导航到指定网页（driver.get(\"http://www.example.com\").WebDriver有一些小的，任务聚焦的接口，并且导航也是有用的task,导航到具体网页，可以通过： driver.get(\"http://www.example.com\") 前后移动浏览器记录： driver.forward() driver.back() 注意，这些功能依赖于底层驱动。当你调用这些方法的时候，不同的浏览器可能会有不同行为。 7.Cookies 当离开这些后续步骤后，可能感兴趣的是了解如何使用cookies.首先，我们要确定当前域名的cookie是有效的： # Go to the correct domain driver.get(\"http://www.example.com\") # Now set the cookie. This one's valid for the entire domain cookie = {'name' : 'foo', 'value' : 'bar'} driver.add_cookie(cookie) # And now output all the avilable cookies for the current URL driver.get_cookies() Top &#94; 上一篇 Selenium主题2 下一篇 Selenium主题4","tags":"自动化测试-Selenium","title":"selenium-常用方法"},{"url":"http://king32783784.github.io/2015/01/17/selenium/","text":"一、等待 目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。 Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。 1.显式等待 显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver . Firefox () driver . get ( \"http://somedomain/url_that_delays_loading\" ) try : element = WebDriverWait ( driver , 10 ) . until ( EC . presence_of_element_located (( By . ID , \"myDynamicElement\" )) ) finally : driver . quit () 示例代码，默认等待１０s或则在１０s内找到元素，否则触发TimeoutException异常。默认情况下，WebDriverWait等待500ms就会触发异常，直到成功返回元素.ExpectedCondition成功的返回值是布尔值true或非空代表其他值的异常类型。 2.预期条件 以下列举了浏览器自动化测试常用的条件。Python＆selenium提供了一些便利方法，所以不必自己编写一个expected_condition类或为他们创建自己的工具包。 title_is title_contains presence_of_element_located visibility_of_element_located visibility_of presence_of_all_elements_located text_to_be_present_in_element text_to_be_present_in_element_value frame_to_be_available_and_switch_to_it invisibility_of_element_located element_to_be_clickable-it is Displayed and Enabled staleness_of element_to_be_selected element_located_to_be_selected element_selection_state_to_be element_located_selection_state_to_be alert_is_present from selenium.webdriver.support import expected_conditions as EC wait = WebDriverWait(driver, 10) element = wait.until(EC.element_to_be_clickable(By.ID, 'someid'))) 该预期条件模块包含了通过WebDriverWait实现的预期条件。 3.隐式等待 隐式等待让WebDriver试图找单个元素或多个元素失败后，在一定时间间隔下轮询DOM.默认设置为０。一旦设置，隐式等待会伴随WebDriver对象的整个生命周期。 from selenium import webdriver driver = webdriver . Firefox () driver . implicitly_wait ( 10 ) # seconds driver . get ( \"http://somedomain/url_that_delays_loading\" ) myDynamicElement = driver . find_element_by_id ( \"myDynamicElement\" ) Top &#94; 上一篇 Selenium主题4 下一篇 Selenium主题6","tags":"自动化测试-Selenium","title":"selenium-等待"},{"url":"http://king32783784.github.io/2015/02/03/selenium/","text":"expected_conditions 模块的源码分析 from selenium.common.exceptions import NoSuchElementException from selenium.common.exceptions import NoSuchFrameException from selenium.common.exceptions import StateElementReferenceException from selenium.common.exceptions import WebDriverException from selenium.common.exceptions import NoAlertPresentException 导入异常处理模块。 title_is class title_is ( object ): def __init__ ( self , title ) self . title = title def __call__ ( self , driver ) return self . title == driver . title 说明：用于检查页面的标题，title是期望的标题，必须是完全匹配，如果标题匹配则返回True，否则返回false。 用法：比如判断标题是否为\"hi | word\", title_is(\"hi | word\") title_contains class title_contains ( object ): def __init__ ( self , title ): self . title = title def __call__ ( self , driver ): return self . title in driver . title 说明：检查页面的标题是否包含指定的字符，如果包含返回True,否则返回false。 用法：判断标题是否包含\"hi\", title_is(\"hi\") presence_of_element_located class presence_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ) 说明：检查页面的DOM上是否存在指定元素。该元素并不需要是可见的。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到元素。 用法：例如判断当前页面是否存在id为\"kw\"的元素，presence_of_located((By.ID, \"kw\")) By中包含ID、XPATH、LINK_TEXT、 PARTIAL_LINK_TEXT、NAME、TAG_NAME、CLASS_NAME、CSS_SELECTOR _find_elemnt()用于查找元素，简单看一下_find_elment()方法的实现： def _find_element(driver, by) try: return driver.find_element(*by) except NoSuchElementException as e: raise e except WebDriverException as e: raise e visibility_of_element_located class visibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ) except StaleElementReferenceException: return False 说明：期望检查元素是否出现在页面的DOM上并可见。 可见性意味着元素不仅显示，而且具有大于0的高度和宽度。 locator - 用于找到元素的元组，包括找到元素的方式和值. 返回找到的元素 方法：例如判断当前页面是否存在name为\"wd\"的元素，并且该元素可视，visibility_of_element_located((By.NAME, \"wd\")) 调用_element_if_visible()方法检查元素是否存在并可视 def _element_if_visible(element, visibility=True): retrun element if element.is_displayed() == visibility else False _element_if_visible通过调用element.is_displayed()判断元素是否可视。element.is_displayed不再描述，以后的文章会再着重说明。 visibility_of class visibility_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return _element_if_visible ( self , element ) 说明：该类和visibility_of_element_located类似，不同的地方是该类直接传入要判断的元素。 如果存在返回True,如果不存在返回False presence_of_all_elements_located(object): def __init__(sel, locator): self.locator = locator def __call__(self, driver): retrun _find_elments(driver, self.locator) 说明：该类和presence_of_element_located类似。该类检查页面是否存在至少一个符合要求的元素，返回符合要求的列表。 visibility_of_any_elements_located(object): class visibility_of_any_elements_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): retrun [ element for element in _find_elements ( driver , self . locator ) if _element_if_visible ( element )] 说明：期望页面中至少出现一个符合条件的元素。符合定位方式并且可视。 方法：方法同 visibility_of_element_located 简单看一下_find_elements()和_find_element()类似 def _find_elements(driver, by): try: return driver.find_elements(*by) except WebDriverException as e: raise e text_to_be_present_in_element class text_to_be_present_in_element ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). text return self . text in element_text except StaleElementReferenceException: return False 说明： 期望检查给定的文本是否存在于指定的element.locator的text中。存在返回True,不存在返回false. 用法： 例如检查名称为\"tj_trhao123\"的元素文本中是否包含\"hao123\",((By.NAME, \"tj_trhao123\"), \"hao123\")) text_to_be_present_in_element_value class text_to_be_present_in_element_value ( object ): def __init__ ( self , locator , text_ ): self . locator = locator self . text = text_ def __call__ ( self , driver ): try: element_text = _find_element ( driver , self . locator ). get_attribute ( \"value\" ) if element_text: return self . text in element_text else: return False except StaleElementReferenceException: return False 说明： 期望检查给定文本是否存在于元素的定位器定位到元素的文本中。存在返回True，不存在返回false。 用法： 判断\"百度一下\"，是否存在于id为su的元素的\"value\"属性值中，text_to_be_present_in_element_value((By.ID, \"su\"), \"百度一下\")) 从代码中可以看到同样是通过_find_element找到元素，并且通过get_attribute获取元素值。 frame_to_be_available_and_switch_to_it class frame_to_be_available_and_switch_to_it ( object ): def __init__ ( self , locator ): self . frame_locator = locator def __call__ ( self , driver ): try: if isinstance ( self . frame_locator , tuple ): driver . switch_to . frame ( _find_element ( driver , self . frame_locator )) else: driver . switch_to . frame ( self . frame_locator ) return True except NoSuchFrameException: return False 说明：检查给定的frame是否可切换。 如果帧可用，则将给定的webdriver切换到指定的frame.如果切换成功，返回True,否则返回false。 用法：参数locator可以为定位frame的元组，也可以是frame元素。 isinstance首先判断给点的locator是否为元组（包含定位方式和对应值），如果是，先通过_find_element获取元素，然后再通过switch_to.frame切换。 简单看一下switch_to.frame的实现代码片段 @property def switch_to(self): retrun self._switch_to self._switch_to = SwitchTo(self) class SwitchTo: def frame(self, frame_reference): self._driver.execute(Command.SWITCH_TO_FRAME, {'id': frame_reference}) invisibility_of_element_located class invisibility_of_element_located ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): try: return _element_if_visible ( _find_element ( driver , self . locator ), False ) except ( NoSuchElementException , StaleElementReferenceException ): return True 说明：检查一个元素是不可见的或不存在于DOM中. 用法：传入定位元素的locator try表示元素存在，但调用_element_if_visible判断元素是否可视，传入判断的值为False,也就是如果可见则返回False. except中NoSuchElementException表示指定元素没有在DOM中。StaleElementReferenceException表示是元素状态是不可见的。 element_to_be_clickable class element_to_be_clickable ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): element = visibility_of_element_located ( self . locator )( driver ) if element and element . is_enabled (): return element else: return False 说明：检查元素是可用的，意思就是可以点击或操作的。 用法：传入locator定位元素，如果可用返回元素，如果不可用返回false. 简单看一下is_enabled, def is_enabled(self): return self.execute(Command.IS_ELEMENT_ENABLED)['value'] staleness_of class staleness_of ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): try: self . element . is_enabled () return False except StaleElementReferenceException: return True 说明：等待元素不再附着在DOM中，传入的element是要等待的元素。如果元素仍然可用，则返回false, 如果不可用则返回True. element_to_be_selected class element_to_be_selected ( object ): def __init__ ( self , element ): self . element = element def __call__ ( self , ignored ): return self . element . is_selected () 说明：检查元素的选择框是否选中。 用法：传入要验证的元素 is_selected 用于检查是否选中了复选框或单选按钮 def is_selected(self): return self._execute(Command.IS_ELEMENT_SELECTED)['value'] element_located_to_be_selected class element_located_to_be_selected ( object ): def __init__ ( self , locator ): self . locator = locator def __call__ ( self , driver ): return _find_element ( driver , self . locator ). is_selected () 说明：和element_to_be_selected类似，传入的参数不同，这个是传入locator,先定位元素再判断。 element_selection_state_to_be class element_selection_state_to_be ( object ): def __init__ ( self , element , is_selected ): self . element = element self . is_selected = is_selected def __call__ ( self , ignored ): return self . element . is_selected () == self . is_selected 说明： 给定元素和是否选中的状态（布尔值如True或False) 用法： 传入判定的元素和状态，如果和输入状态一致返回True,否则返回false。 element_located_selection_state_to_be class element_located_selection_state_to_be ( object ): def __init__ ( self , locator , is_selected ): self . locator = locator self . is_selected = is_selected def __call__ ( self , driver ): try: element = _find_element ( driver , self . locator ( return element . is_selected () == self . is_selected except StaleElementReferenceException: return false 说明：和element_selection_state_to_be类似，不同的是该类需要传入定位方法和状态。 返回值，如果和输入状态一致返回True，如果不一致返回false。另外，如果元素没找到，返回false。 alert_is_present class alert_is_present ( object ): def __init__ ( self ): pass def __call__ ( self , driver ): try: alert = driver . switch_to . alert alert . text return alert except NoAlertPresentException: return False 说明：判断是否有弹窗（一般为警告信息）。有返回alert,没有返回False.","tags":"自动化测试-Selenium","title":"selenium-expected_conditions源码分析"},{"url":"http://king32783784.github.io/2015/01/22/selenium/","text":"1.常见问题 1.1 如何使用ChromeDriver? 下载最新的chromedriver chromedriver from download page ,解压文件： unzip chromedriver_linux32_x.x.x.x.zip 解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例： driver = webdriver.Chrome(executable_path=\"/path/to/chromedriver\") 1.2 Selenium 2是否支持XPath2.0? 参考 http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0. 1.3 如何滚动到页面底部 参考 http://blog.varunin.com/2011/08/scrolling-on-pages-using-selenium.html 可以使用execute_script方法执行加载页面中的javascript.因此，可以调用JavaScript API滚动只页面底部或任意位置。 这里给出一个滚动到页面底部的例子： driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\") window DOM对象中有 scrollTo 方法可以滚动到打开窗口的任意位置。 scrollHeight 是所有元素的公共部分。document.body.scrollHeight会提供页面的整个高度。 1.4 Firefox profile如何自动保存文件？ 参考： http://stackoverflow.com/questions/1176348/access-to-file-download-dialog-in-firefox 参考： http://blog.codecentric.de/en/2010/07/file-downloads-with-selenium-mission-impossible/ 第一步要确定要保存文件的类型 要确定自动下载的内容类型，可以使用 curl curl -I URL | grep \"Content -Type\" 另一种方式是通过 requests 模块去找到文本类型，可以像这样： import requests content_type = requests . head ( 'http://www.python.org' ) . headers [ 'content-type' ] print ( content_type ) 当content类型被识别后，可以用来进行firefox的偏好设置： browser.helperApps.neverAsk.saveToDisk 示例如下： import os from selenium import webdriver fp = webdriver . FirefoxProfile () fp . set_preference ( \"browser.download.folerList\" , 2 ) fp . set_preference ( \"browser.download.manager.showWhenStarting\" , False ) fp . set_preference ( \"browser.download.dir\" , os . getcwd ()) fp . set_preference ( \"browser.helperApps.nerverAsk.saveToDisk\" , \"application/octet-stream\" ) browser = webdriver . Firefox ( firefox_profile = fp ) browser . get ( \"http://pypi.python.org/pypi/selenium\" ) browser . find_element_by_partial_link_text ( \"selenium-2\" ) . click () 在上面的例子中， application / octet - stream 用作 content 类型。 browser . download . dir 选项指定需要下载文件的目录。 1.5 如何上传文件到文件输入？ 选择 元素并调用send_keys()方法传递路径，相对test scipt的相对路径，或绝对路径。注意Windows和unix系统直接路径的差异性。 1.6 如何使用Firefox中的firebug？ 首先下载Firebug XPI文件，然后调用add_extension方法进行firefox profile: from selenium import webdriver fp = webdriver . FirefoxProfile () fp . add_extension ( extension = 'firebug-1.8.4.xpi' ) fp . get_preference ( \"extensions.firebug.currentVersion\" , \"1.8.4\" ) #Avoid startup screen browser = webdriver . Firefox ( firefox_profile = fp ) 1.7 如何获取当前窗口的截屏 使用webdriver提供的save_screenshot方法获取。 from selenium import webdriver driver = webdriver . Firefox () driver . get ( 'http://www.python.org/' ) driver . save_screenshot ( 'screenshot.png' ) driver . quit () Top &#94; 上一篇 Selenium主题9 下一篇 selenium-Sample(一)","tags":"自动化测试-Selenium","title":"selenium-常见问题"},{"url":"http://king32783784.github.io/2015/01/25/selenium/","text":"示例５ 拖放drag和drop 代码： # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.webdriver.support.ui import Select from selenium.webdriver.common.keys import Keys # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) element = self . driver . find_element_by_id ( \"forgot_link_bottom\" ) target = self . driver . find_element_by_xpath ( \"//*[@id='quicksearch_main']\" ) action_chains = ActionChains ( self . driver ) action_chains . drag_and_drop ( element , target ) . perform () actions = ActionChains ( self . driver ) elem = self . driver . find_element_by_id ( \"find\" ) actions . move_to_element ( elem ) actions . click ( elem ) actions . perform () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 说明： element = self.driver.find_element_by_id(\"forgot_link_bottom\") ＃获取源元素 target = self.driver.find_element_by_xpath(\"//*[@id='quicksearch_main']\") #获取移动到的元素 action_chains = ActionChains(self.driver) action_chains.drag_and_drop(element, target).perform() #执行拖放 示例6 弹出对话框示例 代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/bin/bash/env python # -*- coding: utf-8 -*- import time import os from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class Testdrog_drop ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"find\" ) . click () time . sleep ( 10 ) alert = self . driver . switch_to_alert () #获取警告对话框 alert . accept () ＃确定警告对话框 self . driver . close () if __name__ == '__main__' : testdrop = Testdrog_drop () testdrop . getpage () 示例７ 历史记录和位置示例 代码 #!/bin/bash/env python # - - coding: utf-8 - - import time from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains # bugzilla address url = \"http://192.168.32.3/\" class TestHistory ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getpage ( self ): self . driver . get ( url ) self . driver . find_element_by_id ( \"enter_bug\" ) . click () time . sleep ( 3 ) def testhistory ( self ): self . getpage () self . driver . back () time . sleep ( 3 ) self . driver . forward () if __name__ == \"__main__\" : testhistory = TestHistory () testhistory . testhistory () 说明： self.driver.back()和self.driver.forward() 实现了页面的返回和前进。 示例８ Cookies添加 代码： #!/bin/bash/env python # - coding: utf-8 - from selenium import webdriver class TestCookie ( object ): def __init__ ( self ): self . driver = webdriver . Firefox () def getcookie ( self ): self . driver . get ( \"http://www.baidu.com\" ) cookieslist = self . driver . get_cookies () print ( cookieslist ) def addcookie ( self ): self . getcookie () cookie = { 'name' : 'test01' , 'value' : 'test02' } self . driver . add_cookie ( cookie ) cookieslist = self . driver . get_cookies () print ( cookieslist ) self . driver . close () if __name__ == \"__main__\" : testcookie = TestCookie () testcookie . addcookie () 说明： cookie格式为字典包括\"name\"和\"value\"两个键值对。add_cookie方法将cookie添加到cookies中。 上一篇 selenium-Sample(二) 下一篇 selenium-Sample(四)","tags":"自动化测试-Selenium","title":"selenium-Sample(三）"},{"url":"http://king32783784.github.io/2016/11/01/自动化测试/","text":"Avocado 用户指南 内容： 关于Avocado 入门 安装Avocado 使用Avocado 写一个简单测试 运行一个较复杂的测试 第一个测试失败时中断测试job 结合外部runner运行测试 测试调试 编写Avocado测试 基本例子 保存测试生成的数据（自定义） 访问测试参数 使用multplex文件 高级日志功能 unittest.TestCase 继承 Setup和cleanup方法 运行第三方测试集 获取资源文件 测试输出检查和输出记录模式 Avocado Testlog，stdout和stderr模块 独立进程中运行Avocado测试 设置测试超时 测试标签 Python unitest 兼容测试和警告 简单测试的环境变量 简单测试的BASH扩展 Wrap up 结果格式 人性化测试结果 机器可读的结果 一次多种结果 Exit Codes 实现其他结果格式 配置 配置文件的解析顺序 插件设置文件 解析订单概述 测试中使用值的优先级 设置插件 Avocado数据目录 测试发现 测试载入的顺序 日志系统 UI调整 存储用户日志 分页器 测试变种－Mux Mux内部 Mux API 节点 键和值 变体 分辨顺序 插入文件 复合文件 高级YAML标记 !include !using !remove_node !remove_value !mux 完整示例 Job重放 Job对比 运行远程测试 远程Host运行测试 虚拟机上运行测试 Docker容器上运行测试 环境变量 使用GDB调试 透明执行可执行文件 avocado.uitls.gdb APIs 封装测试执行文件 用法 警告 插件系统 插件列表 制作插件 高级主题和维护 参考指南 job,test和identifiers 测试类型 测试状态 库和APIs 测试解析 结果规格 job前后脚本 job清理 Avocado 开发tips 中断测试 In tree utils Line-profiler 使用Eclipse远程debug 在Eclipase中使用Trello avocado发布 删除版本号 应当注意哪些项目库 所有库的标记 构建rpms 包命名 上传包到仓库 书写发行注记 发送电子邮件到avocado-devel和其他地方 API参考 测试APIs 工具APIs 内部(核心)APIs 外部(插件)APIs Avocado 发行注记 发行注记 关于Avocado Avocado 是一套帮助自动化测试工具和库。 可以把它称作为测试框架。内部测试是通过python编写的，并且遵从unittest模式，但是它也可以将执行任何外部可执行文件作为测试。 组成部分： 一个可以引导执行测试的Test runner。这些测试可以是选择任意语言编写的测试，或则通过python编写，并使用可用的库。这两种情况，你都可以获取自动日志和系统信息收集功能。 提供一个帮助你通过一种concise,yet expressive 和 powerful的方式编写测试。你可以通过后面 库和API 章节了解更多这方面的信息。 插件，可以扩展和增加框架的功能 Avocado尽可能尝试遵守标准的Python测试技术。 使用Avocado API编写的测试是从unittest类派生，而添加了适合于功能和性能测试的其他方法。 测试运行器旨在帮助人们运行测试，同时提供各种系统和日志记录工具。 接下来的专题，会按照本文的目录详细介绍Avocado Top &#94; 下一篇 Avocado-入门","tags":"自动化测试-Avocado","title":"Avocado User's Guide"},{"url":"http://king32783784.github.io/2016/11/12/自动化测试/","text":"编写Avocado测试 现在我们开始使用python编写Avocado测试，测试继承于avocado.Test. 基本例子 创建一个时间测试，sleeptest,测试非常简单，只是sleep一会： import time from avocado import Test class SleepTest ( Test ): def test ( self ): sleep_length = self . params . get ( 'sleep_length' , default = 1 ) self . log . debug ( \"Sleep for %.2f seconds\" , sleep_length ) time sleep ( sleep_length ) 这是为avocado编写的一个简单示例，可以使用其他power API编写。 从上面的例子可以看出，avocado测试从avocado.Test继承的test方法入手。 多个测试和命名约定 可以在一个类中存在多个测试。 要想做多个测试，只需要在命名方法前加test,例如test_foo,test_bar等。建议遵守这个命名风格，就像 PEP8 Function Names . 对于class名称，可以任意命名，当最好还是遵从CamelCase命名，参考PEP8 中 Class Names 方便属性 测试类提供了一定数量的方便属性： 为测试添加测试log,可以使用self.log.可以定义log debug,info,error和warning信息。 参数解析系统，可以访问self.parms使用。可以在后面的Test variants - Mux文章查看更多信息。 保存生成的数据 每个测试都提供一个所谓的whiteboard,可以通过self.whiteboard访问。Witeboard是一个可以自动保存到测试结果（可以支持的output格式）字符串。你同样可以选择保存二进制数据到whiteboard,但你需要先进行编码转换（base64). 基于上面的sleeptest，假设想保存sleep_length用于其他脚本或数据分析工具： def test(self): sleep_length = self.params.get('sleep_length', default=1) self.log.debug(\"Sleeping for %.2f second\", sleep_length) time.sleep(sleep_length) slef.writeboard = \"%.2f\" % sleep_length whiteboard可以并应当接收由可用的测试结果插件生成的文件。Result.json文件已经为每个测试包含了whiteboard.此外，会用一个命名为whiteboard的文件保存和results.json相同级别的信息（也许你想使用与你定制的脚本配套的结果处理工具，该文件会保存白板内容的原始副本）。 访问测试参数 每个测试都有一组可以通过self.params.get($name, $path=None, $default=None)访问的参数.Avocado会从Multiplex 配置文件中发现所有参数并填充到self.params.比如上面的例子，sleeptest的multiplex文件： sleeptest : type : \"builtin\" length : ! Mux short : sleep_length : 0.5 medium : sleep_length : 1 long : sleep_length : 5 当我们用avocado run $test --mux-yaml $file.yaml运行这个例子，3个variants会执行并且内容会插入/run的命名空间。每个variant包含变量的\"type\"和\"sleep_length\"。要获取有效值，需要名称（\"sleep_length)和path。需要选择路径 ,在这个例子：/run/sleeptest/length/ 或sleeptest/ ,取决于如何设置。 默认的参数是可选的，但是要处理好这部分。可能有人运行你的测试时选择不同的参数或没有参数，它仍然能够很好的运行。 所以关于如何访问\"sleep_length\"的完整示例： self.params.get(\"sleep_length\", \"/*/sleeptest/*\", 1) 还有一种更简单的方式。它用于定义解析顺序，简单的查询可以简单的指定路径： self.params.get(\"sleep_length\", None, 1) self.params.get(\"sleep_length\", '*', 1) self.params.get(\"sleep_length\", default=1) 应该避免参数冲突（不同的匹配值应该指定不同的路径）。如果不能这样（例如使用复合yaml文件）可以通过 --mux-path进行默认路径的修改。它将对参数和操作通过路径进行一个接一个的切片。当第一个切片匹配后会返回，不再尝试其他切片。虽然相对查询只匹配来自--mux-path的切片。 有很多方式使用paths分离存在冲突的params或只是使查询更清晰。通常tests中使用\"*\"就足够了，namespacing不是必须的，但是有助于高级用法更清晰简单。 关于路径的考虑基本是从用户角度。更多信息参考 The variants-Mux 使用multplex文件 Ａvocado可以使用multplex文件提供params和生成generation来运行sleeptest: $ avocado run sleeptest.py --mux-yaml examples/tests/sleeptest.py.date/sleeptest.yaml JOB ID : d565e8dec576d6040f894841f32a836c751f968f JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.44-d565e8de/job.log TESTS : 3 ( 1/3 ) sleeptest.py:SleepTest.test ; 1: PASS ( 0.50 s ) ( 2/3 ) sleeptest.py:SleepTest.test ; 2: PASS ( 1.00 s ) ( 3/3 ) sleeptest.py:SleepTest.test ; 3: PASS ( 5.00 s ) RESULTS : PASS 3 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 6.50 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.44-d565e8de/html/results.html The --mux-yaml accepts either only \\(FILE_LOCATION or $INJECT_TO:\\) FILE_LOCATION. As explained in Test variants - Mux without any path the content gets injected into /run in order to be in the default relative path location. The \\(INJECT_TO can be either relative path, then it's injected into /run/\\) INJECT_TO location, or absolute path (starting with '/'), then it's injected directly into the specified path and it's up to the test/framework developer to get the value from this location (using path or adding the path to mux-path). To understand the difference execute those commands: $ avocado multiplex -t -m examples/tests/sleeptest.py.data/sleeptest.yaml $ avocado multiplex -t -m duration:examples/tests/sleeptest.py.data/sleeptest.yaml $ avocado multiplex -t -m /my/location:examples/tests/sleeptest.pt.data/sleeptest.yaml 注意，因为multiplex文件为sleeptest指定了所有参数，所以不能将ID留空： $ scripts/avocado run --mux-yaml examples/tests/sleeptest/sleeptest.yaml Empty test ID. A test path or alias must be provided 可以使用同一个multiplex文件启动多个测试： $avocado run sleeptest . py synctest . py -- mux-yaml examples/tests/sleeptest . py . data/sleeptest . yaml JOB ID : cd20fc8d1714da6d4791c19322374686da68c45c JOB LOG : $HOME/avocado/job-results/job-2016-05-04T09 . 25 - cd20fc8/job . log TESTS : 8 ( 1 / 8 ) sleeptest . py : SleepTest . test;1 : PASS ( 0.50 s ) ( 2 / 8 ) sleeptest . py : SleepTest . test;2 : PASS ( 1.00 s ) ( 3 / 8 ) sleeptest . py : SleepTest . test;3 : PASS ( 5.01 s ) ( 4 / 8 ) sleeptest . py : SleepTest . test;4 : PASS ( 10.00 s ) ( 5 / 8 ) synctest . py : SyncTest . test;1 : PASS ( 2.38 s ) ( 6 / 8 ) synctest . py : SyncTest . test;2 : PASS ( 2.47 s ) ( 7 / 8 ) synctest . py : SyncTest . test;3 : PASS ( 2.46 s ) ( 8 / 8 ) synctest . py : SyncTest . test;4 : PASS ( 2.45 s ) RESULTS : PASS 8 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 26.26 s JOB HTML : $HOME/avocado/job-results/job-2016-05-04T09 . 25 - cd20fc8/html/results . html 高级日志功能 Avocado 在测试的同时提供高级日志功能。这些可以和标准python API库组合。 一个常见的例子是需要在更长或更复杂的测试中遵循具体的进展。 让我们看一个非常简单的测试示例，但在单个测试中有一个多个明确的阶段： import logging import time from avocado import Test progress_log = logging . getLogger ( \"progress\" class Plant ( Test ): def test_plant_organic ( self ): rows = self . params . get ( \"rows\" , default = 3 ) #Preparing soil for row in range ( rows ): progress_log . info ( \" %s : Preparing soil on row %s \" , self . name , row ) # Letting soil rest progress_log . info ( \" %s : letting soil rest before throwing seeds\" , self . name ) time . sleep ( 2 ) # Throwing seeds for row in range ( rows ): progress_log . info ( \" %s : throwing seeds on row %s \" , self . name , row ) # Let them grow progress_log . info ( \" %s : waiting for Avocados to grow\" , self . name ) time . sleep ( 5 ) # Harvest them for row in range ( rows ): progress_log . info ( \" %s : harvesting organic avocados on row %s \" , self . name , row ) 这时，可以请求avocaod显示你的日志流，独占或则加入其他内建流： $ avocado --show app, progress run plant.py 结果类似于： JOB ID : af786f86db530bff26cd6a92c36e99bedcdca95b JOB LOG : / home/cleber/avocado/job-results/job-2016-03-18T10 . 29 - af786f8/job . log TESTS : 1 ( 1 / 1 ) plant . py : Plant . test_plant_organic : progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 0 progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 1 progress : 1 - plant . py : Plant . test_plant_organic : preparing soil on row 2 progress : 1 - plant . py : Plant . test_plant_organic : letting soil rest before throwing seeds - progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 0 progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 1 progress : 1 - plant . py : Plant . test_plant_organic : throwing seeds on row 2 progress : 1 - plant . py : Plant . test_plant_organic : waiting for Avocados to grow \\progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 0 progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 1 progress : 1 - plant . py : Plant . test_plant_organic : harvesting organic avocados on row 2 PASS ( 7.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 7.01 s JOB HTML : / home/cleber/avocado/job-results/job-2016-03-18T10 . 29 - af786f8/html/results . html 自定义的progress流和app输出混合在一起，可能不太适合。如果想让progress流输入到一个独立文件，这样会清晰。 $ avocado run plant.py --store-loggin-stream progress 这样，除了所有其他日志文件通常生成，会有另一个名为日志文件progress.INFO在作业结果目录。 在测试运行期间，可以观察进度： $ tail -f ~/avocado/job-results/latest/progress.INFO 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 0 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 1 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: preparing soil on row 2 10:36:59 INFO | 1-plant.py:Plant.test_plant_organic: letting soil rest before throwing seeds 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 0 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 1 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: throwing seeds on row 2 10:37:01 INFO | 1-plant.py:Plant.test_plant_organic: waiting for Avocados to grow 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 0 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 1 10:37:06 INFO | 1-plant.py:Plant.test_plant_organic: harvesting organic avocados on row 2 同一个progress日志记录器，可以在多个测试方法和在多个测试模块一起使用。 在给出的示例中，测试名称用于给出额外的上下文。 <未完待续> if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"自动化测试-Avocado","title":"Avocado-编写Avocado测试"},{"url":"http://king32783784.github.io/2016/11/03/自动化测试/","text":"1.Avocado 安装 1.1 通过包安装 像 Fedora 可以通过rpm包进行安装，其他通过RPM管理的发行版需要自己制作相关包。Avocado同样支持DEP包的安装可以在contrib/packages/debian找到。 Fedora 首先通过下面的命令获取仓库配置文件。 sudo curl https://repos-avocadoproject.rhcloud.com/static/avocado-fedora.repo -o /etc/yum.repos.d/avocado.repo 检查是否有了Avocodo和Avocado-lts的仓库配置： sudo dnf repolist avocado avocado-lts ... repo id repo name status avocado Avocado 50 avocado-lts Avocado LTS (Long Term Stability) disabled Avocao了解更多的LTS信息，参考 Avocado Long Term Stability 接下来，可以进行avocado安装啦： sudo dnf install avocado 另外还有两个包需要安装： avocado-examples: 包含测试例子和示例文件 avocado-plugins-output-html: HTML job 报告的插件 RHEL7 如果要运行在红帽商业版或CentOS上，需要进行下面设置： # If not already, enable epel (for RHEL7 it's following cmd) sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm # Add avocado repository and install avocado sudo curl https://repos-avocadoproject.rhcloud.com/static/avocado-el.repo -o /etc/yum.repos.d/avocado.repo sudo yum install avocado 同fedora一样，需要安装以下包： avocado-examples: 包含测试例子和示例文件 avocado-plugins-output-html: HTML job 报告的插件 OpenSUSE Avocado同样支持，执行运行以下命令即可： sudo zypper install avocado 1.2 源码安装 首先确保系统有基本的编译环境，如fedora： sudo yum install -y git gcc python-devel python-pip libvirt-devel libyaml-devel redhat-rpm-config xz-devel 然后，获取源码： git clone git://github.com/avocado-framework/avocado.git cd avocado sudo make requirements sudo python setup.py install 注意，python和pip需要2.7.x版本。如果安装出现问题，需要指明python2.7 和 pip2.7. Avocodo可能需要一些插件： cd optional_plugins/html sudo python setup.py install 安装python依赖工具 avocado可以通过pip安装。 pip install avocado-framework 注意：只有基本的avocado基本的test runner安装，导入插件时可能会失败，需要根据不同的系统安装不同的依赖。 如果想安装全部插件，需要执行以下命令： pip install -r https://raw.githubusercontent.com/avocado-framework/avocado/master/requirements.txt 2. Avocado使用 首先 要使用命令行工具test runner,用来运行你的测试和收集测试结果。 2.1 运行测试 可以运行avocado加 run子命令，后面跟一个测试，例如： $ avocado run /bin/true JOB ID : 381b849a62784228d2fd208d929cc49f310412dc JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.39-381b849a/job.log TESTS : 1 ( 1/1 ) /bin/true: PASS ( 0.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 0 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.01 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.39-381b849a/html/results.html 可以看到，我们把/bin/true作为一个测试运行，并记录了测试过程。这是一个简单的例子，这是支持测试的一种类型。 Test Types 了解更多的测试类型。 注意： 尽管可以通过 avocao run \\(test1 $test3... 运行多个测试，但可以导致崩溃。一个安全的方式为： avocodo run --\\) argument1 --$argument2 -- $test1 $test2. 后面所有内容都会当做位置参数。 2.2 列出测试项 有两种方式覆盖这些测试。可以通过--dry-run 参数模拟： avocado run / bin/true -- dry-run JOB ID : 0000000000000000000000000000000000000000 JOB LOG : / tmp/avocado-dry-runSeWniM/job-2015-10-16T15 . 46 - 0000000 / job . log TESTS : 1 ( 1 / 1 ) / bin/true : SKIP RESULTS : PASS 0 | ERROR 0 | FAIL 0 | SKIP 1 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.00 s JOB HTML : / tmp/avocado-dry-runSeWniM/job-2015-10-16T15 . 46 - 0000000 / html/results . html 另一个方式是使用list参数列出支持的测试参数。如： $ avocado list INSTRUMENTED /usr/share/avocado/tests/abort.py INSTRUMENTED /usr/share/avocado/tests/datadir.py INSTRUMENTED /usr/share/avocado/tests/doublefail.py INSTRUMENTED /usr/share/avocado/tests/doublefree.py INSTRUMENTED /usr/share/avocado/tests/errortest.py INSTRUMENTED /usr/share/avocado/tests/failtest.py INSTRUMENTED /usr/share/avocado/tests/fiotest.py INSTRUMENTED /usr/share/avocado/tests/gdbtest.py INSTRUMENTED /usr/share/avocado/tests/gendata.py INSTRUMENTED /usr/share/avocado/tests/linuxbuild.py INSTRUMENTED /usr/share/avocado/tests/multiplextest.py INSTRUMENTED /usr/share/avocado/tests/passtest.py INSTRUMENTED /usr/share/avocado/tests/sleeptenmin.py INSTRUMENTED /usr/share/avocado/tests/sleeptest.py INSTRUMENTED /usr/share/avocado/tests/synctest.py INSTRUMENTED /usr/share/avocado/tests/timeouttest.py INSTRUMENTED /usr/share/avocado/tests/trinity.py INSTRUMENTED /usr/share/avocado/tests/warntest.py INSTRUMENTED /usr/share/avocado/tests/whiteboard.py ... 这些测试文件被Avocodo视为包含在INSTRUMENTED测试。 我们可以只列出可执行shell脚本： $ avocado list | grep &#94;SIMPLE SIMPLE /usr/share/avocado/tests/env_variables.sh SIMPLE /usr/share/avocado/tests/output_check.sh SIMPLE /usr/share/avocado/tests/simplewarning.sh SIMPLE /usr/share/avocado/tests/failtest.sh SIMPLE /usr/share/avocado/tests/passtest.sh 如前面说的那样，SIMPLE表示这些文件是一些简单的可执行的测试。 可以通过--verbose 或 -V,列出avocado中不是测试的文件。 $ avocado list examples/gdb-prerun-scripts/ -V Type file NOT_A_TEST examples/gdb-prerun-scripts/README NOT_A_TEST examples/gdb-prerun-scripts/pass-sigusr1 SIMPLE: 0 INSTRUMENTED: 0 MISSING: 0 NOT_A_TEST: 2 3.编写一个简单的测试 下面是一个 simple 测试的简单示例： $ echo '#!/bin/bash' > /tmp/simple_test.sh $ echo 'exit 0 ' >> /tmp/simple_test.sh $ chmod +x /tmp/simple_test.sh 注意，我们给这个文件增加了执行权限，它会被avocado当做一个simple test. 4.运行一个较复杂的测试 你 可以以任意顺序执行任意数量的测试，而且可以混合不同类型的测试： $ avocado run failtest.py sleeptest.py synctest.py failtest.py synctest.py /tmp/simple_test.sh JOB ID : 86911e49b5f2c36caeea41307cee4fecdcdfa121 JOB LOG : $HOME /avocado/job-results/job-2014-08-12T15.42-86911e49/job.log TESTS : 6 ( 1/6 ) failtest.py:FailTest.test: FAIL ( 0.00 s ) ( 2/6 ) sleeptest.py:SleepTest.test: PASS ( 1.00 s ) ( 3/6 ) synctest.py:SyncTest.test: PASS ( 2.43 s ) ( 4/6 ) failtest.py:FailTest.test: FAIL ( 0.00 s ) ( 5/6 ) synctest.py:SyncTest.test: PASS ( 2.44 s ) ( 6/6 ) /bin/true: PASS ( 0.00 s ) ( 6/6 ) /tmp/simple_test.sh.1: PASS ( 0.02 s ) RESULTS : PASS 2 | ERROR 2 | FAIL 2 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 5.88 s JOB HTML : $HOME /avocado/job-results/job-2014-08-12T15.42-86911e49/html/results.html 5.出现fail后中断测试 Avocado run 命令包含 --failfast on 参数，当出现错误是会退出测试： $ avocado run --failfast on /bin/true /bin/false /bin/true /bin/true JOB ID : eaf51b8c7d6be966bdf5562c9611b1ec2db3f68a JOB LOG : $HOME /avocado/job-results/job-2016-07-19T09.43-eaf51b8/job.log TESTS : 4 ( 1/4 ) /bin/true: PASS ( 0.01 s ) ( 2/4 ) /bin/false: FAIL ( 0.01 s ) Interrupting job ( failfast ) . RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 2 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.02 s JOB HTML : /home/apahim/avocado/job-results/job-2016-07-19T09.43-eaf51b8/html/results.html 6.通过外部Runner 运行测试 大 部软件都存在自己的测试集。通常包括一个定制的runner,它可以找到并运行自己的测试。 Avocado能支持运行这些测试，而且可以支持生成不同格式的结果，收集系统信息以及这些测试（Avocado的sysinfo功能）等等。 大部分方式如下： $ avocado run --external -runner=/path/to/external_runner foo bar baz 这个例子，avocado会产生foo bar baz的测试结果。实际结果将来源于执行 /path/to/external_runner foo /path/to/external_runner bar和/path/to/external_runner baz 另一种方式展示这一特性，就是思考\"外部runner\"可以是解释器和可以解释执行任何测试。UNIXshell,/bin/sh就可以被当做外部执行引擎，而且shell脚本就可以当成它的测试： $ echo \"exit 0\" > /tmp/pass $ echo \"exit 1\" > /tmp/fail $ avocado run --external-runner = /bin/sh /tmp/pass /tmp/fail JOB ID : 4a2a1d259690cc7b226e33facdde4f628ab30741 JOB LOG : /home/<user>/avocado/job-results/job-<date>-<shortid>/job.log TESTS : 2 ( 1/2 ) /tmp/pass: PASS ( 0.01 s ) ( 2/2 ) /tmp/fail: FAIL ( 0.01 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 0.01 s JOB HTML : /home/<user>/avocado/job-results/job-<date>-<shortid>/html/results.html 这个例子很明显，可以通过给/tmp/pass和/tmp/fail ，shell\"shebangs\"（＃！/ bin / sh）来实现，使它们可执行（chmod + x / tmp / pass / tmp / ，并将其作为\"简单\"测试运行。 下面看另一个例子： $ avocado run --external-runner = /bin/curl http://local-avocado-server:9405/jobs/ \\ http://remote-avocado-server:9405/jobs/ JOB ID : 56016a1ffffaba02492fdbd5662ac0b958f51e11 JOB LOG : /home/<user>/avocado/job-results/job-<date>-<shortid>/job.log TESTS : 2 ( 1/2 ) http://local-avocado-server:9405/jobs/: PASS ( 0.02 s ) ( 2/2 ) http://remote-avocado-server:9405/jobs/: FAIL ( 3.02 s ) RESULTS : PASS 1 | ERROR 0 | FAIL 1 | SKIP 0 | WARN 0 | INTERRUPT 0 TESTS TIME : 3.04 s JOB HTML : /home/<user>/avocado/job-results/job-<date>-<shortid>/html/results.html 这个例子是把\"/bin/curl\"当做\"external test runner\". 7. 测试调试 当 开发一个新的测试时，经常做的就是查看一个测试job的运行日志。 为了实现这个目的， 可以通过 avocado --show test run ... 或 avocado run --show-job-log ... 例如： $ avocado --show test run examples/tests/sleeptest.py ... Job ID: f9ea1742134e5352dec82335af584d1f151d4b85 START 1-sleeptest.py:SleepTest.test PARAMS (key=timeout, path=*, default=None) => None PARAMS (key=sleep_length, path=*, default=1) => 1 Sleeping for 1.00 seconds PASS 1-sleeptest.py:SleepTest.test Test results available in $ HOME /avocado/job-results/job-2015-06-02T10.45-f9ea174 UI输出被抑制，只显示作业日志，这使得它成为测试开发和调试的有用功能。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"自动化测试-Avocado","title":"Avocado-入门"},{"url":"http://king32783784.github.io/2014/09/15/linux/","text":"SPECJVM2008使用方法 1.工具介绍 SPECjvm2008 （Java Virtual Machine Benchmark）是一个评估JRE运行性能的基准测试套件。包含几个现实生活中的应用和专注于核心java功能的基准的测量基准套件。该套件侧重于JRE执行一个单一的应用程序；它反映了硬件处理器和内存子系统的性能，与文件系统I/O和网络I/O关系不大。SPECjvm2008负载模仿各种常见用途的应用计算。这些特征反映了这一基准适用于测量基本 Java 性能上种类繁多的客户端和服务器系统。 套件包含21个基准测试，其中每个基准测试均包含一个2分钟的热身测试和4分钟的正式测试。由于测试过程中程序并不中断基准测试的执行，所以测试时间至少为126分钟，根据Java性能的不同，测试时间会有所不同。关于21个基准测试的具体内容将在文档最后进行介绍。 官网： http://www.spec.org/jvm2008/ 2工具安装 2.1下载 下载SPECjvm2008测试套件： #wget ftp://ftp.spec.org/dist/osg/java/SPECjvm2008_1_01_setup.jar 2.2安装 #java -jar SPECjvm2008_1_01_setup.jar -i console 选择默认的内容进行安装，直至完成。默认的安装路径会是/SPECjvm2008 2.3调试 在/etc/profile中加入环境变量 JAVA_HOME=/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/ CLASSPATH=.： $ JAVA_HOME /lib/tools.jar：/lib.dt.jar PATH= $ JAVA_HOME /bin： $ PATH export JAVA_HOME CLASSPATH PATH 保存后，执行 source /etc/profile即可。 安装目录下有一个脚本，linux对应的是run-specjvm.sh，windows对应的是 run-specjvm.cmd 执行如下命令，用以测试安装或环境是否ok ./run-specjvm.sh startup.helloworld -ikv startup.helloworld 是测试helloworld程序的启动时间，选择这个测试用例是考虑到运行速度比较快。 -ikv的意思是跳过签名检查，那个过程有点慢。 2.4 配置 默认情况，我们只需要修改安装目录下 props/specjvm.properties 和 props/specjvm.reporter.properites 这两个配置文件就行了。 specjvm.properties主要负责对整个套件的运行进行调整。比如，指定需要运行的测试用例，测试迭代次数，每个用例跑完是否要GC等。 specjvm.reporter.properites主要用来丰富报表输出内容，一般是一些无法通过自动检测得到的环境信息。比如，主机的内存型号，cpu逻辑个数，主板提供商等。 官方对specjvm.properties的内容是遵循COC原则设计的。所以，我们只需要修改特定的参数就可以了。 下面是我测试时修改的一些参数。 specjvm.additional.properties.file=props/specjvm.reporter.properties // 指定报表配置文件路径 specjvm.benchmark.analyzer.names=HeapMemoryFreeAnalyzer HeapMemoryTotalAnalyzer // heap分析器 specjvm.home.dir=/home/admin/SPECjvm2008 // SPEC_HOME路径 specjvm.iteration.time=240s // 迭代时长 specjvm.startup.jvm_options=-Xms1024m -Xmx1024m -XX:+UseConcMarkSweepGC // JVM switches specjvm.reporter.properties这个配置文件就不多做介绍了，你甚至可以不做任何修改。 3 工具使用说明 3.1 命令及参数说明 通常的命令执行格式 java [<jvm options>] -jar SPECjvm2008.jar [<SPECjvm2008 options>] [<benchmark name> ...] 可用参数查询：java -jar SPECjvm2008.jar --help Arg Long arg Value Property name Description -h --help Show this help. --version Print SPECjvm2008 version and exit. -sv --showversion Print SPECjvm2008 version and continue. --base Run the base compliant run of SPECjvm2008 (default, unless jvm args are specified). --peak Run the peak compliant run of SPECjvm2008. --lagom Run the Lagom benchmark suite, a version, of SPECjvm2008 that uses a fixed workload. -pf --propfile string specjvm.propfile Use this properties file. -i --iterations int specjvm.miniter, specjvm.maxniter How many iterations to run. 'inf' means an infinite number. -mi --miniter int specjvm.miniter Minimum number of iterations. -ma --maxiter int specjvm.maxniter Maximum number of iterations. -it --iterationtime time specjvm.iteration.time How long one iteration should be. The time is specified as an integer, and assumed to be in seconds, or an integer with unit, for example 4m (4 minutes). Units available are ms, s, m and h. If the iteration time is too short, based on the warmup result, it will be adjusted to expect to finish at least 5 operations. -fit --forceIterationIime time specjvm.iteration.time, specjvm.iteration.time.forced As iteration time, but the time will not be adjusted based on the warmup result. -ja --jvmArgs string specjvm.startup.jvm_options JVM options used for startup subtests. -jl --jvmLauncher path specjvm.benchmark.startup.launcher JVM launcher used for startup subtests. -wt --warmuptime time specjvm.benchmark.warmup.time How long warmup time. The time format is the same as in iteration time. -ops --operations int specjvm.fixed.operations, specjvm.run.type How many operations each iteration will consist of. It will then be a fixed workload and iteration time is ignored. -bt --benchmarkThreads int specjvm.benchmark.threads How many benchmark threads to use. -r --reporter raw file name Invokes the reporter with given file(s). The benchmarks will not be run. -v --verbose specjvm.print.verbose, specjvm.print.progress Print verbose info (harness only). -pja --parseJvmArgs Parse jvm arguments info from command line, including heap settings (uses JMXBean info). This is not done by default. -coe --continueOnError specjvm.continue.on.error Continue to run suite, even if one test fails. -ict --ignoreCheckTest specjvm.run.initial.check Do not run check benchmark. -ikv --ignoreKitValidation specjvm.run.checksum.validation Do not run checksum validition of benchmark kit. -crf --createRawFile boolean specjvm.create.xml.report Whether to generate a raw file. -ctf --createTextFile boolean specjvm.create.txt.report Whether to generate text report. If raw is disabled, so is txt. -chf --createHtmlFile boolean specjvm.create.html.report Whether to generate html report. If raw is disabled, so is html. -xd --xmlDir path specjvm.benchmark.xml.validation.input.dir To set path to xml input files <benchmark(s)> specjvm.benchmarks Name of benchmark(s) to run. By default all submission benchmarks will be selected. 'all' means all sumission benchmarks will be run. See SPECjvm2008 workload names for all values. 3.2 基准测试用例介绍 SPECjvm2008的benchmarks测试用例列表如下： (单位 ops/m 每分钟操作数) Benchmark Name Description startup.helloworld 测试helloworld程序从运行开始到结束所需的时间 startup.compiler.compiler 普通java编译所需要的时间 startup.compiler.sunflow 编译sunflow图像渲染引擎所需要的时间 startup.compress 测试压缩程序，单次压缩所需的时间 startup.crypto.aes 测试AES/DES加密算法，单次加解密所需的时间 输入数据长度为 100 bytes , 713KB startup.crypto.rsa 测试RSA加密算法，单次加解密需要的时间 输入数据长度为 100 bytes, 16KB startup.crypto.signverify 测试单次使用MD5withRSA, SHA1withRSA, SHA1withDSA, SHA256withRSA来签名，识别所需要的时间。 输入数据长度为 1KB, 65KB, 1MB startup.mpegaudio 单次mpeg音频解码所需的时间 startup.scimark.fft 单次快速傅立叶变换所需的时间 startup.scimark.lu 单次LU分解所需的时间 startup.scimark.monte_carlo 单次运行蒙特卡罗算法所需的时间 startup.scimark.sor 单次运行jacobi逐次超松弛迭代法所需的时间 startup.scimark.sparse 单次稀疏矩阵乘积所需的时间 startup.serial 单次通过socket传输java序列化对象到对端反序列化完成所需的时间（基于jboss serialization benchmark） startup.sunflow 单次图片渲染处理所需的时间 startup.xml.transform 单次xml转换所需的时间，转换包括dom,sax,stream方式 startup.xml.validation 单次xml schema校验所需的时间 compiler.compiler 在规定时间内，多线程迭代测试普通java编译，得出 ops/m compiler.sunflow 在规定时间内，多线程迭代测试sunflow图像渲染，得出 ops/m compress 在规定时间内，多线程迭代测试压缩，得出 ops/m crypto.aes 在规定时间内，多线程迭代测试AES/DES加解密算法，得出 ops/m crypto.rsa 在规定时间内，多线程迭代测试RSA加解密算法，得出 ops/m crypto.signverify 在规定时间内，多线程迭代测试使用MD5withRSA, SHA1withRSA, SHA1withDSA, SHA256withRSA来签名，识别，得出 ops/m derby 在规定时间内，迭代测试数据库相关逻辑，包括数据库锁，BigDecimal计算等，最后得出 ops/m mpegaudio 在规定时间内，多线程迭代mpeg音频解码，得出 ops/m scimark.fft.large 在规定时间内，多线程迭代测试快速傅立叶变换，使用32M大数据集，最后得出 ops/m scimark.lu.large 在规定时间内，多线程迭代测试LU分解，使用32M大数据集，最后得出 ops/m scimark.sor.large 在规定时间内，多线程迭代测试jacobi逐次超松弛迭代法，使用32M大数据集，最后得出 ops/m scimark.sparse.large 在规定时间内，多线程迭代测试稀疏矩阵乘积，使用32M大数据集，最后得出 ops/m scimark.fft.small 在规定时间内，多线程迭代测试快速傅立叶变换，使用512K小数据集，最后得出 ops/m scimark.lu.small 在规定时间内，多线程迭代测试LU分解，使用512KB小数据集，最后得出 ops/m scimark.sor.small 在规定时间内，多线程迭代测试jacobi逐次超松弛迭代法，使用512KB小数据集，最后得出 ops/m scimark.sparse.small 在规定时间内，多线程迭代测试稀疏矩阵乘积，使用512KB小数据集，最后得出 ops/m scimark.monte_carlo 在规定时间内，多线程迭代测试蒙特卡罗算法，得出 ops/m serial 在规定时间内，多线程迭代测试通过socket传输java序列化对象到对端反序列化（基于jboss serialization benchmark），得出 ops/m sunflow 在规定时间内，利用sunflow多线程迭代测试图片渲染，得出 ops/m xml.transform 在规定时间内，多线程迭代测试xml转换，得出ops/m xml.validation 在规定时间内，多线程迭代测试xml schema验证，得出 ops/m 4执行基准测试 官方提供了三种基准测试方式，常用的有两种，一种是base，一种是peak，区别在于前者是不允许做任何vm参数调整。后者可以添加vm调优参数。 默认启动方式： java -jar SPECjvm2008.jar 此测试将完整的测试21个用例。 可以选择特定的用例进行测试 如：java -jar SPECjvm2008.jar startup.helloworld 根据需要可以进行vm参数调整，调整后需要使用-peak参数。 如：java -Xms256M -Xmx1024M -jar SPECjvm2008.jar -peak -ikv 5结果查看 测试结果默认的输出路径是安装目录的results 目录下。内部根据你执行测试套件的顺序，又分了不同的子文件夹。进入某个子文件夹，查看html格式的结果就行了。 6参考的URL 用户手册 运行和报告规范 http://www.spec.org/jvm2008/docs/RunRules.html 已知问题 http://www.spec.org/jvm2008/docs/KnownIssues.html 7 总结 1）如果选了base，又修改了vm options怎么办？ 套件在运行时，会给你警告。并且，在你的测试结果上会显示大大的一行Run is not compliant。另外，如果你想将测试结果提交官方，某些参数必须符合官方要求，否则同样是警告。 2）哪些参数有官方要求？ 默认配置文件props/specjvm.properties 里，注释了Permitted for的就是。 3）如何指定配置文件路径？ -pf指定配置文件路径，默认使用的是安装目录下的 props/specjvm.properties，（日志里会打印出使用文件的路径）","tags":"性能测试","title":"SpecJvm2008使用说明"},{"url":"http://king32783784.github.io/2014/10/10/linux/","text":"一、工具介绍 SPEC CPU 2006 benchmark是SPEC新一代的行业标准化的CPU测试基准套件。重点测试系统的处理器，内存子系统和编译器。这个基准测试套件包括的SPECint基准和SPECfp基准。 其中SPECint2006基准包含12个不同的基准测试和SPECfp2006年基准包含19个不同的基准测试。SPEC设计了这个套件提供了一个比较标准的计算密集型，高性能的跨硬件的CPU测试工具。在SPEC CPU 2006基准有几种不同的方法来衡量计算机性能。 一种方式是测量计算机完成单一任务的速度; 另一种方式吞吐量，容量或速率的测量。 说明：由于spec2006支持多种类型操作系统。以下安装、测试、移植等介绍均基于Unix 和其他的 Unix-like system如linux。Windows系统不在此范围内。 1.spec2006与spec2000的对比简要说明 2006年8月24日，标准性能评估公司（SPEC）宣布CPU2006将取代CPU2000。 Spec cpu基准测试被广泛的应用于工业界和学术界。新套件比cpu2000要大很多，而且将涵盖到CPU、存储器系统、编译器特别是C++编译器。Cpu2000只有1个关于C++的基准测试，CPU2006则含有7个相关套件，这其中包括了50W行c++代码，Fortran和C语言和之前一样有很好的覆盖。 2. Spec2000和spec20006具体的套件信息如下： 2.1 Spec int2000 12个整点测试项目 164.gzip C语言编写，很流行的数据压缩程序。使用Lempel-Ziv coding(LZ77)作为压缩算法。SPEC中的gzip除了读入集外没有其他文件I/O操作，所有压缩和解压都在主存中进行，方便测试CPU和存储子系统。 175.vpr C语言编写，FPGA中的电路定位和路由程序,用于计算机辅助电路设计领域。 176.gcc: C语言编写，C语言优化编译器。该GCC基于GCC 2.7.2.2版本，为摩托罗拉88100处理器生成机器码。 181.mcf: C语言编写，组合优化/单点轮换调度(Single-depot vehicle scheduling),派生自使用单站轮换调度的公共物流应用程序。 186.crafty： C语言编写，国际象棋游戏程序。这是一个在64位机上设计的高性能计算机国际象棋程序，在32位机上可以使用long long来表示该数据类型。主要是一个整点程序，大量的逻辑运算。通过配置，能生成不同的搜索集，可以对处理器的整点运算，转移预测和流水线等做测试。 197.parser: C语言编写，字处理程序。连接语法分析器(Link Grammar Parser)是一个基于连接语法的英语句法分析器。连接语法时英语语法的较早理论。给定一个句子，系统能给它赋予一个词法结构，这个结构是两个词之间被标记的连接。该分析器有大约60000个词表的字典。 252.eon： C++语言编写，计算机可视化。eon是一个基于概率的射线跟踪程序，基于Kajiya 1986 ACM SIGGRAPH会议的论文。它将一定数量的3D射线发射到一个3D多面体中，计算射线和多边形的交点，并通过计算入射光和交点生成新射线。最终的计算结果时一个能在照相机内看到的图片。程序中的计算需求和基本计算机图形学中介绍的传统确定性射线跟踪程序很相似，但是它有较少的存储一致性需求，因为很多在同一个位置生成的随机射线横切3D空间中完全不同的区域.输入：eon渲染一个150×150像素的一把椅子在房间前脚的图片。 253.perlbmk: C语言编写,Perl语言解释器。这是一个Perl v5.005_03版本的删减版，删除了很多操作系统相关的特性，并增加了一些第三方的模块，包括MD5 v1.7, MHonArc v2.3.3, IO-stringy v1.205,MailTools v1.11,TimeData v1.08。输入：由四个perl脚本组成，一个email-to-HTML 转换器，占用时间最长；一个spec CPU2000用来对比较输出的diff脚本，一个通过迭代算法寻找合格数字的脚本，一个用于测试伪随机数按照预定顺序生成的脚本。输出分别对应各个输入。 254.gap: C语言编写，群论，解释器中常用。它实现一个语言和库用于做群论计算。GAP是(Groups,Algorithms和Programming的缩写)。 255.vortex： C语言编写,单用户面向对象数据库中事务处理的benchmark。SPEC中的vortex来自完整面向对象数据库程序VORTEx的一个子集。输入和输入数据库的事务都会被转换成一个方案。 256.bzip2： C语言编写，压缩程序。基于Julian Seward的bzip2 v0.1，唯一的不同是SPEC中的bzip2除了输入外，无文件I/O。所有的压缩和解压都在内存中进行。输入，输出都和gzip的相似。 300.twolf： C语言实现，定位和路由模拟。twolf来自TimberWolfSC定位和全局路由，它被用于创建微处理器产品印刷电路布局的流程中，确定晶体管的位置和组内的全局连接。定位问题是一个排列，穷举法耗时太长，TimberWolfSC程序则使用模拟退火作为启发来找到较优解。 2.2 Spec int2000 12个整点测试项目 400.perlbench：C语言编写，同spec2000的253.perlbmk类似，是Perl V5.8.7版本的删减版，同样删除了一下操作系统特性有关的东西，增加了第三方的模块，如：SpamAssassin V2.61,Digest-MD5 v2.33,HTML-Parser v3.35,MHonArc V2.6.8,IO-stringy V1.205,MailTools V1.60，TimeDate V1.16。400.perlbench采用3个脚本进行增加负载或工作。1.主要的负载在于打开 垃圾邮件过滤软件SpamAssassin。采取的过滤方式是采用记分制，也就是说会根据我们所设定的标准来给予分数超过标准值的时候即判定为 SPAM（垃圾邮件），其余为非垃圾邮件。但对SpamAssassin软件做了很大程度的修改，避免一些I/0操作，并且没有使用贝叶斯过滤。2.是比较流行的email到HTML的转换器MHonArc 3.使用了spec2006的工具套件specdiff。 401.bzip2: C语言实现，同spec2000的256.bzip2类似,基于Julian Seward的bzip2 v1.03.唯一的不同是SPEC中的bzip2除了输入外，无文件I/O。所有的压缩和解压都在内存中进行。输入，输出都和gzip的相似。负载包括六个部分：两个小的JPEG图片、一个程序、一个tar包起的几个源程序文件、一个HTML文件、混合文件，包括压缩起来的高可压缩文件及不怎么可压缩的文件。测试分别使用了三个不同的压缩等级进行压缩和解压缩 403.gcc:C语言实现，同spec2000的176.gcc类似。该测试是基于gcc V3.2,为AMDCPU生成机器码。相比spec2000的176.gcc，该测试有更多的输入文件，因此测试压力会更大，负载来源于对9组C代码进行编译。 429.mcf:C语言实现，同时需要libm库支持，同spec2000的181.mcf类似，MCF是一个用于大型公共交通中的单站车辆调度的程序。但对输入文件做了一定的修改，由32位变成64位，用以兼容64位系统。并且增加了cache命中和程序的性能。相比spec2000的181.mcf来说，占用的内存由之前的100M-190M变为860M-1700M。 445.gobmk：C语言实现，同spec2000的186.crafty类似。不同的是这里是实现的围棋游戏。相比spec2000程序更复杂。 456.hmmer：C语言实现。HMMER是基于隐马尔可夫模型(profile HMMs)，用于生物序列分析工作。同Timed HMMer Search 类似。 458.sjeng：C语言实现。基于一种象棋游戏Sjeng11.2，属于人工智能的范畴。 462.libquantum:C语言实现（C99）。libquantum是模拟量子计算机的库文件，用来进行量子计算机应用的研究。 464.h264ref:C语言实现。一种视频压缩程序，基于H264AVC 9.3版，去除了I/O和平台相关的东西。 471.omnetpp:C++语言实现。OMNeT++，离散事件仿真。包括约8000台计算机和900个交换机/集线器，以及混合了各种从10Mb到1000Mb速率的大型CSMA/CD协议以太网络模拟。 473 astar：C++语言实现，实现了2D寻路算法A*的三种不同版本。 xalancbmk：C++语言实现，包含Xalan-C++ v1.8 mod、Xerces-C++ v2.5.0，实现了XML文档/XSL表到HTML文档的转换。 2.3 Spec fp2000 13个浮点测试项目 168 wupwise：Fortran 77语言实现，格点规范理论与威尔逊数值模拟对费米子格是夸克传播子的计算。输入文件wupwise.in包含几个创建该问题的参数，SEED:提供一个随机数 NITER：迭代次数KAPPA：参数表征矩阵M = I - KAPPA * D。输出文件wupwise.out,包含每次NITER迭代的校验值（EPS）和包含最终的EPSILON特征的结果。 171 swim：Fortran 77语言实现，气象学中的浅水模型。 172.mgrid ：Fortran 77语言实现，多重网格求解器：3D势场 173.applu： Fortran 77语言实现，抛物线/椭圆型偏微分方程 177.mesa：C语言实现 ，3D图形库。 178.galgel :Fortran 90语言实现，计算流体动力学 179.art :C，图像识别/神经网络 183.equake:C语言实现， 地震波传播模拟 187.facerec: Fortran 90语言实现，图像处理：人脸识别 189.lucas :Fortran 90语言实现，数论/素性测试 191.fma3d :Fortran 90语言实现，有限元模拟碰撞 200.sixtrack :Fortran 77语言实现，高能核物理加速器设计 301.apsi: Fortran 77语言实现，气象学中污染物分布 2.4 Spec fp2006 17个浮点测试项目 410.bwaves：Fortran 77语言实现，流体力学范畴。对三维瞬跨音速粘性流中冲击波的模拟计算 416.gamess：Fortran语言实现，量子化学范畴。采用GMAESS组件，包含 胞嘧啶分子、水和Cu2+离子、三唑离子等3种SCF自洽场计算。 433.milc：C语言实现，量子力学范畴，采用MILC组件，包含用来研究QCD量子色动力学、夸克及胶子的四维SU(3)格点规范理论的模。 434.zeusmp ：Fortran 77/REAL*8语言实现，属于计算流体力学范畴，ZEUS-MP程序，用来计算理想、非相对论条件下的流体力学和磁流体力学，434.zeusmp模拟计算了一个统一磁场中的3D冲击波。 435.gromacs ：C & Fortran语言实现，属于生物化学/分子力学范畴。GROMACS是一个分子力学计算套件，然而也可以用于非生物系统，435.gromacs模拟了在一个水和离子溶液中的蛋白质溶菌酶结构在各种实验手段如核磁共振的X光照射下的变化。 436.cactusADM：Fortran 90, ANSI C语言实现，物理中的广义相对论。来源于Cactus BenchADM。436.cactusADM对时空曲率由内部物质决定的爱因斯坦演化方程进行求解，爱因斯坦演化方程由10个标准ADM 3+1分解的二阶非线性偏微分方程组成。 437.leslie3d ：Fortran 90语言实现，属于流体力学范畴。 LESlie3d是用来计算湍流的计算流体力学程序，437.leslie3d计算了一个如燃油注入燃烧室的时间分层混合流体。 444.namd：C++语言实现。属于生物/分子学范畴。NAMD是一个大型生物分子系统并行计算程序，444.namd模拟了了92224个原子组成的A-I载脂蛋白 447.dealII：C++语言实现。进行有限元分析，w/Boost lib 、deal.II lib、deal.II是定位于自适应有限元及误差估计的C++库，447.dealII对非常系数的亥姆霍兹方程进行求解，它使用了基于二元加权误差估计生成最佳网格的自适应方法，该方程在3维得解。 450.soplex:C++语言实现。采用Plex v1.2.1程序，Plex使用单纯形算法解线性方程 453.povray：ISO C++ 语言实现。 POV-Ray POV-Ray是一个光线追踪渲染软件，453.povray渲染一幅1280x1024的反锯齿国际象棋棋盘图像 454.calculix：Fortran 90 & C语言实现，结构力学范畴。CalculiX是一个用于线性及非线性三位结构力学的有限元分析软件，454.calculix计算了一个高速旋转的压缩盘片在离心力的作用下的应力和变形情况 459.GemsFDTD：Fortran 90语言实现。属于电磁学范畴。 459.GemsFDTD使用FDTD（有限差分时域）方法求解三维时域中的麦克斯韦方程，计算了一个理想导体的雷达散射截面 465.tonto： Fortran 95实现。量子化学范畴Tonto是一个面向对象的量子化学程序包，465.tonto计算面向量子晶体学，它基于一个符合X光衍射实验数据的、约束的分子Hartree-Fock波函数 470.lbm ：ANSI C语言实现。 470.lbm使用LBM（格子波尔兹曼方法）模拟非压缩流体，它模拟了两种情况：类似活塞推动的剪切驱动流体和管道流体，测试包含了3000个步骤 481.wrf ：Fortran 90 & C语言实现。WRF v2.0.2 481.wrf基于WRF(Weather Research and Forecastin)模型，对NCAR的数据进行了计算，数据包括了UTC 2001.06.11到UTC 2001.06.12以三小时为间隔的数据 482.sphinx3：C语言实现。Sphinx-3一种语音识别软件。 二、工具安装 1.标准安装方式 $ mount -t iso9660 -o ro,exec /dev/cdrom /mnt $ cd /mnt $ ./install.sh 可以指定安装目录如： $./install.sh -d /home/cpu2006 安装过程中可能遇到以下提示： Installing FROM /Volumes/SPEC_CPU2006 Installing TO /home/cpu2006 Is this correct? (Please enter 'yes' or 'no') yes 2.通过安装完成的软件进行测试 先准备相关测试文件，如：cpu2006-20141030.tar。 解压文件： $ tar xf cpu2006-20141030.tar 进入安装目录： $ cd cpu2006v99/（根据实际路径） 导入测试工具： $. shrc 注意：输入时，圆点与shrc之间至少一个空格，该命令开始导入SPEC CPU2006程序。 修改测试文件绝对路径： $ bin /relocate 显示\"Top of SPEC benchmark tree is '/cpu2006v99'\" 3.运行测试 根据需求，进行参数选择，开始运行测试脚本： 例如：runspec -c linux-mipsel-gcc -i ref -n 3 all 命令参数说明： -c：读取测试配置文件，linux-mipsel-gcc位于SPEC CPU2000安装目录的config目录下，该文件可以根据实际信息进行修改。其编译选项不建议修改。 -i：输入测试数据集的大小，ref代表最大测试数据集，test代表最小测试数据集； -n：每个测试项目运行的次数，如果需要SPEC CPU2006自动计算测试分值，需要指定运行次数等于或大于3，即n>=3； all：SPEC CPU2006将运行基准测试程序中的所有测试项目。 出现以下信息，表明测试已经启动\" runspec v4283 - Copyright 1999-2006 Standard Performance Evaluation Corporation Using 'mipsel-linux' tools Reading MANIFEST... 17899 files Loading runspec modules............... Locating benchmarks...found 31 benchmarks in 13 benchsets. Locating output formats: ASCII, config, CSV, flags, html (DISABLED), mail, PDF, PostScript, raw, Screen, Submission Check Reading config file '/cpu2006v99/config/linux-mipsel-gcc.cfg' Benchmarks selected: 400.perlbench, 401.bzip2, 403.gcc, 429.mcf, 445.gobmk, 456.hmmer, 458.sjeng, 462.libquantum, 464.h264ref, 471.omnetpp, 473.astar, 483.xalancbmk, 999.specrand, 410.bwaves, 416.gamess, 433.milc, 434.zeusmp, 435.gromacs, 436.cactusADM, 437.leslie3d, 444.namd, 447.dealII, 450.soplex, 453.povray, 454.calculix, 459.GemsFDTD, 465.tonto, 470.lbm, 481.wrf, 482.sphinx3, 998.specrand Compiling Binaries up to date 400.perlbench ref base linux-mipsel-gcc default Up to date 401.bzip2 ref base linux-mipsel-gcc default Up to date 403.gcc ref base linux-mipsel-gcc default Up to date 429.mcf ref base linux-mipsel-gcc default …… 这组测试配置基本和spec2000类似，不同的是，spec2006在测试前，会把每个测试组件重新编译建立一次。所以在测试前，应确保此时的系统中包含以下编译器：g++、gcc、gfortran编译器。如果进行连续测试，则不必进行再次编译，可以加参数\"—nobuild\". 附config文件大体说明：斜体部分为文本内容 //为解释说明 ##################################################################### ignore_errors = yes tune = base ext = loongson.3a2000 output_format = asc, Screen, html reportable = 0 teeout = yes teerunout = yes hw_avail = Feb-2015 sw_avail = Feb-2015 license_num = company_name = Loongson prepared_by = Loongson tester_name = isoft test_date = July-2016 verbose = 9 default=default=default=default: ##################################################################### # # Compiler selection # ##################################################################### makeflags = -j 4 CC = mips64el-loongson-linux-gcc CXX = mips64el-loongson-linux-g++ FC = mips64el-loongson-linux-gfortran ## HW config hw_cpu_name = Loongson hw_model = 3A2000 hw_cpu_mhz = 1000 hw_fpu = Integrated hw_nchips = 1 hw_ncores = 4 hw_ncoresperchip= 4 hw_nthreads = 4 hw_ncpuorder = 1 hw_parallel = yes hw_pcache = 64KB I + 64KB D hw_scache = 4096KB(I + D) hw_memory = 2 x 4GB DDR1066 hw_vendor = Loongson ## SW config sw_os = iSoft sw_file = ext4 sw_state = runlevel 3 sw_compiler = gcc , g++ & gfortran 4.8 ##################################################################### # Optimization ##################################################################### ## Base is low opt default=default=default=default: # For this data model, -m32 needs to be here, as one of the lines below OPTIMIZE = -static -march=loongson3a PORTABILITY = COPTIMIZE = -flto -Ofast CXXOPTIMIZE = -flto -Ofast FOPTIMIZE = -flto -Ofast notes0100= C/C++ base flags: -flto -Ofast notes0110= Fortran base flags: -flto -Ofast ##################################################################### # 32/64 bit Portability Flags - all ##################################################################### default=base=default=default: notes25= default=peak=default=default: notes25= ##################################################################### # Portability Flags - INT ##################################################################### 400.perlbench=default=default=default: notes35 = 400.perlbench: -DSPEC_CPU_LINUX_IA32 CPORTABILITY= -DSPEC_CPU_LINUX_IA32 -fno-strict-aliasing #notes35 = 400.perlbench: -DSPEC_CPU_LINUX #CPORTABILITY= -DSPEC_CPU_LINUX -DSPEC_CPU_LITTLEENDIAN #COPTIMIZE = -O2 ...... 其他具体组件的编译信息不再一一说明，基本可以保持默认即可。 更多测试类型与方法参见下文。 4.测试结果收集与分析 测试结束后在result目录下，查看测试结果，测试结果一般以测试类型和测试次序进行区别，并且会按照整点和浮点进行划分。如果是按照正式reportable的模式进行测试的话，会出一份网页版的正式测试结果，参见下图： 非正式结果可以去asc或txt文档查看，格式例如下文： Base Base Base Peak Peak Peak Benchmarks Ref. Run Time Ratio Ref. Run Time Ratio -------------- ------ --------- --------- ------ --------- --------- 400.perlbench 9770 430 22.7 S 9770 339 28.8 S 400.perlbench 9770 429 22.8 * 9770 338 28.9 S 400.perlbench 9770 429 22.8 S 9770 339 28.8 * 401.bzip2 9650 559 17.3 * 9650 552 17.5 * 401.bzip2 9650 559 17.3 S 9650 553 17.5 S 401.bzip2 9650 560 17.2 S 9650 552 17.5 S 403.gcc 8050 374 21.5 S 8050 337 23.9 S 403.gcc 8050 367 22.0 * 8050 337 23.9 S 403.gcc 8050 366 22.0 S 8050 337 23.9 * 429.mcf 9120 187 48.9 S 9120 187 48.9 S 429.mcf 9120 188 48.6 * 9120 188 48.6 * 429.mcf 9120 211 43.2 S 9120 211 43.2 S 445.gobmk 10490 559 18.8 S 10490 542 19.4 S 445.gobmk 10490 559 18.8 S 10490 542 19.4 * 445.gobmk 10490 559 18.8 * 10490 541 19.4 S 456.hmmer 9330 213 43.8 S 9330 213 43.7 * 456.hmmer 9330 247 37.8 S 9330 214 43.6 S 456.hmmer 9330 214 43.5 * 9330 213 43.7 S 458.sjeng 12100 616 19.6 * 12100 574 21.1 * 458.sjeng 12100 617 19.6 S 12100 575 21.0 S 458.sjeng 12100 585 20.7 S 12100 574 21.1 S 462.libquantum 20720 14.2 1460 * 20720 14.2 1460 * 462.libquantum 20720 14.4 1440 S 20720 14.4 1440 S 462.libquantum 20720 13.5 1540 S 20720 13.5 1540 S 464.h264ref 22130 578 38.3 * 22130 527 42.0 S 464.h264ref 22130 579 38.2 S 22130 526 42.0 * 464.h264ref 22130 578 38.3 S 22130 526 42.0 S 471.omnetpp 6250 349 17.9 S 6250 288 21.7 * 471.omnetpp 6250 348 17.9 * 6250 288 21.7 S 471.omnetpp 6250 348 18.0 S 6250 289 21.7 S 473.astar 7020 313 22.4 S 7020 313 22.4 S 473.astar 7020 311 22.6 S 7020 311 22.6 S 473.astar 7020 311 22.6 * 7020 311 22.6 * 483.xalancbmk 6900 174 39.7 * 6900 170 40.7 S 483.xalancbmk 6900 174 39.6 S 6900 170 40.5 S 483.xalancbmk 6900 174 39.7 S 6900 170 40.6 * ============================================================================== 400.perlbench 9770 429 22.8 * 9770 339 28.8 * 401.bzip2 9650 559 17.3 * 9650 552 17.5 * 403.gcc 8050 367 22.0 * 8050 337 23.9 * 429.mcf 9120 188 48.6 * 9120 188 48.6 * 445.gobmk 10490 559 18.8 * 10490 542 19.4 * 456.hmmer 9330 214 43.5 * 9330 213 43.7 * 458.sjeng 12100 616 19.6 * 12100 574 21.1 * 462.libquantum 20720 14.2 1460 * 20720 14.2 1460 * 464.h264ref 22130 578 38.3 * 22130 526 42.0 * 471.omnetpp 6250 348 17.9 * 6250 288 21.7 * 473.astar 7020 311 22.6 * 7020 311 22.6 * 483.xalancbmk 6900 174 39.7 * 6900 170 40.6 * SPECint(R)_base2006 36.7 SPECint2006 39.1 Base Ratio为测试分值，该测试一般运行3遍取中值。整体结果为所有结果的几何平均值。 5. 举例说明SPEC CPU2006常用测试命令组合 1．runspec -c test.cfg -i test -I all 基于最小测试数据集快速执行所有的测试，测试过程中如果某个用例发生错误，则跳过错误用例，继续执行其他用例。 2．runspec -c test.cfg -i ref -n 3 -I all 基于最大测试数据集全面执行所有的测试，用于测试单核CPU，测试过程中如果某个用例发生错误，则跳过错误用例，继续执行其他用例。 3．runspec -c test.cfg –r ref –n 3 fp 基于最大测试数据集，只运行fp测试 4．runspec -c test.cfg –r ref –n 3 int 基于最大测试数据集，只运行int测试 5.runspec -c test.cfg -i ref 473.astar 基于最大测试数据集只执行473.astar单个测试。 6 runspec –c test.cfg –i ref --rate 4 int 基于最大数据测试集进行rate测试，运行4线程测试的分值 6.其他命令补充 --action build 创建测试项目 --action onlyrun 只是运行，不进行确认测试结果是否正确 --action report 标准测试 --action clean 清理已经建立的测试项目 模式很多，不再一一介绍。 --check_version 检查版本更新 --copies –c number 默认1 用来进行SPECrate run --help 显示帮助文档 --ignore_errors 忽略错误 ations number —n 测试次数，一次reportable测试，必须是3次 --iter—loose 未设置reportable测试 --output_format 输出文件格式 默认为html text 可以选择 all cfg test csv html mail pdf ps printer raw screen text 等多种方式。 --rate -r 进行SPECspeed测试可以指定copies数量运行。 --rebuild 重新编译测试文件 --tune tuning 默认是base 可以选择base, peak, or all ，Report 首先是base,其次是peak. 以上是比较常用的命令，一些不常用的命令不再介绍，可参考下文了解。 -a Same as --action --action action Do: build|buildsetup|clean|clobber|configpp| onlyrun|realclean|report|run|runsetup|scrub| setup|trash|validate --basepeak Copy base results to peak (use with --rawformat) --nobuild Do not attempt to build binaries -c Same as --config -C Same as --copies --check_version Check whether an updated version of CPU2006 is available --comment \"text\" Add a comment to the log and the stored configfile. --config file Set config file for runspec to use --copies Set the number of copies for a SPECrate run -D Same as --rebuild -d Same as --deletework --debug Same as --verbose --define SYMBOL[=VALUE] Define a config preprocessor macro --delay secs Add delay before and after benchmark invocation --deletework Force work directories to be rebuilt --dryrun Same as --fake --dry-run Same as --fake -e Same as --extension --ext Same as --extension --extension ext[,ext...] Set the extensions -F Same as --flagsurl --fake Show what commands would be executed. --fakereport Generate a report without compiling codes or doing a run. --fakereportable Generate a fake report as if \"--reportable\" were set. --[no]feedback Control whether builds use feedback directed optimization --flagupdate Same as --update --flagsupdate Same as --update --flagsurl url Location (url or filespec) where to find your flags file --getflags Same as --update --graph_auto Let the tools pick minimum and maximum for the graph --graph_min N Set the minimum for the graph --graph_max N Set the maximum for the graph -h Same as --help --help Print usage message --http_proxy Specify the proxy for internet access --http_timeout Timeout when attempting http access -I Same as --ignore_errors -i Same as --size --ignore_errors Continue with benchmark runs even if some fail --ignoreerror Same as --ignore_errors ...... 7.手动编译及跨平台移植方法（仅供参考） Spec2006包含的测试套件基本上与平台无关，因此理论上是可以直接进行跨平台进行测试。 Spec2006为了实现测试结果的准确及降低对平台的依赖，制作了自己的工具包。其中包括: specdiff（examines results to see if the correct answer was obtained）、specinvoke (invokes benchmarks for CPU2006)、specmake（GNU make ，Calling it \"specmake\" avoids possible conflicts with versions of make that may already be on your system. SPEC requires that published results use the versions of the tools that it supplies, so that if SPEC applies patches or extensions from time to time, all users run with a consistent tool set. Similar considerations apply to other tools in this list.)、specxz （The xz compression program）、specmd5sum（md5sum from GNU coreutils, with enhancements）、spectar（ GNU tar）、specperl（Perl）。Various Perl modules such as Algorithm::Diff, GD, HTML::Parser, PDF::API2, URI, XML::SAX, etc.。 编译工具：C99 编译器 C++编译器 如果是初始安装包，则需要解压源码包 # xz -dc install_archives/cpu2006.tar.xz | tar -xf - tools/src 建立工具包的命令如下： AIX (32-bit): CC=xlc CFLAGS='-O -qarch=ppc -D_LARGE_FILES -D_ILS_MACROS' PERLFLAGS=\"-Doptimize='-O' -Accflags='-D_LARGE_FILES'\" OBJECT_MODE=32 ./buildtools AIX (64-bit): CC=xlc CFLAGS='-O3 -qarch=ppc64 -q64 -D_ILS_MACROS' PERLFLAGS=\"-Doptimize='-O' -Aoptimize='-qarch=ppc64 -q64'\" OBJECT_MODE=64 ./buildtools HPUX: CC=\"/opt/ansic/bin/cc\" CFLAGS=\"-Ae +O2 +z -D_FILE_OFFSET_BITS=64 -AC99\" XZCFLAGS=-AC99 PERLFLAGS=\"-Doptimize=+O1 -Dlibpth=/usr/lib/hpux32 -Dldflags=-lm -Dcppstdin=cc -Acppstdin=-E -Acppstdin=-Aa -Acppstdin=-D__STDC_EXT__ -Acppstdin=-AC89\" ./buildtools IRIX: ulimit -s 128000; CFLAGS=\"-c99 -D_FILE_OFFSET_BITS=64\" MD5CFLAGS=\"-O2\" PERLFLAGS=\"-Doptimize=-O3 -Uloclib -Dlibpth=/usr/lib32\" XZFLAGS=\"--disable-assembler --disable-shared\" XZCFLAGS=\"-O1\" ./buildtools 建立完成之后，确认是否成功的方法： cd $ SPEC (Unix) . shrc 或 runspec -V 或specmake -v specxz -h specperl -v specdiff –h runspec -h specinvoke -h 工具编译完成之后，需要对工具进行打包 packagetools <archname> 如果自动化编译出现问题，可以手动编译每个测试工具。编译方法为进入对应的工具包，手动编译。 Top &#94;","tags":"性能测试","title":"Spec2006使用说明"},{"url":"http://king32783784.github.io/2011/07/11/C/","text":"结构体声明 例如： struct Student { char name[20]; char sex; int age; char addr[40]; } / 定义一个Student 类型的student变量 / struct Student student; 定义结构体的时候每次都要写struct显得比较繁琐，可以用typedef来方便声明。这样就可以想int、char一样定义结构体类型了。比如： typedef struct _TEST_T { int i; char c[10]; }TEST_T; 初始化 1.初始化的就是定义一个结构体变量，并且给它赋值比如： TEST_T gst = {1, \"12345\"}; /*可以初始化，设置i为1，c为一个字符串.*/ TEST_T gst = {1}; /*初始化个数少于实际个数时，只初始化前面的成员。*/ TEST_T gst = {.c=\"12345\"}; /*有选择的初始化成员。*/ 2、复合字面量。 gst = (TEST_T){122, \"1256\"}; /*这是一个赋值语句，也可以作为初始化。可以出现在程序的任何地方。*/ 当然也可以使用复合字面量来初始化： gst = (TEST_T){.i=122, .c=\"123\"}; 3、结构体数组 可以用多个大括号括起来： TEST_T gst[10] = \\{\\{\\},\\{\\},\\{\\},\\{\\}\\} 也可以初始化其中的一个元素： TEST_T gst[10] = {[2]={}, [3]={}} 也可以使用复合字面量： TEST_T gst[10] = {[2].i=0, [3].i={}} 为什么要初始化 1、对局部变量初始化可以防止随机值产生的危害。 2、对全局变量初始化可以告诉编译器，这是一个定义，而不是一个声明。（如果两个c中有相同的全局变量定义，且没有初始化，编译器会认为第二个是声明而不是定义。） 声明和定义的区别在于是否分配内存进行存储。","tags":"编程语言-C","title":"C-结构体声明"},{"url":"http://king32783784.github.io/2011/08/15/C/","text":"1.简单的宏定义 #define MAXTIME 1000 简单的MATIME定义好了，它代表1000，如果在程序中写： if(i<MAXTIME){...} 编译器在处理这个代码之前会对MAXTIME进行替换为1000。 宏定义类同于简单的文本替换，而不是变量。 2.define的\"函数定义\" define可以像函数那样接受一些参数，如下： #define max(x,y)(x)>(y)?(x):(y); 这个定义将返回两个数中最大的，而且这个函数没有经过类型检查，好像函数模板，但没有模板安全。存在隐患： #define Add(a,b) a+b; 如果代数式 c Add(a,b) d,本意为a+b然后去和c、d相乘，而define只是一个简单替换，式子反而变为了： c a + b d ,忽略了运算规则。 #define pin(int*); pin a,b; 本来是想定义a，b都是int型指针，而一替换变成了 int*a,b; 3.宏的单行定义 #define A(x) T_##x #define B (x)#@x #define C (x)#x 我们假设x=1,则有： A(1): T_1 B(1): '1' C(1): \"1\" 3.define的多行定义 define可以替换多行的代码，例如MFC中的宏定义 #define MACRO(arg1, arg2) do{/ /*declarations*/ stmt1;/ stmt2;/ }while(0) /*(no trailing;)*/ 每行换行时加上换行符\"/\" 4.条件编译 在大规模的开发中，define最重要的功能就是条件编译。也就是本文的用法。 #ifdef UCLINU ... ... #endif 编译时，可以通过#define设置编译环境 5如何定义宏，取消宏 //定义宏 #define [MarcoName] [Macro Value] //取消宏 #undef [MacroName] //普通宏 #define PI(3.14] //带参数的宏 #define max(a,b)((a)>(b)?(a),(b)) 加括号是个好习惯哦 6.头文件(.h)可以被头文件或C文件包含 重复包含（重复定义） 由于头文件包含可以嵌套，那么C文件就有可能包含多次同一个头文件，就可能出现重复定义的问题的。 通过条件编译开关来避免重复包含（重复定义） 例如 #ifndef headerfileXXX #define headerfileXXX … //文件内容 … #endif 7.define命令的一些高级用法 define中的三个特殊符号\"#\" \"##\" \"#@\"，前面提到过但未解释。 #define Conn(x,y) x##y x##y 表示什么？ 表示x连接y, int n = Conn(123, 456); //表示n=123456 相信你已经猜到了 char* str = Conn(\"asdf\", \"adf\"); //表示str = \"asdfadf\" #define ToChar(x) #@x @x，就是给x加上单引号，返回一个const char: char a = ToChar(1) //a='1' x, 就是加双引号. 下面看一下宏定义常用用法： 防止头文件被重复包含： #ifdef BODYDEF_H #define BODYDEF_H ... #endif 得到指定地址上的一个字节或字： #define MEM_B( x ) ( *( (byte *) (x) ) ) #define MEM_W( x ) ( *( (word *) (x) ) ) 得到一个field在结构体(struct)中的偏移量 #define OFFSETOF( type, field ) ( (size_t) &(( type *) 0)-> field ) 得到一个结构体中field所占用的字节数 #define FSIZ( type, field ) sizeof( ((type *) 0)->field ) 得到一个变量的地址（word宽度） #define B_PTR( var ) ( (byte *) (void *) &(var) ) #define W_PTR( var ) ( (word *) (void *) &(var) ) 将一个字母转换为大写 #define UPCASE( c ) ( ((c) >= ''a'' && (c) <= ''z'') ? ((c) - 0x20) : (c) ) 判断字符是不是10进值的数字 #define DECCHK( c ) ((c) >= ''0'' && (c) <= ''9'') 判断字符是不是16进值的数字 #define HEXCHK( c ) ( ((c) >= ''0'' && (c) <= ''9'') ||((c) >= ''A'' && (c) <= ''F'') ||((c) >= ''a'' && (c) <= ''f'') ) 防止溢出的一个方法 #define INC_SAT( val ) (val = ((val)+1 > (val)) ? (val)+1 : (val)) 返回数组元素的个数 #define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) ) 使用一些宏跟踪调试 在调试时，我们可以设置__DEBUG宏，也可以再Makefile中使用-D编译选项设置， [cpp] view plain copy print? #define __DEBUG 使用方法为， [ cpp ] view plain copy print ? #ifdef __DEBUG printf ( \"%s\" , ...); #endif 另外，ANSI C标准中有几个标准预定义宏，前面几个（func...STDC）常用于printf(sprintf)等语句中： __func__：在源代码中插入当前所在函数名； __LINE__：在源代码中插入当前源代码行号； __FILE__：在源文件中插入当前源文件名； __DATE__：在源文件中插入当前的编译日期 __TIME__：在源文件中插入当前编译时间； __STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1； __cplusplus：当编写C++程序时该标识符被定义。 其中__cplusplus常用于头文件中，格式如下： [ cpp ] view plain copy print ? #ifndef _ZX_FUNC_H #define _ZX_FUNC_H #ifdef __cplusplus extern \"C\" { #endif /* functions */ char * strdup ( const char * s ); #ifdef __cplusplus } #endif #endif extern\"C\"表示将其中的代码按照C编译方法编译，目的是实现C++与C语言的调用。 C编译与C++编译的区别是：C会将上面strdup编译成_STRDUP符号，而C++会编译成_STRDUP_CHAR，这也是C++为什么能实现函数重载的原因。extern只能出现在C++文件中，一般如上面的方式置于头文件中。 要在C中调用C++代码，需要在C代码中的函数或变量声明为extern类型，在C++中将函数或变量用extern \"C\"修饰。 简单数学计算（绝对值，三角函数等） [cpp] view plain copy print? #define ABS( a ) ( ((a)>0) ? (a) : (-(a)) ) define 一个复杂语句 比如交换a,b的值， [cpp] view plain copy print? #define(a,b) do { \\ int t = 0; t = a; \\ a = b; \\ b = t; \\ } while(0) define的这些高级用法在Linux内核源代码很多处出现，可阅读参考内核源代码。","tags":"编程语言-C","title":"C-宏定义"},{"url":"http://king32783784.github.io/2011/07/11/C/","text":"结构体声明 例如： struct Student { char name[20]; char sex; int age; char addr[40]; } / 定义一个Student 类型的student变量 / struct Student student; 定义结构体的时候每次都要写struct显得比较繁琐，可以用typedef来方便声明。这样就可以想int、char一样定义结构体类型了。比如： typedef struct _TEST_T { int i; char c[10]; }TEST_T; 初始化 1.初始化的就是定义一个结构体变量，并且给它赋值比如： TEST_T gst = {1, \"12345\"}; /*可以初始化，设置i为1，c为一个字符串.*/ TEST_T gst = {1}; /*初始化个数少于实际个数时，只初始化前面的成员。*/ TEST_T gst = {.c=\"12345\"}; /*有选择的初始化成员。*/ 2、复合字面量。 gst = (TEST_T){122, \"1256\"}; /*这是一个赋值语句，也可以作为初始化。可以出现在程序的任何地方。*/ 当然也可以使用复合字面量来初始化： gst = (TEST_T){.i=122, .c=\"123\"}; 3、结构体数组 可以用多个大括号括起来： TEST_T gst[10] = \\{\\{\\},\\{\\},\\{\\},\\{\\}\\} 也可以初始化其中的一个元素： TEST_T gst[10] = {[2]={}, [3]={}} 也可以使用复合字面量： TEST_T gst[10] = {[2].i=0, [3].i={}} 为什么要初始化 1、对局部变量初始化可以防止随机值产生的危害。 2、对全局变量初始化可以告诉编译器，这是一个定义，而不是一个声明。（如果两个c中有相同的全局变量定义，且没有初始化，编译器会认为第二个是声明而不是定义。） 声明和定义的区别在于是否分配内存进行存储。","tags":"编程语言-C","title":"C-结构体声明"},{"url":"http://king32783784.github.io/2013/05/27/C/","text":"先看代码， minprintf #include<stdarg.h> /*minprintf:minimal printf with variable argument list */ void minprintf(char *fmt,...) { va_list ap; /*points to unnamed arg in turn */ char *p, *sval; int ival; double dval; va_start(ap,fmt); /*make ap point to 1st unamed arg*/ for (p = fmt; *p; p++) { if (*p != '%') { putchar(*p); continue; } switch(*++p) { case 'd': ival = va_arg(ap ,int); printf(\"%d\", ival); break; case 'f': ival = va_arg(ap ,double); printf(\"%f\", ival); break; case 's': for(sval = va_arg(ap,char *);*sval;sval ++) putchar(*sval); break; default: putchar(*p); break; } } va_end(ap) ; /*clean up when done*/ } 在C语言中，没有函数重载。所以要想实现不定数目的函数参数，变得比较复杂。了解这个问题，涉及到标准头文件 几个宏定义，va_start和va_end 等。在此之前，先看一下C语言中传递函数的参数时的用法和原理： 1.在c中，当我们无法列出传递函数的所有实参的类型和数目时，，可以用省略号指定参数列表。 void foo(...); void foo(parm_list,..); 这就是C中一种传参的形式，多用于变长参数表。 2.函数参数传递的原理 函数参数是以数据结构：栈的形式存取，从右至左入栈。这跟栈的机制有关。 参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数时，从最后一个开始入栈。因此栈底的高地址，栈顶低地址。void func(int x,float y,char z),在函数调用的时候，是参char z先进栈，然后是 floaty,intx,出的时候顺序是相反的。理论上说，如果我们找到任意变量的地址，并知道其他变量的类型，便可以通过移动位置（指针移位运算，找到其他的输入变量。 下面看几个宏定义 typedef char* va_list; void va_start(va_list ap, prev_param):/ANSI version*/ type va_arg(va_list ao,type); void va_end(va_list ap); va_list是一个字符指针，可以理解为当前参数的一个指针，取参必须通过这个指针进行。 1在调用参数表之前，定义一个va_list类型的变量（假设va_list类型变量被定义为ap）； 2然后应该对ap进行初始化，让它指向可变参数列表的第一个参数，是通过va_start实现的，第一个参数是ap本身，第二个参数是在变参表前面紧挨着的一个变量，即\"...\"之前的那个参数。 3 获取参数，调用va_arg,他的第一个参数是ap，第二个参数是获取的参数的指定类型，然后返回这个指定类型的值，并且把ap指向参数的下一个变量位置 4 获取所有参加之后，我们有必要将ap指针关掉，调用va_end ，他是将ap指向为空，应该养成取完参数之后，关闭指针的习惯，一般情况下，vstart 和 vend 同时出现。 如下面的小例子 #include <stdio.h> void fun ( int a ,..) { int * temp = & a ; temp ++ ; for ( int i = 0 ; i < a ; ++ i ) { printf ( \"%d\" , * temp ); temp ++ ; } } int main () { int a = 1 , int b = 2 ; int c = 3 ; int d = 4 ; fun ( 4 , a , b , c , d ); return 0 ; } 获取省略号指定的参数 在函数体声明一个va_list，然后用va_start函数获取参数列表中的参数,使用完毕后调用va_end（）结束，例如： void TestFun(char *pszDest, int DestLen, const char* pszFormat,...) { va_list args; va_start(args,pszFormat); //\"一定要\"...\"之前的那个参数 _vsnprintf(pszDest,Destlen,pszFormat,args); va_end(args); } 5.如何使用参数个数可变的函数, #include <stdio.h> #include <string.h> #include <stdarg.h> /*注意函数原型声明,至少有一个确定的参数,后面跟省略号*/ int demo ( char ,...) void main ( void ) { demo ( \"DEMO\" , \"This\" , \"is\" , \"a\" , \"demo!\" , \" \" ); } int demo ( char msg ,...) { /*定义保存函数参数的结构*/ va_list argp ; int argno = 0 ; char para ; /*argp 指向第一个可选参数,msg是最后一个确定的参数*/ va_start ( argp , msg ); { while ( 1 ) { para = va_arg ( argp , char ); if ( strcmp ( para , \" \" ) == 0 ) break ; printf ( \"Parameter #%d is :%s \\n \" , argno , para ); argno ++ ; } va_end ( argp ) retrun 0 ; } 6 回过头来看一下一开始那个程序. minprintf函数用来遍历printf函数的参数表,它的参数为printf函数中参数的指针 指针ap 用来实现遍历函数的参数列表.在函数运行中ap会先后指向参数表中的每一个参数. va_start(ap,fmt).ap指向省略中的第一个参数.fmt指向最后一个函数参数表中有名参数.即开始时ap指向的参数的前一个参数. for(p =fmt; p;p++),p初始为 fmt ,即指向ap前一个参数,通过对p的循环实现ap指针遍历省略的参数表. 就有了下面的switch,来讨论可能出现的参数. 最后通过va_end(ap),将ap指向NULL.避免出现异常.注意:，应该养成，关闭指针的习惯. Top &#94;","tags":"编程语言-C","title":"通过printf函数简单实现解析不定参数表"},{"url":"http://king32783784.github.io/2011/08/15/C/","text":"1.简单的宏定义 #define MAXTIME 1000 简单的MATIME定义好了，它代表1000，如果在程序中写： if(i<MAXTIME){...} 编译器在处理这个代码之前会对MAXTIME进行替换为1000。 宏定义类同于简单的文本替换，而不是变量。 2.define的\"函数定义\" define可以像函数那样接受一些参数，如下： #define max(x,y)(x)>(y)?(x):(y); 这个定义将返回两个数中最大的，而且这个函数没有经过类型检查，好像函数模板，但没有模板安全。存在隐患： #define Add(a,b) a+b; 如果代数式 c Add(a,b) d,本意为a+b然后去和c、d相乘，而define只是一个简单替换，式子反而变为了： c a + b d ,忽略了运算规则。 #define pin(int*); pin a,b; 本来是想定义a，b都是int型指针，而一替换变成了 int*a,b; 3.宏的单行定义 #define A(x) T_##x #define B (x)#@x #define C (x)#x 我们假设x=1,则有： A(1): T_1 B(1): '1' C(1): \"1\" 3.define的多行定义 define可以替换多行的代码，例如MFC中的宏定义 #define MACRO(arg1, arg2) do{/ /*declarations*/ stmt1;/ stmt2;/ }while(0) /*(no trailing;)*/ 每行换行时加上换行符\"/\" 4.条件编译 在大规模的开发中，define最重要的功能就是条件编译。也就是本文的用法。 #ifdef UCLINU ... ... #endif 编译时，可以通过#define设置编译环境 5如何定义宏，取消宏 //定义宏 #define [MarcoName] [Macro Value] //取消宏 #undef [MacroName] //普通宏 #define PI(3.14] //带参数的宏 #define max(a,b)((a)>(b)?(a),(b)) 加括号是个好习惯哦 6.头文件(.h)可以被头文件或C文件包含 重复包含（重复定义） 由于头文件包含可以嵌套，那么C文件就有可能包含多次同一个头文件，就可能出现重复定义的问题的。 通过条件编译开关来避免重复包含（重复定义） 例如 #ifndef headerfileXXX #define headerfileXXX … //文件内容 … #endif 7.define命令的一些高级用法 define中的三个特殊符号\"#\" \"##\" \"#@\"，前面提到过但未解释。 #define Conn(x,y) x##y x##y 表示什么？ 表示x连接y, int n = Conn(123, 456); //表示n=123456 相信你已经猜到了 char* str = Conn(\"asdf\", \"adf\"); //表示str = \"asdfadf\" #define ToChar(x) #@x @x，就是给x加上单引号，返回一个const char: char a = ToChar(1) //a='1' x, 就是加双引号. 下面看一下宏定义常用用法： 防止头文件被重复包含： #ifdef BODYDEF_H #define BODYDEF_H ... #endif 得到指定地址上的一个字节或字： #define MEM_B( x ) ( *( (byte *) (x) ) ) #define MEM_W( x ) ( *( (word *) (x) ) ) 得到一个field在结构体(struct)中的偏移量 #define OFFSETOF( type, field ) ( (size_t) &(( type *) 0)-> field ) 得到一个结构体中field所占用的字节数 #define FSIZ( type, field ) sizeof( ((type *) 0)->field ) 得到一个变量的地址（word宽度） #define B_PTR( var ) ( (byte *) (void *) &(var) ) #define W_PTR( var ) ( (word *) (void *) &(var) ) 将一个字母转换为大写 #define UPCASE( c ) ( ((c) >= ''a'' && (c) <= ''z'') ? ((c) - 0x20) : (c) ) 判断字符是不是10进值的数字 #define DECCHK( c ) ((c) >= ''0'' && (c) <= ''9'') 判断字符是不是16进值的数字 #define HEXCHK( c ) ( ((c) >= ''0'' && (c) <= ''9'') ||((c) >= ''A'' && (c) <= ''F'') ||((c) >= ''a'' && (c) <= ''f'') ) 防止溢出的一个方法 #define INC_SAT( val ) (val = ((val)+1 > (val)) ? (val)+1 : (val)) 返回数组元素的个数 #define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) ) 使用一些宏跟踪调试 在调试时，我们可以设置__DEBUG宏，也可以再Makefile中使用-D编译选项设置， [cpp] view plain copy print? #define __DEBUG 使用方法为， [ cpp ] view plain copy print ? #ifdef __DEBUG printf ( \"%s\" , ...); #endif 另外，ANSI C标准中有几个标准预定义宏，前面几个（func...STDC）常用于printf(sprintf)等语句中： __func__：在源代码中插入当前所在函数名； __LINE__：在源代码中插入当前源代码行号； __FILE__：在源文件中插入当前源文件名； __DATE__：在源文件中插入当前的编译日期 __TIME__：在源文件中插入当前编译时间； __STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1； __cplusplus：当编写C++程序时该标识符被定义。 其中__cplusplus常用于头文件中，格式如下： [ cpp ] view plain copy print ? #ifndef _ZX_FUNC_H #define _ZX_FUNC_H #ifdef __cplusplus extern \"C\" { #endif /* functions */ char * strdup ( const char * s ); #ifdef __cplusplus } #endif #endif extern\"C\"表示将其中的代码按照C编译方法编译，目的是实现C++与C语言的调用。 C编译与C++编译的区别是：C会将上面strdup编译成_STRDUP符号，而C++会编译成_STRDUP_CHAR，这也是C++为什么能实现函数重载的原因。extern只能出现在C++文件中，一般如上面的方式置于头文件中。 要在C中调用C++代码，需要在C代码中的函数或变量声明为extern类型，在C++中将函数或变量用extern \"C\"修饰。 简单数学计算（绝对值，三角函数等） [cpp] view plain copy print? #define ABS( a ) ( ((a)>0) ? (a) : (-(a)) ) define 一个复杂语句 比如交换a,b的值， [cpp] view plain copy print? #define(a,b) do { \\ int t = 0; t = a; \\ a = b; \\ b = t; \\ } while(0) define的这些高级用法在Linux内核源代码很多处出现，可阅读参考内核源代码。","tags":"编程语言-C","title":"C-宏定义"},{"url":"http://king32783784.github.io/2013/05/27/C/","text":"先看代码， minprintf #include<stdarg.h> /*minprintf:minimal printf with variable argument list */ void minprintf(char *fmt,...) { va_list ap; /*points to unnamed arg in turn */ char *p, *sval; int ival; double dval; va_start(ap,fmt); /*make ap point to 1st unamed arg*/ for (p = fmt; *p; p++) { if (*p != '%') { putchar(*p); continue; } switch(*++p) { case 'd': ival = va_arg(ap ,int); printf(\"%d\", ival); break; case 'f': ival = va_arg(ap ,double); printf(\"%f\", ival); break; case 's': for(sval = va_arg(ap,char *);*sval;sval ++) putchar(*sval); break; default: putchar(*p); break; } } va_end(ap) ; /*clean up when done*/ } 在C语言中，没有函数重载。所以要想实现不定数目的函数参数，变得比较复杂。了解这个问题，涉及到标准头文件 几个宏定义，va_start和va_end 等。在此之前，先看一下C语言中传递函数的参数时的用法和原理： 1.在c中，当我们无法列出传递函数的所有实参的类型和数目时，，可以用省略号指定参数列表。 void foo(...); void foo(parm_list,..); 这就是C中一种传参的形式，多用于变长参数表。 2.函数参数传递的原理 函数参数是以数据结构：栈的形式存取，从右至左入栈。这跟栈的机制有关。 参数的内存存放格式：参数存放在内存的堆栈段中，在执行函数时，从最后一个开始入栈。因此栈底的高地址，栈顶低地址。void func(int x,float y,char z),在函数调用的时候，是参char z先进栈，然后是 floaty,intx,出的时候顺序是相反的。理论上说，如果我们找到任意变量的地址，并知道其他变量的类型，便可以通过移动位置（指针移位运算，找到其他的输入变量。 下面看几个宏定义 typedef char* va_list; void va_start(va_list ap, prev_param):/ANSI version*/ type va_arg(va_list ao,type); void va_end(va_list ap); va_list是一个字符指针，可以理解为当前参数的一个指针，取参必须通过这个指针进行。 1在调用参数表之前，定义一个va_list类型的变量（假设va_list类型变量被定义为ap）； 2然后应该对ap进行初始化，让它指向可变参数列表的第一个参数，是通过va_start实现的，第一个参数是ap本身，第二个参数是在变参表前面紧挨着的一个变量，即\"...\"之前的那个参数。 3 获取参数，调用va_arg,他的第一个参数是ap，第二个参数是获取的参数的指定类型，然后返回这个指定类型的值，并且把ap指向参数的下一个变量位置 4 获取所有参加之后，我们有必要将ap指针关掉，调用va_end ，他是将ap指向为空，应该养成取完参数之后，关闭指针的习惯，一般情况下，vstart 和 vend 同时出现。 如下面的小例子 #include <stdio.h> void fun ( int a ,..) { int * temp = & a ; temp ++ ; for ( int i = 0 ; i < a ; ++ i ) { printf ( \"%d\" , * temp ); temp ++ ; } } int main () { int a = 1 , int b = 2 ; int c = 3 ; int d = 4 ; fun ( 4 , a , b , c , d ); return 0 ; } 获取省略号指定的参数 在函数体声明一个va_list，然后用va_start函数获取参数列表中的参数,使用完毕后调用va_end（）结束，例如： void TestFun(char *pszDest, int DestLen, const char* pszFormat,...) { va_list args; va_start(args,pszFormat); //\"一定要\"...\"之前的那个参数 _vsnprintf(pszDest,Destlen,pszFormat,args); va_end(args); } 5.如何使用参数个数可变的函数, #include <stdio.h> #include <string.h> #include <stdarg.h> /*注意函数原型声明,至少有一个确定的参数,后面跟省略号*/ int demo ( char ,...) void main ( void ) { demo ( \"DEMO\" , \"This\" , \"is\" , \"a\" , \"demo!\" , \" \" ); } int demo ( char msg ,...) { /*定义保存函数参数的结构*/ va_list argp ; int argno = 0 ; char para ; /*argp 指向第一个可选参数,msg是最后一个确定的参数*/ va_start ( argp , msg ); { while ( 1 ) { para = va_arg ( argp , char ); if ( strcmp ( para , \" \" ) == 0 ) break ; printf ( \"Parameter #%d is :%s \\n \" , argno , para ); argno ++ ; } va_end ( argp ) retrun 0 ; } 6 回过头来看一下一开始那个程序. minprintf函数用来遍历printf函数的参数表,它的参数为printf函数中参数的指针 指针ap 用来实现遍历函数的参数列表.在函数运行中ap会先后指向参数表中的每一个参数. va_start(ap,fmt).ap指向省略中的第一个参数.fmt指向最后一个函数参数表中有名参数.即开始时ap指向的参数的前一个参数. for(p =fmt; p;p++),p初始为 fmt ,即指向ap前一个参数,通过对p的循环实现ap指针遍历省略的参数表. 就有了下面的switch,来讨论可能出现的参数. 最后通过va_end(ap),将ap指向NULL.避免出现异常.注意:，应该养成，关闭指针的习惯. Top &#94;","tags":"编程语言-C","title":"通过printf函数简单实现解析不定参数表"},{"url":"http://king32783784.github.io/2009/10/10/UNIX/","text":"一、追加至一个文件 一个进程，将数据添加到一个文件尾端。早期不支持open的O_APPEND选项。所有程序被编写成下列形式 if (lseek(fd, 0L, 2 ) < 0) /* position to EOF*/ err_sys(\"lseek error\"); if (write(fd, buf, 100) != 100) /* and write */ err_sys(\"write error\"); 单个进程而言，可以正常工作，但若有多个进程同事使用这种方法将数据添加到同一文件，则会产生问题。 UNIX系统提供了一种方法使这种操作成为原子操作。该方法是在打开文件时设置O_APPEND标志。使内核每次对这种文件进行写之前，都将当前偏移量设置到该文件的尾端处，每次写之前就不在需要调用lseek。 二、pread和 pwrite函数 原型如下： #include ＜unistd.h> ssize_t pread (int filedes, void *buf, size_t nbytes, off_t offset); 返回值：读到的字节数，若已到文件结尾则返回0，若出错则返回-1 ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset); 若成功，返回已写的字节数，若出错则返回-1 调用pread相当于顺序调用lseek和read,但是pread与这种顺序调用存在区别 调用pread时，无法中断其定位和读写作。 不能更新文件指针 三、创建一个文件 当用open进行打开文件时，如果该文件已经存在，open将失败。检查文件是否存在和创建该文件这两个操作是作为一个原子操作执行的。如果没有这个原子操作，需要用下面程序段。 if((fd = open(pathname, O_WRONLY)) < 0 ) { if （errno == ENOENT) { if ((fd = creat(pathname, mode)) < 0) err_sys(\"creat error\"); } else { err_sys(\"open error\"); } } 如果在open和creat之间，另一个进程创建了该文件，那么就会引起问题。例如，若在这两个函数调用之间，另一个进程创建了该文件，并且写进了一些数据。然后，原先的进程执行这段程序的creat。刚由另一个进程写上去的数据就会被擦除。这样两则合并为一个原子操作，就不会发生该问题。 一般而言，原子操作，指的是由多步组成的操作，如果操作原子地执行，那么执行完所有步骤，要么不执行，不可能只执行一部分。 Top &#94;","tags":"unix环境编程","title":"原子操作"},{"url":"http://king32783784.github.io/2009/10/12/UNIX/","text":"信号 我们运行如下命令，可看到Linux支持的信号列表： $ kill -l1 ) SIGHUP 2 ) SIGINT 3 ) SIGQUIT 4 ) SIGILL 5 ) SIGTRAP 6 ) SIGABRT 7 ) SIGBUS 8 ) SIGFPE 9 ) SIGKILL 10 ) SIGUSR1 11 ) SIGSEGV 12 ) SIGUSR213 ) SIGPIPE 14 ) SIGALRM 15 ) SIGTERM 17 ) SIGCHLD18 ) SIGCONT 19 ) SIGSTOP 20 ) SIGTSTP 21 ) SIGTTIN22 ) SIGTTOU 23 ) SIGURG 24 ) SIGXCPU 25 ) SIGXFSZ26 ) SIGVTALRM 27 ) SIGPROF 28 ) SIGWINCH 29 ) SIGIO30 ) SIGPWR 31 ) SIGSYS 34 ) SIGRTMIN 35 ) SIGRTMIN+136 ) SIGRTMIN+2 37 ) SIGRTMIN+3 38 ) SIGRTMIN+4 39 ) SIGRTMIN+540 ) SIGRTMIN+6 41 ) SIGRTMIN+7 42 ) SIGRTMIN+8 43 ) SIGRTMIN+944 ) SIGRTMIN+10 45 ) SIGRTMIN+11 46 ) SIGRTMIN+12 47 ) SIGRTMIN+1348 ) SIGRTMIN+14 49 ) SIGRTMIN+15 50 ) SIGRTMAX-14 51 ) SIGRTMAX-1352 ) SIGRTMAX-12 53 ) SIGRTMAX-11 54 ) SIGRTMAX-10 55 ) SIGRTMAX-956 ) SIGRTMAX-8 57 ) SIGRTMAX-7 58 ) SIGRTMAX-6 59 ) SIGRTMAX-560 ) SIGRTMAX-4 61 ) SIGRTMAX-3 62 ) SIGRTMAX-2 63 ) SIGRTMAX-164 ) SIGRTMAX 列表中，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。 下面我们对编号小于SIGRTMIN的信号进行说明。 1) SIGHUP 本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。 登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程 序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP 信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽 略它，这样就算退出了Linux登录，wget也能继续下载。 此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。 2) SIGINT 程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。 3) SIGQUIT 和SIGINT类似, 但由QUIT字符(通常是Ctrl-)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。 4) SIGILL 执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。 5) SIGTRAP 由断点指令或其它trap指令产生. 由debugger使用。 6) SIGABRT 调用abort函数生成的信号。 7) SIGBUS 非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。 8) SIGFPE 在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。 9) SIGKILL 用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。 10) SIGUSR1 留给用户使用 11) SIGSEGV 试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据. 12) SIGUSR2 留给用户使用 13) SIGPIPE 管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。 14) SIGALRM 时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号. 15) SIGTERM 程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。 17) SIGCHLD 子进程结束时, 父进程会收到这个信号。 如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核 进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或 者父进程先终止，这时子进程的终止自动由init进程来接管)。 18) SIGCONT 让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符 19) SIGSTOP 停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略. 20) SIGTSTP 停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号 21) SIGTTIN 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行. 22) SIGTTOU 类似于SIGTTIN, 但在写终端(或修改终端模式)时收到. 23) SIGURG 有\"紧急\"数据或out-of-band数据到达socket时产生. 24) SIGXCPU 超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。 25) SIGXFSZ 当进程企图扩大文件以至于超过文件大小资源限制。 26) SIGVTALRM 虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间. 27) SIGPROF 类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间. 28) SIGWINCH 窗口大小改变时发出. 29) SIGIO 文件描述符准备就绪, 可以开始进行输入/输出操作. 30) SIGPWR Power failure 31) SIGSYS 非法的系统调用。 在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP 不能恢复至默认动作的信号有：SIGILL,SIGTRAP 默认会导致进程流产的信号有：SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGIOT,SIGQUIT,SIGSEGV,SIGTRAP,SIGXCPU,SIGXFSZ 默认会导致进程退出的信号有：SIGALRM,SIGHUP,SIGINT,SIGKILL,SIGPIPE,SIGPOLL,SIGPROF,SIGSYS,SIGTERM,SIGUSR1,SIGUSR2,SIGVTALRM 默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU 默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH 此外，SIGIO在SVR4是退出，在4.3BSD中是忽略；SIGCONT在进程挂起时是继续，否则是忽略，不能被阻塞 可靠信号与不可靠信号测试: #include <stdio.h> #include <signal.h> static volatile int signum = 0 ; void sigme ( int signo ) { printf ( \"signal received:%d \\n \" , signum ++ ); sleep ( 3 ); } int main () { signal ( SIGUSR1 , sigme ); /*signal(SIGRTMIN, sigme);*/ while ( 1 ); return 0 ; } 在3秒内向这个程序发送SIGUSR1，只有第一个被接收到，而SIGRTMIN则不会有这样的问题。","tags":"unix环境编程","title":"信号"}]}