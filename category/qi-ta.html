<!DOCTYPE html>
<html lang="zh">
<head>

        <title>Hi | World</title>
        <meta charset="utf-8" />
        <link href="http://king32783784.github.io/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Hi | World Full Atom Feed" />
        <link href="http://king32783784.github.io/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="Hi | World Full RSS Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="../theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="../theme/style.css" />
        <link rel="stylesheet" type="text/css" href="../theme/pygment.css" />
        <link rel="stylesheet" type="text/css" href="../theme/SentyZHAO/SentyZHAO.css" />

        <script src="../theme/js/libs/jquery-1.9.1.min.js"></script>
        <script src="../theme/js/libs/modernizr-2.6.2.min.js"></script>
</head>

<body id="index" class="home">
    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1 style='font-family: "SentyZHAO";'><a href="..">Hi | World <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>

              <ul class="columns" style='font-family: "SentyZHAO";'>
                <li><a href="..">主 页</a></li>

                <li><a href="../pages/tech-share.html">归档</a></li>
                <li><a href="../pages/opensource.html">开源项目</a></li>
                <li><a href="../pages/links.html">链接</a></li>
                <li><a href="../pages/Reference material.html">参考资料</a></li>
                <li><a href="../pages/tools.html">工具集</a></li>
                <li class="active"><a href="../pages/aboutme.html">关于我</a></li>

              </ul>
            </div>

<section id="content" class="body">
<h2>Articles in the 其他 category</h2>
<div class="row">
    <div class="eleven columns">
        <ol id="post-list">
            <li>
            <article class="hentry">
                <header>
                    <h2 class="entry-title">
                        <a href="../2016/08/12/Docker/" rel="bookmark" title="Permalink to Docker基础技术：Linux Namespace（下）">Docker基础技术：Linux Namespace（下）<转></a>
                    </h2>
                </header>
                <footer class="post-info">
                    <abbr class="published" title="2016-08-12T00:00:00+08:00"> 2016-08-12 五 </abbr>
<address class="vcard author">By <a class="url fn" href="../author/others.html">others</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> </head><body><p>在 <a href="https://king32783784.github.io/lipeng/2016/08/11/Docker/">Docker基础技术：Linux Namespace（上篇)</a>中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。
<img alt="" src="https://king32783784.github.io/lipeng/tmpfile/jail_cell.jpg"/></p>
<p>好，下面我们就介绍一下还剩下的这两个Namespace。</p>
<h4 id="user-namespace">User Namespace</h4>
<p><strong>User Namespace</strong> 主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。</p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改 <strong>/proc/<pid>/uid_map</pid></strong>  和 <strong>/proc/<pid>/gid_map</pid></strong> 这两个文件。这两个文件的格式为：</p>
<p>ID-inside-ns ID-outside-ns length</p>
<p>其中：</p>
<ul>
<li>第一个字段ID-inside-ns表示在容器显示的UID或GID，</li>
<li>第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。</li>
<li>第三个字段表示映射的范围，一般填1，表示一一对应。</li>
</ul>
<p>比如 ...</p></body> </div><!-- /.entry-content -->
                <div class="medium primary btn"><a href="../2016/08/12/Docker/" rel="bookmark" title="Permalink to Docker基础技术：Linux Namespace（下）">Read more <i class="icon-arrow-right"></i></a></div>
                <div class="row tag-row">
                    <span>Tagged as : </span>
                    <a class="danger label" href="../tag/docker.html">Docker</a>
                </div>
            </article>
            </li>
            <li>
            <article class="hentry">
                <header>
                    <h2 class="entry-title">
                        <a href="../2016/08/11/Docker/" rel="bookmark" title="Permalink to Docker基础技术：Linux Namespace（上）">Docker基础技术：Linux Namespace（上）<转></a>
                    </h2>
                </header>
                <footer class="post-info">
                    <abbr class="published" title="2016-08-11T00:00:00+08:00"> 2016-08-11 四 </abbr>
<address class="vcard author">By <a class="url fn" href="../author/others.html">others</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> </head><body><p>时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New “Old Stuff”。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。
<img alt="" src="https://king32783784.github.io/lipeng/tmpfile/isolation.jpg"/></p>
<p>当然，文章的风格一定会尊重时下的“流行”——我们再也没有整块整块的时间去看书去专研，而我们只有看微博微信那样的碎片时间（那怕我们有整块的时间，也被那些在手机上的APP碎片化了）。所以，这些文章的风格必然坚持“马桶风格”（希望简单到占用你拉一泡屎就时间，而且你还不用动脑子，并能学到些东西）</p>
<p>废话少说，我们开始。先从Linux Namespace开始。</p>
<h4 id="jian-jie">简介</h4>
<p>Linux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。</p>
<p>举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以 ...</p></body> </div><!-- /.entry-content -->
                <div class="medium primary btn"><a href="../2016/08/11/Docker/" rel="bookmark" title="Permalink to Docker基础技术：Linux Namespace（上）">Read more <i class="icon-arrow-right"></i></a></div>
                <div class="row tag-row">
                    <span>Tagged as : </span>
                    <a class="danger label" href="../tag/docker.html">Docker</a>
                </div>
            </article>
            </li>
            <li>
            <article class="hentry">
                <header>
                    <h2 class="entry-title">
                        <a href="../2016/08/11/Performance/" rel="bookmark" title="Permalink to 如何做性能测试">如何做性能测试<转></a>
                    </h2>
                </header>
                <footer class="post-info">
                    <abbr class="published" title="2016-08-11T00:00:00+08:00"> 2016-08-11 四 </abbr>
<address class="vcard author">By <a class="url fn" href="../author/others.html">others</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> </head><body><p>偶然间看到了阿里中间件Dubbo的性能测试报告，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。</p>
<p>首先，这份测试报告里的主要问题如下：</p>
<ul>
<li>
<p>用的全是平均值。老实说，平均值是非常不靠谱的。</p>
</li>
<li>
<p>响应时间没有和吞吐量TPS/QPS挂钩。而只是测试了低速率的情况，这是完全错误的。</p>
</li>
<li>
<p>响应时间和吞吐量没有和成功率挂钩。</p>
</li>
</ul>
<h4 id="wei-shi-yao-ping-jun-zhi-bu-kao-pu">为什么平均值不靠谱</h4>
<p>关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到，<strong>平均工资</strong>，<strong>平均房价</strong>，<strong>平均支出</strong>，等等这样的字眼，你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力）</p>
<p>软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章《Why Averages Suck and Percentiles are Great》，我在这里简单说一下。</p>
<p>我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如，<strong>测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况 ...</strong></p></body> </div><!-- /.entry-content -->
                <div class="medium primary btn"><a href="../2016/08/11/Performance/" rel="bookmark" title="Permalink to 如何做性能测试">Read more <i class="icon-arrow-right"></i></a></div>
                <div class="row tag-row">
                    <span>Tagged as : </span>
                    <a class="danger label" href="../tag/xing-neng-ce-shi.html">性能测试</a>
                </div>
            </article>
            </li>
            <li>
            <article class="hentry">
                <header>
                    <h2 class="entry-title">
                        <a href="../2015/08/18/autotest/" rel="bookmark" title="Permalink to Autotest-Linux distribution detection">Autotest-Linux distribution detection</a>
                    </h2>
                </header>
                <footer class="post-info">
                    <abbr class="published" title="2015-08-18T00:00:00+08:00"> 2015-08-18 二 </abbr>
<address class="vcard author">By <a class="url fn" href="../author/penglee.html">penglee</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> </head><body><p><img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/></p>
<h2 id="linuxfa-xing-ban-jian-ce">linux发行版检测</h2>
<p>Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上.
这个功能是由probe类群的实现和注册实现的.
这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等.</p>
<h3 id="kuai-su-jian-cha-fa-xing-ban">快速检查发行版</h3>
<p>autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect().
它的用法简单命了:</p>
<div class="highlight"><pre><span></span>    <span class="kn">from</span> <span class="nn">autotest.client.shared</span> <span class="kn">import</span> <span class="n">distro</span>
    <span class="n">detected_distro</span> <span class="o">=</span> <span class="n">distro</span><span class="o">.</span><span class="n">detect</span><span class="p">()</span>
</pre></div>
<p>这样就可以返回发行版检测的结果,但是不太适用于<strong>UNKNOWN_DISIRO</strong>.</p>
<ul>
<li>name</li>
<li>version</li>
<li>release</li>
<li>arch</li>
</ul>
<p>例如:</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt;detected_distro = distro.detect()
&gt;&gt;&gt;print detected_distro.name
redhat
</pre></div>
<h3 id="wei-zhi-fa-xing-ban">未知发行版</h3>
<p>当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊.</p>
<div class="highlight"><pre><span></span> autotest.clientshared.distro.UNKNOWN_DISIRO ...</pre></div></body> </div><!-- /.entry-content -->
                <div class="medium primary btn"><a href="../2015/08/18/autotest/" rel="bookmark" title="Permalink to Autotest-Linux distribution detection">Read more <i class="icon-arrow-right"></i></a></div>
                <div class="row tag-row">
                    <span>Tagged as : </span>
                    <a class="danger label" href="../tag/zi-dong-hua-ce-shi.html">自动化测试</a>
                </div>
            </article>
            </li>
            <li>
            <article class="hentry">
                <header>
                    <h2 class="entry-title">
                        <a href="../2015/08/17/autotest/" rel="bookmark" title="Permalink to Autotest-Using and developing job profilers">Autotest-Using and developing job profilers</a>
                    </h2>
                </header>
                <footer class="post-info">
                    <abbr class="published" title="2015-08-17T00:00:00+08:00"> 2015-08-17 一 </abbr>
<address class="vcard author">By <a class="url fn" href="../author/penglee.html">penglee</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> </head><body><p><img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/></p>
<h2 id="shi-yong-he-tian-jia-ce-shi-fen-xi-qi">使用和添加测试分析器</h2>
<p>添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子:</p>
<ul>
<li>一个控制文件. profilers/myprofiler/control</li>
<li>分析器控制脚本. profilers/myprofiler.py</li>
<li>分析器的源码(如果不仅仅是控制脚本)</li>
</ul>
<p>我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核.</p>
<p>控制文件非常简单,像这样:</p>
<div class="highlight"><pre><span></span>job.profilers.add('readprofile')
job.run_test('sleeptest', 1)
job.profilers.delete('readprofile')
</pre></div>
<p>只是说明"请再以下测试中使用readprofile".一次测试,如果想添加多个分析器,可以多次调用profilers.add.</p>
<p>还有源码包"util-linux-2.12r.tar.bz2",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile ...</p></body> </div><!-- /.entry-content -->
                <div class="medium primary btn"><a href="../2015/08/17/autotest/" rel="bookmark" title="Permalink to Autotest-Using and developing job profilers">Read more <i class="icon-arrow-right"></i></a></div>
                <div class="row tag-row">
                    <span>Tagged as : </span>
                    <a class="danger label" href="../tag/zi-dong-hua-ce-shi.html">自动化测试</a>
                </div>
            </article>
            </li>
            <li>
            <article class="hentry">
                <header>
                    <h2 class="entry-title">
                        <a href="../2015/08/16/autotest/" rel="bookmark" title="Permalink to Autotest-add test">Autotest-add test</a>
                    </h2>
                </header>
                <footer class="post-info">
                    <abbr class="published" title="2015-08-16T00:00:00+08:00"> 2015-08-16 日 </abbr>
<address class="vcard author">By <a class="url fn" href="../author/penglee.html">penglee</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> </head><body><p><img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/></p>
<h2 id="ce-shi-mo-kuai-kai-fa">测试模块开发</h2>
<p>测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的）</p>
<p>测试模块需要：</p>
<ul>
<li>可以跨多硬件架构</li>
<li>可以支持不同的发行版</li>
<li>至少一个维护者</li>
<li>提供一个默认的简单例子</li>
<li>对自己目录外的东西不做修改</li>
</ul>
<h2 id="tian-jia-ce-shi-xiang">添加测试项</h2>
<p>增加一个测试项，可能是最容易的开发工作了．</p>
<p>每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括
<em> 一个control 文件（tests/mytest/control)
</em> 一个测试包装脚本（tests/mytest/mytest.py)
* 如果不仅仅是python脚本中实现的，还需要补充测试源码</p>
<p>可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py,  包括其中命名为dbench的类．这些这新开发的测试中
也必须要有．</p>
<p>control文件至少是：</p>
<div class="highlight"><pre><span></span>job.run_test('dbench')
</pre></div>
<p>这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西．</p>
<p>目录下同样有个测试工具源码包dbench-3 ...</p></body> </div><!-- /.entry-content -->
                <div class="medium primary btn"><a href="../2015/08/16/autotest/" rel="bookmark" title="Permalink to Autotest-add test">Read more <i class="icon-arrow-right"></i></a></div>
                <div class="row tag-row">
                    <span>Tagged as : </span>
                    <a class="danger label" href="../tag/zi-dong-hua-ce-shi.html">自动化测试</a>
                </div>
            </article>
            </li>
            <li>
            <article class="hentry">
                <header>
                    <h2 class="entry-title">
                        <a href="../2015/08/15/autotest/" rel="bookmark" title="Permalink to Autotest-Control file specification">Autotest-Control file specification</a>
                    </h2>
                </header>
                <footer class="post-info">
                    <abbr class="published" title="2015-08-15T00:00:00+08:00"> 2015-08-15 六 </abbr>
<address class="vcard author">By <a class="url fn" href="../author/penglee.html">penglee</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> </head><body><p><img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/></p>
<h2 id="control-file-specification">Control file specification</h2>
<p>该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改.
主要内容:</p>
<ul>
<li>命名control文件</li>
<li>常用变量</li>
<li>示例</li>
</ul>
<h3 id="controlwen-jian-ming-ming">control文件命名</h3>
<p>control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义．　例如，５００次硬重启测试，一个正规的定义就是　control.hard500</p>
<h3 id="chang-yong-bian-liang">常用变量</h3>
<p>下面是一个常用变量的列表</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>*AUTHOR</td>
<td>测试编写的个人或公司信息</td>
</tr>
<tr>
<td>ＤEPENENCIES</td>
<td>测试依赖信息，比如"CONSOLE"</td>
</tr>
<tr>
<td>*DOC</td>
<td>描述测试包括哪些参数的说明</td>
</tr>
<tr>
<td>EXPERIMENTAL</td>
<td>如果定义为True,测试忽略</td>
</tr>
<tr>
<td>*NAME</td>
<td>前端识别测试的名称</td>
</tr>
<tr>
<td>RUN_VERIFY</td>
<td>定义scheduler是否执行验证，默认为True</td>
</tr>
<tr>
<td>SYNC_COUNT</td>
<td>次数，接受大于等于１的参数，默认为１</td>
</tr>
<tr>
<td>*TIME</td>
<td>说明测试时长，　ＳＨＯＲＴ&lt;15m, MEDIUM &lt; 4H ,LONG ...</td></tr></tbody></table></body> </div><!-- /.entry-content -->
                <div class="medium primary btn"><a href="../2015/08/15/autotest/" rel="bookmark" title="Permalink to Autotest-Control file specification">Read more <i class="icon-arrow-right"></i></a></div>
                <div class="row tag-row">
                    <span>Tagged as : </span>
                    <a class="danger label" href="../tag/zi-dong-hua-ce-shi.html">自动化测试</a>
                </div>
            </article>
            </li>
            <li>
            <article class="hentry">
                <header>
                    <h2 class="entry-title">
                        <a href="../2015/08/14/autotest/" rel="bookmark" title="Permalink to Autotest-client control">Autotest-client control</a>
                    </h2>
                </header>
                <footer class="post-info">
                    <abbr class="published" title="2015-08-14T00:00:00+08:00"> 2015-08-14 五 </abbr>
<address class="vcard author">By <a class="url fn" href="../author/penglee.html">penglee</a></address>                </footer><!-- /.post-info -->
                <div class="entry-content"> </head><body><p><img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/></p>
<h2 id="client-control-files">Client Control files</h2>
<p><strong>主要内容</strong></p>
<ul>
<li>jobs 例子</li>
<li>扩展测试</li>
<li>流程控制</li>
<li>系统信息抓取</li>
<li>分析器</li>
<li>创建文件系统</li>
<li>job执行期间重启</li>
<li>并行运行多个测试</li>
</ul>
<p>control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试.</p>
<h2 id="jobli-zi">job例子</h2>
<p>可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样:</p>
<div class="highlight"><pre><span></span>job.run_test('kernbench')
</pre></div>
<p>参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/<testname>/control
在autotestclient端的顶层目录下,你可以执行测试:</testname></p>
<div class="highlight"><pre><span></span>$ client/autotest-local &lt;control_file_name&gt;
</pre></div>
<p>在control文件中同样可以指定测试参数</p>
<div class="highlight"><pre><span></span>job.run_test('kernbench', iterations=2, threads=5)
</pre></div>
<ul>
<li>第一个参数是测试名称;</li>
<li>第二个参数是执行次数和线程数,大多数你可以执行它的默认参数.</li>
</ul>
<p>还可以指定一个tag参数,用来给测试结果目录命名 ...</p></body> </div><!-- /.entry-content -->
                <div class="medium primary btn"><a href="../2015/08/14/autotest/" rel="bookmark" title="Permalink to Autotest-client control">Read more <i class="icon-arrow-right"></i></a></div>
                <div class="row tag-row">
                    <span>Tagged as : </span>
                    <a class="danger label" href="../tag/zi-dong-hua-ce-shi.html">自动化测试</a>
                </div>
            </article>
            </li>
        </ol><!-- /#posts-list -->
    </div><!-- /.eleven.columns -->
<div class="three columns">

<!--
<h4>Pages</h4>

 <ul>
      <li><a href="../pages/tech-share.html">归档</a></li>
      <li><a href="../pages/opensource.html">开源项目</a></li>
      <li><a href="../pages/links.html">链接</a></li>
      <li><a href="../pages/Reference material.html">参考资料</a></li>
      <li><a href="../pages/tools.html">工具集</a></li>
      <li class="active"><a href="../pages/aboutme.html">关于我</a></li>
  </ul>
-->
<!--
<h4>分类</h4>
<ul>
		<li><a href="../category/qi-ta.html">其他</a></li>
</ul>
-->

<h4>标签</h4>
	<ul>
	    <li class="tag-4"><a href="../tag/xing-neng-ce-shi.html">性能测试</a></li>
	    <li class="tag-4"><a href="../tag/unixbian-cheng.html">unix编程</a></li>
	    <li class="tag-4"><a href="../tag/linux.html">Linux</a></li>
	    <li class="tag-1"><a href="../tag/zi-dong-hua-ce-shi.html">自动化测试</a></li>
	    <li class="tag-3"><a href="../tag/suan-fa.html">算法</a></li>
	    <li class="tag-3"><a href="../tag/docker.html">Docker</a></li>
	    <li class="tag-4"><a href="../tag/shell.html">shell</a></li>
	    <li class="tag-4"><a href="../tag/benchmark.html">benchmark</a></li>
</ul>

<!--
-->
</div> </div><!-- /.row -->
<p class="paginator">
    Page 1 / 3
        <a href="../category/qi-ta2.html"><i class="icon-arrow-right"></i></a>
</p>
</section><!-- /#content -->

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">


        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">

                <li><div class="btn primary"><a href="http://github.com/king32783784" target="_blank">Github</a></div></li>






              </ul>
            </div>
          </div>
        </footer>

    </div>


<script type="text/javascript">
    var disqus_shortname = 'xiayfblackwhite';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="../theme/js/libs/gumby.min.js"></script>
  <script src="../theme/js/plugins.js"></script>
  <script src="../theme/js/main.js"></script>
  <link rel="stylesheet" type="text/css" href="../theme/emoji/css/basic/emojify.min.css" />
  <script src="../theme/emoji/js/emojify.min.js"></script>
  <script>
    emojify.setConfig({
        img_dir : '../theme/emoji/images/basic'
    });
    emojify.run();
</script>
</body>
</html>