<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Vim.Linux - peng.lee</title><link>http://king32783784.github.io/</link><description>Don't know how to develop's testers are not good testers &lt;a href="pages/aboutme.html"&gt;More...&lt;/a&gt;</description><lastBuildDate>Tue, 15 Nov 2016 00:00:00 +0800</lastBuildDate><item><title>pyqt基本操作(三）</title><link>http://king32783784.github.io/2016/11/15/python/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="dui-hua-kuang"&gt;对话框&lt;/h3&gt;
&lt;p&gt;PyQT提供基本的消息框和标准对话框。在PyQt也可以根据需要创建自定义的对话框。&lt;/p&gt;
&lt;p&gt;使用PyQt提供的类和方法可以创建和使用消息框、标准对话框等。标准对话框包含基本的打开，关闭，字体选择对话框和颜色选择对话框等。&lt;/p&gt;
&lt;h4 id="xiao-xi-kuang"&gt;消息框&lt;/h4&gt;
&lt;p&gt;使用QtGui.QMessageBox类中的方法可以创建简单的消息框，用于向用户传递信息。QtGui.QMessageBox类中包含一下方法：
　
&lt;em&gt; about():创建关于消息框
&lt;/em&gt; aboutQt(): 创建关于Qt消息框
&lt;em&gt; critical():　创建错误处理对话框
&lt;/em&gt; infomation():　创建信息消息框
&lt;em&gt; question(): 创建询问消息框
&lt;/em&gt; warning(): 创建警告消息框&lt;/p&gt;
&lt;p&gt;以下是示例：&lt;/p&gt;
&lt;table class="table highlighttable table-striped table-hover"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23 …&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Tue, 15 Nov 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-11-15:/2016/11/15/python/</guid><category>pyqt</category></item><item><title>pyqt基本操作</title><link>http://king32783784.github.io/2016/11/13/python/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;pyqt是对Qt的封装。Ｑt是面向对象的图形用户界面库，可以在多个操作系统上使用。&lt;/p&gt;
&lt;h3 id="pyqtji-ben-cao-zuo"&gt;PyQt基本操作&lt;/h3&gt;
&lt;h4 id="ji-ben-de-jie-mian"&gt;基本的界面：&lt;/h4&gt;
&lt;table class="table highlighttable table-striped table-hover"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c1"&gt;#*-* coding=utf-8 *-*&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;PyQt4&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;QtCore&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QtGui&lt;/span&gt;&lt;span class="err"&gt;　　　　　　&lt;/span&gt;&lt;span class="c1"&gt;# 导入PyQt模块&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QtGui&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;QMainWindow&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="err"&gt;　　　　&lt;/span&gt;&lt;span class="c1"&gt;# 通过继承QtGui.QMainWindow创建类&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="err"&gt;　　　　　　　　　　　&lt;/span&gt;&lt;span class="c1"&gt;# 初始化方法&lt;/span&gt;
        &lt;span class="n"&gt;QtGui&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;QMainWindow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Sun, 13 Nov 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-11-13:/2016/11/13/python/</guid><category>pyqt</category></item><item><title>Avocado-编写Avocado测试</title><link>http://king32783784.github.io/2016/11/12/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="bian-xie-avocadoce-shi"&gt;编写Avocado测试&lt;/h3&gt;
&lt;p&gt;现在我们开始使用python编写Avocado测试，测试继承于avocado.Test.&lt;/p&gt;
&lt;h4 id="ji-ben-li-zi"&gt;基本例子&lt;/h4&gt;
&lt;p&gt;创建一个时间测试，sleeptest,测试非常简单，只是sleep一会：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;avocado&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Test&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SleepTest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;sleep_length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'sleep_length'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Sleep for &lt;/span&gt;&lt;span class="si"&gt;%.2f&lt;/span&gt;&lt;span class="s2"&gt; seconds"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sleep_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sleep_length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是为avocado编写的一个简单示例，可以使用其他power API编写。&lt;/p&gt;
&lt;p&gt;从上面的例子可以看出，avocado测试从avocado.Test继承的test方法入手。&lt;/p&gt;
&lt;h5 id="duo-ge-ce-shi-he-ming-ming-yue-ding"&gt;多个测试和命名约定&lt;/h5&gt;
&lt;p&gt;可以在一个类中存在多个测试。&lt;/p&gt;
&lt;p&gt;要想做多个测试，只需要在命名方法前加test,例如test_foo …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Sat, 12 Nov 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-11-12:/2016/11/12/自动化测试/</guid><category>Avocado</category></item><item><title>Avocado-入门</title><link>http://king32783784.github.io/2016/11/03/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="1avocado-an-zhuang"&gt;1.Avocado 安装&lt;/h3&gt;
&lt;h4 id="11-tong-guo-bao-an-zhuang"&gt;1.1 通过包安装&lt;/h4&gt;
&lt;p&gt;像&lt;span id="avocado02"&gt;Fedora&lt;/span&gt;可以通过rpm包进行安装，其他通过RPM管理的发行版需要自己制作相关包。Avocado同样支持DEP包的安装可以在contrib/packages/debian找到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fedora&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先通过下面的命令获取仓库配置文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo curl https://repos-avocadoproject.rhcloud.com/static/avocado-fedora.repo -o /etc/yum.repos.d/avocado.repo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查是否有了Avocodo和Avocado-lts的仓库配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo dnf repolist avocado avocado-lts 
...
repo id      repo name                          status
avocado      Avocado                            50
avocado-lts  Avocado LTS (Long Term …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Thu, 03 Nov 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-11-03:/2016/11/03/自动化测试/</guid><category>Avocado</category></item><item><title>Avocado User’s Guide</title><link>http://king32783784.github.io/2016/11/01/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="avocado-yong-hu-zhi-nan"&gt;Avocado 用户指南&lt;/h3&gt;
&lt;p&gt;内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#avocado01"&gt;关于Avocado&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://king32783784.github.io/2016/11/03/自动化测试/"&gt;入门&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://king32783784.github.io/2016/11/03/自动化测试/#avocado02"&gt;安装Avocado&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://king32783784.github.io/2016/11/03/自动化测试/#avocado03"&gt;使用Avocado&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://king32783784.github.io/2016/11/03/自动化测试/#avocado04"&gt;写一个简单测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://king32783784.github.io/2016/11/03/自动化测试/#avocado05"&gt;运行一个较复杂的测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://king32783784.github.io/2016/11/03/自动化测试/#avocado06"&gt;第一个测试失败时中断测试job&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://king32783784.github.io/2016/11/03/自动化测试/#avocado07"&gt;结合外部runner运行测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://king32783784.github.io/2016/11/03/自动化测试/#avocado08"&gt;测试调试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编写Avocado测试&lt;ul&gt;
&lt;li&gt;基本例子&lt;/li&gt;
&lt;li&gt;保存测试生成的数据（自定义）&lt;/li&gt;
&lt;li&gt;访问测试参数&lt;/li&gt;
&lt;li&gt;使用multplex文件&lt;/li&gt;
&lt;li&gt;高级日志功能&lt;/li&gt;
&lt;li&gt;unittest.TestCase 继承&lt;/li&gt;
&lt;li&gt;Setup和cleanup方法&lt;/li&gt;
&lt;li&gt;运行第三方测试集&lt;/li&gt;
&lt;li&gt;获取资源文件&lt;/li&gt;
&lt;li&gt;测试输出检查和输出记录模式&lt;/li&gt;
&lt;li&gt;Avocado Testlog，stdout和stderr模块&lt;/li&gt;
&lt;li&gt;独立进程中运行Avocado测试&lt;/li&gt;
&lt;li&gt;设置测试超时&lt;/li&gt;
&lt;li&gt;测试标签&lt;/li&gt;
&lt;li&gt;Python unitest 兼容测试和警告&lt;/li&gt;
&lt;li&gt;简单测试的环境变量&lt;/li&gt;
&lt;li&gt;简单测试的BASH扩展&lt;/li&gt;
&lt;li&gt;Wrap up&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结果格式&lt;ul&gt;
&lt;li&gt;人性化测试结果&lt;/li&gt;
&lt;li&gt;机器可读的结果&lt;/li&gt;
&lt;li&gt;一次多种结果&lt;/li&gt;
&lt;li&gt;Exit Codes&lt;/li&gt;
&lt;li&gt;实现其他结果格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置&lt;ul&gt;
&lt;li&gt;配置文件的解析顺序&lt;/li&gt;
&lt;li&gt;插件设置文件&lt;/li&gt;
&lt;li&gt;解析订单概述 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Tue, 01 Nov 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-11-01:/2016/11/01/自动化测试/</guid><category>Avocado</category></item><item><title>LTP－kernel-syscalls-accept()</title><link>http://king32783784.github.io/2016/08/05/LTP/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="acceptyong-li-fen-xi"&gt;accept用例分析&lt;/h4&gt;
&lt;p&gt;case本身说明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Verify that accept() returns the proper errno for various failure cases
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;验证accept()是否返回正确的errno.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试log&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;accept01    1  TPASS  :  bad file descriptor successful
accept01    2  TPASS  :  bad file descriptor successful
accept01    3  TPASS  :  invalid socket buffer successful
accept01    4  TPASS  :  invalid salen successful
accept01    5  TPASS  :  invalid salen successful
accept01 …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Fri, 05 Aug 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-08-05:/2016/08/05/LTP/</guid><category>LTP</category></item><item><title>LTP－kernel-syscalls-abort</title><link>http://king32783784.github.io/2016/08/02/LTP/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;从本文开始，开始分析kernel部分的测试用例，该部分测试用例大部分为Ｃ语言编写，因此会穿插加入一定的Ｃ语言或unix环境编程的知识。&lt;/p&gt;
&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/I0T0E4Y826.jpg" width="420"/&gt;&lt;/p&gt;
&lt;h4 id="abort"&gt;abort&lt;/h4&gt;
&lt;p&gt;设计说明&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fork child. Child出现abort,检查返回状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Core file大小的限制必须大于０&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;abort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数名: abort&lt;/p&gt;
&lt;p&gt;功 能: 异常终止一个进程&lt;/p&gt;
&lt;p&gt;用 法: void abort(void);&lt;/p&gt;
&lt;p&gt;abort()是使异常程序终止，同时发送SIGABRT信号给调用进程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;abort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="err"&gt;该函数不返回&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此函数将SIGABRT信号发送给调用进程（进程不应忽略此信号).ISO C规定，调用abort将向主机环境递送一个未成功终止的通知，其方法是调用raise(SIGABRT)函数。
ISO C要求若捕捉此信号而且相应信号处理程序返回，abort仍不会返回其调用者。如果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用exit、_exit、_Exit …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Tue, 02 Aug 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-08-02:/2016/08/02/LTP/</guid><category>LTP</category></item><item><title>LTP－kernel-syscalls</title><link>http://king32783784.github.io/2016/08/01/LTP/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="syscalls"&gt;syscalls&lt;/h4&gt;
&lt;p&gt;ltp中kernel测试比重很大，尤其是syscalls，包括一下用例：
注：测试内容分析时补充。&lt;/p&gt;
&lt;table class="table table-hover table-striped"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;用例名称&lt;/th&gt;
&lt;th&gt;测试内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abort&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;accept&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;accept4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;access&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;acct&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;add_key&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;adjtimex&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;alarm&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;asyncio&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bdflush&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bind&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;brk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cacheflush&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;capget&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;capset&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chdir&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chmod&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chown&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chroot&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock_getres&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock_nanosleep&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock_nanosleep2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clone&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;close&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cma&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;confstr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;connect&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;creat&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dup&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dup2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dup3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;epoll&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;epoll2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;epoll_create1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;epoll_ctl&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;epoll_pwait&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;epoll_wait&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eventfd&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eventfd2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;execl&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;execle&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;execlp …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Mon, 01 Aug 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-08-01:/2016/08/01/LTP/</guid><category>LTP</category></item><item><title>LTP－Command-file</title><link>http://king32783784.github.io/2016/06/03/LTP/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="file"&gt;file&lt;/h4&gt;
&lt;p&gt;file　用例主要用于测试file命令。&lt;/p&gt;
&lt;h5 id="fileming-ling-jie-shao"&gt;file命令介绍&lt;/h5&gt;
&lt;p&gt;file命令可以通过查看文件内容来找出特定类型的文件，在UNIX/ Linux系统中，文件类型并不是由文件扩展名来决定的(windows中却正是这么做的),file命令的目的是从多个文件中收集文件类型统计信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;file --help

Usage: file [OPTION...] [FILE...]
Determine type of FILEs.

  --help                 display this help and exit
-v, --version              output version information and exit
-m, --magic-file LIST      use LIST as a colon-separated list of magic
                           number files
-z, --uncompress           try to …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Fri, 03 Jun 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-06-03:/2016/06/03/LTP/</guid><category>LTP</category></item><item><title>LTP－Command</title><link>http://king32783784.github.io/2016/06/02/LTP/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;本节将重点分析commands部分的用例。&lt;/p&gt;
&lt;h4 id="commandzhu-yao-yong-li"&gt;Command主要用例&lt;/h4&gt;
&lt;p&gt;主要case包括：&lt;/p&gt;
&lt;table class="table table-hover table-striped"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;case&lt;/th&gt;
&lt;th&gt;包含子case&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ade&lt;/td&gt;
&lt;td&gt;ar file ld ldd nm objdump size&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;at&lt;/td&gt;
&lt;td&gt;at&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cpio&lt;/td&gt;
&lt;td&gt;cpio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cron&lt;/td&gt;
&lt;td&gt;cron&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;df&lt;/td&gt;
&lt;td&gt;df&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;du&lt;/td&gt;
&lt;td&gt;du&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eject&lt;/td&gt;
&lt;td&gt;eject&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fileutils&lt;/td&gt;
&lt;td&gt;cp ln mkdir mv&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gzip&lt;/td&gt;
&lt;td&gt;gzip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insmod&lt;/td&gt;
&lt;td&gt;insmod&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logrotate&lt;/td&gt;
&lt;td&gt;logrotate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lsmod&lt;/td&gt;
&lt;td&gt;lsmod&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mail&lt;/td&gt;
&lt;td&gt;mail&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mkfs&lt;/td&gt;
&lt;td&gt;mkfs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mkswap&lt;/td&gt;
&lt;td&gt;mkswap&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sssd&lt;/td&gt;
&lt;td&gt;sssd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;su&lt;/td&gt;
&lt;td&gt;su&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tar&lt;/td&gt;
&lt;td&gt;tar …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Thu, 02 Jun 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-06-02:/2016/06/02/LTP/</guid><category>LTP</category></item><item><title>LTP－Case list</title><link>http://king32783784.github.io/2016/06/01/LTP/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;该topic将深入分析ltp的测试内容，着重于具体每个case的测试内容及测试方法。通过对ltp case的分析，加强linux系统的理解和用例设计。本节主要整理ltp的包括测试case的类型和case列表。&lt;/p&gt;
&lt;h3 id="zheng-ti-qing-kuang"&gt;整体情况&lt;/h3&gt;
&lt;p&gt;case主要分为”commands"、“kdump"、"kernel"、"misc"、"network"、"open_posix_testsuite"、"realtime"、"lib"等部分，主要内容如下：&lt;/p&gt;
&lt;table class="table table-hover table-striped"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;包含内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;commands&lt;/td&gt;
&lt;td&gt;ade cpio df eject gzip logrotate mail mkfs sshd tar unzip which at cron du fileutils insmod lsmod mkswap su tmp-tools wc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kernel&lt;/td&gt;
&lt;td&gt;connectors controllers firmware hotplug input ipc …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Wed, 01 Jun 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-06-01:/2016/06/01/LTP/</guid><category>LTP</category></item><item><title>Python-HOWTOS(一）</title><link>http://king32783784.github.io/2016/03/11/python-howtosyi/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;Python HOWTOS 是一些单一的、特定的主题并试图覆盖python大部分内容，参考linux howto形成的集合，部分内容比python库包含更多的内容。
目前，包括这些topic.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将python2代码移植到python3&lt;/li&gt;
&lt;li&gt;移植扩展模块到python3&lt;/li&gt;
&lt;li&gt;Curses编程&lt;/li&gt;
&lt;li&gt;Descriptor 使用方法&lt;/li&gt;
&lt;li&gt;函数式编程方法&lt;/li&gt;
&lt;li&gt;Logging使用方法&lt;/li&gt;
&lt;li&gt;Logging Cookbook&lt;/li&gt;
&lt;li&gt;正则表达式使用方法&lt;/li&gt;
&lt;li&gt;Socket编程方法&lt;/li&gt;
&lt;li&gt;排序使用方法&lt;/li&gt;
&lt;li&gt;Unicode使用方法&lt;/li&gt;
&lt;li&gt;如何通过urllib包获取网络资源&lt;/li&gt;
&lt;li&gt;Argparse教程&lt;/li&gt;
&lt;li&gt;IP地址模块介绍&lt;/li&gt;
&lt;li&gt;参数解析方法&lt;/li&gt;
&lt;li&gt;CPython中DTrace和SystemTap使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="jiang-python2dai-ma-yi-zhi-dao-python3"&gt;将python2代码移植到python3&lt;/h3&gt;
&lt;p&gt;Python3是python的未来，与此同时，Python2仍然在使用，使用这两个主流版本的python开发项目是件好事。本指南将帮助我们如何更好的使用python2&amp;amp;3.如果想查看扩展模块级的信息，可以查看移植扩展模块到python3[].如果想了解python3的出现原因，可以查看Nick Coghlan's&lt;a href="https://ncoghlan-devs-python-notes.readthedocs.io/en/latest/python3/questions_and_answers.html"&gt;Python 3 Q&amp;amp;A&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id="jian-yao-shuo-ming"&gt;简要说明&lt;/h4&gt;
&lt;p&gt;为了使你的项目兼容python2/3，基本步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.只担心支持python2.7 …&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Fri, 11 Mar 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-03-11:/2016/03/11/python-howtosyi/</guid><category>python-howtos</category></item><item><title>Python-tips01</title><link>http://king32783784.github.io/2016/01/01/effective-python/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="que-ren-pythonban-ben"&gt;确认python版本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;目前两个版本活跃状态，python2和python3&lt;/li&gt;
&lt;li&gt;python有很多流行的运行环境，如cpython jython ironpython以及  pypy&lt;/li&gt;
&lt;li&gt;运行Python时，确保python是想用的版本&lt;/li&gt;
&lt;li&gt;以后项目尽量使用python3&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="pep8feng-ge"&gt;PEP8风格&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;编写python代码时，应该遵循PEP8风格指南&lt;/li&gt;
&lt;li&gt;采用通用的代码风格，便于多人协作&lt;/li&gt;
&lt;li&gt;一致的代码风格易于维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bytes-stryu-unicodede-qu-bie"&gt;bytes、str与Unicode的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Python3中，bytes是一种包含8位值的序列，str是一种包含Unicode字符的序列。开发时不能以&amp;gt;或+等操作符来混同操作bytes和str实例。&lt;/li&gt;
&lt;li&gt;Python2中，str是一种包含8位值的序列，Unicode是一种包含Unicode字符的序列。如果 str只包含7位ASCII字符，可以通过想过操作符同时操作str和Unicode。&lt;/li&gt;
&lt;li&gt;对于输入的数据进行操作之前，使用辅助函数来保证字符序列的类型与开发者的期望相符。&lt;/li&gt;
&lt;li&gt;从文件中读取二进制数据或向其中写入二进制数据时，总应该以'rb'或'wb'等二进制模式来开启文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编写Python程序的时候，一定要把编码和解码操作放在解码最外围做。程序的核心部分分别使用Unicode字符类型（Python3中str，Python2中的unicode),而且不要对字符编码做任何假设。
由于字符类型有别，所以Python代码经常会出现两种常见的使用情景：
&lt;em&gt; 开发者需要原始8位值，这些8位值表示UTF-8格式来编码字符
&lt;/em&gt; 开发者需要操作没有特定编码形式的Unicode字符。&lt;/p&gt;
&lt;p&gt;编写两个helper函数以便在这种情况之间转换，使得转换后的输入数据符合预期。
python3中，需要编写接受str或bytes …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Fri, 01 Jan 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-01-01:/2016/01/01/effective-python/</guid><category>python</category></item><item><title>PyUnit(一）</title><link>http://king32783784.github.io/2016/01/01/python/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="pyunitjian-jie"&gt;PyUnit简介&lt;/h3&gt;
&lt;p&gt;PyUnit是Python 2.1版本新增功能。&lt;/p&gt;
&lt;p&gt;Python单元测试框架，又叫PyUnit。是JUnit的Python实现，是由Kent Beck和Erich Gamma共同开发的。同样，JUnit是Kent的Smalltalk测试框架的Java实现。PyUnit和JUnit都是各自怨言的标准测试框架。&lt;/p&gt;
&lt;p&gt;PyUnit模块支持自动化测试，通用的setup和shutdown的代码，测试用例整合为测试集，还有独立的测试报告框架。PyUnit提供的类能够很容易的使以上特性应用于测试。PyUnit是借由以下概念支持单元测试的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试fixture&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试fixture是指运行测试前的准备工作和运行测试后的清理工作。例如，创建临时或代理数据库、目录，或者启动服务进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试用例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试用例是最小的测试单元，检查特定的输入会产生预期的结果。PyUnit提供一个测试用例几类TestCase，继承基类可以创建新的测试用例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试集是测试用例的集合，同时也可以是其他测试集的结合，或者是测试用例和测试集的混合集合。用于批量执行测试用例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行器用来执行测试用例，并且把测试结果呈现给用户。执行器可以使用图形界面，文本界面，甚至特殊值来显示测试结果。&lt;/p&gt;
&lt;p&gt;测试用例和测试fixture通过TestCase和FunctionTestCase两个类来实现的。TestCase用来创建新的测试用例，而FunctionTestCase是用来把已有测试用例整合为PyUnit结构用例的（译者注：项目原来已经有测试用例了，后来想改用PyUnit测试框架，这时候就要用到FunctionTestCase了）。使用TestCase类创建新测试用例，需要覆盖setUp …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Fri, 01 Jan 2016 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2016-01-01:/2016/01/01/python/</guid><category>Pyunit</category></item><item><title>Autotest-client Package(1)</title><link>http://king32783784.github.io/2015/11/01/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h3 id="autotest_local-mo-kuai"&gt;autotest_local 模块&lt;/h3&gt;
&lt;p&gt;class autotest.client.autotest_local.AutotestLocalAPP&lt;/p&gt;
&lt;p&gt;本地自动测试，指定一个control文件启动测试&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;autotest.common&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;common&lt;/span&gt; &lt;span class="c1"&gt;# pylint: disable=W0611&lt;/span&gt;
    &lt;span class="n"&gt;rootdir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abspath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;common&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__file__&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;autodir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rootdir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'client'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;autodirbin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rootdir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'client'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'bin'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ImportError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;common&lt;/span&gt; &lt;span class="c1"&gt;# pylint: disable …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Sun, 01 Nov 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-11-01:/2015/11/01/autotest/</guid><category>autotest</category></item><item><title>Autotest-Autotest Remote (Autoserv)(三）</title><link>http://king32783784.github.io/2015/08/22/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h3 id="running-autotest-in-a-guest"&gt;Running Autotest In a Guest&lt;/h3&gt;
&lt;p&gt;接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。
给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项"opcontrol --setup"应根据host中vmlinux位置调整。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;remote_host=hosts.SSHHost("192.168.1.1")
kvm_on_remote_host= kvm.KVM(remote_host)

kvm_on_remote_host.get("/var/local/src/kvm-compiled.tar.gz")
addresses= [{"mac":"02:00:00:00:00:01", "ip":"10.0.0.1 …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Sat, 22 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-22:/2015/08/22/autotest/</guid><category>autotest</category></item><item><title>Autotest-Autotest Remote (Autoserv)(二）</title><link>http://king32783784.github.io/2015/08/21/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h3 id="kvmzhi-chi"&gt;KVM支持&lt;/h3&gt;
&lt;p&gt;如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做：
    1.创建虚拟机，运行在虚拟层的机器
    2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。
    3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。
    4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest&lt;/p&gt;
&lt;p&gt;可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。
下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;remote_host = hosts.SSHHost("192.168.1.1")

kvm_on_remote_host …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Fri, 21 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-21:/2015/08/21/autotest/</guid><category>autotest</category></item><item><title>Autotest-Autotest Remote (Autoserv)（一）</title><link>http://king32783784.github.io/2015/08/20/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;p&gt;Autoserv 是“自动化机器控制“的框架
Autoserv 目的是控制机器，它可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电源管理&lt;/li&gt;
&lt;li&gt;安装内核&lt;/li&gt;
&lt;li&gt;修改bootloader
*　运行任意命令&lt;/li&gt;
&lt;li&gt;运行Autotest Local(客户端）测试&lt;/li&gt;
&lt;li&gt;传输文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;被控制的机器可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本机&lt;/li&gt;
&lt;li&gt;远程机器（通过ssh 和　conmux)&lt;/li&gt;
&lt;li&gt;虚拟机(通过ＫＶＭ）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="kong-zhi-wen-jian"&gt;控制文件&lt;/h2&gt;
&lt;p&gt;类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。&lt;/p&gt;
&lt;p&gt;这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;remote_host = host.SSHHost("192.168.1.1")
print remote_host.run …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Thu, 20 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-20:/2015/08/20/autotest/</guid><category>autotest</category></item><item><title>Autotest-others</title><link>http://king32783784.github.io/2015/08/19/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h2 id="zhi-xing-wai-bu-ce-shi"&gt;执行外部测试&lt;/h2&gt;
&lt;p&gt;autotest可以像执行自身测试一样执行外部测试．&lt;/p&gt;
&lt;h3 id="zhi-xing-ce-shi"&gt;执行测试&lt;/h3&gt;
&lt;p&gt;一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址．
　　
    job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2')&lt;/p&gt;
&lt;p&gt;这样就会执行下载，安装，解压测试．&lt;/p&gt;
&lt;h3 id="gou-jian-wai-bu-xia-zai-ce-shi"&gt;构建外部下载测试&lt;/h3&gt;
&lt;p&gt;外部下载的测试包含bz2包和测试目录．
&lt;em&gt; 1．包名　my_test.tar.bz2
&lt;/em&gt; 2. 测试脚本　my_test.py
* 3.　测试脚本中的以本身命名的类　class my_test(test.test):&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest_lib.client.bin&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;

    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;my_test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Wed, 19 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-19:/2015/08/19/autotest/</guid><category>autotest</category></item><item><title>Autotest-Linux distribution detection</title><link>http://king32783784.github.io/2015/08/18/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h2 id="linuxfa-xing-ban-jian-ce"&gt;linux发行版检测&lt;/h2&gt;
&lt;p&gt;Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上.
这个功能是由probe类群的实现和注册实现的.
这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等.&lt;/p&gt;
&lt;h3 id="kuai-su-jian-cha-fa-xing-ban"&gt;快速检查发行版&lt;/h3&gt;
&lt;p&gt;autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect().
它的用法简单命了:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest.client.shared&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;distro&lt;/span&gt;
    &lt;span class="n"&gt;detected_distro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;distro&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;detect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以返回发行版检测的结果,但是不太适用于&lt;strong&gt;UNKNOWN_DISIRO&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;version&lt;/li&gt;
&lt;li&gt;release&lt;/li&gt;
&lt;li&gt;arch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;detected_distro = distro.detect()
&amp;gt;&amp;gt;&amp;gt;print detected_distro.name
redhat
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="wei-zhi-fa-xing-ban"&gt;未知发行版&lt;/h3&gt;
&lt;p&gt;当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; autotest.clientshared.distro.UNKNOWN_DISIRO …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Tue, 18 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-18:/2015/08/18/autotest/</guid><category>autotest</category></item><item><title>Autotest-Using and developing job profilers</title><link>http://king32783784.github.io/2015/08/17/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h2 id="shi-yong-he-tian-jia-ce-shi-fen-xi-qi"&gt;使用和添加测试分析器&lt;/h2&gt;
&lt;p&gt;添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个控制文件. profilers/myprofiler/control&lt;/li&gt;
&lt;li&gt;分析器控制脚本. profilers/myprofiler.py&lt;/li&gt;
&lt;li&gt;分析器的源码(如果不仅仅是控制脚本)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核.&lt;/p&gt;
&lt;p&gt;控制文件非常简单,像这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.profilers.add('readprofile')
job.run_test('sleeptest', 1)
job.profilers.delete('readprofile')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只是说明"请再以下测试中使用readprofile".一次测试,如果想添加多个分析器,可以多次调用profilers.add.&lt;/p&gt;
&lt;p&gt;还有源码包"util-linux-2.12r.tar.bz2",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Mon, 17 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-17:/2015/08/17/autotest/</guid><category>autotest</category></item><item><title>Autotest-add test</title><link>http://king32783784.github.io/2015/08/16/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h2 id="ce-shi-mo-kuai-kai-fa"&gt;测试模块开发&lt;/h2&gt;
&lt;p&gt;测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的）&lt;/p&gt;
&lt;p&gt;测试模块需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以跨多硬件架构&lt;/li&gt;
&lt;li&gt;可以支持不同的发行版&lt;/li&gt;
&lt;li&gt;至少一个维护者&lt;/li&gt;
&lt;li&gt;提供一个默认的简单例子&lt;/li&gt;
&lt;li&gt;对自己目录外的东西不做修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tian-jia-ce-shi-xiang"&gt;添加测试项&lt;/h2&gt;
&lt;p&gt;增加一个测试项，可能是最容易的开发工作了．&lt;/p&gt;
&lt;p&gt;每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括
&lt;em&gt; 一个control 文件（tests/mytest/control)
&lt;/em&gt; 一个测试包装脚本（tests/mytest/mytest.py)
* 如果不仅仅是python脚本中实现的，还需要补充测试源码&lt;/p&gt;
&lt;p&gt;可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py,  包括其中命名为dbench的类．这些这新开发的测试中
也必须要有．&lt;/p&gt;
&lt;p&gt;control文件至少是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.run_test('dbench')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西．&lt;/p&gt;
&lt;p&gt;目录下同样有个测试工具源码包dbench-3 …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Sun, 16 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-16:/2015/08/16/autotest/</guid><category>autotest</category></item><item><title>Autotest-Control file specification</title><link>http://king32783784.github.io/2015/08/15/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h2 id="control-file-specification"&gt;Control file specification&lt;/h2&gt;
&lt;p&gt;该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改.
主要内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名control文件&lt;/li&gt;
&lt;li&gt;常用变量&lt;/li&gt;
&lt;li&gt;示例&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="controlwen-jian-ming-ming"&gt;control文件命名&lt;/h3&gt;
&lt;p&gt;control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义．　例如，５００次硬重启测试，一个正规的定义就是　control.hard500&lt;/p&gt;
&lt;h3 id="chang-yong-bian-liang"&gt;常用变量&lt;/h3&gt;
&lt;p&gt;下面是一个常用变量的列表&lt;/p&gt;
&lt;table class="table table-hover table-striped"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*AUTHOR&lt;/td&gt;
&lt;td&gt;测试编写的个人或公司信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ＤEPENENCIES&lt;/td&gt;
&lt;td&gt;测试依赖信息，比如"CONSOLE"&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*DOC&lt;/td&gt;
&lt;td&gt;描述测试包括哪些参数的说明&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPERIMENTAL&lt;/td&gt;
&lt;td&gt;如果定义为True,测试忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*NAME&lt;/td&gt;
&lt;td&gt;前端识别测试的名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RUN_VERIFY&lt;/td&gt;
&lt;td&gt;定义scheduler是否执行验证，默认为True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SYNC_COUNT&lt;/td&gt;
&lt;td&gt;次数，接受大于等于１的参数，默认为１&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*TIME&lt;/td&gt;
&lt;td&gt;说明测试时长，　ＳＨＯＲＴ&amp;lt;15m, MEDIUM &amp;lt; 4H ,LONG …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Sat, 15 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-15:/2015/08/15/autotest/</guid><category>autotest</category></item><item><title>Autotest-client control</title><link>http://king32783784.github.io/2015/08/14/autotest/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h2 id="client-control-files"&gt;Client Control files&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jobs 例子&lt;/li&gt;
&lt;li&gt;扩展测试&lt;/li&gt;
&lt;li&gt;流程控制&lt;/li&gt;
&lt;li&gt;系统信息抓取&lt;/li&gt;
&lt;li&gt;分析器&lt;/li&gt;
&lt;li&gt;创建文件系统&lt;/li&gt;
&lt;li&gt;job执行期间重启&lt;/li&gt;
&lt;li&gt;并行运行多个测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试.&lt;/p&gt;
&lt;h2 id="jobli-zi"&gt;job例子&lt;/h2&gt;
&lt;p&gt;可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.run_test('kernbench')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/&lt;testname&gt;/control
在autotestclient端的顶层目录下,你可以执行测试:&lt;/testname&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ client/autotest-local &amp;lt;control_file_name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在control文件中同样可以指定测试参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.run_test('kernbench', iterations=2, threads=5)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数是测试名称;&lt;/li&gt;
&lt;li&gt;第二个参数是执行次数和线程数,大多数你可以执行它的默认参数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还可以指定一个tag参数,用来给测试结果目录命名 …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Fri, 14 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-14:/2015/08/14/autotest/</guid><category>autotest</category></item><item><title>Autotest-Local</title><link>http://king32783784.github.io/2015/08/13/autotest02/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h2 id="local-former-client"&gt;Local (Former Client)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速入门&lt;/li&gt;
&lt;li&gt;client端控制文件&lt;/li&gt;
&lt;li&gt;测试模块开发&lt;/li&gt;
&lt;li&gt;如何添加测试到autotest&lt;/li&gt;
&lt;li&gt;使用和开发job profilers&lt;/li&gt;
&lt;li&gt;linux发行版检测&lt;/li&gt;
&lt;li&gt;API 参考&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="kuai-su-ru-men"&gt;快速入门&lt;/h3&gt;
&lt;p&gt;Autotest 客户端需要很少的依赖,需要安装python2.4或以上版本.推荐使用虚拟机或测试机验证,避免出现异常.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下载client端&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone --recursive git://github.com/autotest/autotest.git
cd autotest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试例子&lt;/strong&gt;
比如autotest中的sleeptest,sleeptest是一个简单的sleep几秒测试.可以从autotest目录启动(/usr/local/autotest/client):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;client/autotest-local --verbose run sleeptest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以通过以下方式,进行任何独立测试:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;client/autotest-local …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Thu, 13 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-13:/2015/08/13/autotest02/</guid><category>autotest</category></item><item><title>Autotest-summary</title><link>http://king32783784.github.io/2015/08/12/Autotest01/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/autotestlogo.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;p&gt;Autotest是一个开源的自动化测试框架.设计目的是为了测试Linux内核,同样可以用来检查新的硬件,虚拟化测试以及linux平台用户空间程序.它遵循GPL协议,并有大量的开发组织成员,其中包括像谷歌,IBM,红帽等.
Avocado,是Autotest开发组,开发的下一代的自动化测试框架.详细信息参考&lt;a href="http://avocado-framework.github.io/"&gt;Avocado&lt;/a&gt;,后续有时间会再对Avocado进行介绍.
本专题主要介绍以下内容:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* 基本信息
* 客户端介绍
* 服务端介绍
* 前端介绍
* 系统管理
* 调度模块
* 如何开发
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本文主要介绍关于Autotest的一些基本信息.主要内容:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* Autotest主要结构
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Autotest项目主页:&lt;a href="http://autotest.github.io/"&gt;Autotest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github: &lt;a href="https://github.com/autotest/autotest"&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="autotestzhu-yao-jie-gou"&gt;Autotest主要结构&lt;/h2&gt;
&lt;p&gt;下图是Autotest框架简化图:&lt;/p&gt;
&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://github.com/king32783784/king32783784.github.io/blob/master/tmpfile/Autotest1.png?raw=true" width="480"/&gt;&lt;/p&gt;
&lt;h3 id="webjie-kou-he-ming-ling-xing-jie-kou"&gt;Web接口和命令行接口&lt;/h3&gt;
&lt;p&gt;Web接口和命令行接口是相辅相成的方式去连接Autotest并创建job.这两则具有相同的功能,意在方便用户.你可以用这些接口做以下事情:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* 管理jobs,如创建,监控,中止等
* 管理客户端
* 查看测试结果
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端会通过向mysql数据库中创建记录的方式将jobs插入服务端.&lt;/p&gt;
&lt;h3 id="fu-wu-duan"&gt;服务端&lt;/h3&gt;
&lt;p&gt;服务端主要包括3个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个Mysql数据库,该数据库保存了所有的job,客户端(测试物理机 …&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Wed, 12 Aug 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-08-12:/2015/08/12/Autotest01/</guid><category>autotest</category></item><item><title>selenium-expected_conditions源码分析</title><link>http://king32783784.github.io/2015/02/03/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="expected_conditions-mo-kuai-de-yuan-ma-fen-xi"&gt;expected_conditions 模块的源码分析&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.common.exceptions&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;NoSuchElementException&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.common.exceptions&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;NoSuchFrameException&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.common.exceptions&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;StateElementReferenceException&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.common.exceptions&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;WebDriverException&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.common.exceptions&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;NoAlertPresentException&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入异常处理模块。&lt;/p&gt;
&lt;h5 id="title_is"&gt;title_is&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;title_is&lt;/span&gt;(&lt;span class="n"&gt;object&lt;/span&gt;):
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;title&lt;/span&gt;)
        &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;title&lt;/span&gt; = &lt;span class="n"&gt;title&lt;/span&gt;

    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;__call__&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;, &lt;span class="n"&gt;driver&lt;/span&gt;)
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;self …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Tue, 03 Feb 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-02-03:/2015/02/03/selenium/</guid><category>Selenium</category></item><item><title>selenium-Sample(五）</title><link>http://king32783784.github.io/2015/02/01/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="shi-li-10-bu-tong-deng-dai-fang-fa-shi-li"&gt;示例10 不同等待方法示例&lt;/h4&gt;
&lt;p&gt;等待方法包括多种策略，具体参见前面文章。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;table class="table highlighttable table-striped table-hover"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45 …&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Sun, 01 Feb 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-02-01:/2015/02/01/selenium/</guid><category>Selenium</category></item><item><title>selenium-Sample(四）</title><link>http://king32783784.github.io/2015/01/26/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="shi-li-9-ge-chong-yuan-su-ding-wei-fang-fa"&gt;示例9 各种元素定位方法&lt;/h4&gt;
&lt;p&gt;下面的例子将展示webdriver 元素定位的几种方式。包括id、name、xpath、link_tetx、partial_link_text、tag_name、class_name、css_selector等。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;table class="table highlighttable table-striped table-hover"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37 …&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Mon, 26 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-26:/2015/01/26/selenium/</guid><category>Selenium</category></item><item><title>selenium-Sample(三）</title><link>http://king32783784.github.io/2015/01/25/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="shi-li-5-tuo-fang-draghe-drop"&gt;示例５　拖放drag和drop&lt;/h4&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.action_chains&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ActionChains&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.support.ui&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Select&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.keys&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Keys&lt;/span&gt;

&lt;span class="c1"&gt;# bugzilla address&lt;/span&gt;
&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"http://192.168.32.3/"&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Testdrog_drop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Sun, 25 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-25:/2015/01/25/selenium/</guid><category>Selenium</category></item><item><title>selenium-Sample(二）</title><link>http://king32783784.github.io/2015/01/24/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="chang-jian-ying-yong-de-shi-li"&gt;常见应用的示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Sample List&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;填写表单示例1-自动设置bugzilla Simple Search&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;填写表单示例2-自动设置bugzilla Advanced Search&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拖放drag和drop示例-待定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;窗口和框架之间移动示例-待定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弹出对话框示例-待定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;历史记录和位置示例-待定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookies示例-待定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元素定位不同方式示例-待定&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ID定位
名称定位
Xpath定位
链接文本定位超链接
Tag Name定位
class name定位
css选择器定位
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;等待-不同条件显示等待示例-待定&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;title_is
title_contains
presence_of_element_locate
visibility_of_element_located
visibility_of
presence_of_all_elements_located
text_to_be_present_in_element_value
text_to_be_present_in_element
frame_to_be_available_and_switch_to_it
invisibility_of_element_located
elements_to_be_clickable-it is Displayed and Enabled
staleness_of
element_to_be_selected
element_located_to_be_selected
element_selection_state_to_be
element_located_selection_state_to_be
arelt_is_present
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;等待-等待示例-隐式等待&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;页面对象设计模式示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;... ...&lt;/p&gt;
&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/RGBIHR91YT.jpg" width="420"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例3. 填写表单示例1-自动设置bugzilla …&lt;/strong&gt;&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Sat, 24 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-24:/2015/01/24/selenium/</guid><category>Selenium</category></item><item><title>selenium-Sample(一）</title><link>http://king32783784.github.io/2015/01/23/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="ying-yong-shi-li"&gt;应用示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.通过selenium爬取"https://stocksnap.io/"上的图片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简要说明，通过selenium打开firefox浏览器，导航到指定网址；然后定位到图片源地址，并保存；然后调用urllib模块，下载图片到指定位置。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;#!/bin/bash/env python&lt;/span&gt;
    &lt;span class="c1"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;urllib&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;urllib2&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;re&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;

    &lt;span class="c1"&gt;# 爬取页面地址  &lt;/span&gt;
    &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"https://stocksnap.io/"&lt;/span&gt;

    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;GetpicHtml&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Firefox …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Fri, 23 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-23:/2015/01/23/selenium/</guid><category>Selenium</category></item><item><title>selenium-常见问题</title><link>http://king32783784.github.io/2015/01/22/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="1chang-jian-wen-ti"&gt;1.常见问题&lt;/h3&gt;
&lt;h4 id="11-ru-he-shi-yong-chromedriver"&gt;1.1 如何使用ChromeDriver?&lt;/h4&gt;
&lt;p&gt;下载最新的chromedriver&lt;a href="https://sites.google.com/a/chromium.org/chromedriver/downloads"&gt;chromedriver from download page&lt;/a&gt;,解压文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unzip chromedriver_linux32_x.x.x.x.zip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解压后，会看到chromedriver的二进制文件。然后可以像这样创建Chrome WebDriver实例：
　
    driver = webdriver.Chrome(executable_path="/path/to/chromedriver")&lt;/p&gt;
&lt;h4 id="12-selenium-2shi-fou-zhi-chi-xpath20"&gt;1.2　Selenium 2是否支持XPath2.0?&lt;/h4&gt;
&lt;p&gt;参考&lt;a href="http://www.seleniumhq.org/docs/03_webdriver.jsp#how-xpath-works-in-webdriver"&gt; http://seleniumhq.org/docs/03_webdriver.html#how-xpath-works-in-webdriver&lt;/a&gt;
Selenium 将XPath查询委派给浏览器自己的XPath引擎查询，所以Selenium支持的XPath取决于浏览器的支持。如果浏览器没有XPath引擎（如IE6,7,8)，则Selenium就支持XPath1.0 …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Thu, 22 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-22:/2015/01/22/selenium/</guid><category>Selenium</category></item><item><title>selenium-Remote WebDriver</title><link>http://king32783784.github.io/2015/01/21/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="remote-webdriver"&gt;Remote WebDriver&lt;/h3&gt;
&lt;p&gt;WebDriver实现。&lt;/p&gt;
&lt;p&gt;class selenium.webdriver.remote.webdriver.WebDriver(command_executor='http://127.0.0.1:4444/wd/hub', desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False, file_detector=None)&lt;/p&gt;
&lt;p&gt;Bases: object
控制浏览器向remote server发送命令。Remote server 运行的协议定义为&lt;a href="https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol"&gt;https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol&lt;/a&gt;.
属性：
    * session_id- webdriver用于打开和控制浏览器窗口的ＩＤ字符串
    * capabilities- Dictionaty of effective capabilities …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Wed, 21 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-21:/2015/01/21/selenium/</guid><category>Selenium</category></item><item><title>selenium-API-2</title><link>http://king32783784.github.io/2015/01/20/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="alert"&gt;Alert&lt;/h3&gt;
&lt;p&gt;警告相关的实现&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;selenium&lt;/span&gt;.&lt;span class="n"&gt;webdriver&lt;/span&gt;.&lt;span class="n"&gt;common&lt;/span&gt;.&lt;span class="n"&gt;alert&lt;/span&gt;.&lt;span class="n"&gt;Alert&lt;/span&gt;(&lt;span class="n"&gt;driver&lt;/span&gt;)
    &lt;span class="n"&gt;Bases:&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt;
    &lt;span class="n"&gt;允许使用alerts&lt;/span&gt;.
    &lt;span class="n"&gt;使用这个类作为与alert互动的接口&lt;/span&gt;。&lt;span class="n"&gt;它包括dismissing&lt;/span&gt;(&lt;span class="n"&gt;忽略&lt;/span&gt;），&lt;span class="n"&gt;accepting&lt;/span&gt;(&lt;span class="n"&gt;接受&lt;/span&gt;），&lt;span class="n"&gt;inputting&lt;/span&gt;（&lt;span class="n"&gt;输入&lt;/span&gt;）&lt;span class="n"&gt;和获取警告提示的文本信息的方法&lt;/span&gt;。
    &lt;span class="n"&gt;接受&lt;/span&gt;／&lt;span class="n"&gt;忽略警报信息&lt;/span&gt;：
        &lt;span class="n"&gt;Alert&lt;/span&gt;(&lt;span class="n"&gt;driver&lt;/span&gt;).&lt;span class="n"&gt;accpet&lt;/span&gt;()
        &lt;span class="n"&gt;Alert&lt;/span&gt;(&lt;span class="n"&gt;driver&lt;/span&gt;).&lt;span class="n"&gt;dismiss&lt;/span&gt;()

    &lt;span class="n"&gt;往警报信息中输入&lt;/span&gt;：
        &lt;span class="n"&gt;name_prompt&lt;/span&gt; = &lt;span class="n"&gt;Alert&lt;/span&gt;(&lt;span class="n"&gt;driver&lt;/span&gt;)&lt;span class="n"&gt;name_prompt&lt;/span&gt;.&lt;span class="n"&gt;send_keys&lt;/span&gt;(&lt;span class="s"&gt;"Willian Shakesphere"&lt;/span&gt;)
        &lt;span class="n"&gt;name_prompt&lt;/span&gt;.&lt;span class="n"&gt;accept&lt;/span&gt;()

    &lt;span class="n"&gt;读取警报信息作为验证&lt;/span&gt;：
        &lt;span class="n"&gt;alert_text&lt;/span&gt; = &lt;span class="n"&gt;Alert&lt;/span&gt;(&lt;span class="n"&gt;driver&lt;/span&gt;).&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="k"&gt;self&lt;/span&gt;.&lt;span class="n"&gt;assertEqual&lt;/span&gt;(&lt;span class="s"&gt;"Do you wish to quit …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Tue, 20 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-20:/2015/01/20/selenium/</guid><category>Selenium</category></item><item><title>selenium-API</title><link>http://king32783784.github.io/2015/01/19/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="webdriver-api"&gt;WebDriver API&lt;/h3&gt;
&lt;p&gt;注：这不是官方API文档，官方在这：&lt;a href="https://seleniumhq.github.io/selenium/docs/api/py/api.html"&gt;Selenium Documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇覆盖了Selenium Webdriver的所有接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐导入样式&lt;/strong&gt;
本节API展示了类的绝对位置。推荐的导入风格如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，可以访问的类如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;webdriver.Firefox
webdriver.FirefoxProfile
webdriver.Chrome
webdriver.ChromeOptions
webdriver.Ie
webdriver.Opera
webdriver.PhantomJS
webdriver.Remote
webdriver.DesiredCapabilities
webdriver.ActionChains
webdriver.TouchActions
webdriver.Proxy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特殊键类（keys)可以这样导入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.keys …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Mon, 19 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-19:/2015/01/19/selenium/</guid><category>Selenium</category></item><item><title>selenium-页面对象</title><link>http://king32783784.github.io/2015/01/18/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="yi-ye-mian-dui-xiang"&gt;一、页面对象&lt;/h3&gt;
&lt;p&gt;该篇是介绍页面对象设计模式的方法。页面对象是Web应用程序用户界面的区域，测试时主要在此区域。&lt;/p&gt;
&lt;p&gt;使用页面对象模式的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建多测试用例共用的可重复代码&lt;/li&gt;
&lt;li&gt;减少重复的代码&lt;/li&gt;
&lt;li&gt;如果用户界面发生改变，只需修改一次对应部分&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="1ce-shi-yong-li"&gt;1.测试用例&lt;/h4&gt;
&lt;p&gt;以下是一个测试python.org搜索字符串的用例，并且确保可以查到一些结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;unittest&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;page&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PythonOrgSearch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unittest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TestCase&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;'''A sample teest class to show how page object works'''&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;setUp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Firefox&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"http://www.python …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Sun, 18 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-18:/2015/01/18/selenium/</guid><category>Selenium</category></item><item><title>selenium-等待</title><link>http://king32783784.github.io/2015/01/17/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="yi-deng-dai"&gt;一、等待&lt;/h3&gt;
&lt;p&gt;目前大多数网络应用都在使用AJAX技术。当浏览器加载一个页面，页面上的元素可能分多次进行加载。这会导致元素定位困难，如果元素没有在DOM中出现，则会触发ElementNotVisibleException异常。通过等待，我们可以解决这个问题。等待提供了设置操作间的时间间隔－元素定位直接或其他元素操作。&lt;/p&gt;
&lt;p&gt;Selenium Webdriver 提供了等待的两种类型，implicit和explicit。显式等待是使webdriver在操作之间有确定的时间等待。隐式等待是使WebDriver 去间隔的轮询DOM，尝试定位到元素。&lt;/p&gt;
&lt;h4 id="1xian-shi-deng-dai"&gt;1.显式等待&lt;/h4&gt;
&lt;p&gt;显式等待是代码中定义一定的条件，等待条件达成，继续执行。最差的方式是time.sleep(),通过设置等待时间间隔实现。有一些便利方法，会帮助设置等待时间。WebDriverWait与ExpectedCondition组合就是其中一种实现方式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.by&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;By&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.support.ui&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;WebDriverWait&lt;/span&gt;
&lt;span class="kn"&gt;from …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Sat, 17 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-17:/2015/01/17/selenium/</guid><category>Selenium</category></item><item><title>selenium-元素定位</title><link>http://king32783784.github.io/2015/01/16/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="yuan-su-ding-wei"&gt;元素定位&lt;/h3&gt;
&lt;p&gt;提供很多种方式去定位页面的元素。可以从中选择一个适合的用于测试。Selenium 提供了以下方法用于定位页面元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*find_element_by_id
*find_element_by_name
*find_element_by_xpath
*find_element_by_link_text
*find_element_by_partial_link_text
*find_element_by_tag_name
*find_element_by_class_name
*find_element_By_css_selector
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要找到多个元素（这些方法将返回一个列表）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*find_elements_by_name
*find_elements_by_xpath
*find_elements_by_link_text
*find_elements_by_partial_link_text
*find_elements_by_tag_name
*find_elements_by_class_name
*find_elements_by_css_selector
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了上面列出的公共方法外，还有两个用于页面对象定位器的私有方法。这两个私有方法是：find_element 和　find_elements.
用法例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.by&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;By&lt;/span&gt;

&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;By&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;XPATH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'//button[test()="Some text"]'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_elements&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;By&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;XPATH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'//button'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些都是类可用的属性 …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Fri, 16 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-16:/2015/01/16/selenium/</guid><category>Selenium</category></item><item><title>selenium-常用方法</title><link>http://king32783784.github.io/2015/01/15/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="yi-dao-hang"&gt;一 导航&lt;/h3&gt;
&lt;p&gt;使用WebDriver第一件想做的事情就是导航到指定链接。通常可以调用get方法去实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;driver.get("http://www.google.com")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;driver.get方法会导航到url指定的页面。webdriver会等待页面完全加载后，把控制权还给test脚本。需要注意的是，如果页面中使用了大量的AJAX负载过大，webdriver可能不知道什么时间加载完成。如果你想确保页面加载完全可以使用wait.&lt;/p&gt;
&lt;h4 id="1ye-mian-jiao-hu"&gt;1.页面交互&lt;/h4&gt;
&lt;p&gt;只是导航到指定链接并不是很有用。我们想做的页面上的交互，准确的说是页面的元素操作。首先，我们要先找到它。webdriver提供了很多方法去找到元素，例如，元素定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;input type="text" name="passwd" id="passwd-id" /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以使用下面方法找到该元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;element = driver.find_element_by_id("passwd-id")
element = driver.find_element_by_name("passwd")
element = driver.find_element_by_xpath("//input[@id='passwd-id' …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Thu, 15 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-15:/2015/01/15/selenium/</guid><category>Selenium</category></item><item><title>selenium-入门</title><link>http://king32783784.github.io/2015/01/14/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="ru-men"&gt;入门&lt;/h3&gt;
&lt;h4 id="jian-dan-yong-fa"&gt;简单用法&lt;/h4&gt;
&lt;p&gt;如果已经具备了Selenium＆Python，可以这样开始使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.keys&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Keys&lt;/span&gt;

&lt;span class="n"&gt;driver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Firefox&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"http://www.python.org"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="s2"&gt;"Python"&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="n"&gt;elem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"q"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_keys&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"pycon"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_keys&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Keys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RETURN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="s2"&gt;"No results found."&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;driver …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Wed, 14 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-14:/2015/01/14/selenium/</guid><category>Selenium</category></item><item><title>selenium-基本介绍</title><link>http://king32783784.github.io/2015/01/13/selenium/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;该topic将开始学习selenium的使用。主要内容如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.安装&lt;/li&gt;
&lt;li&gt;2.入门&lt;/li&gt;
&lt;li&gt;3.导航&lt;/li&gt;
&lt;li&gt;4.元素定位&lt;/li&gt;
&lt;li&gt;5.等待&lt;/li&gt;
&lt;li&gt;6.页面对象&lt;/li&gt;
&lt;li&gt;7.WebDriver API&lt;/li&gt;
&lt;li&gt;8.常见问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="an-zhuang"&gt;安装&lt;/h3&gt;
&lt;h4 id="jian-jie"&gt;简介&lt;/h4&gt;
&lt;p&gt;Selenium＆python提供了使用Selenium WebDriver编写功能／通过性测试的ＡＰＩ。通过Selenium Python API可以直观的使用Selenium的功能。
Selenium&amp;amp;python提供了直观的ＡＰＩ访问Selenium WebDrivers如firefox、ie、chrome、Remote等。目前支撑的python版本为2.7\3.2及以上。
本文只涉及Selenium 2 WebDriver.Selenium1没有覆盖。&lt;/p&gt;
&lt;h4 id="xia-zai-selenium-pythonzhi-chi-bao"&gt;下载Selenium python支持包&lt;/h4&gt;
&lt;p&gt;可以在&lt;a href="https://pypi.python.org/pypi/selenium"&gt;PyPI page for selenium package …&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Tue, 13 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-13:/2015/01/13/selenium/</guid><category>Selenium</category></item><item><title>selenium-浏览器性能测试</title><link>http://king32783784.github.io/2015/01/12/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;浏览器是系统下比较常用的软件，在linux系统比较常用的是firefox、chrome.如何评估浏览器的基础性能？有很多评测网站进行了这边的测试。
如
&lt;em&gt; &lt;a href="http://css4-selectors.com/browser-selector-test/"&gt;CSS&lt;/a&gt;
&lt;/em&gt; &lt;a href="http://acid3.acidtests.org/"&gt;acid3&lt;/a&gt;
&lt;em&gt; &lt;a href="http://chrome.360.cn/test/v8/run.html"&gt;v8test&lt;/a&gt;
&lt;/em&gt; &lt;a href="http://chrome.2345.com/labs/test/octanebenchmark.html"&gt;octane&lt;/a&gt;
&lt;em&gt; &lt;a href="http://html5test.com/"&gt;html5&lt;/a&gt;
&lt;/em&gt; &lt;a href="http://dromaeo.com/"&gt;dromaeo&lt;/a&gt;等&lt;/p&gt;
&lt;p&gt;考虑到每次测试都需要点击这些网站和取测试结果，决定采用selenium去实现自动测试。
测试代码如下：
browser-run.py:&lt;/p&gt;
&lt;p&gt;```python&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#encoding = utf-8&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;runtest&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;re&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;  
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;subprocess&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;span class="nb"&gt;reload&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setdefaultencoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'utf8'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# create logger with 'spam_application'&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getLogger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'browser-test' …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Mon, 12 Jan 2015 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2015-01-12:/2015/01/12/自动化测试/</guid><category>Selenium</category></item><item><title>Spec2006使用说明</title><link>http://king32783784.github.io/2014/10/10/linux/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="yi-gong-ju-jie-shao"&gt;一、工具介绍&lt;/h3&gt;
&lt;p&gt;SPEC CPU 2006 benchmark是SPEC新一代的行业标准化的CPU测试基准套件。重点测试系统的处理器，内存子系统和编译器。这个基准测试套件包括的SPECint基准和SPECfp基准。 其中SPECint2006基准包含12个不同的基准测试和SPECfp2006年基准包含19个不同的基准测试。SPEC设计了这个套件提供了一个比较标准的计算密集型，高性能的跨硬件的CPU测试工具。在SPEC CPU 2006基准有几种不同的方法来衡量计算机性能。 一种方式是测量计算机完成单一任务的速度; 另一种方式吞吐量，容量或速率的测量。
说明：由于spec2006支持多种类型操作系统。以下安装、测试、移植等介绍均基于Unix 和其他的 Unix-like system如linux。Windows系统不在此范围内。&lt;/p&gt;
&lt;h4 id="1spec2006yu-spec2000de-dui-bi-jian-yao-shuo-ming"&gt;1.spec2006与spec2000的对比简要说明&lt;/h4&gt;
&lt;p&gt;2006年8月24日，标准性能评估公司（SPEC）宣布CPU2006将取代CPU2000。
Spec cpu基准测试被广泛的应用于工业界和学术界。新套件比cpu2000要大很多，而且将涵盖到CPU、存储器系统、编译器特别是C++编译器。Cpu2000只有1个关于C++的基准测试，CPU2006则含有7个相关套件，这其中包括了50W行c++代码，Fortran和C语言和之前一样有很好的覆盖。&lt;/p&gt;
&lt;h4 id="2-spec2000he-spec20006ju-ti-de-tao-jian-xin-xi-ru-xia"&gt;2. Spec2000和spec20006具体的套件信息如下：&lt;/h4&gt;
&lt;h5 id="21-spec-int2000-12ge-zheng-dian-ce-shi-xiang-mu"&gt;2.1 …&lt;/h5&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Fri, 10 Oct 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2014-10-10:/2014/10/10/linux/</guid><category>benchmark</category></item><item><title>SpecJvm2008使用说明</title><link>http://king32783784.github.io/2014/09/15/linux/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="specjvm2008shi-yong-fang-fa"&gt;SPECJVM2008使用方法&lt;/h3&gt;
&lt;h4 id="1gong-ju-jie-shao"&gt;1.工具介绍&lt;/h4&gt;
&lt;p&gt;SPECjvm2008 （Java Virtual Machine Benchmark）是一个评估JRE运行性能的基准测试套件。包含几个现实生活中的应用和专注于核心java功能的基准的测量基准套件。该套件侧重于JRE执行一个单一的应用程序；它反映了硬件处理器和内存子系统的性能，与文件系统I/O和网络I/O关系不大。SPECjvm2008负载模仿各种常见用途的应用计算。这些特征反映了这一基准适用于测量基本 Java 性能上种类繁多的客户端和服务器系统。
套件包含21个基准测试，其中每个基准测试均包含一个2分钟的热身测试和4分钟的正式测试。由于测试过程中程序并不中断基准测试的执行，所以测试时间至少为126分钟，根据Java性能的不同，测试时间会有所不同。关于21个基准测试的具体内容将在文档最后进行介绍。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href="http://www.spec.org/jvm2008/"&gt;http://www.spec.org/jvm2008/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id="2gong-ju-an-zhuang"&gt;2工具安装&lt;/h4&gt;
&lt;h5 id="21xia-zai"&gt;2.1下载&lt;/h5&gt;
&lt;p&gt;下载SPECjvm2008测试套件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#wget ftp://ftp.spec.org/dist/osg/java/SPECjvm2008_1_01_setup.jar
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="22an-zhuang"&gt;2.2安装&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#java -jar …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Mon, 15 Sep 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2014-09-15:/2014/09/15/linux/</guid><category>benchmark</category></item><item><title>Linux Test Project(一)</title><link>http://king32783784.github.io/2014/09/12/ltp/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h2 id="testing-linux-one-syscall-at-a-time"&gt;Testing Linux, one syscall at a time.&lt;/h2&gt;
&lt;p&gt;LTP是从SGI开始的,后由IBM 思科 富士通 SUSE Redhat等组织开发的.该工具的目标是建立一个测试套件用来验证linux的可靠性,健壮性及稳定性.LTP测试套件包含了linux内核及相关功能的工具.&lt;/p&gt;
&lt;p&gt;本文主要介绍关于ltp的一些基本信息.&lt;/p&gt;
&lt;p&gt;LTP项目主页:&lt;a href="https://linux-test-project.github.io/#"&gt;ltp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github链接:&lt;a href="https://github.com/linux-test-project/ltp"&gt;ltp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LTP是一个验证ltp内核功能和稳定性的测试集.用来支持linux开发过程中,通过更多的单元测试,减少bug的引入,降低bug对用户的影响.LTP并不是用来做benchmarking测试的,而是更专注与功能,问题回归及稳定性测试.LTP同样不是一个标准测试,标准测试有&lt;a href="http://www.linuxbase.org/"&gt;LSB&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="yi-ji-ben-jie-gou"&gt;一 基本结构&lt;/h2&gt;
&lt;p&gt;LTP测试套件是由包含一个基本动作和一个确认基本动作工作是否正常的测试用例组成.这个测试用例通常的测试结果是PASS/FAIL.一个测试程序是包含一个或多个测试用例的可执行程序.测试程序包括相应的测试参数,这些参数包括内存测试容量,临时文件位置,网络测试类型等等.Test tags 是用于匹配测试程序和一组命令行参数.Test tags是测试集的基础.&lt;/p&gt;
&lt;h3 id="1bian-xie-ce-shi"&gt;1.编写测试&lt;/h3&gt;
&lt;p&gt;编写一个测试用例比大多数想象的更容易 …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Fri, 12 Sep 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2014-09-12:/2014/09/12/ltp/</guid><category>LTP</category></item><item><title>Reboot test脚本</title><link>http://king32783784.github.io/2014/03/01/stablity/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;为了验证操作系统启动的稳定性，需要进行500次启动测试，便写了脚本实现。&lt;/p&gt;
&lt;p&gt;脚本如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;HOME=`pwd`&lt;/span&gt;
&lt;span class="x"&gt;sleep 15&lt;/span&gt;
&lt;span class="x"&gt;desktop_x86_4x()&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;if [ ! -f /etc/reboot.sh ];then&lt;/span&gt;
&lt;span class="x"&gt;    cp -rf &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/reboot.sh /etc/&lt;/span&gt;
&lt;span class="x"&gt;fi&lt;/span&gt;
&lt;span class="x"&gt;if grep "reboot.sh" /etc/profile &amp;gt; /dev/null;&lt;/span&gt;
&lt;span class="x"&gt;then&lt;/span&gt;
&lt;span class="x"&gt;   break;&lt;/span&gt;
&lt;span class="x"&gt;else&lt;/span&gt;
&lt;span class="x"&gt;   echo "/bin/sh /etc/reboot.sh &amp;amp;" &amp;gt;&amp;gt; /etc/profile&lt;/span&gt;
&lt;span class="x"&gt;fi&lt;/span&gt;
&lt;span class="x"&gt;if id rebootuser &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Sat, 01 Mar 2014 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2014-03-01:/2014/03/01/stablity/</guid><category>shell</category></item><item><title>快速排序</title><link>http://king32783784.github.io/2013/07/01/sort/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="1kuai-su-pai-xu"&gt;1.快速排序&lt;/h4&gt;
&lt;p&gt;对于一个给定的数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集，
一个子集的所有元素都小于该元素，另一个子集的元素都大于或等于该元素，
对两个子集递归执行这一过程，当某个子集中的元素小于二时，
这个子集就不需要再次排序，终止递归。&lt;/p&gt;
&lt;h4 id="2dai-ma-shi-xian-ji-ce-shi"&gt;2.代码实现及测试&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//将中点的元素作为比较元素，放到整个数组的最左边&lt;/span&gt;
        &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Mon, 01 Jul 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2013-07-01:/2013/07/01/sort/</guid><category>算法</category></item><item><title>高性能计算机系统浮点性能测试</title><link>http://king32783784.github.io/2013/06/12/linpack/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img class="img-responsive" height="280" src="https://d2lm6fxwu08ot6.cloudfront.net/img-thumbs/280h/P5LS1TUY3V.jpg" width="420"/&gt;&lt;/p&gt;
&lt;h3 id="yi-gong-ju-jie-shao"&gt;一　工具介绍&lt;/h3&gt;
&lt;p&gt;Linpack现在在国际上已经成为最流行的用于测试高性能计算机系统浮点性能的benchmark。通过利用高性能计算机，用高斯消元法求解N元一次稠密线性代数方程组的测试，评价高性能计算机的浮点性能。HPL是针对现代并行计算机提出的测试方式。用户在不修改任意测试程序的基础上，可以调节问题规模大小N(矩阵大小)、使用到的CPU数目、使用各种优化方法等来执行该测试程序，以获取最佳的性能。HPL采用高斯消元法求解线性方程组。当求解问题规模为N时，浮点运算次数为(2/3 * N^3－2&lt;em&gt;N^2)。因此，只要给出问题规模N，测得系统计算时间T，峰值=计算量(2/3 * N^3－2&lt;/em&gt;N^2)/计算时间T，测试结果以浮点运算每秒（Flops）给出。
实测浮点峰值是指Linpack测试值，也就是说在这台机器上运行Linpack测试程序，通过各种调优方法得到的最优的测试结果。实际上在实际程序运行过程中，几乎不可能达到实测浮点峰值，更不用说达到理论浮点峰值了。这两个值只是作为衡量机器性能的一个指标，用来表明机器处理能力的一个标尺和潜能的度量。&lt;/p&gt;
&lt;p&gt;HPL作为一个基准测试程序在HPC领域取得了巨大的成功。它对趋势进行了准确的预测，积累的优化技巧对于提高实际应用的性能发挥了重要的作用 …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Wed, 12 Jun 2013 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2013-06-12:/2013/06/12/linpack/</guid><category>benchmark</category></item><item><title>C-宏定义</title><link>http://king32783784.github.io/2011/08/15/C/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;1.简单的宏定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#define MAXTIME 1000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单的MATIME定义好了，它代表1000，如果在程序中写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if(i&amp;lt;MAXTIME){...}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译器在处理这个代码之前会对MAXTIME进行替换为1000。
宏定义类同于简单的文本替换，而不是变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.define的“函数定义”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;define可以像函数那样接受一些参数，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#define max(x,y)(x)&amp;gt;(y)?(x):(y);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个定义将返回两个数中最大的，而且这个函数没有经过类型检查，好像函数模板，但没有模板安全。存在隐患：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#define Add(a,b) a+b;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果代数式 c&lt;em&gt;Add(a,b)&lt;/em&gt;d,本意为a+b然后去和c、d相乘，而define只是一个简单替换，式子反而变为了： c …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Mon, 15 Aug 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2011-08-15:/2011/08/15/C/</guid><category>C</category></item><item><title>C-结构体声明</title><link>http://king32783784.github.io/2011/07/11/C/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;结构体声明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：
    struct Student
    {
         char name[20];
         char sex;
         int age;
         char addr[40];
     }
     /&lt;em&gt;定义一个Student 类型的student变量&lt;/em&gt;/
     struct Student student;&lt;/p&gt;
&lt;p&gt;定义结构体的时候每次都要写struct显得比较繁琐，可以用typedef来方便声明。这样就可以想int、char一样定义结构体类型了。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;typedef struct _TEST_T {
    int i;
    char c[10];
}TEST_T;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.初始化的就是定义一个结构体变量，并且给它赋值比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TEST_T gst  = {1, “12345”}; /*可以初始化，设置i为1，c为一个字符串.*/
TEST_T gst  = {1}; /*初始化个数少于实际个数时，只初始化前面的成员。*/
TEST_T …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">peng.lee</dc:creator><pubDate>Mon, 11 Jul 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2011-07-11:/2011/07/11/C/</guid><category>C</category></item><item><title>常用shell命令</title><link>http://king32783784.github.io/2011/01/01/cmds/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="linuxchang-yong-ming-ling-bei-wang"&gt;Linux常用命令备忘&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.查找大于100M的文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find / -type f -size +100M
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.换行符替换为空格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sed ':label;N;s/\n/ /;t label'&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.在文本指定行首加空格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;:10,20 s/^/    /g 在第10行知第20行每行前面加四个空格，用于缩进。&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Sat, 01 Jan 2011 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2011-01-01:/2011/01/01/cmds/</guid><category>shell</category></item><item><title>信号</title><link>http://king32783784.github.io/2009/10/12/UNIX/</link><description>&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们运行如下命令，可看到Linux支持的信号列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;kill&lt;/span&gt; -l1&lt;span class="o"&gt;)&lt;/span&gt; SIGHUP        2&lt;span class="o"&gt;)&lt;/span&gt; SIGINT        3&lt;span class="o"&gt;)&lt;/span&gt; SIGQUIT       4&lt;span class="o"&gt;)&lt;/span&gt; SIGILL 5&lt;span class="o"&gt;)&lt;/span&gt; SIGTRAP       6&lt;span class="o"&gt;)&lt;/span&gt; SIGABRT       7&lt;span class="o"&gt;)&lt;/span&gt; SIGBUS        8&lt;span class="o"&gt;)&lt;/span&gt; SIGFPE 9&lt;span class="o"&gt;)&lt;/span&gt; SIGKILL      10&lt;span class="o"&gt;)&lt;/span&gt; SIGUSR1      11&lt;span class="o"&gt;)&lt;/span&gt; SIGSEGV      12&lt;span class="o"&gt;)&lt;/span&gt; SIGUSR213&lt;span class="o"&gt;)&lt;/span&gt; SIGPIPE      14&lt;span class="o"&gt;)&lt;/span&gt; SIGALRM      15&lt;span class="o"&gt;)&lt;/span&gt; SIGTERM      17&lt;span class="o"&gt;)&lt;/span&gt; SIGCHLD18&lt;span class="o"&gt;)&lt;/span&gt; SIGCONT      19&lt;span class="o"&gt;)&lt;/span&gt; SIGSTOP      20&lt;span class="o"&gt;)&lt;/span&gt; SIGTSTP      21&lt;span class="o"&gt;)&lt;/span&gt; SIGTTIN22&lt;span class="o"&gt;)&lt;/span&gt; SIGTTOU      23&lt;span class="o"&gt;)&lt;/span&gt; SIGURG       24&lt;span class="o"&gt;)&lt;/span&gt; SIGXCPU      25&lt;span class="o"&gt;)&lt;/span&gt; SIGXFSZ26&lt;span class="o"&gt;)&lt;/span&gt; SIGVTALRM …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Mon, 12 Oct 2009 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2009-10-12:/2009/10/12/UNIX/</guid><category>unix编程</category></item><item><title>原子操作</title><link>http://king32783784.github.io/2009/10/10/UNIX/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h4 id="yi-zhui-jia-zhi-yi-ge-wen-jian"&gt;一、追加至一个文件&lt;/h4&gt;
&lt;p&gt;一个进程，将数据添加到一个文件尾端。早期不支持open的O_APPEND选项。所有程序被编写成下列形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (lseek(fd, 0L, 2 ) &amp;lt; 0) /* position to EOF*/

    err_sys("lseek error");

if (write(fd, buf, 100) != 100) /* and write */

    err_sys("write error");
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;单个进程而言，可以正常工作，但若有多个进程同事使用这种方法将数据添加到同一文件，则会产生问题。&lt;/p&gt;
&lt;p&gt;UNIX系统提供了一种方法使这种操作成为原子操作。该方法是在打开文件时设置O_APPEND标志。使内核每次对这种文件进行写之前，都将当前偏移量设置到该文件的尾端处，每次写之前就不在需要调用lseek。&lt;/p&gt;
&lt;h4 id="er-preadhe-pwritehan-shu"&gt;二、pread和 pwrite函数&lt;/h4&gt;
&lt;p&gt;原型如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#include　＜unistd.h&amp;gt;

ssize_t pread (int filedes, void …&lt;/pre&gt;&lt;/div&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Sat, 10 Oct 2009 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2009-10-10:/2009/10/10/UNIX/</guid><category>unix编程</category></item><item><title>排序-希尔排序法</title><link>http://king32783784.github.io/2009/10/01/%E6%8E%92%E5%BA%8F/</link><description>&lt;/head&gt;&lt;body&gt;&lt;h3 id="yi-suan-fa-jiang-jie"&gt;（一）算法讲解&lt;/h3&gt;
&lt;p&gt;原始的算法实现在最坏的情况下需要进行O(n2)的比较和交换。V. Pratt的书[1] 对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。&lt;/p&gt;
&lt;p&gt;希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。&lt;/p&gt;
&lt;p&gt;假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。&lt;/p&gt;
&lt;p&gt;一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。&lt;/p&gt;
&lt;p&gt;例如，假设有这样一组数[ 13 14 94 33 …&lt;/p&gt;&lt;/body&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">penglee</dc:creator><pubDate>Thu, 01 Oct 2009 00:00:00 +0800</pubDate><guid isPermaLink="false">tag:king32783784.github.io,2009-10-01:/2009/10/01/排序/</guid><category>算法</category></item></channel></rss>