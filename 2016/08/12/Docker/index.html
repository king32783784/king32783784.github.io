<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Brown Stone  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20100928

-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Docker基础技术：Linux Namespace（下）<转></title>
<link href="../../../../theme/css/style.css" rel="stylesheet" type="text/css" media="screen" />
<link href="../../../../" type="application/atom+xml" rel="alternate" title="Hi | World ATOM Feed" />
</head>
<body>
<div id="wrapper">
	<div id="page">
		<div id="page-bgtop">
			<div id="page-bgbtm">
    
                        	<div id="content">
					<div class="post">
						<h2 class="title"><a href="2016/08/12/Docker/">Docker基础技术：Linux Namespace（下）<转></a></h2>
						<p class="meta"><span class="date">日期 五 12 八月 2016 </span><span class="posted">By <a href="#">others</a></span><span>&nbsp; | 分类 : <a href="../../../../category/autotestzhuan-ti.html">Autotest专题</a></span></p>
					<p class="meta">Tags : <span><a href="../../../../tag/docker.html">Docker</a> / </span>
</p>	
						<div style="clear: both;">&nbsp;</div>
						<div class="entry">
						 <body><p>在 <a href="https://king32783784.github.io/lipeng/2016/08/11/Docker/">Docker基础技术：Linux Namespace（上篇)</a>中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。
<img class="img-responsive" height="280" src="https://raw.githubusercontent.com/king32783784/king32783784.github.io/master/tmpfile/Autotest1.png" width="420"/></p>
<p>好，下面我们就介绍一下还剩下的这两个Namespace。</p>
<h4 id="user-namespace">User Namespace</h4>
<p><strong>User Namespace</strong> 主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。</p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改 <strong>/proc/<pid>/uid_map</pid></strong>  和 <strong>/proc/<pid>/gid_map</pid></strong> 这两个文件。这两个文件的格式为：</p>
<p>ID-inside-ns ID-outside-ns length</p>
<p>其中：</p>
<ul>
<li>第一个字段ID-inside-ns表示在容器显示的UID或GID，</li>
<li>第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。</li>
<li>第三个字段表示映射的范围，一般填1，表示一一对应。</li>
</ul>
<p>比如，把真实的uid=1000映射成容器内的uid=0</p>
<div class="highlight"><pre><span></span>$ cat /proc/2465/uid_map
     <span class="m">0</span>       <span class="m">1000</span>          1
</pre></div>
<p>再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形</p>
<div class="highlight"><pre><span></span>$ cat /proc/<span class="nv">$$</span>/uid_map
     <span class="m">0</span>          <span class="m">0</span>          4294967295
</pre></div>
<p>另外，需要注意的是：</p>
<ul>
<li>写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看Capabilities）</li>
<li>写入的进程必须是此user namespace的父或子的user namespace进程。</li>
<li>另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。</li>
<li>这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂):</li>
</ul>
<p>code:</p>
<div class="highlight"><pre><span></span><span class="cp">#define _GNU_SOURCE</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/mount.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/capability.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sched.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="cp">#define STACK_SIZE (1024 * 1024)</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">container_stack</span><span class="p">[</span><span class="n">STACK_SIZE</span><span class="p">];</span>
<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">container_args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"/bin/bash"</span><span class="p">,</span>
    <span class="nb">NULL</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">set_map</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inside_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">outside_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">mapfd</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"w"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">mapfd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"open file error"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">mapfd</span><span class="p">,</span> <span class="s">"%d %d %d"</span><span class="p">,</span> <span class="n">inside_id</span><span class="p">,</span> <span class="n">outside_id</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">mapfd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_uid_map</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inside_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">outside_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">file</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"/proc/%d/uid_map"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="n">set_map</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">inside_id</span><span class="p">,</span> <span class="n">outside_id</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_gid_map</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inside_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">outside_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">file</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"/proc/%d/gid_map"</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="n">set_map</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">inside_id</span><span class="p">,</span> <span class="n">outside_id</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">container_main</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Container [%5d] - inside the container!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">geteuid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">getegid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">getuid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">getgid</span><span class="p">());</span>

    <span class="cm">/* 等待父进程通知后再往下执行（进程间的同步） */</span>
    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
    <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">read</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Container [%5d] - setup hostname!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="c1">//set hostname</span>
    <span class="n">sethostname</span><span class="p">(</span><span class="s">"container"</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">//remount "/proc" to make sure the "top" and "ps" show container's information</span>
    <span class="n">mount</span><span class="p">(</span><span class="s">"proc"</span><span class="p">,</span> <span class="s">"/proc"</span><span class="p">,</span> <span class="s">"proc"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">execv</span><span class="p">(</span><span class="n">container_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">container_args</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Something's wrong!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">gid</span><span class="o">=</span><span class="n">getgid</span><span class="p">(),</span> <span class="n">uid</span><span class="o">=</span><span class="n">getuid</span><span class="p">();</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">geteuid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">getegid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">getuid</span><span class="p">(),</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">getgid</span><span class="p">());</span>

    <span class="n">pipe</span><span class="p">(</span><span class="n">pipefd</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Parent [%5d] - start a container!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

    <span class="kt">int</span> <span class="n">container_pid</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="n">container_main</span><span class="p">,</span> <span class="n">container_stack</span><span class="o">+</span><span class="n">STACK_SIZE</span><span class="p">,</span>
            <span class="n">CLONE_NEWUTS</span> <span class="o">|</span> <span class="n">CLONE_NEWPID</span> <span class="o">|</span> <span class="n">CLONE_NEWNS</span> <span class="o">|</span> <span class="n">CLONE_NEWUSER</span> <span class="o">|</span> <span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>


    <span class="n">printf</span><span class="p">(</span><span class="s">"Parent [%5d] - Container [%5d]!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">(),</span> <span class="n">container_pid</span><span class="p">);</span>

    <span class="c1">//To map the uid/gid,</span>
   <span class="c1">//   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span>
    <span class="c1">//The file format is</span>
    <span class="c1">//   ID-inside-ns   ID-outside-ns   length</span>
    <span class="c1">//if no mapping,</span>
    <span class="c1">//   the uid will be taken from /proc/sys/kernel/overflowuid</span>
    <span class="c1">//   the gid will be taken from /proc/sys/kernel/overflowgid</span>
    <span class="n">set_uid_map</span><span class="p">(</span><span class="n">container_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">set_gid_map</span><span class="p">(</span><span class="n">container_pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Parent [%5d] - user/group mapping done!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

    <span class="cm">/* 通知子进程 */</span>
    <span class="n">close</span><span class="p">(</span><span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">waitpid</span><span class="p">(</span><span class="n">container_pid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Parent - container stopped!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。</p>
<p>整个程序的运行效果如下：
    hchen@ubuntu:~<span class="math">\( id
    uid=1000(hchen) gid=1000(hchen) groups=1000(hchen)
    hchen@ubuntu:~\)</span> ./user #&lt;--以hchen用户运行
    Parent: eUID = 1000;  eGID = 1000, UID=1000, GID=1000
    Parent [ 3262] - start a container!
    Parent [ 3262] - Container [ 3263]!
    Parent [ 3262] - user/group mapping done!
    Container [    1] - inside the container!
    Container: eUID = 0;  eGID = 0, UID=0, GID=0 #&lt;---Container里的UID/GID都为0了
    Container [    1] - setup hostname!</p>
<div class="highlight"><pre><span></span>root@container:~# id #&lt;----我们可以看到容器里的用户和命令行提示符是root用户了
uid=0(root) gid=0(root) groups=0(root),65534(nogroup)
</pre></div>
<p>虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，我们容器的安全性会得到提高。</p>
<p>我们注意到，User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。</p>
<h4 id="network-namespace">Network Namespace</h4>
<p>Network的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能&mdash;&mdash;是用了Raw Socket发些&ldquo;奇怪&rdquo;的数据，呵呵）。这里，我还是用ip命令讲解一下。</p>
<p>首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的&ldquo;物理网卡&rdquo;其实也就是一个有可以路由的IP的网卡）</p>
<p><img alt="" class="img-responsive" src="https://king32783784.github.io/lipeng/tmpfile/network.namespace.jpg"/></p>
<p>上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。</p>
<p>当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡&mdash;&mdash;给容器用的）：</p>
<div class="highlight"><pre><span></span>hchen@ubuntu:~$ ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state ...
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...
    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff
3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 ...
    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff
5: veth22a38e6: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc ...
    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff
</pre></div>
<p>那么，要做成这个样子应该怎么办呢？我们来看一组命令：</p>
<div class="highlight"><pre><span></span>## 首先，我们先增加一个网桥lxcbr0，模仿docker0
brctl addbr lxcbr0
brctl stp lxcbr0 off
ifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址

## 接下来，我们要创建一个network namespace - ns1

# 增加一个namesapce 命令为 ns1 （使用ip netns add命令）
ip netns add ns1

# 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）
ip netns exec ns1   ip link set dev lo up

## 然后，我们需要增加一对虚拟网卡

# 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中
ip link add veth-ns1 type veth peer name lxcbr0.1

# 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了
ip link set veth-ns1 netns ns1

# 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）
ip netns exec ns1  ip link set dev veth-ns1 name eth0

# 为容器中的网卡分配一个IP地址，并激活它
ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up


# 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上
brctl addif lxcbr0 lxcbr0.1

# 为容器增加一个路由规则，让容器可以访问外面的网络
ip netns exec ns1     ip route add default via 192.168.10.1

# 在/etc/netns下创建network namespce名称为ns1的目录，
# 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了
mkdir -p /etc/netns/ns1
echo "nameserver 8.8.8.8" &gt; /etc/netns/ns1/resolv.conf
</pre></div>
<p>上面基本上就是docker网络的原理了，只不过，</p>
<p>Docker的resolv.conf没有用这样的方式，而是用了上篇中的Mount Namesapce的那种方式
另外，docker是用进程的PID来做Network Namespace的名称的。
了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：</p>
<div class="highlight"><pre><span></span>ip link add peerA type veth peer name peerB
brctl addif docker0 peerA
ip link set peerA up
ip link set peerB netns <span class="cp">${</span><span class="n">container</span><span class="o">-</span><span class="n">pid</span><span class="cp">}</span>
ip netns exec <span class="cp">${</span><span class="n">container</span><span class="o">-</span><span class="n">pid</span><span class="cp">}</span> ip link set dev peerB name eth1
ip netns exec <span class="cp">${</span><span class="n">container</span><span class="o">-</span><span class="n">pid</span><span class="cp">}</span> ip link set eth1 up ;
ip netns exec <span class="cp">${</span><span class="n">container</span><span class="o">-</span><span class="n">pid</span><span class="cp">}</span> ip addr add <span class="cp">${</span><span class="n">ROUTEABLE_IP</span><span class="cp">}</span> dev eth1 ;
</pre></div>
<p>上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。</p>
<p>这个需要把外部的&ldquo;物理网卡&rdquo;配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到&ldquo;物理网卡&rdquo;上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。</p>
<p>当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。</p>
<p>这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个IPVLAN的驱动，这基本上就是为Docker量身定制的。</p>
<h4 id="namespacewen-jian">Namespace文件</h4>
<p>上面就是目前Linux Namespace的玩法。 现在，我来看一下其它的相关东西。</p>
<p>让我们运行一下上篇中的那个pid.mnt的程序（也就是PID Namespace中那个mount proc的程序），然后不要退出。</p>
<div class="highlight"><pre><span></span>$ sudo ./pid.mnt
<span class="o">[</span>sudo<span class="o">]</span> password <span class="k">for</span> hchen:
Parent <span class="o">[</span> 4599<span class="o">]</span> - start a container!
Container <span class="o">[</span>    1<span class="o">]</span> - inside the container!
</pre></div>
<p>我们到另一个shell中查看一下父子进程的PID：</p>
<div class="highlight"><pre><span></span>hchen@ubuntu:~$ pstree -p 4599
pid.mnt(4599)───bash(4600)
</pre></div>
<p>我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上）。</p>
<p>下面是父进程的：</p>
<div class="highlight"><pre><span></span>hchen@ubuntu:~$ sudo ls -l /proc/4599/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026531840]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026531836]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026531838]
</pre></div>
<p>下面是子进程的：</p>
<div class="highlight"><pre><span></span>hchen@ubuntu:~$ sudo ls -l /proc/4600/ns
total 0
lrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -&gt; mnt:[4026532520]
lrwxrwxrwx 1 root root 0  4月  7 22:01 net -&gt; net:[4026531956]
lrwxrwxrwx 1 root root 0  4月  7 22:01 pid -&gt; pid:[4026532522]
lrwxrwxrwx 1 root root 0  4月  7 22:01 user -&gt; user:[4026531837]
lrwxrwxrwx 1 root root 0  4月  7 22:01 uts -&gt; uts:[4026532521]
</pre></div>
<p>我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。</p>
<p>这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount &ndash;bind /proc/4600/ns/uts ~/uts 来hold这个namespace。</p>
<p>另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下：</p>
<div class="highlight"><pre><span></span>int setns(int fd, int nstype);
</pre></div>
<p>其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：</p>
<div class="highlight"><pre><span></span>fd = open("/proc/4600/ns/nts", O_RDONLY);  // 获取namespace文件描述符
setns(fd, 0); // 加入新的namespace
</pre></div>
<p>参考文档</p>
<p><a href="http://lwn.net/Articles/531114/">Namespaces in operation</a></p>
<p><a href="http://man7.org/linux/man-pages/man7/namespaces.7.html">Linux Namespace Man Page</a></p>
<p><a href="http://crosbymichael.com/creating-containers-part-1.html">Creat Containers &ndash; Part 1</a></p>
<p><a href="https://blog.yadutaf.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/">Introduction to Linux namespaces</a></p>
<p>（全文完）</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></body>	
						</div>
					</div>
			      
					<div style="clear: both;">&nbsp;</div>
                                        <div class="post">
                                        <h2 class="title">Commentaires !</h2>
                                            <div id="disqus_thread"></div>
                                            <script type="text/javascript">
                                               var disqus_identifier = "2016/08/12/Docker/";
                                               (function() {
                                               var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                                               dsq.src = 'https://xiayfblackwhite.disqus.com/embed.js';
                                               (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                                              })();
                                            </script>
                                        </div>
				</div>
				<!-- end #content -->
				<div id="sidebar">
					<div id="logo">
						<h1><a href="../../../..">Hi | World</a></h1>
					</div>
					<div id="menu">
						<ul>
							<li ><a href="../../../..">首页</a></li>
							<li ><a href="../../../../archives.html">归档</a></li>
                                                            <li class="current_page_item"><a href="../../../../pages/tech-share.html">归档</a></li>
                                                            <li class="current_page_item"><a href="../../../../pages/opensource.html">开源项目</a></li>
                                                            <li class="current_page_item"><a href="../../../../pages/links.html">链接</a></li>
                                                            <li class="current_page_item"><a href="../../../../pages/Reference material.html">参考资料</a></li>
                                                            <li class="current_page_item"><a href="../../../../pages/todo list.html">Todo List</a></li>
                                                            <li class="current_page_item"><a href="../../../../pages/tools.html">工具集</a></li>
                                                            <li class="current_page_item"><a href="../../../../pages/aboutme.html">关于我</a></li>
						</ul>
					</div>
					<ul>
						<li>
							<h2>分类列表</h2>
							<ul>
								 <li ><a href="../../../../category/misc.html">misc</a></li>
								 <li class="active"><a href="../../../../category/autotestzhuan-ti.html">Autotest专题</a></li>
								 <li ><a href="../../../../category/suan-fa.html">算法</a></li>
								 <li ><a href="../../../../category/dockerzhuan-ti.html">Docker专题</a></li>
								 <li ><a href="../../../../category/linux.html">Linux</a></li>
								 <li ><a href="../../../../category/linux-benchmark.html">linux-benchmark</a></li>
								 <li ><a href="../../../../category/linux-zi-dong-hua-ce-shi.html">linux-自动化测试</a></li>
								 <li ><a href="../../../../category/unixhuan-jing-bian-cheng.html">unix环境编程</a></li>
								 <li ><a href="../../../../category/xing-neng-ce-shi.html">性能测试</a></li>
							</ul>
						</li>
						<li>
						        <h2>Tags</h2>
						        <ul>
                                                                <li><a href="../../../../tag/selenium.html">Selenium</a></li>
                                                                <li><a href="../../../../tag/zi-dong-hua-ce-shi.html">自动化测试</a></li>
                                                                <li><a href="../../../../tag/ltp.html">LTP</a></li>
                                                                <li><a href="../../../../tag/shell.html">shell</a></li>
                                                                <li><a href="../../../../tag/suan-fa.html">算法</a></li>
                                                                <li><a href="../../../../tag/xing-neng-ce-shi.html">性能测试</a></li>
                                                                <li><a href="../../../../tag/python.html">Python</a></li>
                                                                <li><a href="../../../../tag/docker.html">Docker</a></li>
                                                                <li><a href="../../../../tag/benchmark.html">benchmark</a></li>
                                                                <li><a href="../../../../tag/qi-ta.html">其他</a></li>
                                                                <li><a href="../../../../tag/unixbian-cheng.html">unix编程</a></li>
                                                                <li><a href="../../../../tag/linux.html">Linux</a></li>
                                                                <li><a href="../../../../tag/pyunit.html">PyUnit</a></li>
						        </ul>
						</li>
						
						
					</ul>
				</div>
				<!-- end #sidebar -->
				<div style="clear: both;">&nbsp;</div>
			</div>
		</div>
	</div>
	<!-- end #page -->

<div id="footer">
	<p>Copyright (c) 2008 Sitename.com. All rights reserved. Design by <a href="http://www.freecsstemplates.org/">CSS Templates</a>.</p>
	<p>Proudly powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>, which takes great advantages of <a href="http://python.org">python</a>.
</p>
</div>
<!-- end #footer -->
</body>
</html>