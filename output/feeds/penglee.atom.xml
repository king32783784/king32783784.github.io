<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Hi | World</title><link href="http://king32783784.github.io/" rel="alternate"></link><link href="http://king32783784.github.io/feeds/penglee.atom.xml" rel="self"></link><id>http://king32783784.github.io/</id><updated>2015-11-01T00:00:00+08:00</updated><entry><title>Autotest-client Package(1)</title><link href="http://king32783784.github.io/2015/11/01/autotest/" rel="alternate"></link><published>2015-11-01T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-11-01:2015/11/01/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;h3 id="autotest_local-mo-kuai"&gt;autotest_local 模块&lt;/h3&gt;
&lt;p&gt;class autotest.client.autotest_local.AutotestLocalAPP
本地自动测试，指定一个control文件启动测试&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/python&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;autotest.common&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;common&lt;/span&gt; &lt;span class="c1"&gt;# pylint: disable=W0611&lt;/span&gt;
    &lt;span class="n"&gt;rootdir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abspath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;common&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__file__&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;autodir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rootdir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'client'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;autodirbin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rootdir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'client'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'bin'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ImportError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;common&lt;/span&gt; &lt;span class="c1"&gt;# pylint: disable=W0611&lt;/span&gt;
    &lt;span class="n"&gt;autodirbin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;realpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;autodir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;autodirbin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;autidirbin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="n"&gt;autodirtest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;autodir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"tests"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'AUTODIR'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;autodir&lt;/span&gt;
&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'AUTODIRBIN'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;autidirbin&lt;/span&gt;
&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'AUTODIRTEST'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;autodirtest&lt;/span&gt;
&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'PYTHONPATH'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;autodirbin&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest.client&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;job&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest.client.shared.settings&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;settings&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest.client&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cmdparser&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;optparser&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AutotestLocalAPP&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

    &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;    Autotest local app runs tests locally&lt;/span&gt;

&lt;span class="sd"&gt;    Point it to a control file and let it rock&lt;/span&gt;
&lt;span class="sd"&gt;    '''&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_set_parsers&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_set_parsers&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opt_parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;optparser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AutotestLocalOptionParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cmd_parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cmdparser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CommandParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;usage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opt_parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_help&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;parse_cmdline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;optios&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opt_parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;test_directory&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isdir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;test_directory&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'CUSTOM_DIR'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;test_directory&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"The custom directory specifed does not exist, ignoring it ..."&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cmd_parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# Check for a control file if not in prebuild mode&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;client_test_setup&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"Missing &lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;usage&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_cmdline&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="n"&gt;drop_caches&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;settings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'CLIENT'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'drop_caches'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                         &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;client_test_setup&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest.client&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;setup_job&lt;/span&gt;
            &lt;span class="n"&gt;exit_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;setup_job&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setup_test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;exit_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exit_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# JOB: run the specifed job control file&lt;/span&gt;
        &lt;span class="n"&gt;job&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;runjob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;realpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;drop_caches&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;p&gt;上一篇
下一篇&lt;a href=""&gt;Autotest:&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-Autotest Remote (Autoserv)(三）</title><link href="http://king32783784.github.io/2015/08/22/autotest/" rel="alternate"></link><published>2015-08-22T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-22:2015/08/22/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;h3 id="running-autotest-in-a-guest"&gt;Running Autotest In a Guest&lt;/h3&gt;
&lt;p&gt;接下来看一下虚拟机guest执行一次测试的列子。control文件有点特别的是需要在host中运行OProfile收集运行时的信息。使用oprofile前，需要在guest安装。
给KVm指定一个IP，就会有一个虚拟机生成。试图运行虚拟机里面的oprofile，但没有成功。最后，选项"opcontrol --setup"应根据host中vmlinux位置调整。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;remote_host=hosts.SSHHost("192.168.1.1")
kvm_on_remote_host= kvm.KVM(remote_host)

kvm_on_remote_host.get("/var/local/src/kvm-compiled.tar.gz")
addresses= [{"mac":"02:00:00:00:00:01", "ip":"10.0.0.1"}]
kvm_on_remote_host.install(addresses, build=False, insert_moudles=False)

qemu_options="-m 256 -hda /var/local/vdisk.img -snapshot"
g1= hosts.KVMGuest(kvm_on_remote_host, qemu_options)
g1.wait.up()

at= autotest.Autotest()
at.get("/home/foo/autotest/client")
at.install(g1)

control_file="""
#~ job.profiles.add("oprofile", events=["CPU_CLK_UNHALTED:8000"])
job.run_test("linus_stress")
"""

results_dir= "g1_results"

# --start oprofile
remote_host.run("opcontrol --shutdown")
remote_host.run("opcontrol --reset")
remote_host.run("opcontrol --setup"
    # "--vmlinux /lib/modules/#(uname -r)build/vmlinux
    "--no-vmlinx"
    "--event CPU_CLK_UNHALTED:8000")
remote_host.run("opcontrol --start")

at.run(control_file, results_dir, g1)

# --stop opofile
remote_host.run("opcontrol --stop")
tmpdir= remote_host.get_tmp_dir()
remote_host.run('opreport -l &amp;amp;&amp;gt; "%s"' %(sh_escape(os.path.join(tmpdir, "report")),))
remote_host.get_file(os.path.join(tmpdir, "repoet"), os.path.join(results_dir, "host_oprofile"))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="changing-the-guest-kernel"&gt;Changing the Guest Kernel&lt;/h3&gt;
&lt;h4 id="usualway"&gt;Usual"Way&lt;/h4&gt;
&lt;p&gt;KVM虚拟机使用bootloader,可以运行时进行重启，可以在同一个虚拟机上安装不同的内核&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;remote_host= hosts.SSHHost("192.168.1.1")

kvm_on_remote_host= kvm.KVM(remote_host)
kvm_on_remote_host.get("/var/local/src/kvm-comiled.tar.gz")
addresses=[{"mac": "02:00:00:00:00:01", "ip": "10.0.0.1"}]
kvm_on_remote_host.install(addresses, build=False, insert_moudles=False)

qemu_options="-m 256 -hda /var/local/vdisk.img -snapshot"
g1= hosts.KVMguest(kvm_on_remote_host, qemu_options)
g1.wait_up()

print g1.run("uname -a").stdout

kernel= deb_kernel.DEBKernel()
kernel.get("/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64.deb")

kernel.install(g1)
g1.reboot()

print g1.run("uname -a").stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="qemu-way"&gt;"QEMU" Way&lt;/h4&gt;
&lt;p&gt;通常可以通过qemu 的-kernel -append -initrd 选项，这些选项可以指定虚拟机内核和磁盘镜像。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;remote_host= hosts.SSHHost("192.168.1.1")

kvm_on_remote_host= kvm.KVM(remote_host)
kvm_on_remote_host.get("/var/local/src/kvm-compiled.tar.gz")
addresses=[{"mac": "02:00:00:00:00:01", "ip": "10.0.0.1"})
kvm_on_remote_host.install(addresses, build=False, install_modules=False)

kernel= deb_kernel.DEBKernel()
kernel.get("/home/foo/linux-2.6.21.3-6_2.6.21.3-6_amd64-noNeedForInitrd.deb")
kernel_dir= kernel.extract(remote_host)

qemu_options= '-m 256 -hda /var/local/vdisk.img -snapshot -kernel "%s" -append "%s"' %(sh_escape(os.path.join(kernel_dir, kernel.get_image_name()[1:])), sh_escape("root=/dev/hda1 ro console=tty0 console=ttyS0, 9600"),)

g1=hosts.KVMGuest(kvm_on_remote_host, qemu_options)
g1.wait_up()

print g1.run("uname -a").stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="parallel-commands_1"&gt;Parallel commands&lt;/h3&gt;
&lt;p&gt;Autoserv 可以通过subcommand.py中的parallel()和parallel_simple()并行运行命令。
这对于一次测试多台机器和client-server测试非常有用。这里给出一个netperf2 测试的例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def check_kernel(host, version, package):
    if host.run("uname -r").stdout.strip() != version:
    package.install(host)
    host.reboot()

def install_kvm(kvm_on_host_var_name, host, source, addresses):
    exec("global %(var_name)s\n"
        "%(var_name)s= kvm.KVM(host)\n"
        "%(var_name)s.get(source)\n"
        "%(var_name)s.install(addresses)\n" % {"var_name":kvm_on_host_var_name})

    remote_host1= hosts.SSHHost("192.168.1.1")
    remote_host2= hosts.SSHHost("192.168.1.2")

    kernel= deb_kernel.DEBKernel()
    kernel.get("/var/local/linux-2.6.21.3-3_2.6.21.3-3_amd64.deb")

    host1_command= subcommand(check_kernel, [remote_host1, "2.6.21.3-3", kernel])
    host2_command= subcommand(check_kernel, [remote_host2, "2.6.21.3-3", kernel])

    parallel([host1_command, host2_command])

    install_kvm("kvm_on_remote_host1", remote_host1, "/var/local/src/kvm-33.tar.gz", [{"mac": "02:00:00:00:00:01", "ip": "10.0.0.1"}]
    qemu_options= "-m 256 -hda /var/local/vdisk.img -snapshot"
    gserver= hosts.KVMGuest(kvm_on_remote_host1, qemu_options)
    gserver.wait_up()

    at= autotest.Autotest()
    at.get("/home/foo/autotest/client")
    at.install(gserver)
    at.install(remote_host2)

    server_results_dir= "results-netperf-guest-to-host-far-server"
    client_results_dir= "results-netperf-guest-to-host-far-client"

    server_control_file= 'job.run_test("netperf2", "%s", "%s", "server", tag="server")' % (sh_escape(gserver.hostname), sh_escape(remote_host2.hostname),)
    client_control_file= 'job.run_test("netperf2", "%s", "%s", "client", tag="client")' % (sh_escapt(gserver.hostname),
    sh_escape(remote_host2.hostname),)

    server_command = subcommand(at.run, [server_control_file, server_results_dir, gserver])
    client_command= subcommand(at.run, [client_control_file, client_results_dir, remote_host2])

    parallel([server_command, client_command])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上一篇
下一篇&lt;a href=""&gt;Autotest:&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-Autotest Remote (Autoserv)(二）</title><link href="http://king32783784.github.io/2015/08/21/autotest/" rel="alternate"></link><published>2015-08-21T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-21:2015/08/21/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;h3 id="kvmzhi-chi"&gt;KVM支持&lt;/h3&gt;
&lt;p&gt;如前所述，Autoserv 支持控制虚拟机。这个对象设计的可以支持虚拟机管理/hypervisors。一开始，只支持kvm,为了支持KVM，你需要做：
    1.创建虚拟机，运行在虚拟层的机器
    2.创建KVM对象，通过get()指定源，KVM InstallableObject安装到指定的虚拟机。
    3.创建KVMGuest对象，需要指定做其他事情，KVM对象在上面已创建。
    4.使用KVMGuest对象运行一些其他类型的虚拟机命令，如改变内核，运行autotest&lt;/p&gt;
&lt;p&gt;可以通过查看server/kvm.py 和server/hosts/kvm_guest.py查看其他信息，尤其是KVM.install()的前面的函数和KVMGuest的函数构造。
下面给出一个Autoserv 控制文件的例子，第5行包括解析获取addresslist 列表，这个控制文件是由python实现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;remote_host = hosts.SSHHost("192.168.1.1")

kvm_on_remote_host = kvm.KVM(remote_host)
kvm_on_remote_host.get("/var/local/src/kvm-33.tar.gz")
addresses =[{"mac": "02:00:00:00:00:%02x" %(num,), "ip": "192.168.2.%d" % (num,)} for num in range(1, 32)]
kvm_on_remote_host.install(addreses)

qemu_options= "-m 256 -hda /var/local/vdisk.img -snapshot"
g = hosts.KVMGuest(kvm_on_remote_host, qemu_options)
g.wait_up()

print g.run("unme -a").stdout.strip()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="compiling-qemu_options"&gt;Compiling qemu_options&lt;/h3&gt;
&lt;p&gt;你需要指定KVM的源码，需要从http://sourceforge.net/project/showfiles.phpgroup_id=180599获取。当KVM对象安装，需要控制2个选项：build(默认）和 insert_modules（默认为True）.
如果build为true,Autoserv 会执行configure和make创建client和导入内核模块。 make install 永不会执行，否则会影响已经安装的系统。为了内核构建成功，需要将内核源码放到（/lib/modules/$(uname -r)/bulid. 如果build为flase,configure 和 make 已经执行了，二进制可以从源码文件夹中获取。还可以重新归档，如果你想让压缩包让get()获取。&lt;/p&gt;
&lt;p&gt;如果insert_modules为True，Autoserv会移除kvm模块，包括编译的。如果KVM对象侦测到，它会移除内核中的模块。同时，Autoserv会检查内核合适的模块去插入。如果qemu或qemu-system-x86_64曾经用过，就不再检查，直接使用。如果 insert_modules为False,假设运行的内核已经拥有KVM支持,就不会再进行模块操作。&lt;/p&gt;
&lt;h3 id="kernel-considerations"&gt;Kernel Considerations&lt;/h3&gt;
&lt;p&gt;下面介绍一些内核配置项，为定制自己的内核做参考。&lt;/p&gt;
&lt;h4 id="host-kernel"&gt;Host Kernel&lt;/h4&gt;
&lt;p&gt;CONFIG_HPET_EMULATE_RTC, KVM常见问题，rtc中断丢失，客户端响应慢
KVM, KVM_AMD, KVM_INTEL, 让内核支持这部分&lt;/p&gt;
&lt;h4 id="guest-kernel"&gt;Guest Kernel&lt;/h4&gt;
&lt;p&gt;Guest kernel没有具体的需求，只要能保证在qumu运行。许多发行内核上使用IDE和ide_generic驱动程序，以便与那些不是较新的libata，避免从/dev/hda的到/dev/sda的设备名称更改。可以将它编译成模块，需要的时候插入。&lt;/p&gt;
&lt;h4 id="disk-image-coniderations"&gt;Disk Image Coniderations&lt;/h4&gt;
&lt;p&gt;镜像需要作为qemu的一个选项，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;qemu_options= "-m 256 -hda /var/local/vdisk.img -snapshot"
g= hosts.KVMGuest(kvm_on_remote_host, qemu_options)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;/var/local/vdisk.img 是磁盘镜像， -snapshot指定qumu不能修改image,更改会虚拟机关闭后取消。可以参考&lt;a href="http://wiki.qemu.org/Manual"&gt;QEMU文档&lt;/a&gt;来了解QEMU信息。&lt;/p&gt;
&lt;h4 id="ip-address-configuration"&gt;IP Address Configuration&lt;/h4&gt;
&lt;p&gt;有一些要对diskimage做一些设置，在kvm.py:install()设置，虚拟机操作系统必须配置为与对应的Mac IP配置其网络。 Autoserv只能通过qemu的控制虚拟机的MAC地址，但是它将试图通过其IP联系它。你需要在install(）实现map和IP的映射，还需要确保虚拟机启动后扔采用这个IP。如果你启动一个虚拟机，可以在image中设置IP。如果想启动多台虚拟机，可以通过DHCPserver分配或则选择和mac对应的IP。一种方式如debian系统下通过/etc/network/interfaces文件去设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto eth0
mapping eth0
    script /usr/local/bin/get-mac-address.sh
    map 02:00:00:00:00:01 vhost1
    map 02:00:00:00:00:02 vhost2

iface vhost1 inet static
    address 10.0.2.1
    netmask 255.0.0.0
    geteway 10.0.0.1
iface vhost2 inet static
    address 10.0.2.2
    netmask 255.0.0.0
    geteway 10.0.0.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;/usr/local/bin/get-mac-address.sh :&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;

&lt;span class="nb"&gt;set&lt;/span&gt; -e
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;LANG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;C

&lt;span class="nv"&gt;iface&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="nv"&gt;mac&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;/sbin/ifconfig &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$iface&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; sed -n -e &lt;span class="s1"&gt;'/^'&lt;/span&gt;.*HWaddr &lt;span class="se"&gt;\(&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;:&lt;span class="o"&gt;[&lt;/span&gt;:xdigit:&lt;span class="o"&gt;]]&lt;/span&gt;*&lt;span class="se"&gt;\)&lt;/span&gt;.*/&lt;span class="o"&gt;{&lt;/span&gt;s//&lt;span class="se"&gt;\1&lt;/span&gt;/&lt;span class="p"&gt;;&lt;/span&gt;y/ABCDEF/abcdef/&lt;span class="p"&gt;;&lt;/span&gt;p&lt;span class="p"&gt;;&lt;/span&gt;q&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="s1"&gt;')&lt;/span&gt;
&lt;span class="s1"&gt;which=""&lt;/span&gt;

&lt;span class="s1"&gt;while read testmac scheme; do&lt;/span&gt;
&lt;span class="s1"&gt;    if ["$which" ]; then continue;fi&lt;/span&gt;
&lt;span class="s1"&gt;    if ["$mac" = "$(echo "$testmac" | sed -e '&lt;/span&gt;y/ABCDEF/abcdef/&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;"]; then which="&lt;/span&gt;&lt;span class="nv"&gt;$scheme&lt;/span&gt;&lt;span class="s2"&gt;"; fi&lt;/span&gt;
&lt;span class="s2"&gt;done&lt;/span&gt;

&lt;span class="s2"&gt;if ["&lt;/span&gt;&lt;span class="nv"&gt;$which&lt;/span&gt;&lt;span class="s2"&gt;"]; then echo &lt;/span&gt;&lt;span class="nv"&gt;$which&lt;/span&gt;&lt;span class="s2"&gt;; exit 0; fi&lt;/span&gt;
&lt;span class="s2"&gt;exit 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;/etc/network/interfaces文件需要重复编写，替换，可以通过python脚本实现，调整map_entry, host_entry, first_value和 last_value:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/python&lt;/span&gt;

&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""" #This file describes the network interfaces available on your system&lt;/span&gt;
&lt;span class="s2"&gt;# and how to activate them. For more infomation, see interfaces(5).&lt;/span&gt;

&lt;span class="s2"&gt;# The loopback network interface&lt;/span&gt;
&lt;span class="s2"&gt;auto lo&lt;/span&gt;
&lt;span class="s2"&gt;iface lo inet loopback&lt;/span&gt;

&lt;span class="s2"&gt;# The primary network interface&lt;/span&gt;
&lt;span class="s2"&gt;auto eth0&lt;/span&gt;
&lt;span class="s2"&gt;mapping eth0&lt;/span&gt;
&lt;span class="s2"&gt;    script /usr/local/bin/get-mac-address.sh"""&lt;/span&gt;

&lt;span class="n"&gt;map_entry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"    map 00:1a:11:00:00:&lt;/span&gt;&lt;span class="si"&gt;%02x&lt;/span&gt;&lt;span class="s2"&gt; vhost&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;

&lt;span class="n"&gt;host_entry&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""iface vhost&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s2"&gt; inet static&lt;/span&gt;
&lt;span class="s2"&gt;    address 10.0.2.&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s2"&gt;&lt;/span&gt;
&lt;span class="s2"&gt;    netmask 255.0.0.0&lt;/span&gt;
&lt;span class="s2"&gt;    gateway 10.0.0.1"""&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;

&lt;span class="n"&gt;first_value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;last_value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first_value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_value&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;map_entry&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;

&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first_value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;last_value&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;host_entry&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h4 id="ssh-authentication"&gt;SSH Authentication&lt;/h4&gt;
&lt;p&gt;类似于SSHHost，也需要设置免密码登陆。&lt;/p&gt;
&lt;h4 id="serial-console"&gt;Serial Console&lt;/h4&gt;
&lt;p&gt;虽然对于Autoserv本身不是必要的，但对于启动qumu图形很重要，需要进行初始化。qemu的可以模拟来自视频卡的显示，也可以模拟一个串行端口。 
* grub 配置文件（/boot/grub/menu.lst)
    serial --unit=0 --speed=9600 --word=8 --parity=no --stop=1
    terminal --timeout=3 serial console&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;kernel启动选项 
    console=tty0 console=ttyS0,9600&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/etc/inittab
    T0:23:respawn:/sbin/getty -L ttyS0 9600 vt100&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/20/autotest/"&gt;Autotest： Autotest-Autotest Remote (Autoserv)(一）&amp;gt;&amp;gt;&lt;/a&gt;
下一篇&lt;a href=""&gt;Autotest:&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-Autotest Remote (Autoserv)（一）</title><link href="http://king32783784.github.io/2015/08/20/autotest/" rel="alternate"></link><published>2015-08-20T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-20:2015/08/20/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;p&gt;Autoserv 是“自动化机器控制“的框架
Autoserv 目的是控制机器，它可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电源管理&lt;/li&gt;
&lt;li&gt;安装内核&lt;/li&gt;
&lt;li&gt;修改bootloader
*　运行任意命令&lt;/li&gt;
&lt;li&gt;运行Autotest Local(客户端）测试&lt;/li&gt;
&lt;li&gt;传输文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;被控制的机器可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本机&lt;/li&gt;
&lt;li&gt;远程机器（通过ssh 和　conmux)&lt;/li&gt;
&lt;li&gt;虚拟机(通过ＫＶＭ）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="kong-zhi-wen-jian"&gt;控制文件&lt;/h2&gt;
&lt;p&gt;类似于autotest,Autoserv同样使用控制文件。这些控制文件和autotest使用不同的命令，但是像autotest一样包含一些内部的可以调研python解释器的功能。&lt;/p&gt;
&lt;p&gt;这里有一个控制文件的例子，用来控制远程host安装.dep内核。若文件存在server/目录并且命名为example.control,可以在server/目录通过./autotest-remote example.control调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;remote_host = host.SSHHost("192.168.1.1")
print remote_host.run("uname -a").stdout

kernel = deb_kernel.DEBKernel()
kernel.get("/var/local/linux-2.6.22.deb")

print kernel.get_version()
print kernel.get_image_name()
print kernel.get_initrd_name()

kerne.install(remote_host)

remote_host.reboot()

print remote_host.run("uname -a").stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="hosts"&gt;Hosts&lt;/h2&gt;
&lt;p&gt;"Host"类是Autoserv控制文件的操作对象。这些Ｈost类通过ssh/conmux或virtual机控制机器。这些代码结构支持添加其他类型的hosts.如果想添加
其他类型的host，需要确保添加到server/hosts/&lt;strong&gt;init&lt;/strong&gt;.py文件。&lt;/p&gt;
&lt;h3 id="hostde-zhu-yao-fang-fa"&gt;Host的主要方法&lt;/h3&gt;
&lt;p&gt;以下是最常用的host的方法。每个类型的host都需要包含这些方法，起码支持列表选项中的方法。特定的host需要支持更多的命令和选项。关于这些信息，可以查看　
ａｕｔｏｔｅｓｔ子目录server/client中源码文件。下面的列表只是一个基本的汇总，不是那些源码文件的功能的头文件。特别是，需要查看一下server/hosts/ssh_host.py文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;run(command)&lt;/li&gt;
&lt;li&gt;reboot()&lt;/li&gt;
&lt;li&gt;get_file(source, dest)&lt;/li&gt;
&lt;li&gt;send_file(source, dest)&lt;/li&gt;
&lt;li&gt;get_tmp_dir&lt;/li&gt;
&lt;li&gt;is_up()&lt;/li&gt;
&lt;li&gt;wait_up(timeout)&lt;/li&gt;
&lt;li&gt;wait_down(timeout)&lt;/li&gt;
&lt;li&gt;get_num_cpu()&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="cmdresult-lei"&gt;CmdResult　类&lt;/h4&gt;
&lt;p&gt;run()调用的返回值是一个CmdResult类。该类包含了有关命令和其执行信息。这个类的定义和文档信息可以在server/hosts/base_classes.py文件中查看。
CmdResult类可以打印并且输出其所有的信息。它的每个字段都可以单独访问。这个字段的列表是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;command: 包含命令行本身的字符&lt;/li&gt;
&lt;li&gt;exit_status: 进程整数退出代码&lt;/li&gt;
&lt;li&gt;stdout:包含程序标准输出的字符串&lt;/li&gt;
&lt;li&gt;stderr: 包含程序错误输出的字符串&lt;/li&gt;
&lt;li&gt;duration: 程序运行的持续时间&lt;/li&gt;
&lt;li&gt;aborted:　导致终端命令中止的信号（０）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hostde-zhu-yao-lei-xing_1"&gt;Host的主要类型&lt;/h3&gt;
&lt;h4 id="sshhost"&gt;SSHHost&lt;/h4&gt;
&lt;p&gt;SSHHost是非常重要和实用的host类型。它可以通过ssh会话控制远程机器。它支持所有的hosts的基本方法和run(）功能，支持超时。SSHHost通过
ssh运行命令，通过scp进行文件传输。&lt;/p&gt;
&lt;p&gt;如果想采用SSHHost，必须设置远程机器无密码登陆，如通过公共秘钥。一个SSHHost对象建立在指定的host name,任意的用户名称和端口号。&lt;/p&gt;
&lt;h4 id="conmuxsshhost"&gt;ConmuxSSHHost&lt;/h4&gt;
&lt;p&gt;ConmuxSSHHost是SSHHost的扩展。它通过Conmux来控制远程机器。可以通过hardreset()方法进行硬复位。&lt;/p&gt;
&lt;h4 id="sitehost"&gt;SiteHost&lt;/h4&gt;
&lt;p&gt;Site host 是一个空类，可以添加特殊的方法或支持所以类型hostts的属性。它定义在server/hosts/site_host_py文件中，不过可能是空的。
创建这样的一个类的灵感来自于如更新bios，侦测硬件版本或一些对普通用户不常用的操作。&lt;/p&gt;
&lt;h4 id="kvmguest"&gt;KVMGuest&lt;/h4&gt;
&lt;p&gt;KVMGuest 表示可以运行程序的KVM 虚拟机。　它必须绑定到其他host, 这些机器实际上运行于虚拟层。KVMGuest和SSHHost非常类似，但它可以通过hardreset方法（Guest中）调用hypervisor的命令去实现”硬复位“.可以通过查看&lt;a href=""&gt;KVM section&lt;/a&gt;查看更多的KVM和KVMguest信息。&lt;/p&gt;
&lt;h4 id="bootloader"&gt;Bootloader&lt;/h4&gt;
&lt;p&gt;Boottool 是一个查询和修改bootloader文件的perl脚本。Autoserv提供Bootloader类，是围绕boottool的包装。Ａutoserv 在需要时会第一时间将boottool脚本自动复制到一个临时目录。可以通过查看server/hosts/bootloader.py查看支持方法的信息。其中最重要的一个方法是add_kernel()&lt;/p&gt;
&lt;p&gt;当添加了一个新内核是，boottool会复用上一个内核的命令行及配置，来实现一个新的启动项菜单。&lt;/p&gt;
&lt;h2 id="installableobject_2"&gt;InstallableObject&lt;/h2&gt;
&lt;p&gt;InstallableObject　表示一个可以再host上安装软件包。通过下面两个方法实现：
&lt;em&gt; get(location)
&lt;/em&gt; install(host)&lt;/p&gt;
&lt;p&gt;get()表示获取安装包，它可以获取多种类型保存位置的包：
&lt;em&gt; 本地目录
&lt;/em&gt; URL地址
&lt;em&gt; python文件对象
&lt;/em&gt; 如果参数不是上述类型，get()会默认将获取的内容当为包内容&lt;/p&gt;
&lt;p&gt;get()获取的软件包，通常会放到一个临时目录。这种方式可以一次获取，安装到多台hosts上面。install()会安装包，当通常会装到一个临时目录。&lt;/p&gt;
&lt;h2 id="autotest-support"&gt;Autotest Support&lt;/h2&gt;
&lt;p&gt;Autoserv包含autotest的一些具体支持。它可以安装autotest到一个客户端，可以运行客户端的测试并且取回测试结果。这是通过autotest和运行server/autotest.py中的
类实现的。Auotest对象是一个installableＯbject.要想使用它，必须：
&lt;em&gt; 指定来源后通过get()获取，autotest对象有点特别。如果没有指定任何来源，将会自动从autotest　ＳＶＮ库自动获取。而且会在目标主机中完成。
&lt;/em&gt; 当通过install()安装时，autotest会查找一个/etc/autotest.conf的文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;autodir=/usr/local/autotest/
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;run()运行一个控制文件的语法如下：run(control_file, results_dir, host).control_file 参数支持get()和intallableObject相同类型的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是一个Autoserv控制文件和运行Autotest job的例子。测试结果会传输到server的“job_results"目录下。
    remote_host = hosts.SSHHost("192.168.1.1")&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;at = autotest.Autotest()
at.get("/var/local/autotest/client")
at.install(remote_host)

control_file = """
job.profilers.add("oprofile", events= ["CPU_CLK_UNHALED:8000"])
job.run_test("linux_stress")
"""

results_dir = "job_results"

at.run(control_file, results_dir, remote_host)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="kernel-objects"&gt;Kernel Objects&lt;/h2&gt;
&lt;p&gt;Kernel Objects 是另一个类型的InstallableObjects.计划支持内核源码编译及.rpm和.deb包安装。最初，只支持.deb格式内核。现在已经支持源码格式的内核。
kernels支持依赖以下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get(location)
    用户installableObject方法&lt;/li&gt;
&lt;li&gt;install(host, extra arguments to boottool).当一个内核安装在host后，会使用bootbool使它自己编程默认的启动内核。如果需要指定特别的内核参数，
需要可以添加，并传递给add_kernel()方法用来启动内核。&lt;/li&gt;
&lt;li&gt;get_version()&lt;/li&gt;
&lt;li&gt;get_image_name()&lt;/li&gt;
&lt;li&gt;get_image_name()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样，可以通过查看源码了解更多详细信息，如server/deb_kernel.py&lt;/p&gt;
&lt;p&gt;DEBKernels　有一个额外的方法，host直接提取内核。这个方法可以直接将包解压到指定的host.这样可以不经过安装，可以直接访问包的内容。这个功能比较常用的地方就是
kvm和qumu的　-kernel选项。&lt;/p&gt;
&lt;p&gt;下面给出一个Autoserv安装内核的控制文件的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rh = hosts.SSHHost("192.168.1.1")

print rh.run("uname -a").stdout

kernel = deb_kernel.DEBKernel()
kernel.get("/var/local/linux-2.6.22.deb")

kernel.install(rh)

rh.reboot()

print rh.run("uname -a").stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个类似的例子使用RPM形式的kernel，并让指定启动参数（autoserv -m host1, host2 install-rpm):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if not machines:
    raise "Specify the machines to run on via the -m flag"
hosts = [hosts.SSHHost(h) for h in machines]

kernel = rpm_kernel.RPMKernel()
kernel.get('/stuff/kernels/kernel-smp-2.6.18.x86_64.rpm')

for host in hosts:
    print host.run("uame -a").stdout
    kernel.install(host, default=True)
    host.reboot()
    print host.run("uname -a").stdout

print "Done"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未完待续&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/19/autotest/"&gt;Autotest：Autotest-others&amp;gt;&amp;gt;&lt;/a&gt;
下一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/21/autotest/"&gt;Autotest:Autotest-Autotest Remote (Autoserv)(二）&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-others</title><link href="http://king32783784.github.io/2015/08/19/autotest/" rel="alternate"></link><published>2015-08-19T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-19:2015/08/19/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;h2 id="zhi-xing-wai-bu-ce-shi"&gt;执行外部测试&lt;/h2&gt;
&lt;p&gt;autotest可以像执行自身测试一样执行外部测试．&lt;/p&gt;
&lt;h3 id="zhi-xing-ce-shi"&gt;执行测试&lt;/h3&gt;
&lt;p&gt;一个下载的测试并触发，标准方式是通过run_test方法执行，需要指定tar包地址．
　　
    job.run_test('http://www.example.com/~someone/somewhere/test.tar.bz2')&lt;/p&gt;
&lt;p&gt;这样就会执行下载，安装，解压测试．&lt;/p&gt;
&lt;h3 id="gou-jian-wai-bu-xia-zai-ce-shi"&gt;构建外部下载测试&lt;/h3&gt;
&lt;p&gt;外部下载的测试包含bz2包和测试目录．
&lt;em&gt; 1．包名　my_test.tar.bz2
&lt;/em&gt; 2. 测试脚本　my_test.py
* 3.　测试脚本中的以本身命名的类　class my_test(test.test):&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest_lib.client.bin&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;

    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;my_test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"INIT"&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run_once&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"RUN"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tar -C example_test -jcvf my_test.tar.bz2 .
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="autotest-de-keyvalwen-jian_1"&gt;Autotest 的keyval文件&lt;/h2&gt;
&lt;p&gt;在ａｕｔｏｔｅｓｔ的结果目录中有一些keyval文件，例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;key1=value1
key2=value2
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="ce-shi-jie-guo-zhong-cuo-wu-xin-xi"&gt;测试结果中错误信息&lt;/h2&gt;
&lt;h3 id="debug"&gt;debug&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;debug/

├── build_log.gz
├── client.DEBUG
├── client.ERROR
├── client.INFO
└── client.WARNING
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;autotest local 还有一些小的细节问题，不再一一介绍．&lt;/p&gt;
&lt;p&gt;下篇将开始介绍Remote (Former Server)．&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/18/autotest/"&gt;Autotest：Autotest-add test&amp;gt;&amp;gt;&lt;/a&gt;
下一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/20/autotest/"&gt;Autotest:Autotest-Autotest Remote (Autoserv)&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-Linux distribution detection</title><link href="http://king32783784.github.io/2015/08/18/autotest/" rel="alternate"></link><published>2015-08-18T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-18:2015/08/18/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;h2 id="linuxfa-xing-ban-jian-ce"&gt;linux发行版检测&lt;/h2&gt;
&lt;p&gt;Autotest有个功能,就是让测试清晰了解到它运行在什么样的发行版上.
这个功能是由probe类群的实现和注册实现的.
这些probe类可以检查运行的系统的信息,比如发行版的release文件,二进制信息(如包管理)等.&lt;/p&gt;
&lt;h3 id="kuai-su-jian-cha-fa-xing-ban"&gt;快速检查发行版&lt;/h3&gt;
&lt;p&gt;autotest.client.shared.distro 模块提供一些APIS,最简单的就是使用detect().
它的用法简单命了:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest.client.shared&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;distro&lt;/span&gt;
    &lt;span class="n"&gt;detected_distro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;distro&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;detect&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以返回发行版检测的结果,但是不太适用于&lt;strong&gt;UNKNOWN_DISIRO&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;version&lt;/li&gt;
&lt;li&gt;release&lt;/li&gt;
&lt;li&gt;arch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;detected_distro = distro.detect()
&amp;gt;&amp;gt;&amp;gt;print detected_distro.name
redhat
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="wei-zhi-fa-xing-ban"&gt;未知发行版&lt;/h3&gt;
&lt;p&gt;当检测机制不能检测到发行版,仍会返回一个LinuxDistro实例,但是它的name,version等信息比较特殊.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; autotest.clientshared.distro.UNKNOWN_DISIRO
 =&amp;lt;LinuxDistro: name=unnknown, version=0, realease=0, arch=unknown&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意味着,这个发行版不能找到对应的匹配信息.&lt;/p&gt;
&lt;h3 id="bian-xie-yi-ge-fa-xing-ban-probe"&gt;编写一个发行版probe&lt;/h3&gt;
&lt;p&gt;为目标发行版编写一个probe最简单的方式就是使用现有的Probe类的功能.
如果,不打算采用Probe的话,也应该尽量继承probe类,或则提供类似的接口.&lt;/p&gt;
&lt;h4 id="jian-cha-fa-xing-ban-de-ming-zi"&gt;检查发行版的名字&lt;/h4&gt;
&lt;p&gt;最简单的探针就是查看存在的文件并返回发行版的名字.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ReadHatProbe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Probe&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/etc/redhat-realease'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'redhat'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要使用probe,需要先注册:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest.client.shared&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;distro&lt;/span&gt;
    &lt;span class="n"&gt;distro&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RedHatProbe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个有效的例子，但只有发行版的名字,通常你的目标应该是更多的信息，如版本号。&lt;/p&gt;
&lt;h4 id="zhen-ce-fa-xing-ban-de-ming-zi-he-ban-ben"&gt;侦测发行版的名字和版本&lt;/h4&gt;
&lt;p&gt;如果,你需要侦测发行版的版本信息,可以使用Probe类的 Probe.CHECK_VERSION_REGEX&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Probe.CHECK_VERSION_REGEX=None
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zhu-ce-zi-ji-de-probes"&gt;注册自己的probes&lt;/h4&gt;
&lt;p&gt;Autotest不仅仅可以使用自带的probes,而且可以添加自己的probes用于系统的侦测.
注册的简单方式就剩调用register_probe():&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;autotest.client.shared.distro.register_probe(probe_class)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意,要注册的自己的probes必须是probe的子类.&lt;/p&gt;
&lt;h3 id="apican-kao_1"&gt;API参考&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;LinuxDistro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;class autotest.client.shared.distro.LinuxDistro(name, version, release, arch) &lt;a href="#linuxdistro"&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;收集linux发行版信息的简单方式.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Probe&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;class autotest.client.shared.distro.Probe  &lt;a href="#Probe"&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CHECK_FILE=None&lt;/p&gt;
&lt;p&gt;CHECK_FILE_CONTAINS=None&lt;/p&gt;
&lt;p&gt;CHECK_FILE_DISTRO_NAME =None&lt;/p&gt;
&lt;p&gt;CHECK_VERSION_REGEX = None&lt;/p&gt;
&lt;p&gt;Check_name_for_file()&lt;/p&gt;
&lt;p&gt;check_name_for_file_contains()&lt;/p&gt;
&lt;p&gt;check_release()&lt;/p&gt;
&lt;p&gt;check_version()&lt;/p&gt;
&lt;p&gt;get_distro()&lt;/p&gt;
&lt;p&gt;name_for_file()&lt;/p&gt;
&lt;p&gt;name_for_file_contains()&lt;/p&gt;
&lt;p&gt;release()&lt;/p&gt;
&lt;p&gt;version()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;register&lt;/strong&gt;_&lt;strong&gt;probe()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;autotest.client.shared.distro.register_probe(probe_class) &lt;a href="#register_probe"&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注册probe&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;detect()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;autotest.client.shared.distro.detect() &lt;a href="#detect"&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;尝试检测这台机器上的Linux发行版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Source code for autotest.client.shared.distro&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    This module provides the client facilities to detect the Linux Distribution&lt;/span&gt;
&lt;span class="sd"&gt;    it's running under.&lt;/span&gt;

&lt;span class="sd"&gt;    This is a replacement for the get_os_vendor() function from the utils modules.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;platform&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;re&lt;/span&gt;


    &lt;span class="n"&gt;__all__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'LinuxDistro'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="s1"&gt;'UNKNOWN_DISTRO_NAME'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="s1"&gt;'UNKNOWN_DISTRO_VERSION'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="s1"&gt;'UNKNOWN_DISTRO_RELEASE'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="s1"&gt;'UNKNOWN_DISTRO_ARCH'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="s1"&gt;'Probe'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="s1"&gt;'register_probe'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="s1"&gt;'detect'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="c1"&gt;# [__all__用法]()&lt;/span&gt;

    &lt;span class="c1"&gt;# pylint: disable=R0903&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;LinuxDistro&lt;/strong&gt; &lt;span id="linuxdistro"&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinuxDistro&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        Simple collection of infomation for a Linux Distribution&lt;/span&gt;
&lt;span class="sd"&gt;        '''&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;            Initalizes a new Linux Distro&lt;/span&gt;
&lt;span class="sd"&gt;            :param name: 一个简单的区别于其他发型版的名字&lt;/span&gt;
&lt;span class="sd"&gt;            :type name : 字符&lt;/span&gt;
&lt;span class="sd"&gt;            :parm vesion:发行版的主版本.&lt;/span&gt;
&lt;span class="sd"&gt;            :type vesion: 字符&lt;/span&gt;
&lt;span class="sd"&gt;            :param release: 发行版的发型号或子版本.&lt;/span&gt;
&lt;span class="sd"&gt;            :type vesion:字符&lt;/span&gt;
&lt;span class="sd"&gt;            :parm arch: 发行版的平台架构信息,如interl/amd 32bit/64bit&lt;/span&gt;
&lt;span class="sd"&gt;            :type arch: 字符&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;release&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arch&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;  &lt;span class="c1"&gt;# [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;'&amp;lt;LinuxDistro: name=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;, version=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;, release=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;, arch=&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;&amp;gt;'&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


    &lt;span class="n"&gt;UNKNOWN_DISTRO_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'unknown'&lt;/span&gt;
    &lt;span class="n"&gt;UNKNOWN_DISTRO_VERSION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;UNKNOWN_DISTRO_RELEASE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;UNKNOWN_DISTRO_ARCH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'unknown'&lt;/span&gt;   &lt;span class="c1"&gt;# 定义未知发行版默认信息&lt;/span&gt;

    &lt;span class="c1"&gt;#: 未知发行版,反馈以下信息&lt;/span&gt;
    &lt;span class="n"&gt;UNKNOWN_DISTRO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LinuxDistro&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UNKNOWN_DISTRO_NAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                 &lt;span class="n"&gt;UNKNOWN_DISTRO_VERSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                 &lt;span class="n"&gt;UNKNOWN_DISTRO_RELEASE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                 &lt;span class="n"&gt;UNKNOWN_DISTRO_ARCH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Probe&lt;/strong&gt; &lt;span id="Probe"&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        探测机器信息并且确认是否存在的发行版&lt;/span&gt;
&lt;span class="sd"&gt;        '''&lt;/span&gt;
        &lt;span class="c1"&gt;#:指定运行机器上发行版中的文件.&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

        &lt;span class="c1"&gt;#:设置指向文件的检查内容,默认为None,只检查是否存在&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_CONTAINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

        &lt;span class="c1"&gt;#:如果文件指定,指定发行版名字&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

        &lt;span class="c1"&gt;#:指定发行版版本&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_VERSION_REGEX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;check_name_for_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; 
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;            查找一个文件并返回distro.确认是否指定了特定文件&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;name_for_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;            获取distro名称,如果"CHECK_FILE"设置并且存在&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_name_for_file&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;check_name_for_file_contains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;            该类查找text并返回distro.&lt;/span&gt;
&lt;span class="sd"&gt;            The conditions that must be true include the file that identifies the&lt;/span&gt;
&lt;span class="sd"&gt;            distro file being set (:attr:`CHECK_FILE`), the text to look for&lt;/span&gt;
&lt;span class="sd"&gt;            inside the distro file (:attr:`CHECK_FILE_CONTAINS`) and the name&lt;/span&gt;
&lt;span class="sd"&gt;            of the distro to be returned (:attr:`CHECK_FILE_DISTRO_NAME`)&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE_CONTAINS&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;name_for_file_contains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;             获取distro如果CHECK_FILE指定并且有效&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_name_for_file_contains&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readlines&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE_CONTAINS&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;check_version&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;             检查在文件中是否找到regex并返回distro&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

             &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_VERSION_REGEX&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                 &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

             &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_get_version_match&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;            返回匹配备注文件中的版本信息&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_version&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;patch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                    &lt;span class="n"&gt;version_file_content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_FILE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_VERSION_REGEX&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;version_file_content&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

         &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;version&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
             &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;             返回distro的版本信息&lt;/span&gt;
&lt;span class="sd"&gt;             '''&lt;/span&gt;
             &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO_VERSION&lt;/span&gt;
             &lt;span class="n"&gt;match&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_get_version_match&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groups&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                     &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groups&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;check_release&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;            检查是否存在符合条件的版本号&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_version&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt;
                    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CHECK_VERSION_REGEX&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groups&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;release&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;             返回 distro的版本号&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
             &lt;span class="n"&gt;release&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO_RELEASE&lt;/span&gt;
             &lt;span class="n"&gt;match&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_get_version_match&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groups&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                     &lt;span class="n"&gt;release&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groups&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
             &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_distro&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;            返回 class:'LinuxDistro' probe detected&lt;/span&gt;
&lt;span class="sd"&gt;            '''&lt;/span&gt;
            &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
            &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO_VERSION&lt;/span&gt;
            &lt;span class="n"&gt;release&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO_RELEASE&lt;/span&gt;
            &lt;span class="n"&gt;arch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO_ARCH&lt;/span&gt;

            &lt;span class="n"&gt;distro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_name_for_file&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name_for_file&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_name_for_file_contains&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name_for_file_contains&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_version&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_release&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="n"&gt;release&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                 &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

            &lt;span class="c1"&gt;# 实在想不到比这更好的方式&lt;/span&gt;
            &lt;span class="n"&gt;arch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uname&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

            &lt;span class="c1"&gt;# 名字是首先要侦测的.它可以告诉我们是哪个发行版.&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;distro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LinuxDistro&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;distro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO&lt;/span&gt;

            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;distro&lt;/span&gt;

    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StdLibProbe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Probe&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;         Probe是使用python库内建的probe.&lt;/span&gt;
&lt;span class="sd"&gt;         这个Probe得分比较低,作为备用probe.&lt;/span&gt;
&lt;span class="sd"&gt;        '''&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_distro&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
            &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO_VERSION&lt;/span&gt;
            &lt;span class="n"&gt;realease&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKONWN_DISTRO_RELEASE&lt;/span&gt;
            &lt;span class="n"&gt;arch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKONWN_DISTRO_ARCH&lt;/span&gt;

            &lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d_version_release&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d_codename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d_name&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="s1"&gt;'.'&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;d_version_release&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;d_version&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d_release&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d_version_release&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'.'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d_version&lt;/span&gt;
                &lt;span class="n"&gt;release&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d_release&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d_version_release&lt;/span&gt;

             &lt;span class="n"&gt;arch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uname&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

             &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                 &lt;span class="n"&gt;distro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LinuxDistro&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                 &lt;span class="n"&gt;distro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO&lt;/span&gt;

             &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;distro&lt;/span&gt;

    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RedHatProbe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Probe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        红帽发行版版本检查&lt;/span&gt;
&lt;span class="sd"&gt;        '''&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/etc/redhat=release'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_CONTAINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Red Hat'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'redhat'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_VERSION_REGEX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s1"&gt;r'Red Hat Enterprise Linux Server release(\d{1,2})\.(\d{1,2}).*'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CentosProbe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RedHatProbe&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        Centos系统检测&lt;/span&gt;
&lt;span class="sd"&gt;        '''&lt;/span&gt;

        &lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/etc/redhat-release'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_CONTAINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'CentOS'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'centos'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_VERSION_REGEX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;r'CentOS release(\d{1,2})\.(\d{1,2}).*'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FedoraProbe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RedHatProbe&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        Probe with version checks for Fedora systems&lt;/span&gt;
&lt;span class="sd"&gt;        '''&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/etc/fedora-release'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_CONTAINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Fedora'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'fedora'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_VERSION_REGEX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;r'Fedora release (\d{1,2}).*'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DebianProbe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Probe&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        Simple probe with file checks for Debian systems&lt;/span&gt;
&lt;span class="sd"&gt;        '''&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/etc/debian-version'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'debian'&lt;/span&gt;


    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UbuntuProbe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Probe&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        Simple probe with file checks for Ubuntu systems&lt;/span&gt;
&lt;span class="sd"&gt;        '''&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/etc/os-release'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_CONTAINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'Ubuntu'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'ubuntu'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_VERSION_REGEX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;r'VERSION_ID="(\d+.\d+)"'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SuseProbe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Probe&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'/etc/SuSE-release'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_FILE_DISTRO_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'sles'&lt;/span&gt;
        &lt;span class="n"&gt;CHECK_VERSION_REGEX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;r'SUSE.*\nVERSION = (.*)\nPATCHLEVEL = (.*)'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


    &lt;span class="c1"&gt;#: 已注册probes列表&lt;/span&gt;
    &lt;span class="n"&gt;REGISTERED_PROBES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;register_probe&lt;/strong&gt; &lt;span id="register_probe"&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;probe_class&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; 
        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        注册probe&lt;/span&gt;
&lt;span class="sd"&gt;        '''&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;probe_class&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;REGISTERED_PROBES&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;REGISTERED_PROBES&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;appen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;probe_class&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RedHatProbe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CentosProbe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FedoraProbe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DebianProbe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UbuntuProbe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SuseProbe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;register_probe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;StdLibProbe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;detect&lt;/strong&gt; &lt;span id="detect"&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;detect&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        尝试在机器上侦测发行版&lt;/span&gt;
&lt;span class="sd"&gt;　　    '''&lt;/span&gt;
        &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;probe_class&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;REGISTERED_PROBES&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;probe_instance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;probe_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;didtro_result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;probe_instance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_distro&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;distro_result&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;distro_result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;probe_instance&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

        &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;distro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;distro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UNKNOWN_DISTRO&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;dostro&lt;/span&gt;

    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Spec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;'''&lt;/span&gt;
&lt;span class="sd"&gt;        发行版最低发行要求&lt;/span&gt;
&lt;span class="sd"&gt;　　　　 '''&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;min_version&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="n"&gt;min_release&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;min_version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;min_version&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;min_release&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;min_release&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/17/autotest/"&gt;Autotest：Autotest-Using and developing job profilers&lt;/a&gt;
下一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/19/autotest/"&gt;Autotest:Autotest-others&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-Using and developing job profilers</title><link href="http://king32783784.github.io/2015/08/17/autotest/" rel="alternate"></link><published>2015-08-17T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-17:2015/08/17/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;h2 id="shi-yong-he-tian-jia-ce-shi-fen-xi-qi"&gt;使用和添加测试分析器&lt;/h2&gt;
&lt;p&gt;添加一个分析器和添加一个测试项目类似.每个分析器都有自己的子目录(client/profilers或你可以查看profilers/),一个标准例子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个控制文件. profilers/myprofiler/control&lt;/li&gt;
&lt;li&gt;分析器控制脚本. profilers/myprofiler.py&lt;/li&gt;
&lt;li&gt;分析器的源码(如果不仅仅是控制脚本)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来看一下已有的分析器. autotest提供readprofile,尽管这不是个最简单的方式,但是能够看到你想了解的全部信息.readprofile支持编译近内核.&lt;/p&gt;
&lt;p&gt;控制文件非常简单,像这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.profilers.add('readprofile')
job.run_test('sleeptest', 1)
job.profilers.delete('readprofile')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只是说明"请再以下测试中使用readprofile".一次测试,如果想添加多个分析器,可以多次调用profilers.add.&lt;/p&gt;
&lt;p&gt;还有源码包"util-linux-2.12r.tar.bz2",将会解压到src/.python控制脚本将定义,分析器要做的大部分事情.通过查看readprofile.py,我们可以看到
profiler主类,定义版本.可以看到以下个函数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setup()  它会在第一次用profiler时执行,并且编译源码.&lt;/li&gt;
&lt;li&gt;intialize() 将在导入profiler时执行&lt;/li&gt;
&lt;li&gt;start() 启动分析&lt;/li&gt;
&lt;li&gt;stop() 停止分析&lt;/li&gt;
&lt;li&gt;report() 利用profiler数据生成报告&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来 看一下这些方法的细节.&lt;/p&gt;
&lt;h3 id="setup"&gt;Setup&lt;/h3&gt;
&lt;p&gt;setup(),在版本变动之前,每次测试只执行一次.它会解压util-linux-2.12r.tar.bz2至src/,并且编译.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#http://www.kernel.org/pub/linux/util-linux/util-linux-2.12r.tar.bz2
def setup(self, tarball = 'util-linux-2.12r.tar.bz2'):
    self.tarball = unmap_url(self.bindir, tarball, self.tmpdir)
    extract_tarball_to_dir(self.tarball, self.srcdir)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注释信息告诉我们去哪得到源码.函数定义的参数,定义了使用什么版本的源码.接下来,使用unmap_url下载源码,并且返回一个源码的保存路径.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;os.chdir(self.srcdir)
system('./configure')
os.chdir('sys-utils')
system('make readprofile)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先是切换目录到self.srcdir.切换后,执行./configure,然后执行编译.这里使用的system()(不是os.system(),system()是一个包装后的os.system()).如果返回值
不是0,它将会自动抛出异常.&lt;/p&gt;
&lt;h3 id="initialize"&gt;Initialize&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def initialize(self):
    try:
        system('grep -iq" profile = "/proc/cmdline")
    except:
        raise CmdError, 'readprofile not enabled'

self.cmd = self.srcdir + '/sys-utils/readprofile'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它会在我们导入profiler后执行,用来检查 readprofile是否使能.&lt;/p&gt;
&lt;h3 id="start"&gt;Start&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def start(self, test):
    system(self.cmd + '-r')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动profiler, 只是执行readprofile -r&lt;/p&gt;
&lt;h3 id="stop"&gt;Stop&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def stop(self, test):
    # There's no real way to stop readprofile, so we stash the 
    # rad data at this point instead. BAD EXAMPLE TO COPY!;-)
    self.rawprofile = test.profdir + '/profile.raw'
    print "STOP"
    shutil.copyfile('/proc/profile', self.rawprofile)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般的话,只运行readprofile --stop即可.但是如果启用的多个分析器,我们这样做为了区分每个的分析数据,使他们不相互影响.&lt;/p&gt;
&lt;h3 id="report"&gt;Report&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def report(self, test):
    args = ' -n'
    args += ' -m' + get_systemmap()
    args += ' -p' + self.rawprofile
    cmd = self.cmd + ' ' + args
    txtprofile = test.profdir + '/profile.text'
    system(cmd + ' | sort -nr &amp;gt; ' + txtprofile)
    system('bzip2' + self.rawprofile)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将分析数据转成txt. 我们需要找到kernel的Sytem.map和用户空间产生的结果(a test file).我们将结果保存在test子目录下的profiling/,这个目录在set up时已自动创建.&lt;/p&gt;
&lt;h3 id="tian-jia-zi-ji-de-profiler"&gt;添加自己的profiler&lt;/h3&gt;
&lt;p&gt;只需要在profilers下创建一个新目录,然后添加自己的控制文件,源码和控制脚本.最简单的方式是直接复制已有的readprofile.py为mytest.py,并且修改顶部的类名.&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/16/autotest/"&gt;Autotest：Autotest-add test&amp;gt;&amp;gt;&lt;/a&gt;
下一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/18/autotest/"&gt;Autotest:Autotest-Linux distribution detection&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-add test</title><link href="http://king32783784.github.io/2015/08/16/autotest/" rel="alternate"></link><published>2015-08-16T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-16:2015/08/16/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;h2 id="ce-shi-mo-kuai-kai-fa"&gt;测试模块开发&lt;/h2&gt;
&lt;p&gt;测试模块必需是独立的单元，包含测试需要的所有内容（除了调用测试框架的）&lt;/p&gt;
&lt;p&gt;测试模块需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以跨多硬件架构&lt;/li&gt;
&lt;li&gt;可以支持不同的发行版&lt;/li&gt;
&lt;li&gt;至少一个维护者&lt;/li&gt;
&lt;li&gt;提供一个默认的简单例子&lt;/li&gt;
&lt;li&gt;对自己目录外的东西不做修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tian-jia-ce-shi-xiang"&gt;添加测试项&lt;/h2&gt;
&lt;p&gt;增加一个测试项，可能是最容易的开发工作了．&lt;/p&gt;
&lt;p&gt;每一个测试项都有一个自己的子目录（client 端的是client/tests,server端的是server/tests),一个标准的目录包括
&lt;em&gt; 一个control 文件（tests/mytest/control)
&lt;/em&gt; 一个测试包装脚本（tests/mytest/mytest.py)
* 如果不仅仅是python脚本中实现的，还需要补充测试源码&lt;/p&gt;
&lt;p&gt;可以查看已有的测试，比如tests/dbench.首先包括测试目录tests/dbench,测试控制脚本dbench.py,  包括其中命名为dbench的类．这些这新开发的测试中
也必须要有．&lt;/p&gt;
&lt;p&gt;control文件至少是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.run_test('dbench')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子只包含了基本的参数，通过这个去了解一些新测试项的基本的设置，随后可以自己扩展其他的东西．&lt;/p&gt;
&lt;p&gt;目录下同样有个测试工具源码包dbench-3.04.tar.gz,随后会解压源码在src／
大多要执行的测试都包括在python脚本．可以看一下dbench.py.你会看到继承至test类，并且定义版本．你可以看到４个功能：
&lt;em&gt; initialize() -这个是每个测试前执行的，而且每次都要执行．
&lt;/em&gt; setup()- 这个会在第一次测试时执行，并且会进行源码的编译
&lt;em&gt; run_once()- 可以调用job.run_test N 次，其中Ｎ是通过run_test的iterations参数指定的.它同时也会启动分析器,如果你已经使能了一些分析器
&lt;/em&gt; postprocess_iteration() -此处理由测试迭代产生的任何结果，并写出来变成KEYVAL。 它一般不要求的分析迭代．&lt;/p&gt;
&lt;p&gt;测试结果输出一个PASS,你可以抛出一个异常，当一个测试失败，警告，或ｅｒｒｏｒ．绝大数出错时，ｐｙｔｈｏｎ都会抛出一个异常．所以不必担心这个，你可以处理之外的一些事情．下面说一下这些funtions的细节．
&lt;strong&gt;setup&lt;/strong&gt;
一次测试需要执行一次的setup.除非版本变动，不然只允许一次．在本文的例子中，解压dbench-3.04.tar.gz至src/,并且进行编译．&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#http://samba.org/ftp/tridge/dbench/dbench-3.04.tar.gz
def setup(self, tarball='dbench-3.04.tar.gz'):
    tarball = utils.unmap_url(self.bindir, tarball, self.tmpdir)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注释告诉我们测试程序源码的下载地址．函数开头定义了源码包的名字（你可以通过不同control文件采用不同源码版本）最后，采用unmap_url(重写的url),它会下载源码，并返回localｐａｔｈ．&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;utils.extract_taball_to_dir(tarball, self.srcdir)
os.chdir(self.srcdir)
utils.system('./configure')
utils.system('make')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解压源码到指定目录self.srcdir.然后切换目录src.然后运行./configure; make 去建立测试环境;
我们使用了本地的system(),而不是os.system&lt;/p&gt;
&lt;p&gt;如果返回值不是0,会自动抛出一个异常.
除了编译源码包外,你可以通过software_manager模块去进行系统依赖包的安装.
如何使用?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;autotest.client.shared&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;software_manager&lt;/span&gt;
&lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;software_manager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SoftwareManager&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;backend&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;install&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'package_name'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;run_once&lt;/strong&gt;
它是实际执行测试的.核心只是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;self.results.append(utils.system_output(cmd))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行dbench,输出到self.results。 需要记录测试记录,以便以后进行结果处理.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;postprocess_iteration&lt;/strong&gt;
对于性能基准,我们希望产生一个键值文件key=value ,来描述运行的情况.key只是一个字符,值是整点或浮点值.比如dbench
只有两个参数,"throughout","nprocs".这个函数,每次iteration调用一次.最后会出现一个文件结果:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;throughout = 217
nprocs = 4
throughout =220
nprocs = 4
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="qi-ta-fang-fa"&gt;其他方法&lt;/h3&gt;
&lt;p&gt;这些方法没有用在dbench,但是可以进行添加
&lt;strong&gt;warmup&lt;/strong&gt;
在正式性能测试前,可以进行一次验证测试,确保结果有效;可以在设置之后,进行调用job.run_test来执行一次测试.
&lt;strong&gt;cleanup&lt;/strong&gt;
测试后的清理工作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;execute&lt;/strong&gt;
通过调用warmup, run_once,postprocess用于测试.提供的基本的test类已实现了支持使能分析器和并行运行.如果需要支持自定义行为,就需要重写.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加自己的测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需创建测试下一个新的子目录，并添加自己的控制文件，源代码和包装。 比较简单的做法是,复制dbench.py ​​为mytest.py ,然后对它进行编辑.&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/15/autotest/"&gt;Autotest：Autotest-Control file specification&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;
下一篇&lt;a href=""&gt;Autotest:&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-Control file specification</title><link href="http://king32783784.github.io/2015/08/15/autotest/" rel="alternate"></link><published>2015-08-15T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-15:2015/08/15/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;h2 id="control-file-specification"&gt;Control file specification&lt;/h2&gt;
&lt;p&gt;该篇主要介绍control文件的标准.该标准主要为了使自定义的control文件能够提供前端或测试所需要的信息,并且能够通过前端修改.
主要内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名control文件&lt;/li&gt;
&lt;li&gt;常用变量&lt;/li&gt;
&lt;li&gt;示例&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="controlwen-jian-ming-ming"&gt;control文件命名&lt;/h3&gt;
&lt;p&gt;control文件命名必须是control.xxxx,xxxx是你定义或则代码评审定义．　例如，５００次硬重启测试，一个正规的定义就是　control.hard500&lt;/p&gt;
&lt;h3 id="chang-yong-bian-liang"&gt;常用变量&lt;/h3&gt;
&lt;p&gt;下面是一个常用变量的列表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*AUTHOR&lt;/td&gt;
&lt;td&gt;测试编写的个人或公司信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ＤEPENENCIES&lt;/td&gt;
&lt;td&gt;测试依赖信息，比如"CONSOLE"&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*DOC&lt;/td&gt;
&lt;td&gt;描述测试包括哪些参数的说明&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPERIMENTAL&lt;/td&gt;
&lt;td&gt;如果定义为True,测试忽略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*NAME&lt;/td&gt;
&lt;td&gt;前端识别测试的名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RUN_VERIFY&lt;/td&gt;
&lt;td&gt;定义scheduler是否执行验证，默认为True&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SYNC_COUNT&lt;/td&gt;
&lt;td&gt;次数，接受大于等于１的参数，默认为１&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*TIME&lt;/td&gt;
&lt;td&gt;说明测试时长，　ＳＨＯＲＴ&amp;lt;15m, MEDIUM &amp;lt; 4H ,LONG &amp;gt;4H&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEST_CLASS&lt;/td&gt;
&lt;td&gt;描述类属于类型，如内核．硬件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEST_CATEGORY&lt;/td&gt;
&lt;td&gt;描述测试的类型，如压力，功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*TEST_TYPE&lt;/td&gt;
&lt;td&gt;测试类型：client server&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;标*是每个control文件的必填．并且提供一个脚本用于检查utils/check_control_file_vars.py&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AUTHOR(必填)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设计者的信息是必填，用来后续追踪测试和修改bug,邮箱地址是必须的．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DEPENDENCIES（可选，默认：none)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相关性是描述你需要运行测试什么类型硬件的一种方式。 依赖是说,比如你需要测试蓝牙：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;DEPENDENCY =“bluetooth”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中， Bluetooth是在自动测试创建并已添加到一台机器,自动测试或者通过CLI或Django管理界面的确切标签。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DOC(必需)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文档需要说明测试项测试时需要的条件，确认测试正常运行．以及如果进行调整和修改．同时def execute()调用的参数代表什么含义．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EXPERIMENTAL(可选默认：False)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果设置，前端会忽略这些测试生产自动测试服务器测试导入过程。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NAME(必需)&lt;/strong&gt;
指定的名字，前端会用来显示，这对于不同测试文件为了同一测试的不同验证需求非常有用．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RUN_VERIFY(可选，默认TRUE)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用来定义scheduler是否进行验证&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYNC_COUNT(可选默认１)&lt;/strong&gt;
　１代表的是可以异步执行，大于１代表需同步执行
如果一个测试需要两台机器，SYNC_COUNT=2.autotest就会判断是否满足条件
例如，发布向２３台机器发布任务，单只有２２个可以执行，单独的那个会失败．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TIME(Required)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试需要的时间，不包括设置时间．&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Time&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SHORT&lt;/td&gt;
&lt;td&gt;小于１５分钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEDIUM&lt;/td&gt;
&lt;td&gt;少于４Ｈ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONG&lt;/td&gt;
&lt;td&gt;大于４Ｈ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;TEST_CATEGORY(必需)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义测试属于哪一类
例如　功能性或压力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TEST_CLASS(必需)&lt;/strong&gt;
　xxxx描述类类型的测试。 如果你有不同类型的要过滤的测试，这是非常有用的。
如果一个测试中加入一个TEST_CLASS，前端如果不存在这个类，就要补充这个类。
示例测试类
&lt;em&gt;内核
&lt;/em&gt;硬件 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TEST_TYPE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个要告诉前端什么类型的测试．有效值是server或client.&lt;/p&gt;
&lt;h3 id="shi-li"&gt;示例&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TIME ='MEDIUM'
AUTHOR = 'Scott Zawalski ( scott@xxx.com )'
TEST_CLASS = 'Hardware'
TEST_CATEGORY = 'Functional'
NAME = 'Hard Reboot'
SYNC_COUNT = 1
TEST_TYPE = 'server'
TEST_CLASS = 'Hardware'
DEPENDCIES = 'POWER, CONSOLE'

DOC = """
Tests the reliability of platforms when rebooted. This test allows
you to do a hard reboot or a software reboot.

Args:
type: can be "soft" or "hard", default is "hard"
e.g. job.run_test('reboot', machine, type="soft")
This control file does a HARD reboot
"""

def run(machine):
job.run_test('reboot', machine, type="hard")
parallel_simple(run, machines)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/14/autotest/"&gt;Autotest:Autotest-client control&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;
下一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/16/autotest/"&gt;Autotest:Autotest-add test&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-client control</title><link href="http://king32783784.github.io/2015/08/14/autotest/" rel="alternate"></link><published>2015-08-14T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-14:2015/08/14/autotest/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;h2 id="client-control-files"&gt;Client Control files&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jobs 例子&lt;/li&gt;
&lt;li&gt;扩展测试&lt;/li&gt;
&lt;li&gt;流程控制&lt;/li&gt;
&lt;li&gt;系统信息抓取&lt;/li&gt;
&lt;li&gt;分析器&lt;/li&gt;
&lt;li&gt;创建文件系统&lt;/li&gt;
&lt;li&gt;job执行期间重启&lt;/li&gt;
&lt;li&gt;并行运行多个测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;control file定义了一次test job 关键信息,它定义了一次测试的方方面面.control文件是一个python脚本,它驱动这个测试.&lt;/p&gt;
&lt;h2 id="jobli-zi"&gt;job例子&lt;/h2&gt;
&lt;p&gt;可以添加一个job对象用来驱动测试和一些服务支持.一个job例子可以是这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.run_test('kernbench')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数只有测试的名字(kernbench).autotest有很多测试用例,每个测试都有一个简单的control文件(tests/&lt;testname&gt;/control
在autotestclient端的顶层目录下,你可以执行测试:&lt;/testname&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ client/autotest-local &amp;lt;control_file_name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在control文件中同样可以指定测试参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.run_test('kernbench', iterations=2, threads=5)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数是测试名称;&lt;/li&gt;
&lt;li&gt;第二个参数是执行次数和线程数,大多数你可以执行它的默认参数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还可以指定一个tag参数,用来给测试结果目录命名:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.run_test('kernbench', iterations=2, threads=5, tag='mine')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试时会创建结果目录"kernbench.mine"来替代之前的"kernbench".这个功能非常重要,当你执行了多次测试,可以用来区分测试结果.&lt;/p&gt;
&lt;h2 id="kuo-zhan-ce-shi"&gt;扩展测试&lt;/h2&gt;
&lt;p&gt;当开发一个测试时,为了让它能正常的下载和执行时,需要符合扩展测试的要求.&lt;/p&gt;
&lt;h2 id="liu-cheng-kong-zhi"&gt;流程控制&lt;/h2&gt;
&lt;p&gt;真正掌握一门语言用于脚本控制是学会它的控制结构和错误检查机制.这里给出一个kernbench运行不同threads的例子.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for t in [8, 16, 32]:
    job.run_test('kernbench', iterations=2, threads=t, tag='%d' % t)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="xi-tong-xin-xi-zhua-qu"&gt;系统信息抓取&lt;/h2&gt;
&lt;p&gt;每次重启和测试时,autotest都会生成一个目录用来保存系统的信息.比如/proc/meminfo文件内容,"uname-a"的输出信息.可以在测试结果目录找那个查看.
sysinfo/(每次重启前的数据), &lt;testname&gt;/sysinfo(每次测试前的数据)
每次收集的信息列表的内容,可以通过查看&lt;strong&gt;clent/bin/base_sysinfo.py&lt;/strong&gt;.当然autotest也提供了自定义收集系统信息的机制.可以通过这个方式进行自定义
的系统信息收集:&lt;/testname&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.add_sysinfo_file("/proc/vmstat")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以设置每次重启后,收集/proc/vmstat的信息.可以通过on_every_test参数实现:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.add_sysinfo_file("/proc/vmstat", on_ervey_test=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外一种方式:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.add_sysinfo_command("lspci -v", logfile="lspci.txt")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样每次重启都可以执行lspci -v,并把信息导入到lspci.txt. logfile的参数是可选的.如果不指定它,就会默认以lspci_ -v作为名字.这个方法,同样是每次reboot都会
 执行.&lt;/p&gt;
&lt;h2 id="shi-yong-fen-xi-qi"&gt;使用分析器&lt;/h2&gt;
&lt;p&gt;你可以启用一个或多个分析器.下面是添加和移除的例子:
    job.profilers.add('oprofile')
    job.run_test('sleeptest')
    job.profilers.delete('oprofile')&lt;/p&gt;
&lt;p&gt;多个测试使用方式:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.profilers.add('oprofile')
job.run_test('kernbench')
job.run_test('dbench')
job.profilers.delete('oprofile')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它会为每个测试生成独立的分析结果,以免不影响性能结果.分析结果会在测试结果目录下的&lt;testname profiling=""&gt;
当然,在profilers/&lt;profiler-name&gt;/control下有所有的示例.&lt;/profiler-name&gt;&lt;/testname&gt;&lt;/p&gt;
&lt;h2 id="chuang-jian-wen-jian-xi-tong"&gt;创建文件系统&lt;/h2&gt;
&lt;p&gt;autotest内建支持创建文件系统.用来支持在不同文件系统中进行fsx测试:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# uncomment this line, and replace the device with something sensible
# for you ...
# fs = job.filesystem('/dev/hda2', job.tmpdir)

for fstype in ('ext2', 'ext3'):
    fs.mkfs(fstype)
    fs.mount()
    try:
        job.run_test('fsx', job.tmpdir, tag=fstype)
    finally:
        fs.unmount()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样支持为不同的文件系统添加不同的挂载参数:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fs = job.filesystem('/dev/sda3', job.tmpdir)
iters=10
for fstype, mountopts, tag in (('ext2', '', 'ext2'),
                               ('ext3', '-o data=writeback', 'ext3writeback'),
                               ('ext3', '-o data=ordered', 'ext3ordered'),
                               ('ext3', '-o data=journal', 'ext3journal')):
    fs.mkfs(fstype)
    fs.mount(args=mountopts)
    try:
        job.run_test('fsx', job.tmpdir, tag=tag)
        job.run_test('iozone', job.tmpdir, iterations=iters, tag=tag)
        job.run_test('dbench', iterations=iters, dir=job.tmpdir, tag=tag)
        job.run_test('tiobench', dir=job.tmpdir, tag=tag)
    finally:
        fs.umount()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="jobce-shi-zhong-zhong-qi"&gt;job测试中重启&lt;/h2&gt;
&lt;p&gt;当一个job需要重启时,比如导入一个新的内核.这样就会导致control脚本执行中断.这样就需要分布执行的模块.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def step_init():
    job.next_step([step_test])
    testkernel = job.kernel('2.6.18')
    testkernel.config('http://mbligj.org/congig/opteron2')
    testkernel.build()
    testkernel.boot()  #does autotest by default

def step_test():
    job.run_test('kernbench', iterations=2, threads=5)
    job.run_test('dbench', iterations=5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过指定&lt;strong&gt;step_init&lt;/strong&gt;表明控制脚本已一种分布模式执行.在执行中断时(如reboot)会保存测试环境.&lt;/p&gt;
&lt;p&gt;一个重要的提示是分布执行引擎并不意味支持这个测试过程的分步执行.只能支持再控制文件级别中实现.因为在测试程序执行时一些返回值.实现自动测试过程中中断测试
不太现实.如果出现超时,会杀死子线程.
因此,代码插入到control文件中是正确的:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; def step_init():
     job.next_step([step_test])
     testkernel = job.kernel('testkernel.rpm')
     testkernel.install()
     testkernel.boot()

def step_test()
     job.run_test('ltp')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相关代码插入到测试模块中,是不行的.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Kerneltest&lt;/span&gt;(&lt;span class="n"&gt;test&lt;/span&gt;.&lt;span class="n"&gt;test&lt;/span&gt;):
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;execute&lt;/span&gt;(&lt;span class="k"&gt;self&lt;/span&gt;):
        &lt;span class="n"&gt;testkernel&lt;/span&gt; = &lt;span class="n"&gt;job&lt;/span&gt;.&lt;span class="n"&gt;kernel&lt;/span&gt;(&lt;span class="s"&gt;'testkernel.rpm'&lt;/span&gt;)
        &lt;span class="n"&gt;testkernel&lt;/span&gt;.&lt;span class="n"&gt;boot&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接的,当使用分布引擎时,控制文件不是简单的执行一次.而是循环执行,直到测试完成.在一个独立的情况下，当一个控制文件存在，在重启之后会自动启动执行.在托管环境中管理服务器将执行相同的作用.
当面对分步执行时,循环会变得更加困难.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def step_init():
    step_test(1)

def step_test(iteration):
    if (iteration &amp;lt; 5):
        job.next_step([step_test, iteration + 1])

    print "boot: %d" % iteration

    job.run_test('kernbench', tag="%s" % i)
    job.reboot()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="bing-xing-yun-xing"&gt;并行运行&lt;/h2&gt;
&lt;p&gt;job对象同样提供一个并行运行多个测试的方法. 该方法采用可变数量的参数，分别代表不同的任务并行运行。 每个参数应该是一个列表，其中该列表中的第一项是一个函数的调用和所有其余元素都将被传递给函数被调用时的参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def first_task():
    job.run_test('kernbench')

def second_task():
    job.run_test('dbench')

job.parallel([first_task], [second_task])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制文件会同时执行kernbench和dbench.代码还可以如此写:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;job.parallel([job.run_test, 'kernbench', [job.run_test, 'dbench'])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你想这样更复杂的东西在你的任务中,而不是要求单一的功能，那么你就必须定义自己的函数来做到这一点，如在第一个例子。&lt;/p&gt;
&lt;p&gt;并行任务执行在自己的地址空间,你不比担心.但是毕竟是运行在同一台物理机中.仍然需要主要避免访问同一资源,如相同的文件.&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/13/autotest/"&gt;Autotest：Autotest-Local&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;
下一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/15/autotest/"&gt;Autotest：Autotest-Control file specification&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-Local</title><link href="http://king32783784.github.io/2015/08/13/autotest02/" rel="alternate"></link><published>2015-08-13T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2015-08-13:2015/08/13/autotest02/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;h2 id="local-former-client"&gt;Local (Former Client)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主要内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快速入门&lt;/li&gt;
&lt;li&gt;client端控制文件&lt;/li&gt;
&lt;li&gt;测试模块开发&lt;/li&gt;
&lt;li&gt;如何添加测试到autotest&lt;/li&gt;
&lt;li&gt;使用和开发job profilers&lt;/li&gt;
&lt;li&gt;linux发行版检测&lt;/li&gt;
&lt;li&gt;API 参考&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="kuai-su-ru-men"&gt;快速入门&lt;/h3&gt;
&lt;p&gt;Autotest 客户端需要很少的依赖,需要安装python2.4或以上版本.推荐使用虚拟机或测试机验证,避免出现异常.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下载client端&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone --recursive git://github.com/autotest/autotest.git
cd autotest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试例子&lt;/strong&gt;
比如autotest中的sleeptest,sleeptest是一个简单的sleep几秒测试.可以从autotest目录启动(/usr/local/autotest/client):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;client/autotest-local --verbose run sleeptest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以通过以下方式,进行任何独立测试:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;client/autotest-local run &amp;lt;testname&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可以通过control文件启动测试:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;client/autotest-local client/tests/sleeptest/control
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一些测试可能需要root权限,比如rtc测试.当提示结果为"permission denied error"时,意味着权限不足,你需要以root执行.
&lt;strong&gt;如果以root身份执行client端,后又切回到普通用户,一些重要的目录,可能是root用户的,再进行测试可能会出错.这时你可以删除这些目录:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo rm -rf client/tmp
sudo rm -rf client/results
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在client/samples目录下面有一些测试例子,非常适合练习.kbuile_and_tests/control会下载一个内核,并且编译,而且会重启后进入该内核.
可以以root身份执行:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;client/autotest-loacl --verbose client/samples/kbuild_and_tests/control
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意,尽量在一个测试机或虚拟机执行,不然会丢失之前系统的启动设置.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/12/Autotest/"&gt;Autotest：Autotest-summary&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;
下一篇&lt;a href="https://king32783784.github.io/lipeng/2015/08/14/autotest/"&gt;Autotest：Autotest-client control&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Autotest-summary</title><link href="http://king32783784.github.io/2015/08/12/Autotest01/" rel="alternate"></link><published>2015-08-12T00:00:00+08:00</published><author><name>peng.lee</name></author><id>tag:king32783784.github.io,2015-08-12:2015/08/12/Autotest01/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/autotestlogo.png"/&gt;&lt;/p&gt;
&lt;p&gt;Autotest是一个开源的自动化测试框架.设计目的是为了测试Linux内核,同样可以用来检查新的硬件,虚拟化测试以及linux平台用户空间程序.它遵循GPL协议,并有大量的开发组织成员,其中包括像谷歌,IBM,红帽等.
Avocado,是Autotest开发组,开发的下一代的自动化测试框架.详细信息参考&lt;a href="http://avocado-framework.github.io/"&gt;Avocado&lt;/a&gt;,后续有时间会再对Avocado进行介绍.
本专题主要介绍以下内容:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* 基本信息
* 客户端介绍
* 服务端介绍
* 前端介绍
* 系统管理
* 调度模块
* 如何开发
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本文主要介绍关于Autotest的一些基本信息.主要内容:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* Autotest主要结构
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Autotest项目主页:&lt;a href="http://autotest.github.io/"&gt;Autotest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github: &lt;a href="https://github.com/autotest/autotest"&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="autotestzhu-yao-jie-gou"&gt;Autotest主要结构&lt;/h2&gt;
&lt;p&gt;下图是Autotest框架简化图:
&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/Autotest1.png"/&gt;&lt;/p&gt;
&lt;h3 id="webjie-kou-he-ming-ling-xing-jie-kou"&gt;Web接口和命令行接口&lt;/h3&gt;
&lt;p&gt;Web接口和命令行接口是相辅相成的方式去连接Autotest并创建job.这两则具有相同的功能,意在方便用户.你可以用这些接口做以下事情:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* 管理jobs,如创建,监控,中止等
* 管理客户端
* 查看测试结果
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端会通过向mysql数据库中创建记录的方式将jobs插入服务端.&lt;/p&gt;
&lt;h3 id="fu-wu-duan"&gt;服务端&lt;/h3&gt;
&lt;p&gt;服务端主要包括3个部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个Mysql数据库,该数据库保存了所有的job,客户端(测试物理机),用户,测试项目等信息&lt;/li&gt;
&lt;li&gt;调度程序(monitor_db),从数据库中选择jobs 运行.它对数据库的操作,主要是为了启动autoserv进程去调用服务请求.&lt;ul&gt;
&lt;li&gt;通常一台测试机一个调度进程&lt;/li&gt;
&lt;li&gt;客户机端的jobs是异步的(设置客户端机变为可用)&lt;/li&gt;
&lt;li&gt;服务器端的jobs是同步的(它启动前要等待所有客户端机)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Autoserv: 服务端通过autoserv程序管理客户端,每个运行的job都会有一个autoserv进程.每个autoserv进程:&lt;ul&gt;
&lt;li&gt;控制和监控一个或多个客户端&lt;/li&gt;
&lt;li&gt;确认客户端是否工作正常,如果确认失败,会尝试修复.&lt;/li&gt;
&lt;li&gt;管理job的执行&lt;/li&gt;
&lt;li&gt;在开始测试前,更新客户端的autotest程序.(如新增了测试项)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外,mysql数据库可用部署在不同的机器上进行调度,虽然有一定的调度负载,但每个可用管理几千个客户端.所以没必要部署在不同机器上.&lt;/p&gt;
&lt;h3 id="ke-hu-duan"&gt;客户端&lt;/h3&gt;
&lt;p&gt;启动一个job后,client端做了大部分的工作.它的调用方式有:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;手动执行:通过client/autotest-local &amp;lt;control_file_name&amp;gt;命令启动
通过服务端调用
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个典型的工作流程如下:
&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/Autotest2.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简要说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户创建job(可以通过web端或命令行)或自动事件触发;将job信息记录插入前端数据库;调度器(monitor_db)将job匹配到空闲机器;调度器创建autoserv进程启动job;Autoserv确认客户端或修复;Autoserv在测试机器上安装或更新autotest客户端;Autoserv监控客户端状态,监视问题;
客户机器触发autotest客户端执行测试(已开发测试项目)-运行control文件-log模块记录测试信息-setup-执行测试-测试结果文件由autoserv回收;分析机器新的job;log结果信息处理;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果目录&lt;/strong&gt;:按照一定格式结果目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果数据库&lt;/strong&gt;:一个简单的数据库保存每个测试的job信息 测试结果 性能指标等&lt;/p&gt;
&lt;p&gt;随着前面的介绍,下图是更容易理解的基本框架图:
&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/Autotest3.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简要说明:&lt;/strong&gt;
Autotest通过 Web 前端或者命令行工具提交测试任务， Autotest Server 通过调度器将任务分发到不同的 Client（测试机）， Client 端任务执行完之后，再将结果返回到结果分析后端，Web 前端与命令行接口即可查看测试结果
.
主要构成部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local：在测试机Client上执行测试的引擎&lt;/li&gt;
&lt;li&gt;Remote：从Server端推送测试代码到客户测试机，触发测试执行，监控测试状态，并且把测试结果从测试机反馈到服务器。&lt;/li&gt;
&lt;li&gt;Scheduler：根据用户输入分配测试任务，为每个任务创建服务进程，存储结果到测试数据库&lt;/li&gt;
&lt;li&gt;Frontends：允许用户运行作业并且方便地使测试结果可视化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://king32783784.github.io/lipeng/2015/08/13/autotest/"&gt;Autotest：Autotest-Local&amp;gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>Spec2006使用说明</title><link href="http://king32783784.github.io/2014/10/10/linux/" rel="alternate"></link><published>2014-10-10T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2014-10-10:2014/10/10/linux/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;h2 id="gong-ju-jie-shao"&gt;工具介绍&lt;/h2&gt;
&lt;p&gt;SPEC CPU 2006 benchmark是SPEC新一代的行业标准化的CPU测试基准套件。重点测试系统的处理器，内存子系统和编译器。这个基准测试套件包括的SPECint基准和SPECfp基准。 其中SPECint2006基准包含12个不同的基准测试和SPECfp2006年基准包含19个不同的基准测试。SPEC设计了这个套件提供了一个比较标准的计算密集型，高性能的跨硬件的CPU测试工具。在SPEC CPU 2006基准有几种不同的方法来衡量计算机性能。 一种方式是测量计算机完成单一任务的速度; 另一种方式吞吐量，容量或速率的测量。
说明：由于spec2006支持多种类型操作系统。以下安装、测试、移植等介绍均基于Unix 和其他的 Unix-like system如linux。Windows系统不在此范围内。&lt;/p&gt;
&lt;h3 id="spec2006yu-spec2000de-dui-bi-jian-yao-shuo-ming"&gt;spec2006与spec2000的对比简要说明&lt;/h3&gt;
&lt;p&gt;2006年8月24日，标准性能评估公司（SPEC）宣布CPU2006将取代CPU2000。
Spec cpu基准测试被广泛的应用于工业界和学术界。新套件比cpu2000要大很多，而且将涵盖到CPU、存储器系统、编译器特别是C++编译器。Cpu2000只有1个关于C++的基准测试，CPU2006则含有7个相关套件，这其中包括了50W行c++代码，Fortran和C语言和之前一样有很好的覆盖。&lt;/p&gt;
&lt;h3 id="spec2000he-spec20006ju-ti-de-tao-jian-xin-xi-ru-xia"&gt;Spec2000和spec20006具体的套件信息如下：&lt;/h3&gt;
&lt;h4 id="spec-int2000-12ge-zheng-dian-ce-shi-xiang-mu"&gt;Spec int2000  12个整点测试项目&lt;/h4&gt;
&lt;p&gt;164.gzip
C语言编写，很流行的数据压缩程序。使用Lempel-Ziv coding(LZ77)作为压缩算法。SPEC中的gzip除了读入集外没有其他文件I/O操作，所有压缩和解压都在主存中进行，方便测试CPU和存储子系统。&lt;/p&gt;
&lt;p&gt;175.vpr
C语言编写，FPGA中的电路定位和路由程序,用于计算机辅助电路设计领域。&lt;/p&gt;
&lt;p&gt;176.gcc:
C语言编写，C语言优化编译器。该GCC基于GCC 2.7.2.2版本，为摩托罗拉88100处理器生成机器码。&lt;/p&gt;
&lt;p&gt;181.mcf:
C语言编写，组合优化/单点轮换调度(Single-depot vehicle scheduling),派生自使用单站轮换调度的公共物流应用程序。&lt;/p&gt;
&lt;p&gt;186.crafty：
C语言编写，国际象棋游戏程序。这是一个在64位机上设计的高性能计算机国际象棋程序，在32位机上可以使用long long来表示该数据类型。主要是一个整点程序，大量的逻辑运算。通过配置，能生成不同的搜索集，可以对处理器的整点运算，转移预测和流水线等做测试。&lt;/p&gt;
&lt;p&gt;197.parser:
C语言编写，字处理程序。连接语法分析器(Link Grammar Parser)是一个基于连接语法的英语句法分析器。连接语法时英语语法的较早理论。给定一个句子，系统能给它赋予一个词法结构，这个结构是两个词之间被标记的连接。该分析器有大约60000个词表的字典。&lt;/p&gt;
&lt;p&gt;252.eon：
C++语言编写，计算机可视化。eon是一个基于概率的射线跟踪程序，基于Kajiya 1986 ACM SIGGRAPH会议的论文。它将一定数量的3D射线发射到一个3D多面体中，计算射线和多边形的交点，并通过计算入射光和交点生成新射线。最终的计算结果时一个能在照相机内看到的图片。程序中的计算需求和基本计算机图形学中介绍的传统确定性射线跟踪程序很相似，但是它有较少的存储一致性需求，因为很多在同一个位置生成的随机射线横切3D空间中完全不同的区域.输入：eon渲染一个150×150像素的一把椅子在房间前脚的图片。&lt;/p&gt;
&lt;p&gt;253.perlbmk:
C语言编写,Perl语言解释器。这是一个Perl v5.005_03版本的删减版，删除了很多操作系统相关的特性，并增加了一些第三方的模块，包括MD5 v1.7, MHonArc v2.3.3, IO-stringy v1.205,MailTools v1.11,TimeData v1.08。输入：由四个perl脚本组成，一个email-to-HTML 转换器，占用时间最长；一个spec CPU2000用来对比较输出的diff脚本，一个通过迭代算法寻找合格数字的脚本，一个用于测试伪随机数按照预定顺序生成的脚本。输出分别对应各个输入。&lt;/p&gt;
&lt;p&gt;254.gap:
C语言编写，群论，解释器中常用。它实现一个语言和库用于做群论计算。GAP是(Groups,Algorithms和Programming的缩写)。&lt;/p&gt;
&lt;p&gt;255.vortex：
C语言编写,单用户面向对象数据库中事务处理的benchmark。SPEC中的vortex来自完整面向对象数据库程序VORTEx的一个子集。输入和输入数据库的事务都会被转换成一个方案。&lt;/p&gt;
&lt;p&gt;256.bzip2：
C语言编写，压缩程序。基于Julian Seward的bzip2 v0.1，唯一的不同是SPEC中的bzip2除了输入外，无文件I/O。所有的压缩和解压都在内存中进行。输入，输出都和gzip的相似。&lt;/p&gt;
&lt;p&gt;300.twolf：
C语言实现，定位和路由模拟。twolf来自TimberWolfSC定位和全局路由，它被用于创建微处理器产品印刷电路布局的流程中，确定晶体管的位置和组内的全局连接。定位问题是一个排列，穷举法耗时太长，TimberWolfSC程序则使用模拟退火作为启发来找到较优解。&lt;/p&gt;
&lt;h4 id="spec-int2006-12ge-zheng-dian-ce-shi-xiang-mu"&gt;Spec int2006  12个整点测试项目&lt;/h4&gt;
&lt;p&gt;400.perlbench：C语言编写，同spec2000的253.perlbmk类似，是Perl V5.8.7版本的删减版，同样删除了一下操作系统特性有关的东西，增加了第三方的模块，如：SpamAssassin V2.61,Digest-MD5 v2.33,HTML-Parser v3.35,MHonArc V2.6.8,IO-stringy V1.205,MailTools V1.60，TimeDate V1.16。400.perlbench采用3个脚本进行增加负载或工作。1.主要的负载在于打开 垃圾邮件过滤软件SpamAssassin。采取的过滤方式是采用记分制，也就是说会根据我们所设定的标准来给予分数超过标准值的时候即判定为 SPAM（垃圾邮件），其余为非垃圾邮件。但对SpamAssassin软件做了很大程度的修改，避免一些I/0操作，并且没有使用贝叶斯过滤。2.是比较流行的email到HTML的转换器MHonArc 3.使用了spec2006的工具套件specdiff。&lt;/p&gt;
&lt;p&gt;401.bzip2: C语言实现，同spec2000的256.bzip2类似,基于Julian Seward的bzip2 v1.03.唯一的不同是SPEC中的bzip2除了输入外，无文件I/O。所有的压缩和解压都在内存中进行。输入，输出都和gzip的相似。负载包括六个部分：两个小的JPEG图片、一个程序、一个tar包起的几个源程序文件、一个HTML文件、混合文件，包括压缩起来的高可压缩文件及不怎么可压缩的文件。测试分别使用了三个不同的压缩等级进行压缩和解压缩&lt;/p&gt;
&lt;p&gt;403.gcc:C语言实现，同spec2000的176.gcc类似。该测试是基于gcc V3.2,为AMDCPU生成机器码。相比spec2000的176.gcc，该测试有更多的输入文件，因此测试压力会更大，负载来源于对9组C代码进行编译。&lt;/p&gt;
&lt;p&gt;429.mcf:C语言实现，同时需要libm库支持，同spec2000的181.mcf类似，MCF是一个用于大型公共交通中的单站车辆调度的程序。但对输入文件做了一定的修改，由32位变成64位，用以兼容64位系统。并且增加了cache命中和程序的性能。相比spec2000的181.mcf来说，占用的内存由之前的100M-190M变为860M-1700M。&lt;/p&gt;
&lt;p&gt;445.gobmk：C语言实现，同spec2000的186.crafty类似。不同的是这里是实现的围棋游戏。相比spec2000程序更复杂。&lt;/p&gt;
&lt;p&gt;456.hmmer：C语言实现。HMMER是基于隐马尔可夫模型(profile HMMs)，用于生物序列分析工作。同Timed HMMer Search 类似。&lt;/p&gt;
&lt;p&gt;458.sjeng：C语言实现。基于一种象棋游戏Sjeng11.2，属于人工智能的范畴。&lt;/p&gt;
&lt;p&gt;462.libquantum:C语言实现（C99）。libquantum是模拟量子计算机的库文件，用来进行量子计算机应用的研究。&lt;/p&gt;
&lt;p&gt;464.h264ref:C语言实现。一种视频压缩程序，基于H264AVC 9.3版，去除了I/O和平台相关的东西。&lt;/p&gt;
&lt;p&gt;471.omnetpp:C++语言实现。OMNeT++，离散事件仿真。包括约8000台计算机和900个交换机/集线器，以及混合了各种从10Mb到1000Mb速率的大型CSMA/CD协议以太网络模拟。&lt;/p&gt;
&lt;p&gt;473 astar：C++语言实现，实现了2D寻路算法A*的三种不同版本。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;xalancbmk：C++语言实现，包含Xalan-C++ v1.8 mod、Xerces-C++ v2.5.0，实现了XML文档/XSL表到HTML文档的转换。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="spec-fp2000-13ge-fu-dian-ce-shi-xiang-mu"&gt;Spec fp2000  13个浮点测试项目&lt;/h4&gt;
&lt;p&gt;168 wupwise：Fortran 77语言实现，格点规范理论与威尔逊数值模拟对费米子格是夸克传播子的计算。输入文件wupwise.in包含几个创建该问题的参数，SEED:提供一个随机数 NITER：迭代次数KAPPA：参数表征矩阵M = I - KAPPA * D。输出文件wupwise.out,包含每次NITER迭代的校验值（EPS）和包含最终的EPSILON特征的结果。&lt;/p&gt;
&lt;p&gt;171 swim：Fortran 77语言实现，气象学中的浅水模型。&lt;/p&gt;
&lt;p&gt;172.mgrid ：Fortran 77语言实现，多重网格求解器：3D势场&lt;/p&gt;
&lt;p&gt;173.applu： Fortran 77语言实现，抛物线/椭圆型偏微分方程&lt;/p&gt;
&lt;p&gt;177.mesa：C语言实现 ，3D图形库。&lt;/p&gt;
&lt;p&gt;178.galgel :Fortran 90语言实现，计算流体动力学&lt;/p&gt;
&lt;p&gt;179.art :C，图像识别/神经网络&lt;/p&gt;
&lt;p&gt;183.equake:C语言实现， 地震波传播模拟&lt;/p&gt;
&lt;p&gt;187.facerec: Fortran 90语言实现，图像处理：人脸识别&lt;/p&gt;
&lt;p&gt;189.lucas :Fortran 90语言实现，数论/素性测试&lt;/p&gt;
&lt;p&gt;191.fma3d :Fortran 90语言实现，有限元模拟碰撞&lt;/p&gt;
&lt;p&gt;200.sixtrack :Fortran 77语言实现，高能核物理加速器设计&lt;/p&gt;
&lt;p&gt;301.apsi: Fortran 77语言实现，气象学中污染物分布&lt;/p&gt;
&lt;h4 id="spec-fp2006-17ge-fu-dian-ce-shi-xiang-mu"&gt;Spec fp2006  17个浮点测试项目&lt;/h4&gt;
&lt;p&gt;410.bwaves：Fortran 77语言实现，流体力学范畴。对三维瞬跨音速粘性流中冲击波的模拟计算&lt;/p&gt;
&lt;p&gt;416.gamess：Fortran语言实现，量子化学范畴。采用GMAESS组件，包含　胞嘧啶分子、水和Cu2+离子、三唑离子等3种SCF自洽场计算。&lt;/p&gt;
&lt;p&gt;433.milc：C语言实现，量子力学范畴，采用MILC组件，包含用来研究QCD量子色动力学、夸克及胶子的四维SU(3)格点规范理论的模。&lt;/p&gt;
&lt;p&gt;434.zeusmp ：Fortran 77/REAL*8语言实现，属于计算流体力学范畴，ZEUS-MP程序，用来计算理想、非相对论条件下的流体力学和磁流体力学，434.zeusmp模拟计算了一个统一磁场中的3D冲击波。&lt;/p&gt;
&lt;p&gt;435.gromacs ：C &amp;amp; Fortran语言实现，属于生物化学/分子力学范畴。GROMACS是一个分子力学计算套件，然而也可以用于非生物系统，435.gromacs模拟了在一个水和离子溶液中的蛋白质溶菌酶结构在各种实验手段如核磁共振的X光照射下的变化。&lt;/p&gt;
&lt;p&gt;436.cactusADM：Fortran 90, ANSI C语言实现，物理中的广义相对论。来源于Cactus　　BenchADM。436.cactusADM对时空曲率由内部物质决定的爱因斯坦演化方程进行求解，爱因斯坦演化方程由10个标准ADM 3+1分解的二阶非线性偏微分方程组成。&lt;/p&gt;
&lt;p&gt;437.leslie3d ：Fortran 90语言实现，属于流体力学范畴。  LESlie3d是用来计算湍流的计算流体力学程序，437.leslie3d计算了一个如燃油注入燃烧室的时间分层混合流体。&lt;/p&gt;
&lt;p&gt;444.namd：C++语言实现。属于生物/分子学范畴。NAMD是一个大型生物分子系统并行计算程序，444.namd模拟了了92224个原子组成的A-I载脂蛋白&lt;/p&gt;
&lt;p&gt;447.dealII：C++语言实现。进行有限元分析，w/Boost lib 、deal.II lib、deal.II是定位于自适应有限元及误差估计的C++库，447.dealII对非常系数的亥姆霍兹方程进行求解，它使用了基于二元加权误差估计生成最佳网格的自适应方法，该方程在3维得解。&lt;/p&gt;
&lt;p&gt;450.soplex:C++语言实现。采用Plex v1.2.1程序，Plex使用单纯形算法解线性方程&lt;/p&gt;
&lt;p&gt;453.povray：ISO C++  语言实现。   POV-Ray POV-Ray是一个光线追踪渲染软件，453.povray渲染一幅1280x1024的反锯齿国际象棋棋盘图像&lt;/p&gt;
&lt;p&gt;454.calculix：Fortran 90 &amp;amp; C语言实现，结构力学范畴。CalculiX是一个用于线性及非线性三位结构力学的有限元分析软件，454.calculix计算了一个高速旋转的压缩盘片在离心力的作用下的应力和变形情况&lt;/p&gt;
&lt;p&gt;459.GemsFDTD：Fortran 90语言实现。属于电磁学范畴。    459.GemsFDTD使用FDTD（有限差分时域）方法求解三维时域中的麦克斯韦方程，计算了一个理想导体的雷达散射截面&lt;/p&gt;
&lt;p&gt;465.tonto： Fortran 95实现。量子化学范畴Tonto是一个面向对象的量子化学程序包，465.tonto计算面向量子晶体学，它基于一个符合X光衍射实验数据的、约束的分子Hartree-Fock波函数&lt;/p&gt;
&lt;p&gt;470.lbm ：ANSI C语言实现。    470.lbm使用LBM（格子波尔兹曼方法）模拟非压缩流体，它模拟了两种情况：类似活塞推动的剪切驱动流体和管道流体，测试包含了3000个步骤&lt;/p&gt;
&lt;p&gt;481.wrf ：Fortran 90 &amp;amp; C语言实现。WRF v2.0.2  481.wrf基于WRF(Weather Research and Forecastin)模型，对NCAR的数据进行了计算，数据包括了UTC 2001.06.11到UTC 2001.06.12以三小时为间隔的数据&lt;/p&gt;
&lt;p&gt;482.sphinx3：C语言实现。Sphinx-3一种语音识别软件。&lt;/p&gt;
&lt;h3 id="gong-ju-an-zhuang_1"&gt;工具安装&lt;/h3&gt;
&lt;h4 id="biao-zhun-an-zhuang-fang-shi"&gt;标准安装方式&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;mount&lt;/span&gt;&lt;span class="x"&gt; -t iso9660 -o ro,exec /dev/cdrom /mnt&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;cd&lt;/span&gt;&lt;span class="x"&gt; /mnt&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt;./install.sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以指定安装目录如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$./install.sh -d  /home/cpu2006
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装过程中可能遇到以下提示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Installing FROM /Volumes/SPEC_CPU2006
Installing TO /home/cpu2006
Is this correct? (Please enter 'yes' or 'no')
yes
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="tong-guo-an-zhuang-wan-cheng-de-ruan-jian-jin-xing-ce-shi"&gt;通过安装完成的软件进行测试&lt;/h4&gt;
&lt;p&gt;先准备相关测试文件，如：cpu2006-20141030.tar。
解压文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;tar&lt;/span&gt;&lt;span class="x"&gt; xf cpu2006-20141030.tar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入安装目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;cd&lt;/span&gt;&lt;span class="x"&gt; cpu2006v99/（根据实际路径）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入测试工具：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$.  shrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：输入时，圆点与shrc之间至少一个空格，该命令开始导入SPEC CPU2006程序。
修改测试文件绝对路径：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;bin&lt;/span&gt;&lt;span class="x"&gt;/relocate&lt;/span&gt;
&lt;span class="x"&gt;显示“Top of SPEC benchmark tree is '/cpu2006v99'”&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="yun-xing-ce-shi"&gt;运行测试&lt;/h4&gt;
&lt;p&gt;根据需求，进行参数选择，开始运行测试脚本：
例如：runspec -c linux-mipsel-gcc -i ref -n 3  all
命令参数说明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-c：读取测试配置文件，linux-mipsel-gcc位于SPEC CPU2000安装目录的config目录下，该文件可以根据实际信息进行修改。其编译选项不建议修改。
-i：输入测试数据集的大小，ref代表最大测试数据集，test代表最小测试数据集；
-n：每个测试项目运行的次数，如果需要SPEC CPU2006自动计算测试分值，需要指定运行次数等于或大于3，即n&amp;gt;=3；
all：SPEC CPU2006将运行基准测试程序中的所有测试项目。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现以下信息，表明测试已经启动“&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;runspec v4283 - Copyright 1999-2006 Standard Performance Evaluation Corporation
Using 'mipsel-linux' tools
Reading MANIFEST... 17899 files
Loading runspec modules...............
Locating benchmarks...found 31 benchmarks in 13 benchsets.
Locating output formats: ASCII, config, CSV, flags, html (DISABLED), mail, PDF, PostScript, raw, Screen, Submission Check
Reading config file '/cpu2006v99/config/linux-mipsel-gcc.cfg'
Benchmarks selected: 400.perlbench, 401.bzip2, 403.gcc, 429.mcf, 445.gobmk, 456.hmmer, 458.sjeng, 462.libquantum, 464.h264ref, 471.omnetpp, 473.astar, 483.xalancbmk, 999.specrand, 410.bwaves, 416.gamess, 433.milc, 434.zeusmp, 435.gromacs, 436.cactusADM, 437.leslie3d, 444.namd, 447.dealII, 450.soplex, 453.povray, 454.calculix, 459.GemsFDTD, 465.tonto, 470.lbm, 481.wrf, 482.sphinx3, 998.specrand
Compiling Binaries
 up to date 400.perlbench ref base linux-mipsel-gcc default
 Up to date 401.bzip2 ref base linux-mipsel-gcc default
 Up to date 403.gcc ref base linux-mipsel-gcc default
 Up to date 429.mcf ref base linux-mipsel-gcc default
……
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这组测试配置基本和spec2000类似，不同的是，spec2006在测试前，会把每个测试组件重新编译建立一次。所以在测试前，应确保此时的系统中包含以下编译器：g++、gcc、gfortran编译器。如果进行连续测试，则不必进行再次编译，可以加参数”—nobuild”.
附config文件大体说明：斜体部分为文本内容 //为解释说明&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#####################################################################
ignore_errors = yes
tune          = base
ext           = loongson.3a2000
output_format = asc, Screen, html
reportable    = 0
teeout        = yes
teerunout     = yes
hw_avail = Feb-2015
sw_avail = Feb-2015
license_num = 
company_name = Loongson
prepared_by = Loongson
tester_name = isoft
test_date = July-2016

verbose         = 9

default=default=default=default:
#####################################################################
#
# Compiler selection
#
#####################################################################

makeflags = -j 4


CC           = mips64el-loongson-linux-gcc
CXX          = mips64el-loongson-linux-g++
FC           = mips64el-loongson-linux-gfortran

## HW config
hw_cpu_name  = Loongson
hw_model     = 3A2000
hw_cpu_mhz   = 1000
hw_fpu       = Integrated
hw_nchips   = 1
hw_ncores   = 4
hw_ncoresperchip= 4
hw_nthreads = 4
hw_ncpuorder = 1
hw_parallel  = yes
hw_pcache    = 64KB I + 64KB D
hw_scache    = 4096KB(I + D)
hw_memory   = 2 x 4GB DDR1066 
hw_vendor   = Loongson

## SW config
sw_os        = iSoft
sw_file      = ext4
sw_state     = runlevel 3
sw_compiler  = gcc , g++ &amp;amp; gfortran 4.8

#####################################################################
# Optimization
#####################################################################
## Base is low opt
default=default=default=default:
# For this data model, -m32 needs to be here, as one of the lines below
OPTIMIZE     = -static -march=loongson3a
PORTABILITY     =

COPTIMIZE    = -flto -Ofast 
CXXOPTIMIZE  = -flto -Ofast 
FOPTIMIZE    = -flto -Ofast

notes0100= C/C++ base flags:   -flto -Ofast
notes0110= Fortran base flags: -flto -Ofast

#####################################################################
# 32/64 bit Portability Flags - all
#####################################################################

default=base=default=default:
notes25=

default=peak=default=default:
notes25=


#####################################################################
# Portability Flags - INT
#####################################################################

400.perlbench=default=default=default:
notes35    = 400.perlbench: -DSPEC_CPU_LINUX_IA32
CPORTABILITY= -DSPEC_CPU_LINUX_IA32 -fno-strict-aliasing
#notes35    = 400.perlbench: -DSPEC_CPU_LINUX
#CPORTABILITY= -DSPEC_CPU_LINUX -DSPEC_CPU_LITTLEENDIAN 
#COPTIMIZE     = -O2
......
其他具体组件的编译信息不再一一说明，基本可以保持默认即可。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多测试类型与方法参见下文。&lt;/p&gt;
&lt;h3 id="ce-shi-jie-guo-shou-ji-yu-fen-xi_1"&gt;测试结果收集与分析&lt;/h3&gt;
&lt;p&gt;测试结束后在result目录下，查看测试结果，测试结果一般以测试类型和测试次序进行区别，并且会按照整点和浮点进行划分。如果是按照正式reportable的模式进行测试的话，会出一份网页版的正式测试结果，参见下图：
非正式结果可以去asc或txt文档查看，格式例如下文：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                Base     Base       Base        Peak     Peak       Peak
Benchmarks      Ref.   Run Time     Ratio       Ref.   Run Time     Ratio
-------------- ------  ---------  ---------    ------  ---------  ---------
400.perlbench    9770      430         22.7 S    9770      339         28.8 S
400.perlbench    9770      429         22.8 *    9770      338         28.9 S
400.perlbench    9770      429         22.8 S    9770      339         28.8 *
401.bzip2        9650      559         17.3 *    9650      552         17.5 *
401.bzip2        9650      559         17.3 S    9650      553         17.5 S
401.bzip2        9650      560         17.2 S    9650      552         17.5 S
403.gcc          8050      374         21.5 S    8050      337         23.9 S
403.gcc          8050      367         22.0 *    8050      337         23.9 S
403.gcc          8050      366         22.0 S    8050      337         23.9 *
429.mcf          9120      187         48.9 S    9120      187         48.9 S
429.mcf          9120      188         48.6 *    9120      188         48.6 *
429.mcf          9120      211         43.2 S    9120      211         43.2 S
445.gobmk       10490      559         18.8 S   10490      542         19.4 S
445.gobmk       10490      559         18.8 S   10490      542         19.4 *
445.gobmk       10490      559         18.8 *   10490      541         19.4 S
456.hmmer        9330      213         43.8 S    9330      213         43.7 *
456.hmmer        9330      247         37.8 S    9330      214         43.6 S
456.hmmer        9330      214         43.5 *    9330      213         43.7 S
458.sjeng       12100      616         19.6 *   12100      574         21.1 *
458.sjeng       12100      617         19.6 S   12100      575         21.0 S
458.sjeng       12100      585         20.7 S   12100      574         21.1 S
462.libquantum  20720       14.2     1460   *   20720       14.2     1460   *
462.libquantum  20720       14.4     1440   S   20720       14.4     1440   S
462.libquantum  20720       13.5     1540   S   20720       13.5     1540   S
464.h264ref     22130      578         38.3 *   22130      527         42.0 S
464.h264ref     22130      579         38.2 S   22130      526         42.0 *
464.h264ref     22130      578         38.3 S   22130      526         42.0 S
471.omnetpp      6250      349         17.9 S    6250      288         21.7 *
471.omnetpp      6250      348         17.9 *    6250      288         21.7 S
471.omnetpp      6250      348         18.0 S    6250      289         21.7 S
473.astar        7020      313         22.4 S    7020      313         22.4 S
473.astar        7020      311         22.6 S    7020      311         22.6 S
473.astar        7020      311         22.6 *    7020      311         22.6 *
483.xalancbmk    6900      174         39.7 *    6900      170         40.7 S
483.xalancbmk    6900      174         39.6 S    6900      170         40.5 S
483.xalancbmk    6900      174         39.7 S    6900      170         40.6 *
==============================================================================
400.perlbench    9770      429         22.8 *    9770      339         28.8 *
401.bzip2        9650      559         17.3 *    9650      552         17.5 *
403.gcc          8050      367         22.0 *    8050      337         23.9 *
429.mcf          9120      188         48.6 *    9120      188         48.6 *
445.gobmk       10490      559         18.8 *   10490      542         19.4 *
456.hmmer        9330      214         43.5 *    9330      213         43.7 *
458.sjeng       12100      616         19.6 *   12100      574         21.1 *
462.libquantum  20720       14.2     1460   *   20720       14.2     1460   *
464.h264ref     22130      578         38.3 *   22130      526         42.0 *
471.omnetpp      6250      348         17.9 *    6250      288         21.7 *
473.astar        7020      311         22.6 *    7020      311         22.6 *
483.xalancbmk    6900      174         39.7 *    6900      170         40.6 *
 SPECint(R)_base2006                   36.7
 SPECint2006                           39.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Base Ratio为测试分值，该测试一般运行3遍取中值。整体结果为所有结果的几何平均值。&lt;/p&gt;
&lt;h4 id="ju-li-shuo-ming-spec-cpu2006chang-yong-ce-shi-ming-ling-zu-he"&gt;举例说明SPEC CPU2006常用测试命令组合&lt;/h4&gt;
&lt;p&gt;1．runspec -c test.cfg -i test -I all
基于最小测试数据集快速执行所有的测试，测试过程中如果某个用例发生错误，则跳过错误用例，继续执行其他用例。
2．runspec -c test.cfg -i ref -n 3 -I all
基于最大测试数据集全面执行所有的测试，用于测试单核CPU，测试过程中如果某个用例发生错误，则跳过错误用例，继续执行其他用例。
3．runspec -c test.cfg –r ref –n 3 fp
基于最大测试数据集，只运行fp测试
4．runspec -c test.cfg –r ref –n 3 int
基于最大测试数据集，只运行int测试
5.runspec -c test.cfg -i ref 473.astar
基于最大测试数据集只执行473.astar单个测试。
6 runspec –c test.cfg –i ref --rate 4 int
基于最大数据测试集进行rate测试，运行4线程测试的分值&lt;/p&gt;
&lt;h4 id="qi-ta-ming-ling-bu-chong"&gt;其他命令补充&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;--action build 创建测试项目
--action onlyrun 只是运行，不进行确认测试结果是否正确
--action report 标准测试
--action clean  清理已经建立的测试项目
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模式很多，不再一一介绍。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;--check_version 检查版本更新
--copies –c number 默认1 用来进行SPECrate run
--help  显示帮助文档
--ignore_errors 忽略错误
ations number —n 测试次数，一次reportable测试，必须是3次
--iter—loose 未设置reportable测试
--output_format  输出文件格式 默认为html text 可以选择 all cfg  test csv  html mail pdf  ps  printer  raw screen   text 等多种方式。
--rate  -r  进行SPECspeed测试可以指定copies数量运行。
--rebuild 重新编译测试文件 
--tune tuning 默认是base 可以选择base, peak, or all ，Report 首先是base,其次是peak.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是比较常用的命令，一些不常用的命令不再介绍，可参考下文了解。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-a  Same as --action
--action action Do: build|buildsetup|clean|clobber|configpp| onlyrun|realclean|report|run|runsetup|scrub| setup|trash|validate
--basepeak  Copy base results to peak (use with --rawformat)
--nobuild   Do not attempt to build binaries
-c  Same as --config
-C  Same as --copies
--check_version Check whether an updated version of CPU2006 is available
--comment "text"    Add a comment to the log and the stored configfile.
--config file   Set config file for runspec to use
--copies    Set the number of copies for a SPECrate run
-D  Same as --rebuild
-d  Same as --deletework
--debug Same as --verbose
--define SYMBOL[=VALUE] Define a config preprocessor macro
--delay secs    Add delay before and after benchmark invocation
--deletework    Force work directories to be rebuilt
--dryrun    Same as --fake
--dry-run   Same as --fake
-e  Same as --extension
--ext   Same as --extension
--extension ext[,ext...]    Set the extensions
-F  Same as --flagsurl
--fake  Show what commands would be executed.
--fakereport    Generate a report without compiling codes or doing a run.
--fakereportable    Generate a fake report as if "--reportable" were set.
--[no]feedback  Control whether builds use feedback directed optimization
--flagupdate    Same as --update
--flagsupdate   Same as --update
--flagsurl url  Location (url or filespec) where to find your flags file
--getflags  Same as --update
--graph_auto    Let the tools pick minimum and maximum for the graph
--graph_min N   Set the minimum for the graph
--graph_max N   Set the maximum for the graph
-h  Same as --help
--help  Print usage message
--http_proxy    Specify the proxy for internet access
--http_timeout  Timeout when attempting http access
-I  Same as --ignore_errors
-i  Same as --size
--ignore_errors Continue with benchmark runs even if some fail
--ignoreerror   Same as --ignore_errors
......
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="shou-dong-bian-yi-ji-kua-ping-tai-yi-zhi-fang-fa-jin-gong-can-kao"&gt;手动编译及跨平台移植方法（仅供参考）&lt;/h4&gt;
&lt;p&gt;Spec2006包含的测试套件基本上与平台无关，因此理论上是可以直接进行跨平台进行测试。
Spec2006为了实现测试结果的准确及降低对平台的依赖，制作了自己的工具包。其中包括:
    specdiff（examines results to see if the correct answer was obtained）、specinvoke  (invokes benchmarks for CPU2006)、specmake（GNU make ，Calling it "specmake" avoids possible conflicts with versions of make that may already be on your system. SPEC requires that published results use the versions of the tools that it supplies, so that if SPEC applies patches or extensions from time to time, all users run with a consistent tool set. Similar considerations apply to other tools in this list.)、specxz     （The xz compression program）、specmd5sum（md5sum from GNU coreutils, with enhancements）、spectar（ GNU tar）、specperl（Perl）。Various Perl modules such as Algorithm::Diff, GD, HTML::Parser, PDF::API2, URI, XML::SAX, etc.。
编译工具：C99 编译器 C++编译器
如果是初始安装包，则需要解压源码包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# xz -dc install_archives/cpu2006.tar.xz | tar -xf - tools/src
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立工具包的命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;AIX (32-bit):
CC=xlc CFLAGS='-O -qarch=ppc -D_LARGE_FILES -D_ILS_MACROS' PERLFLAGS="-Doptimize='-O' -Accflags='-D_LARGE_FILES'" OBJECT_MODE=32 ./buildtools

AIX (64-bit):
CC=xlc CFLAGS='-O3 -qarch=ppc64 -q64 -D_ILS_MACROS' PERLFLAGS="-Doptimize='-O' -Aoptimize='-qarch=ppc64 -q64'" OBJECT_MODE=64 ./buildtools

HPUX:
CC="/opt/ansic/bin/cc" CFLAGS="-Ae +O2 +z -D_FILE_OFFSET_BITS=64 -AC99" XZCFLAGS=-AC99 PERLFLAGS="-Doptimize=+O1 -Dlibpth=/usr/lib/hpux32 -Dldflags=-lm -Dcppstdin=cc -Acppstdin=-E -Acppstdin=-Aa -Acppstdin=-D__STDC_EXT__ -Acppstdin=-AC89" ./buildtools

IRIX:
ulimit -s 128000; CFLAGS="-c99 -D_FILE_OFFSET_BITS=64" MD5CFLAGS="-O2" PERLFLAGS="-Doptimize=-O3 -Uloclib -Dlibpth=/usr/lib32" XZFLAGS="--disable-assembler --disable-shared" XZCFLAGS="-O1" ./buildtools
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立完成之后，确认是否成功的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;cd &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;SPEC&lt;/span&gt;&lt;span class="x"&gt; (Unix)&lt;/span&gt;
&lt;span class="x"&gt;.  shrc&lt;/span&gt;
&lt;span class="x"&gt;或 runspec -V&lt;/span&gt;
&lt;span class="x"&gt;或specmake -v&lt;/span&gt;
&lt;span class="x"&gt;specxz -h&lt;/span&gt;
&lt;span class="x"&gt;specperl -v&lt;/span&gt;
&lt;span class="x"&gt;specdiff –h&lt;/span&gt;
&lt;span class="x"&gt;runspec -h&lt;/span&gt;
&lt;span class="x"&gt;specinvoke -h&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;工具编译完成之后，需要对工具进行打包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;packagetools &amp;lt;archname&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果自动化编译出现问题，可以手动编译每个测试工具。编译方法为进入对应的工具包，手动编译。&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;</summary><category term="benchmark"></category></entry><entry><title>Linux Test Project(一)</title><link href="http://king32783784.github.io/2014/09/12/ltp/" rel="alternate"></link><published>2014-09-12T00:00:00+08:00</published><author><name>peng.lee</name></author><id>tag:king32783784.github.io,2014-09-12:2014/09/12/ltp/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;h1 id="testing-linux-one-syscall-at-a-time"&gt;Testing Linux, one syscall at a time.&lt;/h1&gt;
&lt;p&gt;LTP是从SGI开始的,后由IBM 思科 富士通 SUSE Redhat等组织开发的.该工具的目标是建立一个测试套件用来验证linux的可靠性,健壮性及稳定性.LTP测试套件包含了linux内核及相关功能的工具.&lt;/p&gt;
&lt;p&gt;本文主要介绍关于ltp的一些基本信息.&lt;/p&gt;
&lt;p&gt;LTP项目主页:&lt;a href="https://linux-test-project.github.io/#"&gt;ltp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github链接:&lt;a href="https://github.com/linux-test-project/ltp"&gt;ltp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LTP是一个验证ltp内核功能和稳定性的测试集.用来支持linux开发过程中,通过更多的单元测试,减少bug的引入,降低bug对用户的影响.LTP并不是用来做benchmarking测试的,而是更专注与功能,问题回归及稳定性测试.LTP同样不是一个标准测试,标准测试有&lt;a href="http://www.linuxbase.org/"&gt;LSB&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="yi-ji-ben-jie-gou"&gt;一 基本结构&lt;/h2&gt;
&lt;p&gt;LTP测试套件是由包含一个基本动作和一个确认基本动作工作是否正常的测试用例组成.这个测试用例通常的测试结果是PASS/FAIL.一个测试程序是包含一个或多个测试用例的可执行程序.测试程序包括相应的测试参数,这些参数包括内存测试容量,临时文件位置,网络测试类型等等.Test tags 是用于匹配测试程序和一组命令行参数.Test tags是测试集的基础.&lt;/p&gt;
&lt;h3 id="bian-xie-ce-shi"&gt;编写测试&lt;/h3&gt;
&lt;p&gt;编写一个测试用例比大多数想象的更容易.任何一个你编写用于验证内核功能的代码都可以用来形成一个用例.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试退出约定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常一个简单的判断一个测试用例执行结果的方式就是程序的返回值.如果你的测试程序没有得到一个预期结果或错误结果,程序退出是需要返回一个非零值,如exit1,
同样如果程序得到预期的结果,需要返回0,exit(0).一些测试驱动需要去收集这些返回值.如果一个测试程序包含多个测试用例,你不知道那个出错了,但你会知道程序出错了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式化输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个简单方式处理测试结果就是每个测试用例都输出一个标准格式的输出结果.这个格式需要是测试人员和分析工具都能理解的格式,当测试结果都按一个标准格式输出时工具就能够分析测试结果.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LTP目前没有一个最终的测试工具.我们选择了一个简单的解决方式ltp-pan.
 Ltp-pan是一个简单的测试驱动程序,它可以跟踪孤儿进程和抓取测试的输出信息.它工作方式是读取一个包括test tags和命令行列表的文件并执行.默认的ltp-pan会随机的从列表中选择命令执行,并等待其结束.可以通过选择多个命令行执行多个测试,在一定时间执行多个测试并且缓冲多个测试结果.这样Ltp-pan可以营造出复杂的测试环境.Ltp-pan使用一个活动文件,通常叫做zoo文件来保存哪些测试在运行.这个文件包括pid,tag以及命令行的一部分.当启动ltp-pan,它本身变成了自己的一个标签.当一个测试标签退出,ltp-pan会第一个字符加#的方式重写.这个活动文件可以在多个ltp-pan实例中共享,所以当系统崩溃时,你可以通过查看一个文件,了解哪个用例造成的.&lt;/p&gt;
&lt;p&gt;一个Ltp-pan文件包括一个测试tag列表.格式如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;testtag testprogram -o one -p two other command line options

# This is a comment. It is a good idea to describe the test

# tags in your ltp-pan file. Tests programs can have different

# behaviors depending on the command line options so it is

# helpful to describe what each test tag is meant to verify
or # provoke.

# Some more test cases

mm01 mmap001 -m 10000

# 40 Mb mmap() test.

# Creates a 10000 page mmap, touches all of the map, sync's

# it, and munmap()s it.

mm03 mmap001 -i 0 -I 1 -m 100

# repetitive mmapping test.

# Creates a one page map repetitively for one minute.

dup02 dup02

# Negative test for dup(2) with bad fd

kill09 kill09

# Basic test for kill(2)

fs-suite01 ltp-pan -e -a fs-suite01.zoo -n fs-suite01 -f runtest/fs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试例子&lt;/strong&gt;
运行一个测试基本方式是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ltp-pan -a ltp.zoo -n tutor sleep 4

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_start&amp;gt;&amp;gt;&amp;gt;

&lt;span class="nv"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;cmdln &lt;span class="nv"&gt;stime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;971450564

&lt;span class="nv"&gt;cmdline&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"sleep 4"&lt;/span&gt;

&lt;span class="nv"&gt;contacts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;

&lt;span class="nv"&gt;analysis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;exit&lt;/span&gt;

&lt;span class="nv"&gt;initiation_status&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"ok"&lt;/span&gt;

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_output&amp;gt;&amp;gt;&amp;gt;

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;execution_status&amp;gt;&amp;gt;&amp;gt;

&lt;span class="nv"&gt;duration&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;103341903&lt;/span&gt; &lt;span class="nv"&gt;termination_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;exited &lt;span class="nv"&gt;termination_id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0
&lt;span class="nv"&gt;corefile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;no &lt;span class="nv"&gt;cutime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;cstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_end&amp;gt;&amp;gt;&amp;gt;

$ cat ltp.zoo

&lt;span class="c1"&gt;#9357,tutor,pan/ltp-pan -a ltp.zoo -n tutor sleep 4&lt;/span&gt;

&lt;span class="c1"&gt;#9358,cmdln,sleep 4&lt;/span&gt;

$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何实现的:
这个例子展示ltp-pan两个参数,一个活动文件,一个test tag. "sleep 4"测试程序及ltp-pan要执行的参数.这个测试会得到标记“cmdln”。 LTP-run将随机运行一个测试，最终被cmdln，因为指定了唯一测试.
在活动文件,ltp.zoo,ltp-pan写入pid,testlog,运行测试部分命令行.当test tag运行完成,ltp-pan会标记一个"#",代表它可以执行.这时,你能看到cmdln和tutor,如果测试机挡住,你可以读这些文件查找哪个测试导致的.&lt;/p&gt;
&lt;p&gt;同时运行一个测试多次.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ltp-pan -a ltp.zoo -n tutor -x &lt;span class="m"&gt;3&lt;/span&gt; -s &lt;span class="m"&gt;3&lt;/span&gt; -O /tmp sleep 1

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_start&amp;gt;&amp;gt;&amp;gt;

&lt;span class="nv"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;cmdln &lt;span class="nv"&gt;stime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;971465653

&lt;span class="nv"&gt;cmdline&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"sleep 1"&lt;/span&gt;

&lt;span class="nv"&gt;contacts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;

&lt;span class="nv"&gt;analysis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;exit&lt;/span&gt;

&lt;span class="nv"&gt;initiation_status&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"ok"&lt;/span&gt;

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_output&amp;gt;&amp;gt;&amp;gt;



&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;execution_status&amp;gt;&amp;gt;&amp;gt;

&lt;span class="nv"&gt;duration&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;103326814&lt;/span&gt; &lt;span class="nv"&gt;termination_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;exited &lt;span class="nv"&gt;termination_id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0
&lt;span class="nv"&gt;corefile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;no

&lt;span class="nv"&gt;cutime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;cstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_end&amp;gt;&amp;gt;&amp;gt;

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_start&amp;gt;&amp;gt;&amp;gt;

&lt;span class="nv"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;cmdln &lt;span class="nv"&gt;stime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;971465653

&lt;span class="nv"&gt;cmdline&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"sleep 1"&lt;/span&gt;

&lt;span class="nv"&gt;contacts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;

&lt;span class="nv"&gt;analysis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;exit&lt;/span&gt;

&lt;span class="nv"&gt;initiation_status&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"ok"&lt;/span&gt;

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_output&amp;gt;&amp;gt;&amp;gt;



&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;execution_status&amp;gt;&amp;gt;&amp;gt;

&lt;span class="nv"&gt;duration&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;103326814&lt;/span&gt; &lt;span class="nv"&gt;termination_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;exited &lt;span class="nv"&gt;termination_id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0
&lt;span class="nv"&gt;corefile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;no

&lt;span class="nv"&gt;cutime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;cstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;1

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_end&amp;gt;&amp;gt;&amp;gt;

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_start&amp;gt;&amp;gt;&amp;gt;

&lt;span class="nv"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;cmdln &lt;span class="nv"&gt;stime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;971465653

&lt;span class="nv"&gt;cmdline&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"sleep 1"&lt;/span&gt;

&lt;span class="nv"&gt;contacts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;

&lt;span class="nv"&gt;analysis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;exit&lt;/span&gt;

&lt;span class="nv"&gt;initiation_status&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"ok"&lt;/span&gt;

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_output&amp;gt;&amp;gt;&amp;gt;



&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;execution_status&amp;gt;&amp;gt;&amp;gt;

&lt;span class="nv"&gt;duration&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;103326814&lt;/span&gt; &lt;span class="nv"&gt;termination_type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;exited &lt;span class="nv"&gt;termination_id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0
&lt;span class="nv"&gt;corefile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;no

&lt;span class="nv"&gt;cutime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;cstime&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0

&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;test_end&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何工作的?
  在这个例子中运行了另一个命令行,但是测试执行了3遍(-s 3)并且保持了3个test tags在同一时间执行(-x 3). -O 参数是指定临时文件保存目录,并且为每个缓冲结果设定标签.可以看到cmdln运行了3次.如果 -O 没有指定,则3次结果被混合,就没有意义了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scanner&lt;/strong&gt;
Ltp-scanner 是一个测试结果分析工具,它可以理解rts风格的输出.最终生成一个汇总结果显示哪个用例pass,哪个用例fail.&lt;/p&gt;
&lt;p&gt;测试流程参见下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://king32783784.github.io/lipeng/tmpfile/ltp.gif"/&gt;&lt;/p&gt;
&lt;h2 id="er-ltpwen-jian-jie-gou_1"&gt;二.LTP文件结构&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;从 http://ltp.sourceforge.net/下载LTP测试源码包
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LTP的目录结构基本上分为文档目录（doc）、测试驱动程序目录（pan）、测试脚本目录（testscripts）、测试用例库（testcase）、测试命令文件目录（runtest）、头文件目录（include）、库目录（lib）等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* Doc：该目录是说明文件和帮助文档的所在地，这个目录中对LTP的内容和每个工具都有详细的说明。
* Pan：该目录存储的是LTP测试套件的测试驱动程序pan。
* Testscripts：该目录中存储的是可执行的测试脚本，不同方面的测试脚本的集合。
* Testcase：该目录存储了所有LTP测试套件中所使用的测试用例的源码。
* Runtest：该目录中的每个文件都是要执行的测试用例的命令集合，每个文件针对测试的不同方面。
* Include：LTP测试套件的头文件目录，定义了LTP自身的数据结构和函数结构。
* Lib：LTP测试套件运行时自身需要的库文件，定义了LTP自身的各种函数。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;各个文件结构之间的联系：
    ----&amp;gt;testscripts中ltpstress.sh
    ----&amp;gt;runtest(stress.part1,stress.part2,stress.part3)
    ----&amp;gt;pan后台运行
    ----&amp;gt;最终运行Testcase中的各个测试案例&lt;/p&gt;
&lt;p&gt;其中runtest中 stree.part1,stree.part2,stree.part3中的测试命令或脚本  如 mmstress；来源于testcase/bin 中mmstress；而testcase/bin 中mmstress 可执行脚本或命令来源于/testcase中如 kernel,network,   pounder21, commands 等源代码编译生成的， mmstress:kernel/mem/mtest05/mmstress.c&lt;/p&gt;
&lt;p&gt;stress.part&lt;a href="n=1,2,3"&gt;n&lt;/a&gt;中测试命令如何看？
这些命令文件包含测试用例的tag和带有参数的测使用里，格式如下：
    #tag       test case
    test1      test1 -l 10
    mtest01    mtest01 -m 20
    fork01     fork01&lt;/p&gt;
&lt;h2 id="san-ltpce-shi-fang-fa"&gt;三.LTP测试方法&lt;/h2&gt;
&lt;p&gt;测试方法有两个的阶段：一个是“初始测试”，一个是“压力测试”。
初始测试是开始测试的必要条件。初始测试包括 LTP 测试套件在硬件和操作系统上成功运转，这些硬件和操作系统将用于可靠性运转。LTP 测试套件包附带的驱动程序脚本 runalltest.sh 用于验证内核。这个脚本串行地运行一组成包的测试，并报告全部结果。也可以选择同时并行地运行几个实例。默认地，这个脚本执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* 文件系统压力测试。
* 硬盘 I/O 测试。
* 内存管理压力测试。
* IPC 压力测试。
* SCHED测试。
* 命令功能的验证测试。
* 系统调用功能的验证测试。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;压力测试可以验证产品在系统高使用率时的健壮性。作为 runalltest.sh 的补充，特别设计了一个名为 ltpstress.sh 的测试场景，在使用网络与内存管理的同时并行地运行大范围的内核组件，并在测试系统上生成高压力负荷。ltpstress.sh 也是 LTP 测试套件的一部分。这个脚本并行地运行相似的测试用例，串行地运行不同的测试用例，这样做是为了避免由于同时访问同一资源或者互相干扰而引起的间歇性故障。默认地，这个脚本执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* NFS 压力测试。
* 内存管理压力测试。
* 文件系统压力测试。
* 数学 (浮点) 测试。
* 多线程压力测试。
* 硬盘 I/O 测试。
* IPC (pipeio, semaphore) 测试。
* 系统调用功能的验证测试。
* 网络压力测试。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="si-ce-shi-zu-he-de-xuan-ze"&gt;四.测试组合的选择&lt;/h2&gt;
&lt;p&gt;所选择的测试的组合必须给系统的资源带来足够的压力。Linux 内核的四个主要方面可以影响系统的 响应和执行时间：
　　
&lt;em&gt; CPU：用于在机器的 CPU（s）上处理数据的时间。
&lt;/em&gt; Memory：用于自真实存储器中读写数据的时间。
&lt;em&gt; I/O：用于自磁盘存储器读写数据的时间。
&lt;/em&gt; Networking：用于自网络读写数据的时间。&lt;/p&gt;
&lt;p&gt;系统资源利用率评价阶段通常需要多次尝试才能得到合适的测试组合，并得到期望水平的利用率。在这个评价过程中，sar 工具也应该在运行。在评价运行的结论中，您应该收集并评价所有四种资源的利用率水平。
      具体的测试组合修改方法。&lt;/p&gt;
&lt;p&gt;修改方法一：
       runtest中 stress.part1,stress.part2,stress.part3。&lt;/p&gt;
&lt;p&gt;如修改stress.part1中有这样一个测试mem02，根据阅读testcases/kernel/mem/mem／mem02.c 源代码，可将他修改为mem02 -m 15,意思是测试15m内存。
同样的也可以在 stress.part1,stress.part2,stress.part3 中添加、删除一些测试，
如我们测试时就把
stress.part3中关于swap交换分区的去掉&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#swapoff01 swapoff01
#swapoff02 swapoff02
#swapon01 swapon01
#swapon02 swapon02
#swapon03 swapon03
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改方法二：&lt;/p&gt;
&lt;p&gt;前面提到的初始测试或者压力测试都是测试的默认的，如果想测试其他的或者自己的测试案例，需要修改testcase的&lt;/p&gt;
&lt;p&gt;Makefile,因为通过它的Makefile可以看到&lt;/p&gt;
&lt;p&gt;SUBDIRS = &lt;code&gt;ls */Makefile | sed "s/Makefile//g" | grep -v open | grep -v pounder | grep -v DOTS | grep -v kdump | grep -v realtime&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;sed 's//:/ /g' :想把文本中的冒号替换成空格&lt;/p&gt;
&lt;p&gt;grep -v:显示所有与指定模式不匹配的行     &lt;/p&gt;
&lt;p&gt;也就是说open,pounder,DOTS,kdump,realtime没有测试，当然你可以选上或者，添加上自己的测试案例。&lt;/p&gt;
&lt;h2 id="wu-gong-ju-jie-shao"&gt;五.工具介绍&lt;/h2&gt;
&lt;p&gt;Gcov,lcove：&lt;/p&gt;
&lt;p&gt;分析代码覆盖率&lt;/p&gt;
&lt;p&gt;sar:
帮助我们掌握系统资源的使用情况，特别是内存和CPU 的使用情况，
是UNIX系统使用者应该掌握的工具之一
在我们的测试中，sar工具每 10 秒(当然时间间隔可以修改)钟截取一次系统利用率的快照，并保存到结果文件。
针对sar生成的sar.data使用方法：
    sar -u sar.data  //查看cpu使用情况
    sar -r sar.data  //看看memory,swap使用情况
     ……………………
Top:&lt;/p&gt;
&lt;p&gt;跟sar差不多的功能，这里我们就用sar 了。&lt;/p&gt;
&lt;h2 id="qi-ta"&gt;其他&lt;/h2&gt;
&lt;p&gt;什么是稳定性和可靠性？&lt;/p&gt;
&lt;p&gt;稳定性反映的是系统不会出现异常情况；可靠性反映的是系统能够保持正常运行而不受外界影响的能力。
系统的稳定性和可靠性通常以连续运转时间和系统的可靠运行时间来度量。&lt;/p&gt;
&lt;p&gt;什么是压力测试？&lt;/p&gt;
&lt;p&gt;压力测试是一种破坏性的测试，即系统在非正常的、超负荷的条件下的运行情况 。用来评估在超越最大负载的情况下系统将如何运行，是系统在正常的情况下对某种负载强度的承受能力的考验 。&lt;/p&gt;
&lt;p&gt;为什么要进行压力测试？&lt;/p&gt;
&lt;p&gt;通常我们用压力测试来判断系统的稳定性和可靠性。&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;</summary><category term="自动化测试"></category></entry><entry><title>快速排序</title><link href="http://king32783784.github.io/2013/07/01/sort/" rel="alternate"></link><published>2013-07-01T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2013-07-01:2013/07/01/sort/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;h4 id="kuai-su-pai-xu"&gt;快速排序&lt;/h4&gt;
&lt;p&gt;对于一个给定的数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集，
一个子集的所有元素都小于该元素，另一个子集的元素都大于或等于该元素，
对两个子集递归执行这一过程，当某个子集中的元素小于二时，
这个子集就不需要再次排序，终止递归。&lt;/p&gt;
&lt;h4 id="dai-ma-shi-xian-ji-ce-shi"&gt;代码实现及测试&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//将中点的元素作为比较元素，放到整个数组的最左边&lt;/span&gt;
        &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//last位置放的将是比较元素，左边全是比它小的元素&lt;/span&gt;
        &lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//对子集1进行递归调用&lt;/span&gt;
        &lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//对子集2进行递归调用&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
        &lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d,"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;</summary><category term="算法"></category></entry><entry><title>常用shell命令</title><link href="http://king32783784.github.io/2011/01/01/cmds/" rel="alternate"></link><published>2011-01-01T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2011-01-01:2011/01/01/cmds/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;1.查找大于100M的文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find / -type f -size +100M
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;</summary><category term="shell"></category></entry><entry><title>原子操作</title><link href="http://king32783784.github.io/2009/10/10/UNIX/" rel="alternate"></link><published>2009-10-10T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2009-10-10:2009/10/10/UNIX/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;h4 id="zhui-jia-zhi-yi-ge-wen-jian"&gt;追加至一个文件&lt;/h4&gt;
&lt;p&gt;一个进程，将数据添加到一个文件尾端。早期不支持open的O_APPEND选项。所有程序被编写成下列形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (lseek(fd, 0L, 2 ) &amp;lt; 0) /* position to EOF*/

    err_sys("lseek error");

if (write(fd, buf, 100) != 100) /* and write */

    err_sys("write error");
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;单个进程而言，可以正常工作，但若有多个进程同事使用这种方法将数据添加到同一文件，则会产生问题。&lt;/p&gt;
&lt;p&gt;UNIX系统提供了一种方法使这种操作成为原子操作。该方法是在打开文件时设置O_APPEND标志。使内核每次对这种文件进行写之前，都将当前偏移量设置到该文件的尾端处，每次写之前就不在需要调用lseek。&lt;/p&gt;
&lt;h4 id="preadhe-pwritehan-shu"&gt;pread和 pwrite函数&lt;/h4&gt;
&lt;p&gt;原型如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#include　＜unistd.h&amp;gt;

ssize_t pread (int filedes, void *buf, size_t nbytes, off_t offset);

返回值：读到的字节数，若已到文件结尾则返回0，若出错则返回-1

ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);

若成功，返回已写的字节数，若出错则返回-1
调用pread相当于顺序调用lseek和read,但是pread与这种顺序调用存在区别
调用pread时，无法中断其定位和读写作。
不能更新文件指针
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="chuang-jian-yi-ge-wen-jian"&gt;创建一个文件&lt;/h4&gt;
&lt;p&gt;当用open进行打开文件时，如果该文件已经存在，open将失败。检查文件是否存在和创建该文件这两个操作是作为一个原子操作执行的。如果没有这个原子操作，需要用下面程序段。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if((fd = open(pathname, O_WRONLY)) &amp;lt; 0 ) {

    if （errno == ENOENT) {

        if ((fd = creat(pathname, mode)) &amp;lt; 0)
            err_sys("creat error");
    } else {

        err_sys("open error");

    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果在open和creat之间，另一个进程创建了该文件，那么就会引起问题。例如，若在这两个函数调用之间，另一个进程创建了该文件，并且写进了一些数据。然后，原先的进程执行这段程序的creat。刚由另一个进程写上去的数据就会被擦除。这样两则合并为一个原子操作，就不会发生该问题。&lt;/p&gt;
&lt;p&gt;一般而言，原子操作，指的是由多步组成的操作，如果操作原子地执行，那么执行完所有步骤，要么不执行，不可能只执行一部分。&lt;/p&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;</summary><category term="unix编程"></category></entry><entry><title>排序-希尔排序法</title><link href="http://king32783784.github.io/2009/10/01/%E6%8E%92%E5%BA%8F/" rel="alternate"></link><published>2009-10-01T00:00:00+08:00</published><author><name>penglee</name></author><id>tag:king32783784.github.io,2009-10-01:2009/10/01/排序/</id><summary type="html">&lt;/head&gt;&lt;body&gt;&lt;p&gt;原始的算法实现在最坏的情况下需要进行O(n2)的比较和交换。V. Pratt的书[1] 对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。&lt;/p&gt;
&lt;p&gt;希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。&lt;/p&gt;
&lt;p&gt;假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。&lt;/p&gt;
&lt;p&gt;一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。&lt;/p&gt;
&lt;p&gt;例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：&lt;/p&gt;
&lt;p&gt;13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10&lt;/p&gt;
&lt;p&gt;然后我们对每列进行排序：&lt;/p&gt;
&lt;p&gt;10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45&lt;/p&gt;
&lt;p&gt;将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：&lt;/p&gt;
&lt;p&gt;10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45&lt;/p&gt;
&lt;p&gt;排序之后变为：&lt;/p&gt;
&lt;p&gt;10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94&lt;/p&gt;
&lt;p&gt;最后以1步长进行排序（此时就是简单的插入排序了）。 步长串行&lt;/p&gt;
&lt;p&gt;步长的选择是希尔排序的重要部分。只要最终步长为1任何步长串行都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。&lt;/p&gt;
&lt;p&gt;Donald Shell 最初建议步长选择为\frac{n}{2}并且对步长取半直到步长达到 1。虽然这样取可以比\mathcal{O}(n^2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。 可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。 步长串行 最坏情况下复杂度 {n/2^i} \mathcal{O}(n^2) 2^k - 1 \mathcal{O}(n^{3/2}) 2^i 3^j \mathcal{O}( n\log^2 n )&lt;/p&gt;
&lt;p&gt;已知的最好步长串行是由Sedgewick提出的 (1, 5, 19, 41, 109,...)，该串行的项来自 9 * 4^i - 9 * 2^i + 1 和 4^i - 3 * 2^i + 1 这两个算式[1].这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长串行的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。&lt;/p&gt;
&lt;p&gt;另一个在大数组中表现优异的步长串行是(斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列)：（1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713, …）[2] 伪代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="n"&gt;elements&lt;/span&gt; &lt;span class="n"&gt;numbered&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;inc&lt;/span&gt; &lt;span class="err"&gt;←&lt;/span&gt; &lt;span class="n"&gt;round&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;inc&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inc&lt;/span&gt; &lt;span class="o"&gt;..&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="err"&gt;←&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="err"&gt;←&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="err"&gt;≥&lt;/span&gt; &lt;span class="n"&gt;inc&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;inc&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="err"&gt;←&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;inc&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
            &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="err"&gt;←&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;inc&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="err"&gt;←&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;
    &lt;span class="n"&gt;inc&lt;/span&gt; &lt;span class="err"&gt;←&lt;/span&gt; &lt;span class="n"&gt;round&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inc&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mf"&gt;2.2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C示例代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                 &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;{&lt;/span&gt;
                     &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                     &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                     &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
                     &lt;span class="p"&gt;{&lt;/span&gt;
                          &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                          &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                     &lt;span class="p"&gt;}&lt;/span&gt;
                     &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                 &lt;span class="p"&gt;}&lt;/span&gt;
                 &lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C++示例代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;shellsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
             &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Java中的示例代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;shellsort&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;]&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
            &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;
                &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;
                &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;]=&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
     &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Top&lt;a href=""&gt;^&lt;/a&gt;&lt;/p&gt;</summary><category term="算法"></category></entry></feed>